{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport * as Polygon from './polygon';\nimport { Tesselator } from '@deck.gl/core';\n\nvar PolygonTesselator = function (_Tesselator) {\n  _inherits(PolygonTesselator, _Tesselator);\n\n  function PolygonTesselator(opts) {\n    _classCallCheck(this, PolygonTesselator);\n\n    var fp64 = opts.fp64,\n        _opts$IndexType = opts.IndexType,\n        IndexType = _opts$IndexType === void 0 ? Uint32Array : _opts$IndexType;\n    return _possibleConstructorReturn(this, _getPrototypeOf(PolygonTesselator).call(this, _objectSpread({}, opts, {\n      attributes: {\n        positions: {\n          size: 3,\n          type: fp64 ? Float64Array : Float32Array\n        },\n        vertexValid: {\n          type: Uint8ClampedArray,\n          size: 1\n        },\n        indices: {\n          type: IndexType,\n          size: 1\n        }\n      }\n    })));\n  }\n\n  _createClass(PolygonTesselator, [{\n    key: \"get\",\n    value: function get(attributeName) {\n      var attributes = this.attributes;\n\n      if (attributeName === 'indices') {\n        return attributes.indices && attributes.indices.subarray(0, this.vertexCount);\n      }\n\n      return attributes[attributeName];\n    }\n  }, {\n    key: \"updateGeometry\",\n    value: function updateGeometry(opts) {\n      _get(_getPrototypeOf(PolygonTesselator.prototype), \"updateGeometry\", this).call(this, opts);\n\n      var externalIndices = this.buffers.indices;\n\n      if (externalIndices) {\n        this.vertexCount = (externalIndices.value || externalIndices).length;\n      }\n    }\n  }, {\n    key: \"getGeometrySize\",\n    value: function getGeometrySize(polygon) {\n      return Polygon.getVertexCount(polygon, this.positionSize, this.normalize);\n    }\n  }, {\n    key: \"getGeometryFromBuffer\",\n    value: function getGeometryFromBuffer(buffer) {\n      if (this.normalize || !this.buffers.indices) {\n        return _get(_getPrototypeOf(PolygonTesselator.prototype), \"getGeometryFromBuffer\", this).call(this, buffer);\n      }\n\n      return function () {\n        return null;\n      };\n    }\n  }, {\n    key: \"updateGeometryAttributes\",\n    value: function updateGeometryAttributes(polygon, context) {\n      if (this.normalize) {\n        polygon = Polygon.normalize(polygon, this.positionSize, context.geometrySize);\n      }\n\n      this._updateIndices(polygon, context);\n\n      this._updatePositions(polygon, context);\n\n      this._updateVertexValid(polygon, context);\n    }\n  }, {\n    key: \"_updateIndices\",\n    value: function _updateIndices(polygon, _ref) {\n      var geometryIndex = _ref.geometryIndex,\n          offset = _ref.vertexStart,\n          indexStart = _ref.indexStart;\n      var attributes = this.attributes,\n          indexStarts = this.indexStarts,\n          typedArrayManager = this.typedArrayManager;\n      var target = attributes.indices;\n\n      if (!target) {\n        return;\n      }\n\n      var i = indexStart;\n      var indices = Polygon.getSurfaceIndices(polygon, this.positionSize, this.opts.preproject);\n      target = typedArrayManager.allocate(target, indexStart + indices.length, {\n        copy: true\n      });\n\n      for (var j = 0; j < indices.length; j++) {\n        target[i++] = indices[j] + offset;\n      }\n\n      indexStarts[geometryIndex + 1] = indexStart + indices.length;\n      attributes.indices = target;\n    }\n  }, {\n    key: \"_updatePositions\",\n    value: function _updatePositions(polygon, _ref2) {\n      var vertexStart = _ref2.vertexStart,\n          geometrySize = _ref2.geometrySize;\n      var positions = this.attributes.positions,\n          positionSize = this.positionSize;\n\n      if (!positions) {\n        return;\n      }\n\n      var polygonPositions = polygon.positions || polygon;\n\n      for (var i = vertexStart, j = 0; j < geometrySize; i++, j++) {\n        var x = polygonPositions[j * positionSize];\n        var y = polygonPositions[j * positionSize + 1];\n        var z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;\n        positions[i * 3] = x;\n        positions[i * 3 + 1] = y;\n        positions[i * 3 + 2] = z;\n      }\n    }\n  }, {\n    key: \"_updateVertexValid\",\n    value: function _updateVertexValid(polygon, _ref3) {\n      var vertexStart = _ref3.vertexStart,\n          geometrySize = _ref3.geometrySize;\n      var vertexValid = this.attributes.vertexValid,\n          positionSize = this.positionSize;\n      var holeIndices = polygon && polygon.holeIndices;\n      vertexValid.fill(1, vertexStart, vertexStart + geometrySize);\n\n      if (holeIndices) {\n        for (var j = 0; j < holeIndices.length; j++) {\n          vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;\n        }\n      }\n\n      vertexValid[vertexStart + geometrySize - 1] = 0;\n    }\n  }]);\n\n  return PolygonTesselator;\n}(Tesselator);\n\nexport { PolygonTesselator as default };","map":{"version":3,"sources":["../../../src/solid-polygon-layer/polygon-tesselator.js"],"names":["PolygonTesselator","Tesselator","fp64","IndexType","opts","attributes","positions","size","type","Float32Array","vertexValid","indices","attributeName","externalIndices","polygon","Polygon","buffer","context","geometryIndex","vertexStart","offset","indexStart","indexStarts","typedArrayManager","target","i","copy","j","geometrySize","positionSize","polygonPositions","x","y","z","holeIndices"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA,OAAO,KAAP,OAAA,MAAA,WAAA;AACA,SAAA,UAAA,QAAA,eAAA;;IAIqBA,iB;;;AACnB,WAAA,iBAAA,CAAA,IAAA,EAAkB;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,iBAAA,CAAA;;AAAA,QACTE,IADS,GACwBE,IADxB,CAAA,IAAA;AAAA,QAAA,eAAA,GACwBA,IADxB,CAAA,SAAA;AAAA,QACHD,SADG,GAAA,eAAA,KAAA,KAAA,CAAA,GAAA,WAAA,GAAA,eAAA;AAAA,WAAA,0BAAA,CAAA,IAAA,EAAA,eAAA,CAAA,iBAAA,CAAA,CAAA,IAAA,CAAA,IAAA,EAAA,aAAA,CAAA,EAAA,EAAA,IAAA,EAAA;AAIdE,MAAAA,UAAU,EAAE;AACVC,QAAAA,SAAS,EAAE;AAACC,UAAAA,IAAI,EAAL,CAAA;AAAUC,UAAAA,IAAI,EAAEN,IAAI,GAAA,YAAA,GAAkBO;AAAtC,SADD;AAEVC,QAAAA,WAAW,EAAE;AAACF,UAAAA,IAAI,EAAL,iBAAA;AAA0BD,UAAAA,IAAI,EAAE;AAAhC,SAFH;AAGVI,QAAAA,OAAO,EAAE;AAACH,UAAAA,IAAI,EAAL,SAAA;AAAkBD,UAAAA,IAAI,EAAE;AAAxB;AAHC;AAJE,KAAA,CAAA,CAAA,CAAA;AAUjB;;;;wBAGGK,a,EAAe;AAAA,UACVP,UADU,GAAA,KAAA,UAAA;;AAEjB,UAAIO,aAAa,KAAjB,SAAA,EAAiC;AAC/B,eAAOP,UAAU,CAAVA,OAAAA,IAAsBA,UAAU,CAAVA,OAAAA,CAAAA,QAAAA,CAAAA,CAAAA,EAA+B,KAA5D,WAA6BA,CAA7B;AACD;;AAED,aAAOA,UAAU,CAAjB,aAAiB,CAAjB;AACD;;;mCAGcD,I,EAAM;AACnB,MAAA,IAAA,CAAA,eAAA,CAAA,iBAAA,CAAA,SAAA,CAAA,EAAA,gBAAA,EAAA,IAAA,CAAA,CAAA,IAAA,CAAA,IAAA,EAAA,IAAA;;AAEA,UAAMS,eAAe,GAAG,KAAA,OAAA,CAAxB,OAAA;;AACA,UAAA,eAAA,EAAqB;AACnB,aAAA,WAAA,GAAmB,CAACA,eAAe,CAAfA,KAAAA,IAAD,eAAA,EAAnB,MAAA;AACD;AACF;;;oCAEeC,O,EAAS;AACvB,aAAOC,OAAO,CAAPA,cAAAA,CAAAA,OAAAA,EAAgC,KAAhCA,YAAAA,EAAmD,KAA1D,SAAOA,CAAP;AACD;;;0CAEqBC,M,EAAQ;AAC5B,UAAI,KAAA,SAAA,IAAkB,CAAC,KAAA,OAAA,CAAvB,OAAA,EAA6C;AAC3C,eAAA,IAAA,CAAA,eAAA,CAAA,iBAAA,CAAA,SAAA,CAAA,EAAA,uBAAA,EAAA,IAAA,CAAA,CAAA,IAAA,CAAA,IAAA,EAAA,MAAA,CAAA;AACD;;AAED,aAAO,YAAA;AAAA,eAAA,IAAA;AAAP,OAAA;AACD;;;6CAEwBF,O,EAASG,O,EAAS;AACzC,UAAI,KAAJ,SAAA,EAAoB;AAClBH,QAAAA,OAAO,GAAGC,OAAO,CAAPA,SAAAA,CAAAA,OAAAA,EAA2B,KAA3BA,YAAAA,EAA8CE,OAAO,CAA/DH,YAAUC,CAAVD;AACD;;AAED,WAAA,cAAA,CAAA,OAAA,EAAA,OAAA;;AACA,WAAA,gBAAA,CAAA,OAAA,EAAA,OAAA;;AACA,WAAA,kBAAA,CAAA,OAAA,EAAA,OAAA;AACD;;;mCAGcA,O,QAA2D;AAAA,UAAjDI,aAAiD,GAAA,IAAA,CAAjDA,aAAiD;AAAA,UAArBE,MAAqB,GAAA,IAAA,CAAlCD,WAAkC;AAAA,UAAbE,UAAa,GAAA,IAAA,CAAbA,UAAa;AAAA,UACjEhB,UADiE,GAAA,KAAA,UAAA;AAAA,UACrDiB,WADqD,GAAA,KAAA,WAAA;AAAA,UACxCC,iBADwC,GAAA,KAAA,iBAAA;AAGxE,UAAIC,MAAM,GAAGnB,UAAU,CAAvB,OAAA;;AACA,UAAI,CAAJ,MAAA,EAAa;AACX;AACD;;AACD,UAAIoB,CAAC,GAAL,UAAA;AAGA,UAAMd,OAAO,GAAGI,OAAO,CAAPA,iBAAAA,CAAAA,OAAAA,EAAmC,KAAnCA,YAAAA,EAAsD,KAAA,IAAA,CAAtE,UAAgBA,CAAhB;AAGAS,MAAAA,MAAM,GAAG,iBAAiB,CAAjB,QAAA,CAAA,MAAA,EAAmCH,UAAU,GAAGV,OAAO,CAAvD,MAAA,EAAgE;AACvEe,QAAAA,IAAI,EAAE;AADiE,OAAhE,CAATF;;AAKA,WAAK,IAAIG,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGhB,OAAO,CAA3B,MAAA,EAAoCgB,CAApC,EAAA,EAAyC;AACvCH,QAAAA,MAAM,CAACC,CAAPD,EAAM,CAANA,GAAcb,OAAO,CAAPA,CAAO,CAAPA,GAAda,MAAAA;AACD;;AAEDF,MAAAA,WAAW,CAACJ,aAAa,GAAzBI,CAAW,CAAXA,GAAiCD,UAAU,GAAGV,OAAO,CAArDW,MAAAA;AACAjB,MAAAA,UAAU,CAAVA,OAAAA,GAAAA,MAAAA;AACD;;;qCAGgBS,O,SAAsC;AAAA,UAA5BK,WAA4B,GAAA,KAAA,CAA5BA,WAA4B;AAAA,UAAfS,YAAe,GAAA,KAAA,CAAfA,YAAe;AAAA,UAEtCtB,SAFsC,GAAA,KAAA,UAAA,CAAA,SAAA;AAAA,UAGnDuB,YAHmD,GAAA,KAAA,YAAA;;AAKrD,UAAI,CAAJ,SAAA,EAAgB;AACd;AACD;;AACD,UAAMC,gBAAgB,GAAGhB,OAAO,CAAPA,SAAAA,IAAzB,OAAA;;AAEA,WAAK,IAAIW,CAAC,GAAL,WAAA,EAAqBE,CAAC,GAA3B,CAAA,EAAiCA,CAAC,GAAlC,YAAA,EAAmDF,CAAC,IAAIE,CAAxD,EAAA,EAA6D;AAC3D,YAAMI,CAAC,GAAGD,gBAAgB,CAACH,CAAC,GAA5B,YAA0B,CAA1B;AACA,YAAMK,CAAC,GAAGF,gBAAgB,CAACH,CAAC,GAADA,YAAAA,GAA3B,CAA0B,CAA1B;AACA,YAAMM,CAAC,GAAGJ,YAAY,GAAZA,CAAAA,GAAmBC,gBAAgB,CAACH,CAAC,GAADA,YAAAA,GAApCE,CAAmC,CAAnCA,GAAV,CAAA;AAEAvB,QAAAA,SAAS,CAACmB,CAAC,GAAXnB,CAAS,CAATA,GAAAA,CAAAA;AACAA,QAAAA,SAAS,CAACmB,CAAC,GAADA,CAAAA,GAAVnB,CAAS,CAATA,GAAAA,CAAAA;AACAA,QAAAA,SAAS,CAACmB,CAAC,GAADA,CAAAA,GAAVnB,CAAS,CAATA,GAAAA,CAAAA;AACD;AACF;;;uCAEkBQ,O,SAAsC;AAAA,UAA5BK,WAA4B,GAAA,KAAA,CAA5BA,WAA4B;AAAA,UAAfS,YAAe,GAAA,KAAA,CAAfA,YAAe;AAAA,UAExClB,WAFwC,GAAA,KAAA,UAAA,CAAA,WAAA;AAAA,UAGrDmB,YAHqD,GAAA,KAAA,YAAA;AAKvD,UAAMK,WAAW,GAAGpB,OAAO,IAAIA,OAAO,CAAtC,WAAA;AAUAJ,MAAAA,WAAW,CAAXA,IAAAA,CAAAA,CAAAA,EAAAA,WAAAA,EAAiCS,WAAW,GAA5CT,YAAAA;;AACA,UAAA,WAAA,EAAiB;AACf,aAAK,IAAIiB,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGO,WAAW,CAA/B,MAAA,EAAwCP,CAAxC,EAAA,EAA6C;AAC3CjB,UAAAA,WAAW,CAACS,WAAW,GAAGe,WAAW,CAAXA,CAAW,CAAXA,GAAdf,YAAAA,GAAZT,CAAW,CAAXA,GAAAA,CAAAA;AACD;AACF;;AACDA,MAAAA,WAAW,CAACS,WAAW,GAAXA,YAAAA,GAAZT,CAAW,CAAXA,GAAAA,CAAAA;AACD;;;;EA9H4CT,U;;SAA1BD,iB","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Handles tesselation of polygons with holes\n// - 2D surfaces\n// - 2D outlines\n// - 3D surfaces (top and sides only)\n// - 3D wireframes (not yet)\nimport * as Polygon from './polygon';\nimport {Tesselator} from '@deck.gl/core';\n\n// This class is set up to allow querying one attribute at a time\n// the way the AttributeManager expects it\nexport default class PolygonTesselator extends Tesselator {\n  constructor(opts) {\n    const {fp64, IndexType = Uint32Array} = opts;\n    super({\n      ...opts,\n      attributes: {\n        positions: {size: 3, type: fp64 ? Float64Array : Float32Array},\n        vertexValid: {type: Uint8ClampedArray, size: 1},\n        indices: {type: IndexType, size: 1}\n      }\n    });\n  }\n\n  /* Getters */\n  get(attributeName) {\n    const {attributes} = this;\n    if (attributeName === 'indices') {\n      return attributes.indices && attributes.indices.subarray(0, this.vertexCount);\n    }\n\n    return attributes[attributeName];\n  }\n\n  /* Implement base Tesselator interface */\n  updateGeometry(opts) {\n    super.updateGeometry(opts);\n\n    const externalIndices = this.buffers.indices;\n    if (externalIndices) {\n      this.vertexCount = (externalIndices.value || externalIndices).length;\n    }\n  }\n\n  getGeometrySize(polygon) {\n    return Polygon.getVertexCount(polygon, this.positionSize, this.normalize);\n  }\n\n  getGeometryFromBuffer(buffer) {\n    if (this.normalize || !this.buffers.indices) {\n      return super.getGeometryFromBuffer(buffer);\n    }\n    // we don't need to read the positions if no normalization/tesselation\n    return () => null;\n  }\n\n  updateGeometryAttributes(polygon, context) {\n    if (this.normalize) {\n      polygon = Polygon.normalize(polygon, this.positionSize, context.geometrySize);\n    }\n\n    this._updateIndices(polygon, context);\n    this._updatePositions(polygon, context);\n    this._updateVertexValid(polygon, context);\n  }\n\n  // Flatten the indices array\n  _updateIndices(polygon, {geometryIndex, vertexStart: offset, indexStart}) {\n    const {attributes, indexStarts, typedArrayManager} = this;\n\n    let target = attributes.indices;\n    if (!target) {\n      return;\n    }\n    let i = indexStart;\n\n    // 1. get triangulated indices for the internal areas\n    const indices = Polygon.getSurfaceIndices(polygon, this.positionSize, this.opts.preproject);\n\n    // make sure the buffer is large enough\n    target = typedArrayManager.allocate(target, indexStart + indices.length, {\n      copy: true\n    });\n\n    // 2. offset each index by the number of indices in previous polygons\n    for (let j = 0; j < indices.length; j++) {\n      target[i++] = indices[j] + offset;\n    }\n\n    indexStarts[geometryIndex + 1] = indexStart + indices.length;\n    attributes.indices = target;\n  }\n\n  // Flatten out all the vertices of all the sub subPolygons\n  _updatePositions(polygon, {vertexStart, geometrySize}) {\n    const {\n      attributes: {positions},\n      positionSize\n    } = this;\n    if (!positions) {\n      return;\n    }\n    const polygonPositions = polygon.positions || polygon;\n\n    for (let i = vertexStart, j = 0; j < geometrySize; i++, j++) {\n      const x = polygonPositions[j * positionSize];\n      const y = polygonPositions[j * positionSize + 1];\n      const z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;\n\n      positions[i * 3] = x;\n      positions[i * 3 + 1] = y;\n      positions[i * 3 + 2] = z;\n    }\n  }\n\n  _updateVertexValid(polygon, {vertexStart, geometrySize}) {\n    const {\n      attributes: {vertexValid},\n      positionSize\n    } = this;\n    const holeIndices = polygon && polygon.holeIndices;\n    /* We are reusing the some buffer for `nextPositions` by offseting one vertex\n     * to the left. As a result,\n     * the last vertex of each ring overlaps with the first vertex of the next ring.\n     * `vertexValid` is used to mark the end of each ring so we don't draw these\n     * segments:\n      positions      A0 A1 A2 A3 A4 B0 B1 B2 C0 ...\n      nextPositions  A1 A2 A3 A4 B0 B1 B2 C0 C1 ...\n      vertexValid    1  1  1  1  0  1  1  0  1 ...\n     */\n    vertexValid.fill(1, vertexStart, vertexStart + geometrySize);\n    if (holeIndices) {\n      for (let j = 0; j < holeIndices.length; j++) {\n        vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;\n      }\n    }\n    vertexValid[vertexStart + geometrySize - 1] = 0;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}