{"ast":null,"code":"import { toHilbertQuadkey, FromHilbertQuadKey, IJToST, STToUV, FaceUVToXYZ, XYZToLngLat } from './s2-geometry';\nimport Long from 'long';\n\nfunction getIdFromToken(token) {\n  var paddedToken = token.padEnd(16, '0');\n  return Long.fromString(paddedToken, 16);\n}\n\nvar MAX_RESOLUTION = 100;\n\nfunction getGeoBounds(_ref) {\n  var face = _ref.face,\n      ij = _ref.ij,\n      level = _ref.level;\n  var offsets = [[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]];\n  var resolution = Math.max(1, Math.ceil(MAX_RESOLUTION * Math.pow(2, -level)));\n  var result = new Float64Array(4 * resolution * 2 + 2);\n  var ptIndex = 0;\n\n  for (var i = 0; i < 4; i++) {\n    var offset = offsets[i].slice(0);\n    var nextOffset = offsets[i + 1];\n    var stepI = (nextOffset[0] - offset[0]) / resolution;\n    var stepJ = (nextOffset[1] - offset[1]) / resolution;\n\n    for (var j = 0; j < resolution; j++) {\n      offset[0] += stepI;\n      offset[1] += stepJ;\n      var st = IJToST(ij, level, offset);\n      var uv = STToUV(st);\n      var xyz = FaceUVToXYZ(face, uv);\n      var lngLat = XYZToLngLat(xyz);\n      result[ptIndex++] = lngLat[0];\n      result[ptIndex++] = lngLat[1];\n    }\n  }\n\n  result[ptIndex++] = result[0];\n  result[ptIndex++] = result[1];\n  return result;\n}\n\nexport function getS2QuadKey(token) {\n  if (typeof token === 'string') {\n    if (token.indexOf('/') > 0) {\n      return token;\n    }\n\n    token = getIdFromToken(token);\n  }\n\n  return toHilbertQuadkey(token.toString());\n}\nexport function getS2Polygon(token) {\n  var key = getS2QuadKey(token);\n  var s2cell = FromHilbertQuadKey(key);\n  return getGeoBounds(s2cell);\n}","map":{"version":3,"sources":["../../../src/s2-layer/s2-utils.js"],"names":["paddedToken","token","Long","MAX_RESOLUTION","face","ij","level","offsets","resolution","Math","result","ptIndex","i","offset","nextOffset","stepI","stepJ","j","st","IJToST","uv","STToUV","xyz","FaceUVToXYZ","lngLat","XYZToLngLat","getIdFromToken","toHilbertQuadkey","key","getS2QuadKey","s2cell","FromHilbertQuadKey","getGeoBounds"],"mappings":"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","sourcesContent":["// s2-geometry is a pure JavaScript port of Google/Niantic's S2 Geometry library\n// which is perfect since it works in the browser.\nimport {\n  toHilbertQuadkey,\n  FromHilbertQuadKey,\n  IJToST,\n  STToUV,\n  FaceUVToXYZ,\n  XYZToLngLat\n} from './s2-geometry';\nimport Long from 'long';\n\n/**\n * Given an S2 token this function convert the token to 64 bit id\n   https://github.com/google/s2-geometry-library-java/blob/c04b68bf3197a9c34082327eeb3aec7ab7c85da1/src/com/google/common/geometry/S2CellId.java#L439\n * */\nfunction getIdFromToken(token) {\n  // pad token with zeros to make the length 16\n  const paddedToken = token.padEnd(16, '0');\n  return Long.fromString(paddedToken, 16);\n}\n\nconst MAX_RESOLUTION = 100;\n\n/* Adapted from s2-geometry's S2Cell.getCornerLatLngs */\nfunction getGeoBounds({face, ij, level}) {\n  const offsets = [[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]];\n\n  // The S2 cell edge is curved: http://s2geometry.io/\n  // This is more prominent at lower levels\n  // resolution is the number of segments to generate per edge.\n  // We exponentially reduce resolution as level increases so it doesn't affect perf\n  // when there are a large number of cells\n  const resolution = Math.max(1, Math.ceil(MAX_RESOLUTION * Math.pow(2, -level)));\n  const result = new Float64Array(4 * resolution * 2 + 2);\n  let ptIndex = 0;\n\n  for (let i = 0; i < 4; i++) {\n    const offset = offsets[i].slice(0);\n    const nextOffset = offsets[i + 1];\n    const stepI = (nextOffset[0] - offset[0]) / resolution;\n    const stepJ = (nextOffset[1] - offset[1]) / resolution;\n\n    for (let j = 0; j < resolution; j++) {\n      offset[0] += stepI;\n      offset[1] += stepJ;\n      // Cell can be represented by coordinates IJ, ST, UV, XYZ\n      // http://s2geometry.io/devguide/s2cell_hierarchy#coordinate-systems\n      const st = IJToST(ij, level, offset);\n      const uv = STToUV(st);\n      const xyz = FaceUVToXYZ(face, uv);\n      const lngLat = XYZToLngLat(xyz);\n\n      result[ptIndex++] = lngLat[0];\n      result[ptIndex++] = lngLat[1];\n    }\n  }\n  // close the loop\n  result[ptIndex++] = result[0];\n  result[ptIndex++] = result[1];\n  return result;\n}\n\nexport function getS2QuadKey(token) {\n  if (typeof token === 'string') {\n    if (token.indexOf('/') > 0) {\n      // is Hilbert quad key\n      return token;\n    }\n    // is S2 token\n    token = getIdFromToken(token);\n  }\n  // is Long id\n  return toHilbertQuadkey(token.toString());\n}\n\n/**\n * Get a polygon with corner coordinates for an s2 cell\n * @param {*} cell - This can be an S2 key or token\n * @return {Array} - a simple polygon in array format: [[lng, lat], ...]\n *   - each coordinate is an array [lng, lat]\n *   - the polygon is closed, i.e. last coordinate is a copy of the first coordinate\n */\nexport function getS2Polygon(token) {\n  const key = getS2QuadKey(token);\n  const s2cell = FromHilbertQuadKey(key);\n\n  return getGeoBounds(s2cell);\n}\n"]},"metadata":{},"sourceType":"module"}