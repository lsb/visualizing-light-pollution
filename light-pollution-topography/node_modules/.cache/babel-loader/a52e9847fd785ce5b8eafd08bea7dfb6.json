{"ast":null,"code":"import { Vector2, Vector3, clamp, _MathUtils } from 'math.gl';\nimport assert from '../utils/assert';\nvar RIGHT_SHIFT = 1.0 / 256.0;\nvar LEFT_SHIFT = 256.0;\nvar scratchVector2 = new Vector2();\nvar scratchVector3 = new Vector3();\nvar scratchEncodeVector2 = new Vector2();\nvar octEncodeScratch = new Vector2();\nvar uint8ForceArray = new Uint8Array(1);\n\nfunction forceUint8(value) {\n  uint8ForceArray[0] = value;\n  return uint8ForceArray[0];\n}\n\nfunction fromSNorm(value) {\n  var rangeMaximum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 255;\n  return clamp(value, 0.0, rangeMaximum) / rangeMaximum * 2.0 - 1.0;\n}\n\nfunction toSNorm(value) {\n  var rangeMaximum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 255;\n  return Math.round((clamp(value, -1.0, 1.0) * 0.5 + 0.5) * rangeMaximum);\n}\n\nfunction signNotZero(value) {\n  return value < 0.0 ? -1.0 : 1.0;\n}\n\nexport function octEncodeInRange(vector, rangeMax, result) {\n  assert(vector);\n  assert(result);\n  var vector3 = scratchVector3.from(vector);\n  assert(Math.abs(vector3.magnitudeSquared() - 1.0) <= _MathUtils.EPSILON6);\n  result.x = vector.x / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\n  result.y = vector.y / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\n\n  if (vector.z < 0) {\n    var x = result.x;\n    var y = result.y;\n    result.x = (1.0 - Math.abs(y)) * signNotZero(x);\n    result.y = (1.0 - Math.abs(x)) * signNotZero(y);\n  }\n\n  result.x = toSNorm(result.x, rangeMax);\n  result.y = toSNorm(result.y, rangeMax);\n  return result;\n}\nexport function octEncode(vector, result) {\n  return octEncodeInRange(vector, 255, result);\n}\nexport function octEncodeToVector4(vector, result) {\n  octEncodeInRange(vector, 65535, octEncodeScratch);\n  result.x = forceUint8(octEncodeScratch.x * RIGHT_SHIFT);\n  result.y = forceUint8(octEncodeScratch.x);\n  result.z = forceUint8(octEncodeScratch.y * RIGHT_SHIFT);\n  result.w = forceUint8(octEncodeScratch.y);\n  return result;\n}\nexport function octDecodeInRange(x, y, rangeMax, result) {\n  assert(result);\n\n  if (x < 0 || x > rangeMax || y < 0 || y > rangeMax) {\n    throw new Error(\"x and y must be unsigned normalized integers between 0 and \".concat(rangeMax));\n  }\n\n  result.x = fromSNorm(x, rangeMax);\n  result.y = fromSNorm(y, rangeMax);\n  result.z = 1.0 - (Math.abs(result.x) + Math.abs(result.y));\n\n  if (result.z < 0.0) {\n    var oldVX = result.x;\n    result.x = (1.0 - Math.abs(result.y)) * signNotZero(oldVX);\n    result.y = (1.0 - Math.abs(oldVX)) * signNotZero(result.y);\n  }\n\n  return result.normalize();\n}\nexport function octDecode(x, y, result) {\n  return octDecodeInRange(x, y, 255, result);\n}\nexport function octDecodeFromVector4(encoded, result) {\n  assert(encoded);\n  assert(result);\n  var x = encoded.x;\n  var y = encoded.y;\n  var z = encoded.z;\n  var w = encoded.w;\n\n  if (x < 0 || x > 255 || y < 0 || y > 255 || z < 0 || z > 255 || w < 0 || w > 255) {\n    throw new Error('x, y, z, and w must be unsigned normalized integers between 0 and 255');\n  }\n\n  var xOct16 = x * LEFT_SHIFT + y;\n  var yOct16 = z * LEFT_SHIFT + w;\n  return octDecodeInRange(xOct16, yOct16, 65535, result);\n}\nexport function octPackFloat(encoded) {\n  var vector2 = scratchVector2.from(encoded);\n  return 256.0 * vector2.x + vector2.y;\n}\nexport function octEncodeFloat(vector) {\n  octEncode(vector, scratchEncodeVector2);\n  return octPackFloat(scratchEncodeVector2);\n}\nexport function octDecodeFloat(value, result) {\n  assert(Number.isFinite(value));\n  var temp = value / 256.0;\n  var x = Math.floor(temp);\n  var y = (temp - x) * 256.0;\n  return octDecode(x, y, result);\n}\nexport function octPack(v1, v2, v3, result) {\n  assert(v1);\n  assert(v2);\n  assert(v3);\n  assert(result);\n  var encoded1 = octEncodeFloat(v1);\n  var encoded2 = octEncodeFloat(v2);\n  var encoded3 = octEncode(v3, scratchEncodeVector2);\n  result.x = 65536.0 * encoded3.x + encoded1;\n  result.y = 65536.0 * encoded3.y + encoded2;\n  return result;\n}\nexport function octUnpack(packed, v1, v2, v3) {\n  var temp = packed.x / 65536.0;\n  var x = Math.floor(temp);\n  var encodedFloat1 = (temp - x) * 65536.0;\n  temp = packed.y / 65536.0;\n  var y = Math.floor(temp);\n  var encodedFloat2 = (temp - y) * 65536.0;\n  octDecodeFloat(encodedFloat1, v1);\n  octDecodeFloat(encodedFloat2, v2);\n  octDecode(x, y, v3);\n}\nexport function compressTextureCoordinates(textureCoordinates) {\n  var x = textureCoordinates.x * 4095.0 | 0;\n  var y = textureCoordinates.y * 4095.0 | 0;\n  return 4096.0 * x + y;\n}\nexport function decompressTextureCoordinates(compressed, result) {\n  var temp = compressed / 4096.0;\n  var xZeroTo4095 = Math.floor(temp);\n  result.x = xZeroTo4095 / 4095.0;\n  result.y = (compressed - xZeroTo4095 * 4096) / 4095;\n  return result;\n}\nexport function zigZagDeltaDecode(uBuffer, vBuffer, heightBuffer) {\n  assert(uBuffer);\n  assert(vBuffer);\n  assert(uBuffer.length === vBuffer.length);\n\n  if (heightBuffer) {\n    assert(uBuffer.length === heightBuffer.length);\n  }\n\n  function zigZagDecode(value) {\n    return value >> 1 ^ -(value & 1);\n  }\n\n  var u = 0;\n  var v = 0;\n  var height = 0;\n\n  for (var i = 0; i < uBuffer.length; ++i) {\n    u += zigZagDecode(uBuffer[i]);\n    v += zigZagDecode(vBuffer[i]);\n    uBuffer[i] = u;\n    vBuffer[i] = v;\n\n    if (heightBuffer) {\n      height += zigZagDecode(heightBuffer[i]);\n      heightBuffer[i] = height;\n    }\n  }\n}","map":{"version":3,"sources":["../../../../src/geometry/compression/attribute-compression.js"],"names":["RIGHT_SHIFT","LEFT_SHIFT","scratchVector2","scratchVector3","scratchEncodeVector2","octEncodeScratch","uint8ForceArray","rangeMaximum","clamp","Math","value","assert","vector3","_MathUtils","result","vector","x","y","signNotZero","toSNorm","octEncodeInRange","forceUint8","fromSNorm","oldVX","octDecodeInRange","encoded","z","w","xOct16","yOct16","vector2","octEncode","octPackFloat","Number","temp","octDecode","encoded1","octEncodeFloat","encoded2","encoded3","packed","encodedFloat1","encodedFloat2","octDecodeFloat","textureCoordinates","compressed","xZeroTo4095","uBuffer","vBuffer","heightBuffer","u","v","height","i","zigZagDecode"],"mappings":"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","sourcesContent":["// Attribute compression and decompression functions.\n\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Vector2, Vector3, clamp, _MathUtils} from 'math.gl';\nimport assert from '../utils/assert';\n\nconst RIGHT_SHIFT = 1.0 / 256.0;\nconst LEFT_SHIFT = 256.0;\n\nconst scratchVector2 = new Vector2();\nconst scratchVector3 = new Vector3();\nconst scratchEncodeVector2 = new Vector2();\nconst octEncodeScratch = new Vector2();\n\nconst uint8ForceArray = new Uint8Array(1);\n\n// Force a value to Uint8\nfunction forceUint8(value) {\n  uint8ForceArray[0] = value;\n  return uint8ForceArray[0];\n}\n\n/**\n * Converts a SNORM value in the range [0, rangeMaximum] to a scalar in the range [-1.0, 1.0].\n * @param {Number} value SNORM value in the range [0, rangeMaximum]\n * @param {Number} [rangeMaximum=255] The maximum value in the SNORM range, 255 by default.\n * @returns {Number} Scalar in the range [-1.0, 1.0].\n *\n * @see CesiumMath.toSNorm\n */\nfunction fromSNorm(value, rangeMaximum = 255) {\n  return (clamp(value, 0.0, rangeMaximum) / rangeMaximum) * 2.0 - 1.0;\n}\n\n/**\n * Converts a scalar value in the range [-1.0, 1.0] to a SNORM in the range [0, rangeMaximum]\n * @param {Number} value The scalar value in the range [-1.0, 1.0]\n * @param {Number} [rangeMaximum=255] The maximum value in the mapped range, 255 by default.\n * @returns {Number} A SNORM value, where 0 maps to -1.0 and rangeMaximum maps to 1.0.\n *\n * @see CesiumMath.fromSNorm\n */\nfunction toSNorm(value, rangeMaximum = 255) {\n  return Math.round((clamp(value, -1.0, 1.0) * 0.5 + 0.5) * rangeMaximum);\n}\n\n/**\n * Returns 1.0 if the given value is positive or zero, and -1.0 if it is negative.\n * This is similar to `Math.sign` except that returns 1.0 instead of\n * 0.0 when the input value is 0.0.\n * @param {Number} value The value to return the sign of.\n * @returns {Number} The sign of value.\n */\nfunction signNotZero(value) {\n  return value < 0.0 ? -1.0 : 1.0;\n}\n\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-rangeMax] following the 'oct' encoding.\n *\n * Oct encoding is a compact representation of unit length vectors.\n * The 'oct' encoding is described in \"A Survey of Efficient Representations of Independent Unit Vectors\",\n * Cigolle et al 2014: {@link http://jcgt.org/published/0003/02/01/}\n *\n * @param {Vector3} vector The normalized vector to be compressed into 2 component 'oct' encoding.\n * @param {Vector2} result The 2 component oct-encoded unit length vector.\n * @param {Number} rangeMax The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.\n * @returns {Vector2} The 2 component oct-encoded unit length vector.\n *\n * @exception {Error} vector must be normalized.\n *\n * @see octDecodeInRange\n */\nexport function octEncodeInRange(vector, rangeMax, result) {\n  assert(vector);\n  assert(result);\n\n  const vector3 = scratchVector3.from(vector);\n\n  assert(Math.abs(vector3.magnitudeSquared() - 1.0) <= _MathUtils.EPSILON6);\n\n  result.x = vector.x / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\n  result.y = vector.y / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\n\n  if (vector.z < 0) {\n    const x = result.x;\n    const y = result.y;\n    result.x = (1.0 - Math.abs(y)) * signNotZero(x);\n    result.y = (1.0 - Math.abs(x)) * signNotZero(y);\n  }\n\n  result.x = toSNorm(result.x, rangeMax);\n  result.y = toSNorm(result.y, rangeMax);\n\n  return result;\n}\n\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-255] following the 'oct' encoding.\n *\n * @param {Vector3} vector The normalized vector to be compressed into 2 byte 'oct' encoding.\n * @param {Vector2} result The 2 byte oct-encoded unit length vector.\n * @returns {Vector2} The 2 byte oct-encoded unit length vector.\n *\n * @exception {Error} vector must be normalized.\n *\n * @see octEncodeInRange\n * @see octDecode\n */\nexport function octEncode(vector, result) {\n  return octEncodeInRange(vector, 255, result);\n}\n\n/**\n * @param {Vector3} vector The normalized vector to be compressed into 4 byte 'oct' encoding.\n * @param {Vector4} result The 4 byte oct-encoded unit length vector.\n * @returns {Vector4} The 4 byte oct-encoded unit length vector.\n *\n * @exception {Error} vector must be normalized.\n *\n * @see octEncodeInRange\n * @see octDecodeFromVector4\n */\nexport function octEncodeToVector4(vector, result) {\n  octEncodeInRange(vector, 65535, octEncodeScratch);\n  result.x = forceUint8(octEncodeScratch.x * RIGHT_SHIFT);\n  result.y = forceUint8(octEncodeScratch.x);\n  result.z = forceUint8(octEncodeScratch.y * RIGHT_SHIFT);\n  result.w = forceUint8(octEncodeScratch.y);\n  return result;\n}\n\n/**\n * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component vector.\n *\n * @param {Number} x The x component of the oct-encoded unit length vector.\n * @param {Number} y The y component of the oct-encoded unit length vector.\n * @param {Number} rangeMax The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.\n * @param {Vector3} result The decoded and normalized vector\n * @returns {Vector3} The decoded and normalized vector.\n *\n * @exception {Error} x and y must be unsigned normalized integers between 0 and rangeMax.\n *\n * @see octEncodeInRange\n */\nexport function octDecodeInRange(x, y, rangeMax, result) {\n  assert(result);\n  if (x < 0 || x > rangeMax || y < 0 || y > rangeMax) {\n    throw new Error(`x and y must be unsigned normalized integers between 0 and ${rangeMax}`);\n  }\n\n  result.x = fromSNorm(x, rangeMax);\n  result.y = fromSNorm(y, rangeMax);\n  result.z = 1.0 - (Math.abs(result.x) + Math.abs(result.y));\n\n  if (result.z < 0.0) {\n    const oldVX = result.x;\n    result.x = (1.0 - Math.abs(result.y)) * signNotZero(oldVX);\n    result.y = (1.0 - Math.abs(oldVX)) * signNotZero(result.y);\n  }\n\n  return result.normalize();\n}\n\n/**\n * Decodes a unit-length vector in 2 byte 'oct' encoding to a normalized 3-component vector.\n *\n * @param {Number} x The x component of the oct-encoded unit length vector.\n * @param {Number} y The y component of the oct-encoded unit length vector.\n * @param {Vector3} result The decoded and normalized vector.\n * @returns {Vector3} The decoded and normalized vector.\n *\n * @exception {Error} x and y must be an unsigned normalized integer between 0 and 255.\n *\n * @see octDecodeInRange\n */\nexport function octDecode(x, y, result) {\n  return octDecodeInRange(x, y, 255, result);\n}\n\n/**\n * Decodes a unit-length vector in 4 byte 'oct' encoding to a normalized 3-component vector.\n *\n * @param {Vector4} encoded The oct-encoded unit length vector.\n * @param {Vector3} result The decoded and normalized vector.\n * @returns {Vector3} The decoded and normalized vector.\n *\n * @exception {Error} x, y, z, and w must be unsigned normalized integers between 0 and 255.\n *\n * @see octDecodeInRange\n * @see octEncodeToVector4\n */\nexport function octDecodeFromVector4(encoded, result) {\n  assert(encoded);\n  assert(result);\n  const x = encoded.x;\n  const y = encoded.y;\n  const z = encoded.z;\n  const w = encoded.w;\n  if (x < 0 || x > 255 || y < 0 || y > 255 || z < 0 || z > 255 || w < 0 || w > 255) {\n    throw new Error('x, y, z, and w must be unsigned normalized integers between 0 and 255');\n  }\n\n  const xOct16 = x * LEFT_SHIFT + y;\n  const yOct16 = z * LEFT_SHIFT + w;\n  return octDecodeInRange(xOct16, yOct16, 65535, result);\n}\n\n/**\n * Packs an oct encoded vector into a single floating-point number.\n *\n * @param {Vector2} encoded The oct encoded vector.\n * @returns {Number} The oct encoded vector packed into a single float.\n *\n */\nexport function octPackFloat(encoded) {\n  const vector2 = scratchVector2.from(encoded);\n  return 256.0 * vector2.x + vector2.y;\n}\n\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-255] following the 'oct' encoding and\n * stores those values in a single float-point number.\n *\n * @param {Vector3} vector The normalized vector to be compressed into 2 byte 'oct' encoding.\n * @returns {Number} The 2 byte oct-encoded unit length vector.\n *\n * @exception {Error} vector must be normalized.\n */\nexport function octEncodeFloat(vector) {\n  octEncode(vector, scratchEncodeVector2);\n  return octPackFloat(scratchEncodeVector2);\n}\n\n/**\n * Decodes a unit-length vector in 'oct' encoding packed in a floating-point number to a normalized 3-component vector.\n *\n * @param {Number} value The oct-encoded unit length vector stored as a single floating-point number.\n * @param {Vector3} result The decoded and normalized vector\n * @returns {Vector3} The decoded and normalized vector.\n *\n */\nexport function octDecodeFloat(value, result) {\n  assert(Number.isFinite(value));\n\n  const temp = value / 256.0;\n  const x = Math.floor(temp);\n  const y = (temp - x) * 256.0;\n\n  return octDecode(x, y, result);\n}\n\n/**\n * Encodes three normalized vectors into 6 SNORM values in the range of [0-255] following the 'oct' encoding and\n * packs those into two floating-point numbers.\n *\n * @param {Vector3} v1 A normalized vector to be compressed.\n * @param {Vector3} v2 A normalized vector to be compressed.\n * @param {Vector3} v3 A normalized vector to be compressed.\n * @param {Vector2} result The 'oct' encoded vectors packed into two floating-point numbers.\n * @returns {Vector2} The 'oct' encoded vectors packed into two floating-point numbers.\n *\n */\nexport function octPack(v1, v2, v3, result) {\n  assert(v1);\n  assert(v2);\n  assert(v3);\n  assert(result);\n\n  const encoded1 = octEncodeFloat(v1);\n  const encoded2 = octEncodeFloat(v2);\n\n  const encoded3 = octEncode(v3, scratchEncodeVector2);\n  result.x = 65536.0 * encoded3.x + encoded1;\n  result.y = 65536.0 * encoded3.y + encoded2;\n  return result;\n}\n\n/**\n * Decodes three unit-length vectors in 'oct' encoding packed into a floating-point number to a normalized 3-component vector.\n *\n * @param {Vector2} packed The three oct-encoded unit length vectors stored as two floating-point number.\n * @param {Vector3} v1 One decoded and normalized vector.\n * @param {Vector3} v2 One decoded and normalized vector.\n * @param {Vector3} v3 One decoded and normalized vector.\n */\nexport function octUnpack(packed, v1, v2, v3) {\n  let temp = packed.x / 65536.0;\n  const x = Math.floor(temp);\n  const encodedFloat1 = (temp - x) * 65536.0;\n\n  temp = packed.y / 65536.0;\n  const y = Math.floor(temp);\n  const encodedFloat2 = (temp - y) * 65536.0;\n\n  octDecodeFloat(encodedFloat1, v1);\n  octDecodeFloat(encodedFloat2, v2);\n  octDecode(x, y, v3);\n}\n\n/**\n * Pack texture coordinates into a single float. The texture coordinates will only preserve 12 bits of precision.\n *\n * @param {Vector2} textureCoordinates The texture coordinates to compress.  Both coordinates must be in the range 0.0-1.0.\n * @returns {Number} The packed texture coordinates.\n *\n */\nexport function compressTextureCoordinates(textureCoordinates) {\n  // Move x and y to the range 0-4095;\n  const x = (textureCoordinates.x * 4095.0) | 0;\n  const y = (textureCoordinates.y * 4095.0) | 0;\n  return 4096.0 * x + y;\n}\n\n/**\n * Decompresses texture coordinates that were packed into a single float.\n *\n * @param {Number} compressed The compressed texture coordinates.\n * @param {Vector2} result The decompressed texture coordinates.\n * @returns {Vector2} The modified result parameter.\n *\n */\nexport function decompressTextureCoordinates(compressed, result) {\n  const temp = compressed / 4096.0;\n  const xZeroTo4095 = Math.floor(temp);\n  result.x = xZeroTo4095 / 4095.0;\n  result.y = (compressed - xZeroTo4095 * 4096) / 4095;\n  return result;\n}\n\n/**\n * Decodes delta and ZigZag encoded vertices. This modifies the buffers in place.\n *\n * @param {Uint16Array} uBuffer The buffer view of u values.\n * @param {Uint16Array} vBuffer The buffer view of v values.\n * @param {Uint16Array} [heightBuffer] The buffer view of height values.\n *\n * @see {@link https://github.com/AnalyticalGraphicsInc/quantized-mesh|quantized-mesh-1.0 terrain format}\n */\nexport function zigZagDeltaDecode(uBuffer, vBuffer, heightBuffer) {\n  assert(uBuffer);\n  assert(vBuffer);\n  assert(uBuffer.length === vBuffer.length);\n  if (heightBuffer) {\n    assert(uBuffer.length === heightBuffer.length);\n  }\n\n  function zigZagDecode(value) {\n    return (value >> 1) ^ -(value & 1);\n  }\n\n  let u = 0;\n  let v = 0;\n  let height = 0;\n\n  for (let i = 0; i < uBuffer.length; ++i) {\n    u += zigZagDecode(uBuffer[i]);\n    v += zigZagDecode(vBuffer[i]);\n\n    uBuffer[i] = u;\n    vBuffer[i] = v;\n\n    if (heightBuffer) {\n      height += zigZagDecode(heightBuffer[i]);\n      heightBuffer[i] = height;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}