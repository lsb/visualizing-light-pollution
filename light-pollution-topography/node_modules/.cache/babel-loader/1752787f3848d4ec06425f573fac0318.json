{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { VectorTile } from '@mapbox/vector-tile';\nimport Protobuf from 'pbf';\nimport { transformCoordinates, transformToLocalCoordinates } from './transform-to-local-range';\nexport default function parseMVT(input, options) {\n  if (input.byteLength === 0) {\n    return [];\n  }\n\n  var tile = new VectorTile(new Protobuf(input));\n  var loaderOptions = options.mvt;\n  var features = [];\n  var selectedLayers = Array.isArray(loaderOptions.layers) ? loaderOptions.layers : Object.keys(tile.layers);\n  selectedLayers.forEach(function (layerName) {\n    var vectorTileLayer = tile.layers[layerName];\n\n    var featureOptions = _objectSpread({}, loaderOptions, {\n      layerName: layerName\n    });\n\n    if (!vectorTileLayer) {\n      return;\n    }\n\n    for (var i = 0; i < vectorTileLayer.length; i++) {\n      var vectorTileFeature = vectorTileLayer.feature(i);\n      var decodedFeature = getDecodedFeature(vectorTileFeature, featureOptions);\n      features.push(decodedFeature);\n    }\n  });\n  return features;\n}\n\nfunction getDecodedFeature(feature) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var wgs84Coordinates = options.coordinates === 'wgs84';\n  var hasTileIndex = options.tileIndex && options.tileIndex.x && options.tileIndex.y && options.tileIndex.z;\n\n  if (wgs84Coordinates && !hasTileIndex) {\n    throw new Error('MVT Loader: WGS84 coordinates need tileIndex property. Check documentation.');\n  }\n\n  var decodedFeature = wgs84Coordinates && hasTileIndex ? feature.toGeoJSON(options.tileIndex.x, options.tileIndex.y, options.tileIndex.z) : transformCoordinates(feature, transformToLocalCoordinates);\n\n  if (options.layerProperty) {\n    decodedFeature.properties[options.layerProperty] = options.layerName;\n  }\n\n  return decodedFeature;\n}","map":{"version":3,"sources":["../../../src/lib/parse-mvt.js"],"names":["input","tile","loaderOptions","options","features","selectedLayers","Array","Object","vectorTileLayer","featureOptions","layerName","i","vectorTileFeature","decodedFeature","getDecodedFeature","wgs84Coordinates","hasTileIndex","feature","transformCoordinates"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAAA,UAAA,QAAA,qBAAA;AACA,OAAA,QAAA,MAAA,KAAA;AACA,SAAA,oBAAA,EAAA,2BAAA,QAAA,4BAAA;AAQA,eAAe,SAAA,QAAA,CAAA,KAAA,EAAA,OAAA,EAAkC;AAC/C,MAAIA,KAAK,CAALA,UAAAA,KAAJ,CAAA,EAA4B;AAC1B,WAAA,EAAA;AACD;;AAED,MAAMC,IAAI,GAAG,IAAA,UAAA,CAAe,IAAA,QAAA,CAA5B,KAA4B,CAAf,CAAb;AACA,MAAMC,aAAa,GAAGC,OAAO,CAA7B,GAAA;AACA,MAAMC,QAAQ,GAAd,EAAA;AAEA,MAAMC,cAAc,GAAGC,KAAK,CAALA,OAAAA,CAAcJ,aAAa,CAA3BI,MAAAA,IACnBJ,aAAa,CADMI,MAAAA,GAEnBC,MAAM,CAANA,IAAAA,CAAYN,IAAI,CAFpB,MAEIM,CAFJ;AAIAF,EAAAA,cAAc,CAAdA,OAAAA,CAAuB,UAAA,SAAA,EAAa;AAClC,QAAMG,eAAe,GAAGP,IAAI,CAAJA,MAAAA,CAAxB,SAAwBA,CAAxB;;AACA,QAAMQ,cAAc,GAAA,aAAA,CAAA,EAAA,EAAA,aAAA,EAAA;AAAsBC,MAAAA,SAAS,EAATA;AAAtB,KAAA,CAApB;;AAEA,QAAI,CAAJ,eAAA,EAAsB;AACpB;AACD;;AAED,SAAK,IAAIC,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGH,eAAe,CAAnC,MAAA,EAA4CG,CAA5C,EAAA,EAAiD;AAC/C,UAAMC,iBAAiB,GAAGJ,eAAe,CAAfA,OAAAA,CAA1B,CAA0BA,CAA1B;AAEA,UAAMK,cAAc,GAAGC,iBAAiB,CAAA,iBAAA,EAAxC,cAAwC,CAAxC;AACAV,MAAAA,QAAQ,CAARA,IAAAA,CAAAA,cAAAA;AACD;AAbHC,GAAAA;AAgBA,SAAA,QAAA;AACD;;AAED,SAAA,iBAAA,CAAA,OAAA,EAAkD;AAAA,MAAdF,OAAc,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,EAAI;AAChD,MAAMY,gBAAgB,GAAGZ,OAAO,CAAPA,WAAAA,KAAzB,OAAA;AACA,MAAMa,YAAY,GAChBb,OAAO,CAAPA,SAAAA,IAAqBA,OAAO,CAAPA,SAAAA,CAArBA,CAAAA,IAA4CA,OAAO,CAAPA,SAAAA,CAA5CA,CAAAA,IAAmEA,OAAO,CAAPA,SAAAA,CADrE,CAAA;;AAGA,MAAIY,gBAAgB,IAAI,CAAxB,YAAA,EAAuC;AACrC,UAAM,IAAA,KAAA,CAAN,6EAAM,CAAN;AACD;;AAED,MAAMF,cAAc,GAClBE,gBAAgB,IAAhBA,YAAAA,GACIE,OAAO,CAAPA,SAAAA,CAAkBd,OAAO,CAAPA,SAAAA,CAAlBc,CAAAA,EAAuCd,OAAO,CAAPA,SAAAA,CAAvCc,CAAAA,EAA4Dd,OAAO,CAAPA,SAAAA,CADhEY,CACIE,CADJF,GAEIG,oBAAoB,CAAA,OAAA,EAH1B,2BAG0B,CAH1B;;AAMA,MAAIf,OAAO,CAAX,aAAA,EAA2B;AACzBU,IAAAA,cAAc,CAAdA,UAAAA,CAA0BV,OAAO,CAAjCU,aAAAA,IAAmDV,OAAO,CAA1DU,SAAAA;AACD;;AAED,SAAA,cAAA;AACD","sourcesContent":["import {VectorTile} from '@mapbox/vector-tile';\nimport Protobuf from 'pbf';\nimport {transformCoordinates, transformToLocalCoordinates} from './transform-to-local-range';\n\n/*\n  * Parse MVT arrayBuffer and return GeoJSON.\n  *\n  * @param {arrayBuffer} _ A MVT arrayBuffer\n  * @return {?Object} A GeoJSON geometry object\n  */\nexport default function parseMVT(input, options) {\n  if (input.byteLength === 0) {\n    return [];\n  }\n\n  const tile = new VectorTile(new Protobuf(input));\n  const loaderOptions = options.mvt;\n  const features = [];\n\n  const selectedLayers = Array.isArray(loaderOptions.layers)\n    ? loaderOptions.layers\n    : Object.keys(tile.layers);\n\n  selectedLayers.forEach(layerName => {\n    const vectorTileLayer = tile.layers[layerName];\n    const featureOptions = {...loaderOptions, layerName};\n\n    if (!vectorTileLayer) {\n      return;\n    }\n\n    for (let i = 0; i < vectorTileLayer.length; i++) {\n      const vectorTileFeature = vectorTileLayer.feature(i);\n\n      const decodedFeature = getDecodedFeature(vectorTileFeature, featureOptions);\n      features.push(decodedFeature);\n    }\n  });\n\n  return features;\n}\n\nfunction getDecodedFeature(feature, options = {}) {\n  const wgs84Coordinates = options.coordinates === 'wgs84';\n  const hasTileIndex =\n    options.tileIndex && options.tileIndex.x && options.tileIndex.y && options.tileIndex.z;\n\n  if (wgs84Coordinates && !hasTileIndex) {\n    throw new Error('MVT Loader: WGS84 coordinates need tileIndex property. Check documentation.');\n  }\n\n  const decodedFeature =\n    wgs84Coordinates && hasTileIndex\n      ? feature.toGeoJSON(options.tileIndex.x, options.tileIndex.y, options.tileIndex.z)\n      : transformCoordinates(feature, transformToLocalCoordinates);\n\n  // Add layer name to GeoJSON properties\n  if (options.layerProperty) {\n    decodedFeature.properties[options.layerProperty] = options.layerName;\n  }\n\n  return decodedFeature;\n}\n"]},"metadata":{},"sourceType":"module"}