{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread\";\nimport { Buffer, assert } from '@luma.gl/webgl';\nvar GLTF_TO_LUMA_ATTRIBUTE_MAP = {\n  POSITION: 'positions',\n  NORMAL: 'normals',\n  COLOR_0: 'colors',\n  TEXCOORD_0: 'texCoords',\n  TEXCOORD_1: 'texCoords1',\n  TEXCOORD_2: 'texCoords2'\n};\nexport function getBuffersFromGeometry(gl, geometry, options) {\n  var buffers = {};\n  var indices = geometry.indices;\n\n  for (var name in geometry.attributes) {\n    var attribute = geometry.attributes[name];\n    var remappedName = mapAttributeName(name, options);\n\n    if (name === 'indices') {\n      indices = attribute;\n    } else if (attribute.constant) {\n      buffers[remappedName] = attribute.value;\n    } else {\n      var typedArray = attribute.value;\n\n      var accessor = _objectSpread({}, attribute);\n\n      delete accessor.value;\n      buffers[remappedName] = [new Buffer(gl, typedArray), accessor];\n      inferAttributeAccessor(name, accessor);\n    }\n  }\n\n  if (indices) {\n    var data = indices.value || indices;\n    assert(data instanceof Uint16Array || data instanceof Uint32Array, 'attribute array for \"indices\" must be of integer type');\n    var _accessor = {\n      size: 1,\n      isIndexed: indices.isIndexed === undefined ? true : indices.isIndexed\n    };\n    buffers.indices = [new Buffer(gl, {\n      data: data,\n      target: 34963\n    }), _accessor];\n  }\n\n  return buffers;\n}\n\nfunction mapAttributeName(name, options) {\n  var _ref = options || {},\n      _ref$attributeMap = _ref.attributeMap,\n      attributeMap = _ref$attributeMap === void 0 ? GLTF_TO_LUMA_ATTRIBUTE_MAP : _ref$attributeMap;\n\n  return attributeMap && attributeMap[name] || name;\n}\n\nexport function inferAttributeAccessor(attributeName, attribute) {\n  var category;\n\n  switch (attributeName) {\n    case 'texCoords':\n    case 'texCoord1':\n    case 'texCoord2':\n    case 'texCoord3':\n      category = 'uvs';\n      break;\n\n    case 'vertices':\n    case 'positions':\n    case 'normals':\n    case 'pickingColors':\n      category = 'vectors';\n      break;\n\n    default:\n  }\n\n  switch (category) {\n    case 'vectors':\n      attribute.size = attribute.size || 3;\n      break;\n\n    case 'uvs':\n      attribute.size = attribute.size || 2;\n      break;\n\n    default:\n  }\n\n  assert(Number.isFinite(attribute.size), \"attribute \".concat(attributeName, \" needs size\"));\n}","map":{"version":3,"sources":["../../../src/lib/model-utils.js"],"names":["GLTF_TO_LUMA_ATTRIBUTE_MAP","POSITION","NORMAL","COLOR_0","TEXCOORD_0","TEXCOORD_1","TEXCOORD_2","buffers","indices","geometry","attribute","remappedName","mapAttributeName","name","typedArray","accessor","inferAttributeAccessor","data","assert","size","isIndexed","target","attributeMap","options","category","Number"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport {Buffer, assert} from '@luma.gl/webgl';\n\n// Support for mapping new geometries with glTF attribute names to \"classic\" luma.gl shader names\nconst GLTF_TO_LUMA_ATTRIBUTE_MAP = {\n  POSITION: 'positions',\n  NORMAL: 'normals',\n  COLOR_0: 'colors',\n  TEXCOORD_0: 'texCoords',\n  TEXCOORD_1: 'texCoords1',\n  TEXCOORD_2: 'texCoords2'\n};\n\nexport function getBuffersFromGeometry(gl, geometry, options) {\n  const buffers = {};\n  let indices = geometry.indices;\n\n  for (const name in geometry.attributes) {\n    const attribute = geometry.attributes[name];\n    const remappedName = mapAttributeName(name, options);\n\n    if (name === 'indices') {\n      indices = attribute;\n    } else if (attribute.constant) {\n      buffers[remappedName] = attribute.value;\n    } else {\n      const typedArray = attribute.value;\n      // Create accessor by copying the attribute and removing `value``\n      const accessor = {...attribute};\n      delete accessor.value;\n      buffers[remappedName] = [new Buffer(gl, typedArray), accessor];\n\n      inferAttributeAccessor(name, accessor);\n    }\n  }\n\n  if (indices) {\n    const data = indices.value || indices;\n    assert(\n      data instanceof Uint16Array || data instanceof Uint32Array,\n      'attribute array for \"indices\" must be of integer type'\n    );\n    const accessor = {\n      size: 1,\n      isIndexed: indices.isIndexed === undefined ? true : indices.isIndexed\n    };\n    buffers.indices = [\n      new Buffer(gl, {\n        data,\n        target: GL.ELEMENT_ARRAY_BUFFER\n      }),\n      accessor\n    ];\n  }\n\n  return buffers;\n}\n\nfunction mapAttributeName(name, options) {\n  const {attributeMap = GLTF_TO_LUMA_ATTRIBUTE_MAP} = options || {};\n  return (attributeMap && attributeMap[name]) || name;\n}\n\n// Check for well known attribute names\n// eslint-disable-next-line complexity\nexport function inferAttributeAccessor(attributeName, attribute) {\n  let category;\n  switch (attributeName) {\n    case 'texCoords':\n    case 'texCoord1':\n    case 'texCoord2':\n    case 'texCoord3':\n      category = 'uvs';\n      break;\n    case 'vertices':\n    case 'positions':\n    case 'normals':\n    case 'pickingColors':\n      category = 'vectors';\n      break;\n    default:\n  }\n\n  // Check for categorys\n  switch (category) {\n    case 'vectors':\n      attribute.size = attribute.size || 3;\n      break;\n    case 'uvs':\n      attribute.size = attribute.size || 2;\n      break;\n    default:\n  }\n\n  assert(Number.isFinite(attribute.size), `attribute ${attributeName} needs size`);\n}\n"]},"metadata":{},"sourceType":"module"}