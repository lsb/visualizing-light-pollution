{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { log } from '@luma.gl/gltools';\nimport { parseGLSLCompilerError, getShaderName } from '../glsl-utils';\nimport { assertWebGLContext } from '../webgl-utils';\nimport { uid, assert } from '../utils';\nimport Resource from './resource';\nvar ERR_SOURCE = 'Shader: GLSL source code must be a JavaScript string';\nexport var Shader = function (_Resource) {\n  _inherits(Shader, _Resource);\n\n  _createClass(Shader, null, [{\n    key: \"getTypeName\",\n    value: function getTypeName(shaderType) {\n      switch (shaderType) {\n        case 35633:\n          return 'vertex-shader';\n\n        case 35632:\n          return 'fragment-shader';\n\n        default:\n          assert(false);\n          return 'unknown';\n      }\n    }\n  }]);\n\n  function Shader(gl, props) {\n    var _this;\n\n    _classCallCheck(this, Shader);\n\n    assertWebGLContext(gl);\n    assert(typeof props.source === 'string', ERR_SOURCE);\n    var id = getShaderName(props.source, null) || props.id || uid(\"unnamed \".concat(Shader.getTypeName(props.shaderType)));\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Shader).call(this, gl, {\n      id: id\n    }));\n    _this.shaderType = props.shaderType;\n    _this.source = props.source;\n\n    _this.initialize(props);\n\n    return _this;\n  }\n\n  _createClass(Shader, [{\n    key: \"initialize\",\n    value: function initialize(_ref) {\n      var source = _ref.source;\n      var shaderName = getShaderName(source, null);\n\n      if (shaderName) {\n        this.id = uid(shaderName);\n      }\n\n      this._compile(source);\n    }\n  }, {\n    key: \"getParameter\",\n    value: function getParameter(pname) {\n      return this.gl.getShaderParameter(this.handle, pname);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(Shader.getTypeName(this.shaderType), \":\").concat(this.id);\n    }\n  }, {\n    key: \"getName\",\n    value: function getName() {\n      return getShaderName(this.source) || 'unnamed-shader';\n    }\n  }, {\n    key: \"getSource\",\n    value: function getSource() {\n      return this.gl.getShaderSource(this.handle);\n    }\n  }, {\n    key: \"getTranslatedSource\",\n    value: function getTranslatedSource() {\n      var extension = this.gl.getExtension('WEBGL.debug_shaders');\n      return extension ? extension.getTranslatedShaderSource(this.handle) : 'No translated source available. WEBGL.debug_shaders not implemented';\n    }\n  }, {\n    key: \"_compile\",\n    value: function _compile() {\n      var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.source;\n\n      if (!source.startsWith('#version ')) {\n        source = \"#version 100\\n\".concat(source);\n      }\n\n      this.source = source;\n      this.gl.shaderSource(this.handle, this.source);\n      this.gl.compileShader(this.handle);\n      var compileStatus = this.getParameter(35713);\n\n      if (!compileStatus) {\n        var infoLog = this.gl.getShaderInfoLog(this.handle);\n\n        var _parseGLSLCompilerErr = parseGLSLCompilerError(infoLog, this.source, this.shaderType, this.id),\n            shaderName = _parseGLSLCompilerErr.shaderName,\n            errors = _parseGLSLCompilerErr.errors,\n            warnings = _parseGLSLCompilerErr.warnings;\n\n        log.error(\"GLSL compilation errors in \".concat(shaderName, \"\\n\").concat(errors))();\n        log.warn(\"GLSL compilation warnings in \".concat(shaderName, \"\\n\").concat(warnings))();\n        throw new Error(\"GLSL compilation errors in \".concat(shaderName));\n      }\n    }\n  }, {\n    key: \"_deleteHandle\",\n    value: function _deleteHandle() {\n      this.gl.deleteShader(this.handle);\n    }\n  }, {\n    key: \"_getOptsFromHandle\",\n    value: function _getOptsFromHandle() {\n      return {\n        type: this.getParameter(35663),\n        source: this.getSource()\n      };\n    }\n  }]);\n\n  return Shader;\n}(Resource);\nexport var VertexShader = function (_Shader) {\n  _inherits(VertexShader, _Shader);\n\n  function VertexShader(gl, props) {\n    _classCallCheck(this, VertexShader);\n\n    if (typeof props === 'string') {\n      props = {\n        source: props\n      };\n    }\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(VertexShader).call(this, gl, Object.assign({}, props, {\n      shaderType: 35633\n    })));\n  }\n\n  _createClass(VertexShader, [{\n    key: \"_createHandle\",\n    value: function _createHandle() {\n      return this.gl.createShader(35633);\n    }\n  }]);\n\n  return VertexShader;\n}(Shader);\nexport var FragmentShader = function (_Shader2) {\n  _inherits(FragmentShader, _Shader2);\n\n  function FragmentShader(gl, props) {\n    _classCallCheck(this, FragmentShader);\n\n    if (typeof props === 'string') {\n      props = {\n        source: props\n      };\n    }\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(FragmentShader).call(this, gl, Object.assign({}, props, {\n      shaderType: 35632\n    })));\n  }\n\n  _createClass(FragmentShader, [{\n    key: \"_createHandle\",\n    value: function _createHandle() {\n      return this.gl.createShader(35632);\n    }\n  }]);\n\n  return FragmentShader;\n}(Shader);","map":{"version":3,"sources":["../../../src/classes/shader.js"],"names":["ERR_SOURCE","Shader","assert","assertWebGLContext","props","id","getShaderName","uid","source","shaderName","extension","compileStatus","infoLog","errors","warnings","parseGLSLCompilerError","log","type","VertexShader","shaderType","FragmentShader"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport {log} from '@luma.gl/gltools';\nimport {parseGLSLCompilerError, getShaderName} from '../glsl-utils';\nimport {assertWebGLContext} from '../webgl-utils';\nimport {uid, assert} from '../utils';\nimport Resource from './resource';\n\nconst ERR_SOURCE = 'Shader: GLSL source code must be a JavaScript string';\n\n// For now this is an internal class\nexport class Shader extends Resource {\n  static getTypeName(shaderType) {\n    switch (shaderType) {\n      case GL.VERTEX_SHADER:\n        return 'vertex-shader';\n      case GL.FRAGMENT_SHADER:\n        return 'fragment-shader';\n      default:\n        assert(false);\n        return 'unknown';\n    }\n  }\n\n  /* eslint-disable max-statements */\n  constructor(gl, props) {\n    assertWebGLContext(gl);\n\n    // Validate arguments\n    assert(typeof props.source === 'string', ERR_SOURCE);\n\n    // Deduce an id, from shader source, or supplied id, or shader type\n    const id =\n      getShaderName(props.source, null) ||\n      props.id ||\n      uid(`unnamed ${Shader.getTypeName(props.shaderType)}`);\n\n    super(gl, {id});\n\n    this.shaderType = props.shaderType;\n    this.source = props.source;\n\n    this.initialize(props);\n  }\n\n  initialize({source}) {\n    const shaderName = getShaderName(source, null);\n    if (shaderName) {\n      this.id = uid(shaderName);\n    }\n    this._compile(source);\n  }\n\n  // Accessors\n\n  getParameter(pname) {\n    return this.gl.getShaderParameter(this.handle, pname);\n  }\n\n  toString() {\n    return `${Shader.getTypeName(this.shaderType)}:${this.id}`;\n  }\n\n  getName() {\n    return getShaderName(this.source) || 'unnamed-shader';\n  }\n\n  getSource() {\n    return this.gl.getShaderSource(this.handle);\n  }\n\n  // Debug method - Returns translated source if available\n  getTranslatedSource() {\n    const extension = this.gl.getExtension('WEBGL.debug_shaders');\n    return extension\n      ? extension.getTranslatedShaderSource(this.handle)\n      : 'No translated source available. WEBGL.debug_shaders not implemented';\n  }\n\n  // PRIVATE METHODS\n  _compile(source = this.source) {\n    if (!source.startsWith('#version ')) {\n      source = `#version 100\\n${source}`;\n    }\n    this.source = source;\n    this.gl.shaderSource(this.handle, this.source);\n    this.gl.compileShader(this.handle);\n\n    // TODO - For performance reasons, avoid checking shader compilation errors on production?\n    // TODO - Load log even when no error reported, to catch warnings?\n    // https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings\n    const compileStatus = this.getParameter(GL.COMPILE_STATUS);\n    if (!compileStatus) {\n      const infoLog = this.gl.getShaderInfoLog(this.handle);\n      const {shaderName, errors, warnings} = parseGLSLCompilerError(\n        infoLog,\n        this.source,\n        this.shaderType,\n        this.id\n      );\n      log.error(`GLSL compilation errors in ${shaderName}\\n${errors}`)();\n      log.warn(`GLSL compilation warnings in ${shaderName}\\n${warnings}`)();\n      throw new Error(`GLSL compilation errors in ${shaderName}`);\n    }\n  }\n\n  _deleteHandle() {\n    this.gl.deleteShader(this.handle);\n  }\n\n  _getOptsFromHandle() {\n    return {\n      type: this.getParameter(GL.SHADER_TYPE),\n      source: this.getSource()\n    };\n  }\n}\n\nexport class VertexShader extends Shader {\n  constructor(gl, props) {\n    // Signature: new VertexShader(gl, source)\n    if (typeof props === 'string') {\n      props = {source: props};\n    }\n    super(gl, Object.assign({}, props, {shaderType: GL.VERTEX_SHADER}));\n  }\n\n  // PRIVATE METHODS\n  _createHandle() {\n    return this.gl.createShader(GL.VERTEX_SHADER);\n  }\n}\n\nexport class FragmentShader extends Shader {\n  constructor(gl, props) {\n    // Signature: new FragmentShader(gl, source)\n    if (typeof props === 'string') {\n      props = {source: props};\n    }\n\n    super(gl, Object.assign({}, props, {shaderType: GL.FRAGMENT_SHADER}));\n  }\n\n  // PRIVATE METHODS\n  _createHandle() {\n    return this.gl.createShader(GL.FRAGMENT_SHADER);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}