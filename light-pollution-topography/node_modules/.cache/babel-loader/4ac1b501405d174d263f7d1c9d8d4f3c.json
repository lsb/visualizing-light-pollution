{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { toUint8Array, joinUint8Arrays, toUint8ArrayIterator, toUint8ArrayAsyncIterator } from '../util/buffer';\n/** @ignore */\n\nexport default {\n  fromIterable(source) {\n    return pump(fromIterable(source));\n  },\n\n  fromAsyncIterable(source) {\n    return pump(fromAsyncIterable(source));\n  },\n\n  fromDOMStream(source) {\n    return pump(fromDOMStream(source));\n  },\n\n  fromNodeStream(stream) {\n    return pump(fromNodeStream(stream));\n  },\n\n  // @ts-ignore\n  toDOMStream(source, options) {\n    throw new Error(`\"toDOMStream\" not available in this environment`);\n  },\n\n  // @ts-ignore\n  toNodeStream(source, options) {\n    throw new Error(`\"toNodeStream\" not available in this environment`);\n  }\n\n};\n/** @ignore */\n\nconst pump = iterator => {\n  iterator.next();\n  return iterator;\n};\n/** @ignore */\n\n\nfunction* fromIterable(source) {\n  let done,\n      threw = false;\n  let buffers = [],\n      buffer;\n  let cmd,\n      size,\n      bufferLength = 0;\n\n  function byteRange() {\n    if (cmd === 'peek') {\n      return joinUint8Arrays(buffers, size)[0];\n    }\n\n    [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n    return buffer;\n  } // Yield so the caller can inject the read command before creating the source Iterator\n\n\n  ({\n    cmd,\n    size\n  } = yield null); // initialize the iterator\n\n  let it = toUint8ArrayIterator(source)[Symbol.iterator]();\n\n  try {\n    do {\n      // read the next value\n      ({\n        done,\n        value: buffer\n      } = isNaN(size - bufferLength) ? it.next(undefined) : it.next(size - bufferLength)); // if chunk is not null or empty, push it onto the queue\n\n      if (!done && buffer.byteLength > 0) {\n        buffers.push(buffer);\n        bufferLength += buffer.byteLength;\n      } // If we have enough bytes in our buffer, yield chunks until we don't\n\n\n      if (done || size <= bufferLength) {\n        do {\n          ({\n            cmd,\n            size\n          } = yield byteRange());\n        } while (size < bufferLength);\n      }\n    } while (!done);\n  } catch (e) {\n    (threw = true) && typeof it.throw === 'function' && it.throw(e);\n  } finally {\n    threw === false && typeof it.return === 'function' && it.return();\n  }\n}\n/** @ignore */\n\n\nasync function* fromAsyncIterable(source) {\n  let done,\n      threw = false;\n  let buffers = [],\n      buffer;\n  let cmd,\n      size,\n      bufferLength = 0;\n\n  function byteRange() {\n    if (cmd === 'peek') {\n      return joinUint8Arrays(buffers, size)[0];\n    }\n\n    [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n    return buffer;\n  } // Yield so the caller can inject the read command before creating the source AsyncIterator\n\n\n  ({\n    cmd,\n    size\n  } = yield null); // initialize the iterator\n\n  let it = toUint8ArrayAsyncIterator(source)[Symbol.asyncIterator]();\n\n  try {\n    do {\n      // read the next value\n      ({\n        done,\n        value: buffer\n      } = isNaN(size - bufferLength) ? await it.next(undefined) : await it.next(size - bufferLength)); // if chunk is not null or empty, push it onto the queue\n\n      if (!done && buffer.byteLength > 0) {\n        buffers.push(buffer);\n        bufferLength += buffer.byteLength;\n      } // If we have enough bytes in our buffer, yield chunks until we don't\n\n\n      if (done || size <= bufferLength) {\n        do {\n          ({\n            cmd,\n            size\n          } = yield byteRange());\n        } while (size < bufferLength);\n      }\n    } while (!done);\n  } catch (e) {\n    (threw = true) && typeof it.throw === 'function' && (await it.throw(e));\n  } finally {\n    threw === false && typeof it.return === 'function' && (await it.return());\n  }\n} // All this manual Uint8Array chunk management can be avoided if/when engines\n// add support for ArrayBuffer.transfer() or ArrayBuffer.prototype.realloc():\n// https://github.com/domenic/proposal-arraybuffer-transfer\n\n/** @ignore */\n\n\nasync function* fromDOMStream(source) {\n  let done = false,\n      threw = false;\n  let buffers = [],\n      buffer;\n  let cmd,\n      size,\n      bufferLength = 0;\n\n  function byteRange() {\n    if (cmd === 'peek') {\n      return joinUint8Arrays(buffers, size)[0];\n    }\n\n    [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n    return buffer;\n  } // Yield so the caller can inject the read command before we establish the ReadableStream lock\n\n\n  ({\n    cmd,\n    size\n  } = yield null); // initialize the reader and lock the stream\n\n  let it = new AdaptiveByteReader(source);\n\n  try {\n    do {\n      // read the next value\n      ({\n        done,\n        value: buffer\n      } = isNaN(size - bufferLength) ? await it['read'](undefined) : await it['read'](size - bufferLength)); // if chunk is not null or empty, push it onto the queue\n\n      if (!done && buffer.byteLength > 0) {\n        buffers.push(toUint8Array(buffer));\n        bufferLength += buffer.byteLength;\n      } // If we have enough bytes in our buffer, yield chunks until we don't\n\n\n      if (done || size <= bufferLength) {\n        do {\n          ({\n            cmd,\n            size\n          } = yield byteRange());\n        } while (size < bufferLength);\n      }\n    } while (!done);\n  } catch (e) {\n    (threw = true) && (await it['cancel'](e));\n  } finally {\n    threw === false ? await it['cancel']() : source['locked'] && it.releaseLock();\n  }\n}\n/** @ignore */\n\n\nclass AdaptiveByteReader {\n  constructor(source) {\n    this.source = source;\n    this.byobReader = null;\n    this.defaultReader = null;\n\n    try {\n      this.supportsBYOB = !!(this.reader = this.getBYOBReader());\n    } catch (e) {\n      this.supportsBYOB = !!!(this.reader = this.getDefaultReader());\n    }\n  }\n\n  get closed() {\n    return this.reader ? this.reader['closed'].catch(() => {}) : Promise.resolve();\n  }\n\n  releaseLock() {\n    if (this.reader) {\n      this.reader.releaseLock();\n    }\n\n    this.reader = this.byobReader = this.defaultReader = null;\n  }\n\n  async cancel(reason) {\n    const {\n      reader,\n      source\n    } = this;\n    reader && (await reader['cancel'](reason).catch(() => {}));\n    source && source['locked'] && this.releaseLock();\n  }\n\n  async read(size) {\n    if (size === 0) {\n      return {\n        done: this.reader == null,\n        value: new Uint8Array(0)\n      };\n    }\n\n    const result = !this.supportsBYOB || typeof size !== 'number' ? await this.getDefaultReader().read() : await this.readFromBYOBReader(size);\n    !result.done && (result.value = toUint8Array(result));\n    return result;\n  }\n\n  getDefaultReader() {\n    if (this.byobReader) {\n      this.releaseLock();\n    }\n\n    if (!this.defaultReader) {\n      this.defaultReader = this.source['getReader'](); // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions\n      // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified\n      // about why these errors are raised, but I'm sure there's some important spec reason that\n      // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the\n      // only solution in this case :/\n\n      this.defaultReader['closed'].catch(() => {});\n    }\n\n    return this.reader = this.defaultReader;\n  }\n\n  getBYOBReader() {\n    if (this.defaultReader) {\n      this.releaseLock();\n    }\n\n    if (!this.byobReader) {\n      this.byobReader = this.source['getReader']({\n        mode: 'byob'\n      }); // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions\n      // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified\n      // about why these errors are raised, but I'm sure there's some important spec reason that\n      // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the\n      // only solution in this case :/\n\n      this.byobReader['closed'].catch(() => {});\n    }\n\n    return this.reader = this.byobReader;\n  } // This strategy plucked from the example in the streams spec:\n  // https://streams.spec.whatwg.org/#example-manual-read-bytes\n\n\n  async readFromBYOBReader(size) {\n    return await readInto(this.getBYOBReader(), new ArrayBuffer(size), 0, size);\n  }\n\n}\n/** @ignore */\n\n\nasync function readInto(reader, buffer, offset, size) {\n  if (offset >= size) {\n    return {\n      done: false,\n      value: new Uint8Array(buffer, 0, size)\n    };\n  }\n\n  const {\n    done,\n    value\n  } = await reader.read(new Uint8Array(buffer, offset, size - offset));\n\n  if ((offset += value.byteLength) < size && !done) {\n    return await readInto(reader, value.buffer, offset, size);\n  }\n\n  return {\n    done,\n    value: new Uint8Array(value.buffer, 0, offset)\n  };\n}\n/** @ignore */\n\n\nconst onEvent = (stream, event) => {\n  let handler = _ => resolve([event, _]);\n\n  let resolve;\n  return [event, handler, new Promise(r => (resolve = r) && stream['once'](event, handler))];\n};\n/** @ignore */\n\n\nasync function* fromNodeStream(stream) {\n  let events = [];\n  let event = 'error';\n  let done = false,\n      err = null;\n  let cmd,\n      size,\n      bufferLength = 0;\n  let buffers = [],\n      buffer;\n\n  function byteRange() {\n    if (cmd === 'peek') {\n      return joinUint8Arrays(buffers, size)[0];\n    }\n\n    [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n    return buffer;\n  } // Yield so the caller can inject the read command before we\n  // add the listener for the source stream's 'readable' event.\n\n\n  ({\n    cmd,\n    size\n  } = yield null); // ignore stdin if it's a TTY\n\n  if (stream['isTTY']) {\n    return yield new Uint8Array(0);\n  }\n\n  try {\n    // initialize the stream event handlers\n    events[0] = onEvent(stream, 'end');\n    events[1] = onEvent(stream, 'error');\n\n    do {\n      events[2] = onEvent(stream, 'readable'); // wait on the first message event from the stream\n\n      [event, err] = await Promise.race(events.map(x => x[2])); // if the stream emitted an Error, rethrow it\n\n      if (event === 'error') {\n        break;\n      }\n\n      if (!(done = event === 'end')) {\n        // If the size is NaN, request to read everything in the stream's internal buffer\n        if (!isFinite(size - bufferLength)) {\n          buffer = toUint8Array(stream['read'](undefined));\n        } else {\n          buffer = toUint8Array(stream['read'](size - bufferLength)); // If the byteLength is 0, then the requested amount is more than the stream has\n          // in its internal buffer. In this case the stream needs a \"kick\" to tell it to\n          // continue emitting readable events, so request to read everything the stream\n          // has in its internal buffer right now.\n\n          if (buffer.byteLength < size - bufferLength) {\n            buffer = toUint8Array(stream['read'](undefined));\n          }\n        } // if chunk is not null or empty, push it onto the queue\n\n\n        if (buffer.byteLength > 0) {\n          buffers.push(buffer);\n          bufferLength += buffer.byteLength;\n        }\n      } // If we have enough bytes in our buffer, yield chunks until we don't\n\n\n      if (done || size <= bufferLength) {\n        do {\n          ({\n            cmd,\n            size\n          } = yield byteRange());\n        } while (size < bufferLength);\n      }\n    } while (!done);\n  } finally {\n    await cleanup(events, event === 'error' ? err : null);\n  }\n\n  function cleanup(events, err) {\n    buffer = buffers = null;\n    return new Promise(async (resolve, reject) => {\n      for (const [evt, fn] of events) {\n        stream['off'](evt, fn);\n      }\n\n      try {\n        // Some stream implementations don't call the destroy callback,\n        // because it's really a node-internal API. Just calling `destroy`\n        // here should be enough to conform to the ReadableStream contract\n        const destroy = stream['destroy'];\n        destroy && destroy.call(stream, err);\n        err = undefined;\n      } catch (e) {\n        err = e || err;\n      } finally {\n        err != null ? reject(err) : resolve();\n      }\n    });\n  }\n}","map":{"version":3,"sources":["io/adapters.ts"],"names":[],"mappings":"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","sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport {\n    toUint8Array,\n    joinUint8Arrays,\n    ArrayBufferViewInput,\n    toUint8ArrayIterator,\n    toUint8ArrayAsyncIterator\n} from '../util/buffer';\n\nimport { ReadableDOMStreamOptions } from './interfaces';\n\n/** @ignore */\nexport default {\n    fromIterable<T extends ArrayBufferViewInput>(source: Iterable<T> | T): IterableIterator<Uint8Array> {\n        return pump(fromIterable<T>(source));\n    },\n    fromAsyncIterable<T extends ArrayBufferViewInput>(source: AsyncIterable<T> | PromiseLike<T>): AsyncIterableIterator<Uint8Array> {\n        return pump(fromAsyncIterable<T>(source));\n    },\n    fromDOMStream<T extends ArrayBufferViewInput>(source: ReadableStream<T>): AsyncIterableIterator<Uint8Array> {\n        return pump(fromDOMStream<T>(source));\n    },\n    fromNodeStream(stream: NodeJS.ReadableStream): AsyncIterableIterator<Uint8Array> {\n        return pump(fromNodeStream(stream));\n    },\n    // @ts-ignore\n    toDOMStream<T>(source: Iterable<T> | AsyncIterable<T>, options?: ReadableDOMStreamOptions): ReadableStream<T> {\n        throw new Error(`\"toDOMStream\" not available in this environment`);\n    },\n    // @ts-ignore\n    toNodeStream<T>(source: Iterable<T> | AsyncIterable<T>, options?: import('stream').ReadableOptions): import('stream').Readable {\n        throw new Error(`\"toNodeStream\" not available in this environment`);\n    },\n};\n\n/** @ignore */\nconst pump = <T extends Iterator<any> | AsyncIterator<any>>(iterator: T) => { iterator.next(); return iterator; };\n\n/** @ignore */\nfunction* fromIterable<T extends ArrayBufferViewInput>(source: Iterable<T> | T): IterableIterator<Uint8Array> {\n\n    let done: boolean, threw = false;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before creating the source Iterator\n    ({ cmd, size } = yield <any> null);\n\n    // initialize the iterator\n    let it = toUint8ArrayIterator(source)[Symbol.iterator]();\n\n    try {\n        do {\n            // read the next value\n            ({ done, value: buffer } = isNaN(size - bufferLength) ?\n                it.next(undefined) : it.next(size - bufferLength));\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n                buffers.push(buffer);\n                bufferLength += buffer.byteLength;\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } catch (e) {\n        (threw = true) && (typeof it.throw === 'function') && (it.throw(e));\n    } finally {\n        (threw === false) && (typeof it.return === 'function') && (it.return());\n    }\n}\n\n/** @ignore */\nasync function* fromAsyncIterable<T extends ArrayBufferViewInput>(source: AsyncIterable<T> | PromiseLike<T>): AsyncIterableIterator<Uint8Array> {\n\n    let done: boolean, threw = false;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before creating the source AsyncIterator\n    ({ cmd, size } = yield <any> null);\n\n    // initialize the iterator\n    let it = toUint8ArrayAsyncIterator(source)[Symbol.asyncIterator]();\n\n    try {\n        do {\n            // read the next value\n            ({ done, value: buffer } = isNaN(size - bufferLength)\n                ? await it.next(undefined)\n                : await it.next(size - bufferLength));\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n                buffers.push(buffer);\n                bufferLength += buffer.byteLength;\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } catch (e) {\n        (threw = true) && (typeof it.throw === 'function') && (await it.throw(e));\n    } finally {\n        (threw === false) && (typeof it.return === 'function') && (await it.return());\n    }\n}\n\n// All this manual Uint8Array chunk management can be avoided if/when engines\n// add support for ArrayBuffer.transfer() or ArrayBuffer.prototype.realloc():\n// https://github.com/domenic/proposal-arraybuffer-transfer\n/** @ignore */\nasync function* fromDOMStream<T extends ArrayBufferViewInput>(source: ReadableStream<T>): AsyncIterableIterator<Uint8Array> {\n\n    let done = false, threw = false;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before we establish the ReadableStream lock\n    ({ cmd, size } = yield <any> null);\n\n    // initialize the reader and lock the stream\n    let it = new AdaptiveByteReader(source);\n\n    try {\n        do {\n            // read the next value\n            ({ done, value: buffer } = isNaN(size - bufferLength)\n                ? await it['read'](undefined)\n                : await it['read'](size - bufferLength));\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n                buffers.push(toUint8Array(buffer));\n                bufferLength += buffer.byteLength;\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } catch (e) {\n        (threw = true) && (await it['cancel'](e));\n    } finally {\n        (threw === false) ? (await it['cancel']())\n            : source['locked'] && it.releaseLock();\n    }\n}\n\n/** @ignore */\nclass AdaptiveByteReader<T extends ArrayBufferViewInput> {\n\n    private supportsBYOB: boolean;\n    private byobReader: ReadableStreamBYOBReader | null = null;\n    private defaultReader: ReadableStreamDefaultReader<T> | null = null;\n    private reader: ReadableStreamBYOBReader | ReadableStreamDefaultReader<T> | null;\n\n    constructor(private source: ReadableStream<T>) {\n        try {\n            this.supportsBYOB = !!(this.reader = this.getBYOBReader());\n        } catch (e) {\n            this.supportsBYOB = !!!(this.reader = this.getDefaultReader());\n        }\n    }\n\n    get closed(): Promise<void> {\n        return this.reader ? this.reader['closed'].catch(() => {}) : Promise.resolve();\n    }\n\n    releaseLock(): void {\n        if (this.reader) {\n            this.reader.releaseLock();\n        }\n        this.reader = this.byobReader = this.defaultReader = null;\n    }\n\n    async cancel(reason?: any): Promise<void> {\n        const { reader, source } = this;\n        reader && (await reader['cancel'](reason).catch(() => {}));\n        source && (source['locked'] && this.releaseLock());\n    }\n\n    async read(size?: number): Promise<ReadableStreamReadResult<Uint8Array>> {\n        if (size === 0) {\n            return { done: this.reader == null, value: new Uint8Array(0) };\n        }\n        const result = !this.supportsBYOB || typeof size !== 'number'\n            ? await this.getDefaultReader().read()\n            : await this.readFromBYOBReader(size);\n        !result.done && (result.value = toUint8Array(result as ReadableStreamReadResult<Uint8Array>));\n        return result as ReadableStreamReadResult<Uint8Array>;\n    }\n\n    private getDefaultReader() {\n        if (this.byobReader) { this.releaseLock(); }\n        if (!this.defaultReader) {\n            this.defaultReader = this.source['getReader']();\n            // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions\n            // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified\n            // about why these errors are raised, but I'm sure there's some important spec reason that\n            // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the\n            // only solution in this case :/\n            this.defaultReader['closed'].catch(() => {});\n        }\n        return (this.reader = this.defaultReader);\n    }\n\n    private getBYOBReader() {\n        if (this.defaultReader) { this.releaseLock(); }\n        if (!this.byobReader) {\n            this.byobReader = this.source['getReader']({ mode: 'byob' });\n            // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions\n            // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified\n            // about why these errors are raised, but I'm sure there's some important spec reason that\n            // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the\n            // only solution in this case :/\n            this.byobReader['closed'].catch(() => {});\n        }\n        return (this.reader = this.byobReader);\n    }\n\n    // This strategy plucked from the example in the streams spec:\n    // https://streams.spec.whatwg.org/#example-manual-read-bytes\n    private async readFromBYOBReader(size: number) {\n        return await readInto(this.getBYOBReader(), new ArrayBuffer(size), 0, size);\n    }\n}\n\n/** @ignore */\nasync function readInto(reader: ReadableStreamBYOBReader, buffer: ArrayBufferLike, offset: number, size: number): Promise<ReadableStreamReadResult<Uint8Array>> {\n    if (offset >= size) {\n        return { done: false, value: new Uint8Array(buffer, 0, size) };\n    }\n    const { done, value } = await reader.read(new Uint8Array(buffer, offset, size - offset));\n    if (((offset += value.byteLength) < size) && !done) {\n        return await readInto(reader, value.buffer, offset, size);\n    }\n    return { done, value: new Uint8Array(value.buffer, 0, offset) };\n}\n\n/** @ignore */\ntype EventName = 'end' | 'error' | 'readable';\n/** @ignore */\ntype Event = [EventName, (_: any) => void, Promise<[EventName, Error | null]>];\n/** @ignore */\nconst onEvent = <T extends string>(stream: NodeJS.ReadableStream, event: T) => {\n    let handler = (_: any) => resolve([event, _]);\n    let resolve: (value?: [T, any] | PromiseLike<[T, any]>) => void;\n    return [event, handler, new Promise<[T, any]>(\n        (r) => (resolve = r) && stream['once'](event, handler)\n    )] as Event;\n};\n\n/** @ignore */\nasync function* fromNodeStream(stream: NodeJS.ReadableStream): AsyncIterableIterator<Uint8Array> {\n\n    let events: Event[] = [];\n    let event: EventName = 'error';\n    let done = false, err: Error | null = null;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array | Buffer | string;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before we\n    // add the listener for the source stream's 'readable' event.\n    ({ cmd, size } = yield <any> null);\n\n    // ignore stdin if it's a TTY\n    if ((stream as any)['isTTY']) { return yield new Uint8Array(0); }\n\n    try {\n        // initialize the stream event handlers\n        events[0] = onEvent(stream, 'end');\n        events[1] = onEvent(stream, 'error');\n\n        do {\n            events[2] = onEvent(stream, 'readable');\n\n            // wait on the first message event from the stream\n            [event, err] = await Promise.race(events.map((x) => x[2]));\n\n            // if the stream emitted an Error, rethrow it\n            if (event === 'error') { break; }\n            if (!(done = event === 'end')) {\n                // If the size is NaN, request to read everything in the stream's internal buffer\n                if (!isFinite(size - bufferLength)) {\n                    buffer = toUint8Array(stream['read'](undefined));\n                } else {\n                    buffer = toUint8Array(stream['read'](size - bufferLength));\n                    // If the byteLength is 0, then the requested amount is more than the stream has\n                    // in its internal buffer. In this case the stream needs a \"kick\" to tell it to\n                    // continue emitting readable events, so request to read everything the stream\n                    // has in its internal buffer right now.\n                    if (buffer.byteLength < (size - bufferLength)) {\n                        buffer = toUint8Array(stream['read'](undefined));\n                    }\n                }\n                // if chunk is not null or empty, push it onto the queue\n                if (buffer.byteLength > 0) {\n                    buffers.push(buffer);\n                    bufferLength += buffer.byteLength;\n                }\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } finally {\n        await cleanup(events, event === 'error' ? err : null);\n    }\n\n    function cleanup<T extends Error | null | void>(events: Event[], err?: T) {\n        buffer = buffers = <any> null;\n        return new Promise<T>(async (resolve, reject) => {\n            for (const [evt, fn] of events) {\n                stream['off'](evt, fn);\n            }\n            try {\n                // Some stream implementations don't call the destroy callback,\n                // because it's really a node-internal API. Just calling `destroy`\n                // here should be enough to conform to the ReadableStream contract\n                const destroy = (stream as any)['destroy'];\n                destroy && destroy.call(stream, err);\n                err = undefined;\n            } catch (e) { err = e || err; } finally {\n                err != null ? reject(err) : resolve();\n            }\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}