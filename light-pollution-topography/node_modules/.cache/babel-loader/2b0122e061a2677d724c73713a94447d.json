{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport WorkerThread from './worker-thread';\n\nvar WorkerPool = function () {\n  function WorkerPool(_ref) {\n    var source = _ref.source,\n        _ref$name = _ref.name,\n        name = _ref$name === void 0 ? 'unnamed' : _ref$name,\n        _ref$maxConcurrency = _ref.maxConcurrency,\n        maxConcurrency = _ref$maxConcurrency === void 0 ? 1 : _ref$maxConcurrency,\n        onMessage = _ref.onMessage,\n        _ref$onDebug = _ref.onDebug,\n        onDebug = _ref$onDebug === void 0 ? function () {} : _ref$onDebug;\n\n    _classCallCheck(this, WorkerPool);\n\n    this.source = source;\n    this.name = name;\n    this.maxConcurrency = maxConcurrency;\n    this.onMessage = onMessage;\n    this.onDebug = onDebug;\n    this.jobQueue = [];\n    this.idleQueue = [];\n    this.count = 0;\n    this.isDestroyed = false;\n  }\n\n  _createClass(WorkerPool, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this.idleQueue.forEach(function (worker) {\n        return worker.destroy();\n      });\n      this.isDestroyed = true;\n    }\n  }, {\n    key: \"process\",\n    value: function () {\n      var _process = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(data, jobName) {\n        var _this = this;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  _this.jobQueue.push({\n                    data: data,\n                    jobName: jobName,\n                    resolve: resolve,\n                    reject: reject\n                  });\n\n                  _this._startQueuedJob();\n                }));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function process(_x, _x2) {\n        return _process.apply(this, arguments);\n      }\n\n      return process;\n    }()\n  }, {\n    key: \"_startQueuedJob\",\n    value: function _startQueuedJob() {\n      var _this2 = this;\n\n      if (!this.jobQueue.length) {\n        return;\n      }\n\n      var worker = this._getAvailableWorker();\n\n      if (!worker) {\n        return;\n      }\n\n      var job = this.jobQueue.shift();\n      this.onDebug({\n        message: 'processing',\n        worker: worker.name,\n        job: job.jobName,\n        backlog: this.jobQueue.length\n      });\n      worker.process(job.data).then(function (result) {\n        return job.resolve(result);\n      })[\"catch\"](function (error) {\n        return job.reject(error);\n      }).then(function () {\n        return _this2._onWorkerDone(worker);\n      });\n    }\n  }, {\n    key: \"_onWorkerDone\",\n    value: function _onWorkerDone(worker) {\n      if (this.isDestroyed) {\n        worker.destroy();\n      } else {\n        this.idleQueue.push(worker);\n\n        this._startQueuedJob();\n      }\n    }\n  }, {\n    key: \"_getAvailableWorker\",\n    value: function _getAvailableWorker() {\n      if (this.idleQueue.length > 0) {\n        return this.idleQueue.shift();\n      }\n\n      if (this.count < this.maxConcurrency) {\n        this.count++;\n        var name = \"\".concat(this.name.toLowerCase(), \" (#\").concat(this.count, \" of \").concat(this.maxConcurrency, \")\");\n        return new WorkerThread({\n          source: this.source,\n          onMessage: this.onMessage,\n          name: name\n        });\n      }\n\n      return null;\n    }\n  }]);\n\n  return WorkerPool;\n}();\n\nexport { WorkerPool as default };","map":{"version":3,"sources":["../../../src/worker-utils/worker-pool.js"],"names":["WorkerPool","source","name","maxConcurrency","onMessage","onDebug","worker","data","jobName","resolve","reject","job","message","backlog","length"],"mappings":"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","sourcesContent":["import WorkerThread from './worker-thread';\n\n/**\n * Process multiple data messages with small pool of identical workers\n */\nexport default class WorkerPool {\n  /**\n   * @param {function | string} processor - worker function\n   * @param {number} maxConcurrency - max count of workers\n   */\n  constructor({source, name = 'unnamed', maxConcurrency = 1, onMessage, onDebug = () => {}}) {\n    this.source = source;\n    this.name = name;\n    this.maxConcurrency = maxConcurrency;\n    this.onMessage = onMessage;\n    this.onDebug = onDebug;\n\n    this.jobQueue = [];\n    this.idleQueue = [];\n    this.count = 0;\n    this.isDestroyed = false;\n  }\n\n  destroy() {\n    // Destroy idle workers, active Workers will be destroyed on completion\n    this.idleQueue.forEach(worker => worker.destroy());\n    this.isDestroyed = true;\n  }\n\n  /**\n   * Process binary data in a worker\n   * @param data {data containing binary typed arrays} - data to be transferred to worker\n   * @returns a Promise with data containing typed arrays transferred back from work\n   */\n  async process(data, jobName) {\n    return new Promise((resolve, reject) => {\n      this.jobQueue.push({data, jobName, resolve, reject});\n      this._startQueuedJob();\n    });\n  }\n\n  // PRIVATE\n\n  _startQueuedJob() {\n    if (!this.jobQueue.length) {\n      return;\n    }\n    const worker = this._getAvailableWorker();\n    if (!worker) {\n      return;\n    }\n\n    // We have a worker, dequeue and start the job\n    const job = this.jobQueue.shift();\n\n    this.onDebug({\n      message: 'processing',\n      worker: worker.name,\n      job: job.jobName,\n      backlog: this.jobQueue.length\n    });\n\n    worker\n      .process(job.data)\n      .then(result => job.resolve(result))\n      .catch(error => job.reject(error))\n      .then(() => this._onWorkerDone(worker));\n  }\n\n  _onWorkerDone(worker) {\n    if (this.isDestroyed) {\n      worker.destroy();\n    } else {\n      this.idleQueue.push(worker);\n      this._startQueuedJob();\n    }\n  }\n\n  _getAvailableWorker() {\n    // If a worker has completed and returned to the queue, it can be used\n    if (this.idleQueue.length > 0) {\n      return this.idleQueue.shift();\n    }\n\n    // Create fresh worker if we haven't yet created the max amount of worker threads for this worker source\n    if (this.count < this.maxConcurrency) {\n      this.count++;\n      const name = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;\n      return new WorkerThread({source: this.source, onMessage: this.onMessage, name});\n    }\n\n    // No worker available, have to wait\n    return null;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}