{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { GLTFLoader } from '@loaders.gl/gltf';\nimport { getZeroOffsetArrayBuffer } from '@loaders.gl/loader-utils';\nexport var GLTF_FORMAT = {\n  URI: 0,\n  EMBEDDED: 1\n};\nexport function parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset) {\n  tile.rotateYtoZ = true;\n  var gltfByteLength = tile.byteOffset + tile.byteLength - byteOffset;\n\n  if (gltfByteLength === 0) {\n    throw new Error('glTF byte length must be greater than 0.');\n  }\n\n  tile.gltfArrayBuffer = getZeroOffsetArrayBuffer(arrayBuffer, byteOffset, gltfByteLength);\n  tile.gltfByteOffset = 0;\n  tile.gltfByteLength = gltfByteLength;\n\n  if (byteOffset % 4 === 0) {} else {\n    console.warn(\"\".concat(tile.type, \": embedded glb is not aligned to a 4-byte boundary.\"));\n  }\n\n  return tile.byteOffset + tile.byteLength;\n}\nexport function extractGLTF(_x, _x2, _x3, _x4) {\n  return _extractGLTF.apply(this, arguments);\n}\n\nfunction _extractGLTF() {\n  _extractGLTF = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(tile, gltfFormat, options, context) {\n    var parse, fetch;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            extractGLTFBufferOrURL(tile, gltfFormat, options);\n\n            if (!options.loadGLTF) {\n              _context.next = 15;\n              break;\n            }\n\n            parse = context.parse, fetch = context.fetch;\n\n            if (!tile.gltfUrl) {\n              _context.next = 8;\n              break;\n            }\n\n            _context.next = 6;\n            return fetch(tile.gltfUrl, options);\n\n          case 6:\n            tile.gltfArrayBuffer = _context.sent;\n            tile.gltfByteOffset = 0;\n\n          case 8:\n            if (!tile.gltfArrayBuffer) {\n              _context.next = 15;\n              break;\n            }\n\n            _context.next = 11;\n            return parse(tile.gltfArrayBuffer, GLTFLoader, options, context);\n\n          case 11:\n            tile.gltf = _context.sent;\n            delete tile.gltfArrayBuffer;\n            delete tile.gltfByteOffset;\n            delete tile.gltfByteLength;\n\n          case 15:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _extractGLTF.apply(this, arguments);\n}\n\nexport function extractGLTFSync(tile, gltfFormat, options, context) {\n  extractGLTFBufferOrURL(tile, gltfFormat, options);\n\n  if (options.loadGLTF) {\n    if (tile.gltfArrayBuffer) {\n      var parseSync = context.parseSync;\n      tile.gltf = parseSync(tile.gltfArrayBuffer, GLTFLoader, options, context);\n      delete tile.gltfArrayBuffer;\n      delete tile.gltfByteOffset;\n      delete tile.gltfByteLength;\n    } else if (tile.gltfUrl) {\n      throw new Error('cant load glTF URL synchronously');\n    }\n  }\n}\n\nfunction extractGLTFBufferOrURL(tile, gltfFormat, options) {\n  switch (gltfFormat) {\n    case GLTF_FORMAT.URI:\n      var gltfUrlBytes = new Uint8Array(tile.gltfArrayBuffer, tile.gltfByteOffset);\n      var textDecoder = new TextDecoder();\n      var gltfUrl = textDecoder.decode(gltfUrlBytes);\n      tile.gltfUrl = gltfUrl.replace(/[\\s\\0]+$/, '');\n      delete tile.gltfArrayBuffer;\n      delete tile.gltfByteOffset;\n      delete tile.gltfByteLength;\n      break;\n\n    case GLTF_FORMAT.EMBEDDED:\n      break;\n\n    default:\n      throw new Error(\"b3dm: Illegal glTF format field\");\n  }\n}","map":{"version":3,"sources":["../../../../../src/lib/parsers/helpers/parse-3d-tile-gltf-view.js"],"names":["GLTF_FORMAT","URI","EMBEDDED","tile","gltfByteLength","getZeroOffsetArrayBuffer","byteOffset","console","extractGLTFBufferOrURL","options","parse","fetch","context","parseSync","gltfUrlBytes","textDecoder","gltfUrl"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/* global TextDecoder */\n\n// TODO - should we automatically parse the embedded glTF or leave it to the app?\n// - I.e. some apps might work directly on a GLB, in that case no need for us to decode...\n// - And if we decode, do we still keep the GLB in case it is needed?\n// - Do we add an option to control this?\n// - Also, should we have hard dependency on gltf module or use injection or auto-discovery for gltf parser?\n\nimport {GLTFLoader} from '@loaders.gl/gltf';\nimport {getZeroOffsetArrayBuffer} from '@loaders.gl/loader-utils';\n\nexport const GLTF_FORMAT = {\n  URI: 0,\n  EMBEDDED: 1\n};\n\nexport function parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset) {\n  // Set flags\n  // glTF models need to be rotated from Y to Z up\n  // https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification#y-up-to-z-up\n  tile.rotateYtoZ = true;\n\n  // Assume glTF consumes rest of tile\n  const gltfByteLength = tile.byteOffset + tile.byteLength - byteOffset;\n  if (gltfByteLength === 0) {\n    throw new Error('glTF byte length must be greater than 0.');\n  }\n\n  // TODO - We can avoid copy if already 4-byte aligned...\n  // However the rest of the code may not be able to accept byteOffsets, so copy anyway\n  tile.gltfArrayBuffer = getZeroOffsetArrayBuffer(arrayBuffer, byteOffset, gltfByteLength);\n  tile.gltfByteOffset = 0;\n  tile.gltfByteLength = gltfByteLength;\n\n  if (byteOffset % 4 === 0) {\n    // tile.gltfArrayBuffer = arrayBuffer;\n    // tile.gltfByteOffset = byteOffset;\n    // tile.gltfByteLength = gltfByteLength;\n  } else {\n    // Create a copy of the glb so that it is 4-byte aligned\n    // eslint-disable-next-line\n    console.warn(`${tile.type}: embedded glb is not aligned to a 4-byte boundary.`);\n  }\n\n  // Entire tile is consumed\n  return tile.byteOffset + tile.byteLength;\n}\n\nexport async function extractGLTF(tile, gltfFormat, options, context) {\n  extractGLTFBufferOrURL(tile, gltfFormat, options);\n\n  if (options.loadGLTF) {\n    const {parse, fetch} = context;\n    if (tile.gltfUrl) {\n      tile.gltfArrayBuffer = await fetch(tile.gltfUrl, options);\n      tile.gltfByteOffset = 0;\n    }\n    if (tile.gltfArrayBuffer) {\n      // TODO - Should handle byteOffset... However, not used now...\n      tile.gltf = await parse(tile.gltfArrayBuffer, GLTFLoader, options, context);\n      delete tile.gltfArrayBuffer;\n      delete tile.gltfByteOffset;\n      delete tile.gltfByteLength;\n    }\n  }\n}\n\nexport function extractGLTFSync(tile, gltfFormat, options, context) {\n  extractGLTFBufferOrURL(tile, gltfFormat, options);\n\n  if (options.loadGLTF) {\n    if (tile.gltfArrayBuffer) {\n      const {parseSync} = context;\n      // TODO - Should handle byteOffset... Not used now...\n      tile.gltf = parseSync(tile.gltfArrayBuffer, GLTFLoader, options, context);\n      delete tile.gltfArrayBuffer;\n      delete tile.gltfByteOffset;\n      delete tile.gltfByteLength;\n    } else if (tile.gltfUrl) {\n      // TODO - use context.fetch or context.load\n      throw new Error('cant load glTF URL synchronously');\n    }\n  }\n}\n\nfunction extractGLTFBufferOrURL(tile, gltfFormat, options) {\n  switch (gltfFormat) {\n    case GLTF_FORMAT.URI:\n      // We need to remove padding from the end of the model URL in case this tile was part of a composite tile.\n      // This removes all white space and null characters from the end of the string.\n      const gltfUrlBytes = new Uint8Array(tile.gltfArrayBuffer, tile.gltfByteOffset);\n      const textDecoder = new TextDecoder();\n      const gltfUrl = textDecoder.decode(gltfUrlBytes);\n      tile.gltfUrl = gltfUrl.replace(/[\\s\\0]+$/, '');\n      delete tile.gltfArrayBuffer;\n      delete tile.gltfByteOffset;\n      delete tile.gltfByteLength;\n      break;\n    case GLTF_FORMAT.EMBEDDED:\n      break;\n    default:\n      throw new Error(`b3dm: Illegal glTF format field`);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}