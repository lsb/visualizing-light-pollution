{"ast":null,"code":"var geometryTypes = ['Unknown', 'Point', 'LineString', 'Polygon'];\nexport function transformToLocalCoordinates(line, feature) {\n  for (var i = 0; i < line.length; i++) {\n    var point = line[i];\n    line[i] = [point.x / feature.extent, point.y / feature.extent];\n  }\n}\nexport function transformCoordinates(feature) {\n  var transform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (coordinates, feature_) {\n    return coordinates;\n  };\n  return function () {\n    var type = geometryTypes[feature.type];\n    var coordinates = feature.loadGeometry();\n\n    switch (feature.type) {\n      case 1:\n        var points = [];\n\n        for (var i = 0; i < coordinates.length; i++) {\n          points[i] = coordinates[i][0];\n        }\n\n        coordinates = points;\n        transform(coordinates, feature);\n        break;\n\n      case 2:\n        for (var _i = 0; _i < coordinates.length; _i++) {\n          transform(coordinates[_i], feature);\n        }\n\n        break;\n\n      case 3:\n        coordinates = classifyRings(coordinates);\n\n        for (var _i2 = 0; _i2 < coordinates.length; _i2++) {\n          for (var j = 0; j < coordinates[_i2].length; j++) {\n            transform(coordinates[_i2][j], feature);\n          }\n        }\n\n        break;\n\n      default:\n        break;\n    }\n\n    return generateJSON(type, feature, coordinates);\n  }();\n}\n\nfunction generateJSON(type, feature, coordinates) {\n  var geometryType = type;\n\n  if (coordinates.length === 1) {\n    coordinates = coordinates[0];\n  } else {\n    geometryType = \"Multi\".concat(type);\n  }\n\n  var jsonResult = {\n    type: 'Feature',\n    geometry: {\n      type: geometryType,\n      coordinates: coordinates\n    },\n    properties: feature.properties || {}\n  };\n\n  if ('id' in feature) {\n    jsonResult.id = feature.id;\n  }\n\n  return jsonResult;\n}\n\nfunction classifyRings(rings) {\n  var len = rings.length;\n  if (len <= 1) return [rings];\n  var polygons = [];\n  var polygon;\n  var ccw;\n\n  for (var i = 0; i < len; i++) {\n    var area = signedArea(rings[i]);\n\n    if (area === 0) {\n      continue;\n    }\n\n    if (ccw === undefined) ccw = area < 0;\n\n    if (ccw === area < 0) {\n      if (polygon) {\n        polygons.push(polygon);\n      }\n\n      polygon = [rings[i]];\n    } else {\n      polygon.push(rings[i]);\n    }\n  }\n\n  if (polygon) polygons.push(polygon);\n  return polygons;\n}\n\nfunction signedArea(ring) {\n  var length = ring.length;\n  var sum = 0;\n  var p1;\n  var p2;\n\n  for (var i = 0, j = length - 1; i < length; j = i++) {\n    p1 = ring[i];\n    p2 = ring[j];\n    sum += (p2.x - p1.x) * (p1.y + p2.y);\n  }\n\n  return sum;\n}","map":{"version":3,"sources":["../../../src/lib/transform-to-local-range.js"],"names":["geometryTypes","i","line","point","feature","transform","type","coordinates","points","classifyRings","j","generateJSON","geometryType","jsonResult","geometry","properties","len","rings","polygons","area","signedArea","ccw","polygon","length","ring","sum","p1","p2"],"mappings":"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","sourcesContent":["const geometryTypes = ['Unknown', 'Point', 'LineString', 'Polygon'];\n\nexport function transformToLocalCoordinates(line, feature) {\n  // This function transforms local coordinates in a\n  // [0 - bufferSize, this.extent + bufferSize] range to a\n  // [0 - (bufferSize / this.extent), 1 + (bufferSize / this.extent)] range.\n  // The resulting extent would be 1.\n\n  for (let i = 0; i < line.length; i++) {\n    const point = line[i];\n\n    line[i] = [point.x / feature.extent, point.y / feature.extent];\n  }\n}\n\nexport function transformCoordinates(feature, transform = (coordinates, feature_) => coordinates) {\n  const type = geometryTypes[feature.type];\n  let coordinates = feature.loadGeometry();\n\n  switch (feature.type) {\n    // Point\n    case 1:\n      const points = [];\n      for (let i = 0; i < coordinates.length; i++) {\n        points[i] = coordinates[i][0];\n      }\n      coordinates = points;\n      transform(coordinates, feature);\n      break;\n\n    // LineString\n    case 2:\n      for (let i = 0; i < coordinates.length; i++) {\n        transform(coordinates[i], feature);\n      }\n      break;\n\n    // Polygon\n    case 3:\n      coordinates = classifyRings(coordinates);\n      for (let i = 0; i < coordinates.length; i++) {\n        for (let j = 0; j < coordinates[i].length; j++) {\n          transform(coordinates[i][j], feature);\n        }\n      }\n      break;\n\n    default:\n      break;\n  }\n\n  return generateJSON(type, feature, coordinates);\n}\n\nfunction generateJSON(type, feature, coordinates) {\n  let geometryType = type;\n\n  if (coordinates.length === 1) {\n    coordinates = coordinates[0];\n  } else {\n    geometryType = `Multi${type}`;\n  }\n\n  const jsonResult = {\n    type: 'Feature',\n    geometry: {\n      type: geometryType,\n      coordinates\n    },\n    properties: feature.properties || {}\n  };\n\n  if ('id' in feature) {\n    jsonResult.id = feature.id;\n  }\n\n  return jsonResult;\n}\n\n/*\n* Methods below are extracted and modified from @mapbox/vector-tile\n* https://github.com/mapbox/vector-tile-js/blob/58df1e9344ee64f26deee84a9f54cee11fb95ef6/lib/vectortilefeature.js#L197-L233\n*/\n\n// classifies an array of rings into polygons with outer rings and holes\nfunction classifyRings(rings) {\n  const len = rings.length;\n\n  if (len <= 1) return [rings];\n\n  const polygons = [];\n  let polygon;\n  let ccw;\n\n  for (let i = 0; i < len; i++) {\n    const area = signedArea(rings[i]);\n\n    if (area === 0) {\n      /* eslint-disable-next-line no-continue */\n      continue;\n    }\n\n    if (ccw === undefined) ccw = area < 0;\n\n    if (ccw === area < 0) {\n      if (polygon) {\n        polygons.push(polygon);\n      }\n\n      polygon = [rings[i]];\n    } else {\n      polygon.push(rings[i]);\n    }\n  }\n\n  if (polygon) polygons.push(polygon);\n\n  return polygons;\n}\n\nfunction signedArea(ring) {\n  const length = ring.length;\n  let sum = 0;\n  let p1;\n  let p2;\n\n  for (let i = 0, j = length - 1; i < length; j = i++) {\n    p1 = ring[i];\n    p2 = ring[j];\n    sum += (p2.x - p1.x) * (p1.y + p2.y);\n  }\n\n  return sum;\n}\n"]},"metadata":{},"sourceType":"module"}