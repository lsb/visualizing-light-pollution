{"ast":null,"code":"import earcut from 'earcut';\nvar PI_4 = Math.PI / 4;\nvar DEGREES_TO_RADIANS_HALF = Math.PI / 360;\n\nfunction validate(polygon) {\n  polygon = polygon && polygon.positions || polygon;\n\n  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {\n    throw new Error('invalid polygon');\n  }\n}\n\nfunction isSimple(polygon) {\n  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);\n}\n\nfunction isNestedRingClosed(simplePolygon) {\n  var p0 = simplePolygon[0];\n  var p1 = simplePolygon[simplePolygon.length - 1];\n  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];\n}\n\nfunction isFlatRingClosed(positions, size, startIndex, endIndex) {\n  for (var i = 0; i < size; i++) {\n    if (positions[startIndex + i] !== positions[endIndex - size + i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction copyNestedRing(target, targetStartIndex, simplePolygon, size) {\n  var targetIndex = targetStartIndex;\n  var len = simplePolygon.length;\n\n  for (var i = 0; i < len; i++) {\n    for (var j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[i][j] || 0;\n    }\n  }\n\n  if (!isNestedRingClosed(simplePolygon)) {\n    for (var _j = 0; _j < size; _j++) {\n      target[targetIndex++] = simplePolygon[0][_j] || 0;\n    }\n  }\n\n  return targetIndex;\n}\n\nfunction copyFlatRing(target, targetStartIndex, positions, size) {\n  var srcStartIndex = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  var srcEndIndex = arguments.length > 5 ? arguments[5] : undefined;\n  srcEndIndex = srcEndIndex || positions.length;\n  var srcLength = srcEndIndex - srcStartIndex;\n\n  if (srcLength <= 0) {\n    return targetStartIndex;\n  }\n\n  var targetIndex = targetStartIndex;\n\n  for (var i = 0; i < srcLength; i++) {\n    target[targetIndex++] = positions[srcStartIndex + i];\n  }\n\n  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {\n    for (var _i = 0; _i < size; _i++) {\n      target[targetIndex++] = positions[srcStartIndex + _i];\n    }\n  }\n\n  return targetIndex;\n}\n\nfunction getNestedVertexCount(simplePolygon) {\n  return (isNestedRingClosed(simplePolygon) ? 0 : 1) + simplePolygon.length;\n}\n\nfunction getFlatVertexCount(positions, size) {\n  var startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var endIndex = arguments.length > 3 ? arguments[3] : undefined;\n  endIndex = endIndex || positions.length;\n\n  if (startIndex >= endIndex) {\n    return 0;\n  }\n\n  return (isFlatRingClosed(positions, size, startIndex, endIndex) ? 0 : 1) + (endIndex - startIndex) / size;\n}\n\nexport function getVertexCount(polygon, positionSize) {\n  var normalization = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n  if (!normalization) {\n    polygon = polygon.positions || polygon;\n    return polygon.length / positionSize;\n  }\n\n  validate(polygon);\n\n  if (polygon.positions) {\n    var _polygon = polygon,\n        positions = _polygon.positions,\n        holeIndices = _polygon.holeIndices;\n\n    if (holeIndices) {\n      var vertexCount = 0;\n\n      for (var i = 0; i <= holeIndices.length; i++) {\n        vertexCount += getFlatVertexCount(polygon.positions, positionSize, holeIndices[i - 1], holeIndices[i]);\n      }\n\n      return vertexCount;\n    }\n\n    polygon = positions;\n  }\n\n  if (Number.isFinite(polygon[0])) {\n    return getFlatVertexCount(polygon, positionSize);\n  }\n\n  if (!isSimple(polygon)) {\n    var _vertexCount = 0;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = polygon[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var simplePolygon = _step.value;\n        _vertexCount += getNestedVertexCount(simplePolygon);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return _vertexCount;\n  }\n\n  return getNestedVertexCount(polygon);\n}\nexport function normalize(polygon, positionSize, vertexCount) {\n  validate(polygon);\n  vertexCount = vertexCount || getVertexCount(polygon, positionSize);\n  var positions = new Float64Array(vertexCount * positionSize);\n  var holeIndices = [];\n\n  if (polygon.positions) {\n    var _polygon2 = polygon,\n        srcPositions = _polygon2.positions,\n        srcHoleIndices = _polygon2.holeIndices;\n\n    if (srcHoleIndices) {\n      var targetIndex = 0;\n\n      for (var i = 0; i <= srcHoleIndices.length; i++) {\n        targetIndex = copyFlatRing(positions, targetIndex, srcPositions, positionSize, srcHoleIndices[i - 1], srcHoleIndices[i]);\n        holeIndices.push(targetIndex);\n      }\n\n      holeIndices.pop();\n      return {\n        positions: positions,\n        holeIndices: holeIndices\n      };\n    }\n\n    polygon = srcPositions;\n  }\n\n  if (Number.isFinite(polygon[0])) {\n    copyFlatRing(positions, 0, polygon, positionSize);\n    return positions;\n  }\n\n  if (!isSimple(polygon)) {\n    var _targetIndex = 0;\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = polygon[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var simplePolygon = _step2.value;\n        _targetIndex = copyNestedRing(positions, _targetIndex, simplePolygon, positionSize);\n        holeIndices.push(_targetIndex);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n          _iterator2[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    holeIndices.pop();\n    return {\n      positions: positions,\n      holeIndices: holeIndices\n    };\n  }\n\n  copyNestedRing(positions, 0, polygon, positionSize);\n  return positions;\n}\nexport function getSurfaceIndices(normalizedPolygon, positionSize, preproject) {\n  var holeIndices = null;\n\n  if (normalizedPolygon.holeIndices) {\n    holeIndices = normalizedPolygon.holeIndices.map(function (positionIndex) {\n      return positionIndex / positionSize;\n    });\n  }\n\n  var positions = normalizedPolygon.positions || normalizedPolygon;\n\n  if (preproject) {\n    var n = positions.length;\n    positions = positions.slice();\n\n    for (var i = 0; i < n; i += positionSize) {\n      var y = positions[i + 1];\n      positions[i + 1] = Math.log(Math.tan(PI_4 + y * DEGREES_TO_RADIANS_HALF));\n    }\n  }\n\n  return earcut(positions, holeIndices, positionSize);\n}","map":{"version":3,"sources":["../../../../src/gpgpu/point-in-polygon/polygon.js"],"names":["PI_4","Math","DEGREES_TO_RADIANS_HALF","polygon","Array","ArrayBuffer","Number","p0","simplePolygon","p1","i","positions","startIndex","endIndex","targetIndex","len","j","target","isNestedRingClosed","srcStartIndex","srcEndIndex","srcLength","isFlatRingClosed","normalization","validate","holeIndices","vertexCount","getFlatVertexCount","isSimple","getNestedVertexCount","getVertexCount","srcPositions","srcHoleIndices","copyFlatRing","copyNestedRing","normalizedPolygon","positionIndex","n","y","earcut"],"mappings":"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","sourcesContent":["// => COPIED FROM  deck.gl\n\n// Copyright (c) 2015 - 2020 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint-disable max-params */\nimport earcut from 'earcut';\n\n// For Web Mercator projection\nconst PI_4 = Math.PI / 4;\nconst DEGREES_TO_RADIANS_HALF = Math.PI / 360;\n\n// 4 data formats are supported:\n// Simple Polygon: an array of points\n// Complex Polygon: an array of array of points (array of rings)\n//   with the first ring representing the outer hull and other rings representing holes\n// Simple Flat: an array of numbers (flattened \"simple polygon\")\n// Complex Flat: {position: array<number>, holeIndices: array<number>}\n//   (flattened \"complex polygon\")\n\n/**\n * Ensure a polygon is valid format\n * @param {Array|Object} polygon\n */\nfunction validate(polygon) {\n  polygon = (polygon && polygon.positions) || polygon;\n  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {\n    throw new Error('invalid polygon');\n  }\n}\n\n/**\n * Check if a polygon is simple or complex\n * @param {Array} polygon - either a complex or simple polygon\n * @return {Boolean} - true if the polygon is a simple polygon (i.e. not an array of polygons)\n */\nfunction isSimple(polygon) {\n  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);\n}\n\n/**\n * Check if a simple polygon is a closed ring\n * @param {Array} simplePolygon - array of points\n * @return {Boolean} - true if the simple polygon is a closed ring\n */\nfunction isNestedRingClosed(simplePolygon) {\n  // check if first and last vertex are the same\n  const p0 = simplePolygon[0];\n  const p1 = simplePolygon[simplePolygon.length - 1];\n\n  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];\n}\n\n/**\n * Check if a simple flat array is a closed ring\n * @param {Array} positions - array of numbers\n * @param {Number} size - size of a position, 2 (xy) or 3 (xyz)\n * @param {Number} startIndex - start index of the path in the positions array\n * @param {Number} endIndex - end index of the path in the positions array\n * @return {Boolean} - true if the simple flat array is a closed ring\n */\nfunction isFlatRingClosed(positions, size, startIndex, endIndex) {\n  for (let i = 0; i < size; i++) {\n    if (positions[startIndex + i] !== positions[endIndex - size + i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Copy a simple polygon coordinates into a flat array, closes the ring if needed.\n * @param {Float64Array} target - destination\n * @param {Number} targetStartIndex - index in the destination to start copying into\n * @param {Array} simplePolygon - array of points\n * @param {Number} size - size of a position, 2 (xy) or 3 (xyz)\n * @returns {Number} - the index of the write head in the destination\n */\nfunction copyNestedRing(target, targetStartIndex, simplePolygon, size) {\n  let targetIndex = targetStartIndex;\n  const len = simplePolygon.length;\n  for (let i = 0; i < len; i++) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[i][j] || 0;\n    }\n  }\n\n  if (!isNestedRingClosed(simplePolygon)) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[0][j] || 0;\n    }\n  }\n  return targetIndex;\n}\n\n/**\n * Copy a simple flat array into another flat array, closes the ring if needed.\n * @param {Float64Array} target - destination\n * @param {Number} targetStartIndex - index in the destination to start copying into\n * @param {Array} positions - array of numbers\n * @param {Number} size - size of a position, 2 (xy) or 3 (xyz)\n * @param {Number} [srcStartIndex] - start index of the path in the positions array\n * @param {Number} [srcEndIndex] - end index of the path in the positions array\n * @returns {Number} - the index of the write head in the destination\n */\nfunction copyFlatRing(target, targetStartIndex, positions, size, srcStartIndex = 0, srcEndIndex) {\n  srcEndIndex = srcEndIndex || positions.length;\n  const srcLength = srcEndIndex - srcStartIndex;\n  if (srcLength <= 0) {\n    return targetStartIndex;\n  }\n  let targetIndex = targetStartIndex;\n\n  for (let i = 0; i < srcLength; i++) {\n    target[targetIndex++] = positions[srcStartIndex + i];\n  }\n\n  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {\n    for (let i = 0; i < size; i++) {\n      target[targetIndex++] = positions[srcStartIndex + i];\n    }\n  }\n  return targetIndex;\n}\n\n/**\n * Counts the number of vertices in a simple polygon, closes the polygon if needed.\n * @param {Array} simplePolygon - array of points\n * @returns {Number} vertex count\n */\nfunction getNestedVertexCount(simplePolygon) {\n  return (isNestedRingClosed(simplePolygon) ? 0 : 1) + simplePolygon.length;\n}\n\n/**\n * Counts the number of vertices in a simple flat array, closes the polygon if needed.\n * @param {Array} positions - array of numbers\n * @param {Number} size - size of a position, 2 (xy) or 3 (xyz)\n * @param {Number} [startIndex] - start index of the path in the positions array\n * @param {Number} [endIndex] - end index of the path in the positions array\n * @returns {Number} vertex count\n */\nfunction getFlatVertexCount(positions, size, startIndex = 0, endIndex) {\n  endIndex = endIndex || positions.length;\n  if (startIndex >= endIndex) {\n    return 0;\n  }\n  return (\n    (isFlatRingClosed(positions, size, startIndex, endIndex) ? 0 : 1) +\n    (endIndex - startIndex) / size\n  );\n}\n\n/**\n * Counts the number of vertices in any polygon representation.\n * @param {Array|Object} polygon\n * @param {Number} positionSize - size of a position, 2 (xy) or 3 (xyz)\n * @returns {Number} vertex count\n */\nexport function getVertexCount(polygon, positionSize, normalization = true) {\n  if (!normalization) {\n    polygon = polygon.positions || polygon;\n    return polygon.length / positionSize;\n  }\n\n  validate(polygon);\n\n  if (polygon.positions) {\n    // complex flat\n    const {positions, holeIndices} = polygon;\n\n    if (holeIndices) {\n      let vertexCount = 0;\n      // split the positions array into `holeIndices.length + 1` rings\n      // holeIndices[-1] falls back to 0\n      // holeIndices[holeIndices.length] falls back to positions.length\n      for (let i = 0; i <= holeIndices.length; i++) {\n        vertexCount += getFlatVertexCount(\n          polygon.positions,\n          positionSize,\n          holeIndices[i - 1],\n          holeIndices[i]\n        );\n      }\n      return vertexCount;\n    }\n    polygon = positions;\n  }\n  if (Number.isFinite(polygon[0])) {\n    // simple flat\n    return getFlatVertexCount(polygon, positionSize);\n  }\n  if (!isSimple(polygon)) {\n    // complex polygon\n    let vertexCount = 0;\n    for (const simplePolygon of polygon) {\n      vertexCount += getNestedVertexCount(simplePolygon);\n    }\n    return vertexCount;\n  }\n  // simple polygon\n  return getNestedVertexCount(polygon);\n}\n\n/**\n * Normalize any polygon representation into the \"complex flat\" format\n * @param {Array|Object} polygon\n * @param {Number} positionSize - size of a position, 2 (xy) or 3 (xyz)\n * @param {Number} [vertexCount] - pre-computed vertex count in the polygon.\n *   If provided, will skip counting.\n * @return {Object} - {positions: <Float64Array>, holeIndices: <Array|null>}\n */\n/* eslint-disable max-statements */\nexport function normalize(polygon, positionSize, vertexCount) {\n  validate(polygon);\n\n  vertexCount = vertexCount || getVertexCount(polygon, positionSize);\n\n  const positions = new Float64Array(vertexCount * positionSize);\n  const holeIndices = [];\n\n  if (polygon.positions) {\n    // complex flat\n    const {positions: srcPositions, holeIndices: srcHoleIndices} = polygon;\n\n    if (srcHoleIndices) {\n      let targetIndex = 0;\n      // split the positions array into `holeIndices.length + 1` rings\n      // holeIndices[-1] falls back to 0\n      // holeIndices[holeIndices.length] falls back to positions.length\n      for (let i = 0; i <= srcHoleIndices.length; i++) {\n        targetIndex = copyFlatRing(\n          positions,\n          targetIndex,\n          srcPositions,\n          positionSize,\n          srcHoleIndices[i - 1],\n          srcHoleIndices[i]\n        );\n        holeIndices.push(targetIndex);\n      }\n      // The last one is not a starting index of a hole, remove\n      holeIndices.pop();\n\n      return {positions, holeIndices};\n    }\n    polygon = srcPositions;\n  }\n  if (Number.isFinite(polygon[0])) {\n    // simple flat\n    copyFlatRing(positions, 0, polygon, positionSize);\n    return positions;\n  }\n  if (!isSimple(polygon)) {\n    // complex polygon\n    let targetIndex = 0;\n\n    for (const simplePolygon of polygon) {\n      targetIndex = copyNestedRing(positions, targetIndex, simplePolygon, positionSize);\n      holeIndices.push(targetIndex);\n    }\n    // The last one is not a starting index of a hole, remove\n    holeIndices.pop();\n    // last index points to the end of the array, remove it\n    return {positions, holeIndices};\n  }\n  // simple polygon\n  copyNestedRing(positions, 0, polygon, positionSize);\n  return positions;\n}\n/* eslint-enable max-statements */\n\n/*\n * Get vertex indices for drawing polygon mesh\n * @param {Object} normalizedPolygon - {positions, holeIndices}\n * @param {Number} positionSize - size of a position, 2 (xy) or 3 (xyz)\n * @returns {Array} array of indices\n */\nexport function getSurfaceIndices(normalizedPolygon, positionSize, preproject) {\n  let holeIndices = null;\n\n  if (normalizedPolygon.holeIndices) {\n    holeIndices = normalizedPolygon.holeIndices.map(positionIndex => positionIndex / positionSize);\n  }\n  let positions = normalizedPolygon.positions || normalizedPolygon;\n\n  // TODO - handle other coordinate systems and projection modes\n  if (preproject) {\n    // When tesselating lnglat coordinates, project them to the Web Mercator plane for accuracy\n    const n = positions.length;\n    // Clone the array\n    positions = positions.slice();\n    for (let i = 0; i < n; i += positionSize) {\n      // project points to a scaled version of the web-mercator plane\n      // It doesn't matter if x and y are scaled/translated, but the relationship must be linear\n      const y = positions[i + 1];\n      positions[i + 1] = Math.log(Math.tan(PI_4 + y * DEGREES_TO_RADIANS_HALF));\n    }\n  }\n\n  // Let earcut triangulate the polygon\n  return earcut(positions, holeIndices, positionSize);\n}\n"]},"metadata":{},"sourceType":"module"}