{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport Geometry from '../geometry/geometry';\nimport { unpackIndexedGeometry } from '../geometry/geometry-utils';\nimport { uid } from '@luma.gl/webgl';\n\nvar PlaneGeometry = function (_Geometry) {\n  _inherits(PlaneGeometry, _Geometry);\n\n  function PlaneGeometry() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, PlaneGeometry);\n\n    var _props$id = props.id,\n        id = _props$id === void 0 ? uid('plane-geometry') : _props$id;\n\n    var _tesselatePlane = tesselatePlane(props),\n        indices = _tesselatePlane.indices,\n        attributes = _tesselatePlane.attributes;\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(PlaneGeometry).call(this, _objectSpread({}, props, {\n      id: id,\n      indices: indices,\n      attributes: _objectSpread({}, attributes, props.attributes)\n    })));\n  }\n\n  return PlaneGeometry;\n}(Geometry);\n\nexport { PlaneGeometry as default };\n\nfunction tesselatePlane(props) {\n  var _props$type = props.type,\n      type = _props$type === void 0 ? 'x,y' : _props$type,\n      _props$offset = props.offset,\n      offset = _props$offset === void 0 ? 0 : _props$offset,\n      _props$flipCull = props.flipCull,\n      flipCull = _props$flipCull === void 0 ? false : _props$flipCull,\n      _props$unpack = props.unpack,\n      unpack = _props$unpack === void 0 ? false : _props$unpack;\n  var coords = type.split(',');\n  var c1len = props[\"\".concat(coords[0], \"len\")] || 1;\n  var c2len = props[\"\".concat(coords[1], \"len\")] || 1;\n  var subdivisions1 = props[\"n\".concat(coords[0])] || 1;\n  var subdivisions2 = props[\"n\".concat(coords[1])] || 1;\n  var numVertices = (subdivisions1 + 1) * (subdivisions2 + 1);\n  var positions = new Float32Array(numVertices * 3);\n  var normals = new Float32Array(numVertices * 3);\n  var texCoords = new Float32Array(numVertices * 2);\n\n  if (flipCull) {\n    c1len = -c1len;\n  }\n\n  var i2 = 0;\n  var i3 = 0;\n\n  for (var z = 0; z <= subdivisions2; z++) {\n    for (var x = 0; x <= subdivisions1; x++) {\n      var u = x / subdivisions1;\n      var v = z / subdivisions2;\n      texCoords[i2 + 0] = flipCull ? 1 - u : u;\n      texCoords[i2 + 1] = v;\n\n      switch (type) {\n        case 'x,y':\n          positions[i3 + 0] = c1len * u - c1len * 0.5;\n          positions[i3 + 1] = c2len * v - c2len * 0.5;\n          positions[i3 + 2] = offset;\n          normals[i3 + 0] = 0;\n          normals[i3 + 1] = 0;\n          normals[i3 + 2] = flipCull ? 1 : -1;\n          break;\n\n        case 'x,z':\n          positions[i3 + 0] = c1len * u - c1len * 0.5;\n          positions[i3 + 1] = offset;\n          positions[i3 + 2] = c2len * v - c2len * 0.5;\n          normals[i3 + 0] = 0;\n          normals[i3 + 1] = flipCull ? 1 : -1;\n          normals[i3 + 2] = 0;\n          break;\n\n        case 'y,z':\n          positions[i3 + 0] = offset;\n          positions[i3 + 1] = c1len * u - c1len * 0.5;\n          positions[i3 + 2] = c2len * v - c2len * 0.5;\n          normals[i3 + 0] = flipCull ? 1 : -1;\n          normals[i3 + 1] = 0;\n          normals[i3 + 2] = 0;\n          break;\n\n        default:\n          throw new Error('PlaneGeometry: unknown type');\n      }\n\n      i2 += 2;\n      i3 += 3;\n    }\n  }\n\n  var numVertsAcross = subdivisions1 + 1;\n  var indices = new Uint16Array(subdivisions1 * subdivisions2 * 6);\n\n  for (var _z = 0; _z < subdivisions2; _z++) {\n    for (var _x = 0; _x < subdivisions1; _x++) {\n      var index = (_z * subdivisions1 + _x) * 6;\n      indices[index + 0] = (_z + 0) * numVertsAcross + _x;\n      indices[index + 1] = (_z + 1) * numVertsAcross + _x;\n      indices[index + 2] = (_z + 0) * numVertsAcross + _x + 1;\n      indices[index + 3] = (_z + 1) * numVertsAcross + _x;\n      indices[index + 4] = (_z + 1) * numVertsAcross + _x + 1;\n      indices[index + 5] = (_z + 0) * numVertsAcross + _x + 1;\n    }\n  }\n\n  var geometry = {\n    indices: {\n      size: 1,\n      value: indices\n    },\n    attributes: {\n      POSITION: {\n        size: 3,\n        value: positions\n      },\n      NORMAL: {\n        size: 3,\n        value: normals\n      },\n      TEXCOORD_0: {\n        size: 2,\n        value: texCoords\n      }\n    }\n  };\n  return unpack ? unpackIndexedGeometry(geometry) : geometry;\n}","map":{"version":3,"sources":["../../../src/geometries/plane-geometry.js"],"names":["PlaneGeometry","Geometry","props","id","uid","indices","attributes","tesselatePlane","type","offset","flipCull","unpack","coords","c1len","c2len","subdivisions1","subdivisions2","numVertices","positions","normals","texCoords","i2","i3","z","x","u","v","numVertsAcross","index","geometry","size","value","POSITION","NORMAL","TEXCOORD_0","unpackIndexedGeometry"],"mappings":"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","sourcesContent":["import Geometry from '../geometry/geometry';\nimport {unpackIndexedGeometry} from '../geometry/geometry-utils';\nimport {uid} from '@luma.gl/webgl';\n\nexport default class PlaneGeometry extends Geometry {\n  constructor(props = {}) {\n    const {id = uid('plane-geometry')} = props;\n\n    const {indices, attributes} = tesselatePlane(props);\n    super({\n      ...props,\n      id,\n      indices,\n      attributes: {...attributes, ...props.attributes}\n    });\n  }\n}\n\n// Primitives inspired by TDL http://code.google.com/p/webglsamples/,\n// copyright 2011 Google Inc. new BSD License\n// (http://www.opensource.org/licenses/bsd-license.php).\n/* eslint-disable max-statements, complexity */\n/* eslint-disable complexity, max-statements */\nfunction tesselatePlane(props) {\n  const {type = 'x,y', offset = 0, flipCull = false, unpack = false} = props;\n\n  const coords = type.split(',');\n  // width, height\n  let c1len = props[`${coords[0]}len`] || 1;\n  const c2len = props[`${coords[1]}len`] || 1;\n  // subdivisionsWidth, subdivisionsDepth\n  const subdivisions1 = props[`n${coords[0]}`] || 1;\n  const subdivisions2 = props[`n${coords[1]}`] || 1;\n  const numVertices = (subdivisions1 + 1) * (subdivisions2 + 1);\n\n  const positions = new Float32Array(numVertices * 3);\n  const normals = new Float32Array(numVertices * 3);\n  const texCoords = new Float32Array(numVertices * 2);\n\n  if (flipCull) {\n    c1len = -c1len;\n  }\n\n  let i2 = 0;\n  let i3 = 0;\n  for (let z = 0; z <= subdivisions2; z++) {\n    for (let x = 0; x <= subdivisions1; x++) {\n      const u = x / subdivisions1;\n      const v = z / subdivisions2;\n      texCoords[i2 + 0] = flipCull ? 1 - u : u;\n      texCoords[i2 + 1] = v;\n\n      switch (type) {\n        case 'x,y':\n          positions[i3 + 0] = c1len * u - c1len * 0.5;\n          positions[i3 + 1] = c2len * v - c2len * 0.5;\n          positions[i3 + 2] = offset;\n\n          normals[i3 + 0] = 0;\n          normals[i3 + 1] = 0;\n          normals[i3 + 2] = flipCull ? 1 : -1;\n          break;\n\n        case 'x,z':\n          positions[i3 + 0] = c1len * u - c1len * 0.5;\n          positions[i3 + 1] = offset;\n          positions[i3 + 2] = c2len * v - c2len * 0.5;\n\n          normals[i3 + 0] = 0;\n          normals[i3 + 1] = flipCull ? 1 : -1;\n          normals[i3 + 2] = 0;\n          break;\n\n        case 'y,z':\n          positions[i3 + 0] = offset;\n          positions[i3 + 1] = c1len * u - c1len * 0.5;\n          positions[i3 + 2] = c2len * v - c2len * 0.5;\n\n          normals[i3 + 0] = flipCull ? 1 : -1;\n          normals[i3 + 1] = 0;\n          normals[i3 + 2] = 0;\n          break;\n\n        default:\n          throw new Error('PlaneGeometry: unknown type');\n      }\n\n      i2 += 2;\n      i3 += 3;\n    }\n  }\n\n  const numVertsAcross = subdivisions1 + 1;\n  const indices = new Uint16Array(subdivisions1 * subdivisions2 * 6);\n\n  for (let z = 0; z < subdivisions2; z++) {\n    for (let x = 0; x < subdivisions1; x++) {\n      const index = (z * subdivisions1 + x) * 6;\n      // Make triangle 1 of quad.\n      indices[index + 0] = (z + 0) * numVertsAcross + x;\n      indices[index + 1] = (z + 1) * numVertsAcross + x;\n      indices[index + 2] = (z + 0) * numVertsAcross + x + 1;\n\n      // Make triangle 2 of quad.\n      indices[index + 3] = (z + 1) * numVertsAcross + x;\n      indices[index + 4] = (z + 1) * numVertsAcross + x + 1;\n      indices[index + 5] = (z + 0) * numVertsAcross + x + 1;\n    }\n  }\n\n  const geometry = {\n    indices: {size: 1, value: indices},\n    attributes: {\n      POSITION: {size: 3, value: positions},\n      NORMAL: {size: 3, value: normals},\n      TEXCOORD_0: {size: 2, value: texCoords}\n    }\n  };\n\n  // Optionally, unpack indexed geometry\n  return unpack ? unpackIndexedGeometry(geometry) : geometry;\n}\n"]},"metadata":{},"sourceType":"module"}