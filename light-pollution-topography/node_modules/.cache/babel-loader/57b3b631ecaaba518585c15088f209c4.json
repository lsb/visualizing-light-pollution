{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { getPassthroughFS } from '@luma.gl/shadertools';\nimport BufferTransform from './buffer-transform';\nimport TextureTransform from './texture-transform';\nimport { isWebGL2 } from '@luma.gl/gltools';\nimport { assert, isObjectEmpty, getShaderVersion } from '@luma.gl/webgl';\nimport Model from '../lib/model';\n\nvar Transform = function () {\n  _createClass(Transform, null, [{\n    key: \"isSupported\",\n    value: function isSupported(gl) {\n      return isWebGL2(gl);\n    }\n  }]);\n\n  function Transform(gl) {\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Transform);\n\n    this.gl = gl;\n    this.model = null;\n    this.elementCount = 0;\n    this.bufferTransform = null;\n    this.textureTransform = null;\n    this.elementIDBuffer = null;\n\n    this._initialize(props);\n\n    Object.seal(this);\n  }\n\n  _createClass(Transform, [{\n    key: \"delete\",\n    value: function _delete() {\n      var model = this.model,\n          bufferTransform = this.bufferTransform,\n          textureTransform = this.textureTransform;\n\n      if (model) {\n        model[\"delete\"]();\n      }\n\n      if (bufferTransform) {\n        bufferTransform[\"delete\"]();\n      }\n\n      if (textureTransform) {\n        textureTransform[\"delete\"]();\n      }\n    }\n  }, {\n    key: \"run\",\n    value: function run() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _opts$clearRenderTarg = opts.clearRenderTarget,\n          clearRenderTarget = _opts$clearRenderTarg === void 0 ? true : _opts$clearRenderTarg;\n\n      var updatedOpts = this._updateDrawOptions(opts);\n\n      if (clearRenderTarget && updatedOpts.framebuffer) {\n        updatedOpts.framebuffer.clear({\n          color: true\n        });\n      }\n\n      this.model.transform(updatedOpts);\n    }\n  }, {\n    key: \"swap\",\n    value: function swap() {\n      var swapped = false;\n      var resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = resourceTransforms[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var resourceTransform = _step.value;\n          swapped = swapped || resourceTransform.swap();\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      assert(swapped, 'Nothing to swap');\n    }\n  }, {\n    key: \"getBuffer\",\n    value: function getBuffer() {\n      var varyingName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      return this.bufferTransform && this.bufferTransform.getBuffer(varyingName);\n    }\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = resourceTransforms[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var resourceTransform = _step2.value;\n          var data = resourceTransform.getData(opts);\n\n          if (data) {\n            return data;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"getFramebuffer\",\n    value: function getFramebuffer() {\n      return this.textureTransform && this.textureTransform.getFramebuffer();\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if ('elementCount' in opts) {\n        this.model.setVertexCount(opts.elementCount);\n      }\n\n      var resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = resourceTransforms[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var resourceTransform = _step3.value;\n          resourceTransform.update(opts);\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n            _iterator3[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_initialize\",\n    value: function _initialize() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var gl = this.gl;\n\n      this._buildResourceTransforms(gl, props);\n\n      props = this._updateModelProps(props);\n      this.model = new Model(gl, Object.assign({}, props, {\n        fs: props.fs || getPassthroughFS({\n          version: getShaderVersion(props.vs)\n        }),\n        id: props.id || 'transform-model',\n        drawMode: props.drawMode || 0,\n        vertexCount: props.elementCount\n      }));\n      this.bufferTransform && this.bufferTransform.setupResources({\n        model: this.model\n      });\n    }\n  }, {\n    key: \"_updateModelProps\",\n    value: function _updateModelProps(props) {\n      var updatedProps = Object.assign({}, props);\n      var resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = resourceTransforms[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var resourceTransform = _step4.value;\n          updatedProps = resourceTransform.updateModelProps(updatedProps);\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4[\"return\"] != null) {\n            _iterator4[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      return updatedProps;\n    }\n  }, {\n    key: \"_buildResourceTransforms\",\n    value: function _buildResourceTransforms(gl, props) {\n      if (canCreateBufferTransform(props)) {\n        this.bufferTransform = new BufferTransform(gl, props);\n      }\n\n      if (canCreateTextureTransform(props)) {\n        this.textureTransform = new TextureTransform(gl, props);\n      }\n\n      assert(this.bufferTransform || this.textureTransform, 'must provide source/feedback buffers or source/target textures');\n    }\n  }, {\n    key: \"_updateDrawOptions\",\n    value: function _updateDrawOptions(opts) {\n      var updatedOpts = Object.assign({}, opts);\n      var resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = resourceTransforms[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var resourceTransform = _step5.value;\n          updatedOpts = Object.assign(updatedOpts, resourceTransform.getDrawOptions(updatedOpts));\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5[\"return\"] != null) {\n            _iterator5[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      return updatedOpts;\n    }\n  }]);\n\n  return Transform;\n}();\n\nexport { Transform as default };\n\nfunction canCreateBufferTransform(props) {\n  if (!isObjectEmpty(props.feedbackBuffers) || !isObjectEmpty(props.feedbackMap) || props.varyings && props.varyings.length > 0) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction canCreateTextureTransform(props) {\n  if (!isObjectEmpty(props._sourceTextures) || props._targetTexture || props._targetTextureVarying) {\n    return true;\n  }\n\n  return false;\n}","map":{"version":3,"sources":["../../../src/transform/transform.js"],"names":["Transform","gl","isWebGL2","props","Object","model","bufferTransform","textureTransform","opts","clearRenderTarget","updatedOpts","color","swapped","resourceTransforms","resourceTransform","assert","varyingName","data","fs","getPassthroughFS","version","getShaderVersion","id","drawMode","vertexCount","elementCount","updatedProps","canCreateBufferTransform","canCreateTextureTransform","isObjectEmpty"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport {getPassthroughFS} from '@luma.gl/shadertools';\nimport BufferTransform from './buffer-transform';\nimport TextureTransform from './texture-transform';\n\nimport {isWebGL2} from '@luma.gl/gltools';\nimport {assert, isObjectEmpty, getShaderVersion} from '@luma.gl/webgl';\nimport Model from '../lib/model';\n\n// takes source and target buffers/textures and setsup the pipeline\nexport default class Transform {\n  static isSupported(gl) {\n    // TODO : differentiate writting to buffer vs not\n    return isWebGL2(gl);\n  }\n\n  constructor(gl, props = {}) {\n    this.gl = gl;\n    this.model = null;\n    this.elementCount = 0;\n    this.bufferTransform = null;\n    this.textureTransform = null;\n    this.elementIDBuffer = null;\n    this._initialize(props);\n    Object.seal(this);\n  }\n\n  // Delete owned resources.\n  delete() {\n    const {model, bufferTransform, textureTransform} = this;\n    if (model) {\n      model.delete();\n    }\n    if (bufferTransform) {\n      bufferTransform.delete();\n    }\n    if (textureTransform) {\n      textureTransform.delete();\n    }\n  }\n\n  // Run one transform loop.\n  run(opts = {}) {\n    const {clearRenderTarget = true} = opts;\n\n    const updatedOpts = this._updateDrawOptions(opts);\n\n    if (clearRenderTarget && updatedOpts.framebuffer) {\n      updatedOpts.framebuffer.clear({color: true});\n    }\n\n    this.model.transform(updatedOpts);\n  }\n\n  // swap resources if a map is provided\n  swap() {\n    let swapped = false;\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      swapped = swapped || resourceTransform.swap();\n    }\n    assert(swapped, 'Nothing to swap');\n  }\n\n  // Return Buffer object for given varying name.\n  getBuffer(varyingName = null) {\n    return this.bufferTransform && this.bufferTransform.getBuffer(varyingName);\n  }\n\n  // Return data either from Buffer or from Texture\n  getData(opts = {}) {\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      const data = resourceTransform.getData(opts);\n      if (data) {\n        return data;\n      }\n    }\n    return null;\n  }\n\n  // Return framebuffer object if rendering to textures\n  getFramebuffer() {\n    return this.textureTransform && this.textureTransform.getFramebuffer();\n  }\n\n  // Update some or all buffer/texture bindings.\n  update(opts = {}) {\n    if ('elementCount' in opts) {\n      this.model.setVertexCount(opts.elementCount);\n    }\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      resourceTransform.update(opts);\n    }\n  }\n\n  // Private\n\n  _initialize(props = {}) {\n    const {gl} = this;\n    this._buildResourceTransforms(gl, props);\n\n    props = this._updateModelProps(props);\n    this.model = new Model(\n      gl,\n      Object.assign({}, props, {\n        fs: props.fs || getPassthroughFS({version: getShaderVersion(props.vs)}),\n        id: props.id || 'transform-model',\n        drawMode: props.drawMode || GL.POINTS,\n        vertexCount: props.elementCount\n      })\n    );\n\n    /* eslint-disable no-unused-expressions */\n    this.bufferTransform && this.bufferTransform.setupResources({model: this.model});\n    /* eslint-enable no-unused-expressions */\n  }\n\n  _updateModelProps(props) {\n    let updatedProps = Object.assign({}, props);\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      updatedProps = resourceTransform.updateModelProps(updatedProps);\n    }\n    return updatedProps;\n  }\n\n  _buildResourceTransforms(gl, props) {\n    if (canCreateBufferTransform(props)) {\n      this.bufferTransform = new BufferTransform(gl, props);\n    }\n    if (canCreateTextureTransform(props)) {\n      this.textureTransform = new TextureTransform(gl, props);\n    }\n    assert(\n      this.bufferTransform || this.textureTransform,\n      'must provide source/feedback buffers or source/target textures'\n    );\n  }\n\n  _updateDrawOptions(opts) {\n    let updatedOpts = Object.assign({}, opts);\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      updatedOpts = Object.assign(updatedOpts, resourceTransform.getDrawOptions(updatedOpts));\n    }\n    return updatedOpts;\n  }\n}\n\n// Helper Methods\n\nfunction canCreateBufferTransform(props) {\n  if (\n    !isObjectEmpty(props.feedbackBuffers) ||\n    !isObjectEmpty(props.feedbackMap) ||\n    (props.varyings && props.varyings.length > 0)\n  ) {\n    return true;\n  }\n  return false;\n}\n\nfunction canCreateTextureTransform(props) {\n  if (\n    !isObjectEmpty(props._sourceTextures) ||\n    props._targetTexture ||\n    props._targetTextureVarying\n  ) {\n    return true;\n  }\n\n  return false;\n}\n"]},"metadata":{},"sourceType":"module"}