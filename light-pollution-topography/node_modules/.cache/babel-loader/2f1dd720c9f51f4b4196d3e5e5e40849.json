{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { isWebGL } from '@luma.gl/gltools';\nimport ProgramManager from './program-manager';\nimport { Program, VertexArray, clear as _clear, TransformFeedback, Buffer, log, isObjectEmpty, uid, assert } from '@luma.gl/webgl';\nimport { getDebugTableForUniforms, getDebugTableForVertexArray, getDebugTableForProgramConfiguration } from '@luma.gl/webgl';\nimport { getBuffersFromGeometry } from './model-utils';\nvar LOG_DRAW_PRIORITY = 2;\nvar LOG_DRAW_TIMEOUT = 10000;\nvar ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';\n\nvar NOOP = function NOOP() {};\n\nvar DRAW_PARAMS = {};\n\nvar Model = function () {\n  function Model(gl) {\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Model);\n\n    var _props$id = props.id,\n        id = _props$id === void 0 ? uid('model') : _props$id;\n    assert(isWebGL(gl));\n    this.id = id;\n    this.gl = gl;\n    this.id = props.id || uid('Model');\n    this.lastLogTime = 0;\n    this.initialize(props);\n  }\n\n  _createClass(Model, [{\n    key: \"initialize\",\n    value: function initialize(props) {\n      this.props = {};\n      this.programManager = props.programManager || ProgramManager.getDefaultProgramManager(this.gl);\n      this._programManagerState = -1;\n      this._managedProgram = false;\n      var _props$program = props.program,\n          program = _props$program === void 0 ? null : _props$program,\n          vs = props.vs,\n          fs = props.fs,\n          modules = props.modules,\n          defines = props.defines,\n          inject = props.inject,\n          varyings = props.varyings,\n          bufferMode = props.bufferMode,\n          transpileToGLSL100 = props.transpileToGLSL100;\n      this.programProps = {\n        program: program,\n        vs: vs,\n        fs: fs,\n        modules: modules,\n        defines: defines,\n        inject: inject,\n        varyings: varyings,\n        bufferMode: bufferMode,\n        transpileToGLSL100: transpileToGLSL100\n      };\n      this.program = null;\n      this.vertexArray = null;\n      this._programDirty = true;\n      this.userData = {};\n      this.needsRedraw = true;\n      this._attributes = {};\n      this.attributes = {};\n      this.uniforms = {};\n      this.pickable = true;\n\n      this._checkProgram();\n\n      this.setUniforms(Object.assign({}, this.getModuleUniforms(props.moduleSettings)));\n      this.drawMode = props.drawMode !== undefined ? props.drawMode : 4;\n      this.vertexCount = props.vertexCount || 0;\n      this.geometryBuffers = {};\n      this.isInstanced = props.isInstanced || props.instanced || props.instanceCount > 0;\n\n      this._setModelProps(props);\n\n      this.geometry = {};\n      assert(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);\n    }\n  }, {\n    key: \"setProps\",\n    value: function setProps(props) {\n      this._setModelProps(props);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      for (var key in this._attributes) {\n        if (this._attributes[key] !== this.attributes[key]) {\n          this._attributes[key][\"delete\"]();\n        }\n      }\n\n      if (this._managedProgram) {\n        this.programManager.release(this.program);\n      }\n\n      this.vertexArray[\"delete\"]();\n\n      this._deleteGeometryBuffers();\n    }\n  }, {\n    key: \"getDrawMode\",\n    value: function getDrawMode() {\n      return this.drawMode;\n    }\n  }, {\n    key: \"getVertexCount\",\n    value: function getVertexCount() {\n      return this.vertexCount;\n    }\n  }, {\n    key: \"getInstanceCount\",\n    value: function getInstanceCount() {\n      return this.instanceCount;\n    }\n  }, {\n    key: \"getAttributes\",\n    value: function getAttributes() {\n      return this.attributes;\n    }\n  }, {\n    key: \"getProgram\",\n    value: function getProgram() {\n      return this.program;\n    }\n  }, {\n    key: \"setProgram\",\n    value: function setProgram(props) {\n      var program = props.program,\n          vs = props.vs,\n          fs = props.fs,\n          modules = props.modules,\n          defines = props.defines,\n          inject = props.inject,\n          varyings = props.varyings,\n          bufferMode = props.bufferMode,\n          transpileToGLSL100 = props.transpileToGLSL100;\n      this.programProps = {\n        program: program,\n        vs: vs,\n        fs: fs,\n        modules: modules,\n        defines: defines,\n        inject: inject,\n        varyings: varyings,\n        bufferMode: bufferMode,\n        transpileToGLSL100: transpileToGLSL100\n      };\n      this._programDirty = true;\n    }\n  }, {\n    key: \"getUniforms\",\n    value: function getUniforms() {\n      return this.uniforms;\n    }\n  }, {\n    key: \"setDrawMode\",\n    value: function setDrawMode(drawMode) {\n      this.drawMode = drawMode;\n      return this;\n    }\n  }, {\n    key: \"setVertexCount\",\n    value: function setVertexCount(vertexCount) {\n      assert(Number.isFinite(vertexCount));\n      this.vertexCount = vertexCount;\n      return this;\n    }\n  }, {\n    key: \"setInstanceCount\",\n    value: function setInstanceCount(instanceCount) {\n      assert(Number.isFinite(instanceCount));\n      this.instanceCount = instanceCount;\n      return this;\n    }\n  }, {\n    key: \"setGeometry\",\n    value: function setGeometry(geometry) {\n      this.drawMode = geometry.drawMode;\n      this.vertexCount = geometry.getVertexCount();\n\n      this._deleteGeometryBuffers();\n\n      this.geometryBuffers = getBuffersFromGeometry(this.gl, geometry);\n      this.vertexArray.setAttributes(this.geometryBuffers);\n      return this;\n    }\n  }, {\n    key: \"setAttributes\",\n    value: function setAttributes() {\n      var attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (isObjectEmpty(attributes)) {\n        return this;\n      }\n\n      var normalizedAttributes = {};\n\n      for (var name in attributes) {\n        var attribute = attributes[name];\n        normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;\n      }\n\n      this.vertexArray.setAttributes(normalizedAttributes);\n      return this;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms() {\n      var uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      Object.assign(this.uniforms, uniforms);\n      return this;\n    }\n  }, {\n    key: \"getModuleUniforms\",\n    value: function getModuleUniforms(opts) {\n      this._checkProgram();\n\n      var getUniforms = this.programManager.getUniforms(this.program);\n\n      if (getUniforms) {\n        return getUniforms(opts);\n      }\n\n      return {};\n    }\n  }, {\n    key: \"updateModuleSettings\",\n    value: function updateModuleSettings(opts) {\n      var uniforms = this.getModuleUniforms(opts || {});\n      return this.setUniforms(uniforms);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear(opts) {\n      _clear(this.program.gl, opts);\n\n      return this;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      this._checkProgram();\n\n      var _opts$moduleSettings = opts.moduleSettings,\n          moduleSettings = _opts$moduleSettings === void 0 ? null : _opts$moduleSettings,\n          framebuffer = opts.framebuffer,\n          _opts$uniforms = opts.uniforms,\n          uniforms = _opts$uniforms === void 0 ? {} : _opts$uniforms,\n          _opts$attributes = opts.attributes,\n          attributes = _opts$attributes === void 0 ? {} : _opts$attributes,\n          _opts$transformFeedba = opts.transformFeedback,\n          transformFeedback = _opts$transformFeedba === void 0 ? this.transformFeedback : _opts$transformFeedba,\n          _opts$parameters = opts.parameters,\n          parameters = _opts$parameters === void 0 ? {} : _opts$parameters,\n          _opts$vertexArray = opts.vertexArray,\n          vertexArray = _opts$vertexArray === void 0 ? this.vertexArray : _opts$vertexArray;\n      this.setAttributes(attributes);\n      this.updateModuleSettings(moduleSettings);\n      this.setUniforms(uniforms);\n      var logPriority;\n\n      if (log.priority >= LOG_DRAW_PRIORITY) {\n        logPriority = this._logDrawCallStart(LOG_DRAW_PRIORITY);\n      }\n\n      var drawParams = this.vertexArray.getDrawParams();\n      var _this$props = this.props,\n          _this$props$isIndexed = _this$props.isIndexed,\n          isIndexed = _this$props$isIndexed === void 0 ? drawParams.isIndexed : _this$props$isIndexed,\n          _this$props$indexType = _this$props.indexType,\n          indexType = _this$props$indexType === void 0 ? drawParams.indexType : _this$props$indexType,\n          _this$props$indexOffs = _this$props.indexOffset,\n          indexOffset = _this$props$indexOffs === void 0 ? drawParams.indexOffset : _this$props$indexOffs,\n          _this$props$vertexArr = _this$props.vertexArrayInstanced,\n          vertexArrayInstanced = _this$props$vertexArr === void 0 ? drawParams.isInstanced : _this$props$vertexArr;\n\n      if (vertexArrayInstanced && !this.isInstanced) {\n        log.warn('Found instanced attributes on non-instanced model', this.id)();\n      }\n\n      var isInstanced = this.isInstanced,\n          instanceCount = this.instanceCount;\n      var _this$props2 = this.props,\n          _this$props2$onBefore = _this$props2.onBeforeRender,\n          onBeforeRender = _this$props2$onBefore === void 0 ? NOOP : _this$props2$onBefore,\n          _this$props2$onAfterR = _this$props2.onAfterRender,\n          onAfterRender = _this$props2$onAfterR === void 0 ? NOOP : _this$props2$onAfterR;\n      onBeforeRender();\n      this.program.setUniforms(this.uniforms);\n      var didDraw = this.program.draw(Object.assign(DRAW_PARAMS, opts, {\n        logPriority: logPriority,\n        uniforms: null,\n        framebuffer: framebuffer,\n        parameters: parameters,\n        drawMode: this.getDrawMode(),\n        vertexCount: this.getVertexCount(),\n        vertexArray: vertexArray,\n        transformFeedback: transformFeedback,\n        isIndexed: isIndexed,\n        indexType: indexType,\n        isInstanced: isInstanced,\n        instanceCount: instanceCount,\n        offset: isIndexed ? indexOffset : 0\n      }));\n      onAfterRender();\n\n      if (log.priority >= LOG_DRAW_PRIORITY) {\n        this._logDrawCallEnd(logPriority, vertexArray, framebuffer);\n      }\n\n      return didDraw;\n    }\n  }, {\n    key: \"transform\",\n    value: function transform() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _opts$discard = opts.discard,\n          discard = _opts$discard === void 0 ? true : _opts$discard,\n          feedbackBuffers = opts.feedbackBuffers,\n          _opts$unbindModels = opts.unbindModels,\n          unbindModels = _opts$unbindModels === void 0 ? [] : _opts$unbindModels;\n      var parameters = opts.parameters;\n\n      if (feedbackBuffers) {\n        this._setFeedbackBuffers(feedbackBuffers);\n      }\n\n      if (discard) {\n        parameters = Object.assign({}, parameters, _defineProperty({}, 35977, discard));\n      }\n\n      unbindModels.forEach(function (model) {\n        return model.vertexArray.unbindBuffers();\n      });\n\n      try {\n        this.draw(Object.assign({}, opts, {\n          parameters: parameters\n        }));\n      } finally {\n        unbindModels.forEach(function (model) {\n          return model.vertexArray.bindBuffers();\n        });\n      }\n\n      return this;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      log.warn('Model.render() is deprecated. Use Model.setUniforms() and Model.draw()')();\n      return this.setUniforms(uniforms).draw();\n    }\n  }, {\n    key: \"_setModelProps\",\n    value: function _setModelProps(props) {\n      Object.assign(this.props, props);\n\n      if ('uniforms' in props) {\n        this.setUniforms(props.uniforms);\n      }\n\n      if ('pickable' in props) {\n        this.pickable = props.pickable;\n      }\n\n      if ('instanceCount' in props) {\n        this.instanceCount = props.instanceCount;\n      }\n\n      if ('geometry' in props) {\n        this.setGeometry(props.geometry);\n      }\n\n      if ('attributes' in props) {\n        this.setAttributes(props.attributes);\n      }\n\n      if ('_feedbackBuffers' in props) {\n        this._setFeedbackBuffers(props._feedbackBuffers);\n      }\n    }\n  }, {\n    key: \"_checkProgram\",\n    value: function _checkProgram() {\n      var shaderCache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var needsUpdate = this._programDirty || this.programManager.stateHash !== this._programManagerState;\n\n      if (!needsUpdate) {\n        return;\n      }\n\n      var program = this.programProps.program;\n\n      if (program) {\n        this._managedProgram = false;\n      } else {\n        var _this$programProps = this.programProps,\n            vs = _this$programProps.vs,\n            fs = _this$programProps.fs,\n            modules = _this$programProps.modules,\n            inject = _this$programProps.inject,\n            defines = _this$programProps.defines,\n            varyings = _this$programProps.varyings,\n            bufferMode = _this$programProps.bufferMode,\n            transpileToGLSL100 = _this$programProps.transpileToGLSL100;\n        program = this.programManager.get({\n          vs: vs,\n          fs: fs,\n          modules: modules,\n          inject: inject,\n          defines: defines,\n          varyings: varyings,\n          bufferMode: bufferMode,\n          transpileToGLSL100: transpileToGLSL100\n        });\n\n        if (this.program && this._managedProgram) {\n          this.programManager.release(this.program);\n        }\n\n        this._programManagerState = this.programManager.stateHash;\n        this._managedProgram = true;\n      }\n\n      assert(program instanceof Program, 'Model needs a program');\n      this._programDirty = false;\n\n      if (program === this.program) {\n        return;\n      }\n\n      this.program = program;\n\n      if (this.vertexArray) {\n        this.vertexArray.setProps({\n          program: this.program,\n          attributes: this.vertexArray.attributes\n        });\n      } else {\n        this.vertexArray = new VertexArray(this.gl, {\n          program: this.program\n        });\n      }\n\n      this.setUniforms(Object.assign({}, this.getModuleUniforms()));\n    }\n  }, {\n    key: \"_deleteGeometryBuffers\",\n    value: function _deleteGeometryBuffers() {\n      for (var name in this.geometryBuffers) {\n        var buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];\n\n        if (buffer instanceof Buffer) {\n          buffer[\"delete\"]();\n        }\n      }\n    }\n  }, {\n    key: \"_setAnimationProps\",\n    value: function _setAnimationProps(animationProps) {\n      if (this.animated) {\n        assert(animationProps, 'Model.draw(): animated uniforms but no animationProps');\n\n        var animatedUniforms = this._evaluateAnimateUniforms(animationProps);\n\n        Object.assign(this.uniforms, animatedUniforms);\n      }\n    }\n  }, {\n    key: \"_setFeedbackBuffers\",\n    value: function _setFeedbackBuffers() {\n      var feedbackBuffers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (isObjectEmpty(feedbackBuffers)) {\n        return this;\n      }\n\n      var gl = this.program.gl;\n      this.transformFeedback = this.transformFeedback || new TransformFeedback(gl, {\n        program: this.program\n      });\n      this.transformFeedback.setBuffers(feedbackBuffers);\n      return this;\n    }\n  }, {\n    key: \"_logDrawCallStart\",\n    value: function _logDrawCallStart(logLevel) {\n      var logDrawTimeout = logLevel > 3 ? 0 : LOG_DRAW_TIMEOUT;\n\n      if (Date.now() - this.lastLogTime < logDrawTimeout) {\n        return undefined;\n      }\n\n      this.lastLogTime = Date.now();\n      log.group(LOG_DRAW_PRIORITY, \">>> DRAWING MODEL \".concat(this.id), {\n        collapsed: log.level <= 2\n      })();\n      return logLevel;\n    }\n  }, {\n    key: \"_logDrawCallEnd\",\n    value: function _logDrawCallEnd(logLevel, vertexArray, uniforms, framebuffer) {\n      if (logLevel === undefined) {\n        return;\n      }\n\n      var attributeTable = getDebugTableForVertexArray({\n        vertexArray: vertexArray,\n        header: \"\".concat(this.id, \" attributes\"),\n        attributes: this._attributes\n      });\n\n      var _getDebugTableForUnif = getDebugTableForUniforms({\n        header: \"\".concat(this.id, \" uniforms\"),\n        program: this.program,\n        uniforms: Object.assign({}, this.program.uniforms, uniforms)\n      }),\n          uniformTable = _getDebugTableForUnif.table,\n          unusedTable = _getDebugTableForUnif.unusedTable,\n          unusedCount = _getDebugTableForUnif.unusedCount;\n\n      var _getDebugTableForUnif2 = getDebugTableForUniforms({\n        header: \"\".concat(this.id, \" uniforms\"),\n        program: this.program,\n        uniforms: Object.assign({}, this.program.uniforms, uniforms),\n        undefinedOnly: true\n      }),\n          missingTable = _getDebugTableForUnif2.table,\n          missingCount = _getDebugTableForUnif2.count;\n\n      if (missingCount > 0) {\n        log.log('MISSING UNIFORMS', Object.keys(missingTable))();\n      }\n\n      if (unusedCount > 0) {\n        log.log('UNUSED UNIFORMS', Object.keys(unusedTable))();\n      }\n\n      var configTable = getDebugTableForProgramConfiguration(this.vertexArray.configuration);\n      log.table(logLevel, attributeTable)();\n      log.table(logLevel, uniformTable)();\n      log.table(logLevel + 1, configTable)();\n\n      if (framebuffer) {\n        framebuffer.log({\n          logLevel: LOG_DRAW_PRIORITY,\n          message: \"Rendered to \".concat(framebuffer.id)\n        });\n      }\n\n      log.groupEnd(LOG_DRAW_PRIORITY, \">>> DRAWING MODEL \".concat(this.id))();\n    }\n  }]);\n\n  return Model;\n}();\n\nexport { Model as default };","map":{"version":3,"sources":["../../../src/lib/model.js"],"names":["clear","LOG_DRAW_PRIORITY","LOG_DRAW_TIMEOUT","ERR_MODEL_PARAMS","NOOP","DRAW_PARAMS","Model","props","id","uid","assert","isWebGL","ProgramManager","program","vs","fs","modules","defines","inject","varyings","bufferMode","transpileToGLSL100","Object","Number","drawMode","vertexCount","instanceCount","geometry","getBuffersFromGeometry","attributes","isObjectEmpty","normalizedAttributes","attribute","uniforms","opts","getUniforms","moduleSettings","framebuffer","transformFeedback","parameters","vertexArray","log","logPriority","drawParams","isIndexed","indexType","indexOffset","vertexArrayInstanced","isInstanced","onBeforeRender","onAfterRender","didDraw","offset","discard","feedbackBuffers","unbindModels","model","shaderCache","needsUpdate","buffer","animationProps","animatedUniforms","gl","logLevel","logDrawTimeout","Date","collapsed","attributeTable","getDebugTableForVertexArray","header","_attributes","uniformTable","unusedTable","unusedCount","getDebugTableForUniforms","missingTable","missingCount","undefinedOnly","configTable","getDebugTableForProgramConfiguration","message"],"mappings":"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","sourcesContent":["/* eslint-disable complexity */\n\nimport GL from '@luma.gl/constants';\nimport {isWebGL} from '@luma.gl/gltools';\nimport ProgramManager from './program-manager';\nimport {\n  Program,\n  VertexArray,\n  clear,\n  TransformFeedback,\n  Buffer,\n  log,\n  isObjectEmpty,\n  uid,\n  assert\n} from '@luma.gl/webgl';\nimport {\n  getDebugTableForUniforms,\n  getDebugTableForVertexArray,\n  getDebugTableForProgramConfiguration\n} from '@luma.gl/webgl';\nimport {getBuffersFromGeometry} from './model-utils';\n\nconst LOG_DRAW_PRIORITY = 2;\nconst LOG_DRAW_TIMEOUT = 10000;\n\nconst ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';\n\nconst NOOP = () => {};\nconst DRAW_PARAMS = {};\n\nexport default class Model {\n  constructor(gl, props = {}) {\n    // Deduce a helpful id\n    const {id = uid('model')} = props;\n    assert(isWebGL(gl));\n    this.id = id;\n    this.gl = gl;\n    this.id = props.id || uid('Model');\n    this.lastLogTime = 0; // TODO - move to probe.gl\n    this.initialize(props);\n  }\n\n  initialize(props) {\n    this.props = {};\n\n    this.programManager = props.programManager || ProgramManager.getDefaultProgramManager(this.gl);\n    this._programManagerState = -1;\n    this._managedProgram = false;\n\n    const {\n      program = null,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    } = props;\n\n    this.programProps = {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    };\n    this.program = null;\n    this.vertexArray = null;\n    this._programDirty = true;\n\n    // Initialize state\n    this.userData = {};\n    this.needsRedraw = true;\n\n    // Attributes and buffers\n    // Model manages auto Buffer creation from typed arrays\n    this._attributes = {}; // All attributes\n    this.attributes = {}; // User defined attributes\n\n    // Model manages uniform animation\n    this.uniforms = {};\n\n    // picking options\n    this.pickable = true;\n\n    this._checkProgram();\n\n    this.setUniforms(\n      Object.assign(\n        {},\n        this.getModuleUniforms(props.moduleSettings) // Get unforms for supplied parameters\n      )\n    );\n\n    this.drawMode = props.drawMode !== undefined ? props.drawMode : GL.TRIANGLES;\n    this.vertexCount = props.vertexCount || 0;\n\n    // Track buffers created by setGeometry\n    this.geometryBuffers = {};\n\n    // geometry might have set drawMode and vertexCount\n    this.isInstanced = props.isInstanced || props.instanced || props.instanceCount > 0;\n\n    this._setModelProps(props);\n\n    // TODO - just to unbreak deck.gl 7.0-beta, remove as soon as updated\n    this.geometry = {};\n\n    // assert(program || program instanceof Program);\n    assert(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);\n  }\n\n  setProps(props) {\n    this._setModelProps(props);\n  }\n\n  delete() {\n    // delete all attributes created by this model\n    // TODO - should buffer deletes be handled by vertex array?\n    for (const key in this._attributes) {\n      if (this._attributes[key] !== this.attributes[key]) {\n        this._attributes[key].delete();\n      }\n    }\n\n    if (this._managedProgram) {\n      this.programManager.release(this.program);\n    }\n\n    this.vertexArray.delete();\n\n    this._deleteGeometryBuffers();\n  }\n\n  // GETTERS\n\n  getDrawMode() {\n    return this.drawMode;\n  }\n\n  getVertexCount() {\n    return this.vertexCount;\n  }\n\n  getInstanceCount() {\n    return this.instanceCount;\n  }\n\n  getAttributes() {\n    return this.attributes;\n  }\n\n  getProgram() {\n    return this.program;\n  }\n\n  setProgram(props) {\n    const {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    } = props;\n    this.programProps = {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    };\n    this._programDirty = true;\n  }\n\n  getUniforms() {\n    return this.uniforms;\n  }\n\n  // SETTERS\n\n  setDrawMode(drawMode) {\n    this.drawMode = drawMode;\n    return this;\n  }\n\n  setVertexCount(vertexCount) {\n    assert(Number.isFinite(vertexCount));\n    this.vertexCount = vertexCount;\n    return this;\n  }\n\n  setInstanceCount(instanceCount) {\n    assert(Number.isFinite(instanceCount));\n    this.instanceCount = instanceCount;\n    return this;\n  }\n\n  setGeometry(geometry) {\n    this.drawMode = geometry.drawMode;\n    this.vertexCount = geometry.getVertexCount();\n\n    this._deleteGeometryBuffers();\n\n    this.geometryBuffers = getBuffersFromGeometry(this.gl, geometry);\n    this.vertexArray.setAttributes(this.geometryBuffers);\n    return this;\n  }\n\n  setAttributes(attributes = {}) {\n    // Avoid setting needsRedraw if no attributes\n    if (isObjectEmpty(attributes)) {\n      return this;\n    }\n\n    const normalizedAttributes = {};\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      // The `getValue` call provides support for deck.gl `Attribute` class\n      // TODO - remove once deck refactoring completes\n      normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;\n    }\n\n    this.vertexArray.setAttributes(normalizedAttributes);\n    return this;\n  }\n\n  // TODO - should actually set the uniforms\n  setUniforms(uniforms = {}) {\n    Object.assign(this.uniforms, uniforms);\n\n    return this;\n  }\n\n  getModuleUniforms(opts) {\n    this._checkProgram();\n\n    const getUniforms = this.programManager.getUniforms(this.program);\n\n    if (getUniforms) {\n      return getUniforms(opts);\n    }\n\n    return {};\n  }\n\n  updateModuleSettings(opts) {\n    const uniforms = this.getModuleUniforms(opts || {});\n    return this.setUniforms(uniforms);\n  }\n\n  // DRAW CALLS\n\n  clear(opts) {\n    clear(this.program.gl, opts);\n    return this;\n  }\n\n  draw(opts = {}) {\n    // Lazy update program and vertex array\n    this._checkProgram();\n\n    const {\n      moduleSettings = null,\n      framebuffer,\n      uniforms = {},\n      attributes = {},\n      transformFeedback = this.transformFeedback,\n      parameters = {},\n      vertexArray = this.vertexArray\n    } = opts;\n\n    // Update model with any just provided attributes, settings or uniforms\n    this.setAttributes(attributes);\n    this.updateModuleSettings(moduleSettings);\n    this.setUniforms(uniforms);\n\n    let logPriority;\n\n    if (log.priority >= LOG_DRAW_PRIORITY) {\n      logPriority = this._logDrawCallStart(LOG_DRAW_PRIORITY);\n    }\n\n    const drawParams = this.vertexArray.getDrawParams();\n    const {\n      isIndexed = drawParams.isIndexed,\n      indexType = drawParams.indexType,\n      indexOffset = drawParams.indexOffset,\n      vertexArrayInstanced = drawParams.isInstanced\n    } = this.props;\n\n    if (vertexArrayInstanced && !this.isInstanced) {\n      log.warn('Found instanced attributes on non-instanced model', this.id)();\n    }\n\n    const {isInstanced, instanceCount} = this;\n\n    const {onBeforeRender = NOOP, onAfterRender = NOOP} = this.props;\n\n    onBeforeRender();\n\n    this.program.setUniforms(this.uniforms);\n\n    const didDraw = this.program.draw(\n      Object.assign(DRAW_PARAMS, opts, {\n        logPriority,\n        uniforms: null, // Already set (may contain \"function values\" not understood by Program)\n        framebuffer,\n        parameters,\n        drawMode: this.getDrawMode(),\n        vertexCount: this.getVertexCount(),\n        vertexArray,\n        transformFeedback,\n        isIndexed,\n        indexType,\n        isInstanced,\n        instanceCount,\n        offset: isIndexed ? indexOffset : 0\n      })\n    );\n\n    onAfterRender();\n\n    if (log.priority >= LOG_DRAW_PRIORITY) {\n      this._logDrawCallEnd(logPriority, vertexArray, framebuffer);\n    }\n\n    return didDraw;\n  }\n\n  // Draw call for transform feedback\n  transform(opts = {}) {\n    const {discard = true, feedbackBuffers, unbindModels = []} = opts;\n\n    let {parameters} = opts;\n\n    if (feedbackBuffers) {\n      this._setFeedbackBuffers(feedbackBuffers);\n    }\n\n    if (discard) {\n      parameters = Object.assign({}, parameters, {[GL.RASTERIZER_DISCARD]: discard});\n    }\n\n    unbindModels.forEach(model => model.vertexArray.unbindBuffers());\n    try {\n      this.draw(Object.assign({}, opts, {parameters}));\n    } finally {\n      unbindModels.forEach(model => model.vertexArray.bindBuffers());\n    }\n\n    return this;\n  }\n\n  // DEPRECATED METHODS\n\n  render(uniforms = {}) {\n    log.warn('Model.render() is deprecated. Use Model.setUniforms() and Model.draw()')();\n    return this.setUniforms(uniforms).draw();\n  }\n\n  // PRIVATE METHODS\n\n  _setModelProps(props) {\n    Object.assign(this.props, props);\n\n    if ('uniforms' in props) {\n      this.setUniforms(props.uniforms);\n    }\n\n    if ('pickable' in props) {\n      this.pickable = props.pickable;\n    }\n\n    if ('instanceCount' in props) {\n      this.instanceCount = props.instanceCount;\n    }\n    if ('geometry' in props) {\n      this.setGeometry(props.geometry);\n    }\n\n    // webgl settings\n    if ('attributes' in props) {\n      this.setAttributes(props.attributes);\n    }\n    if ('_feedbackBuffers' in props) {\n      this._setFeedbackBuffers(props._feedbackBuffers);\n    }\n  }\n\n  _checkProgram(shaderCache = null) {\n    const needsUpdate =\n      this._programDirty || this.programManager.stateHash !== this._programManagerState;\n\n    if (!needsUpdate) {\n      return;\n    }\n\n    let {program} = this.programProps;\n\n    if (program) {\n      this._managedProgram = false;\n    } else {\n      const {\n        vs,\n        fs,\n        modules,\n        inject,\n        defines,\n        varyings,\n        bufferMode,\n        transpileToGLSL100\n      } = this.programProps;\n      program = this.programManager.get({\n        vs,\n        fs,\n        modules,\n        inject,\n        defines,\n        varyings,\n        bufferMode,\n        transpileToGLSL100\n      });\n      if (this.program && this._managedProgram) {\n        this.programManager.release(this.program);\n      }\n      this._programManagerState = this.programManager.stateHash;\n      this._managedProgram = true;\n    }\n\n    assert(program instanceof Program, 'Model needs a program');\n\n    this._programDirty = false;\n\n    if (program === this.program) {\n      return;\n    }\n\n    this.program = program;\n\n    if (this.vertexArray) {\n      this.vertexArray.setProps({program: this.program, attributes: this.vertexArray.attributes});\n    } else {\n      this.vertexArray = new VertexArray(this.gl, {program: this.program});\n    }\n\n    // Make sure we have some reasonable default uniforms in place\n    this.setUniforms(\n      Object.assign(\n        {},\n        this.getModuleUniforms() // Get all default uniforms,\n      )\n    );\n  }\n\n  _deleteGeometryBuffers() {\n    for (const name in this.geometryBuffers) {\n      // Buffer is raw value (for indices) or first element of [buffer, accessor] pair\n      const buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];\n      if (buffer instanceof Buffer) {\n        buffer.delete();\n      }\n    }\n  }\n\n  // Updates (evaluates) all function valued uniforms based on a new set of animationProps\n  // experimental\n  _setAnimationProps(animationProps) {\n    if (this.animated) {\n      assert(animationProps, 'Model.draw(): animated uniforms but no animationProps');\n      const animatedUniforms = this._evaluateAnimateUniforms(animationProps);\n      Object.assign(this.uniforms, animatedUniforms);\n    }\n  }\n\n  // Transform Feedback\n\n  _setFeedbackBuffers(feedbackBuffers = {}) {\n    // Avoid setting needsRedraw if no feedbackBuffers\n    if (isObjectEmpty(feedbackBuffers)) {\n      return this;\n    }\n\n    const {gl} = this.program;\n    this.transformFeedback =\n      this.transformFeedback ||\n      new TransformFeedback(gl, {\n        program: this.program\n      });\n\n    this.transformFeedback.setBuffers(feedbackBuffers);\n    return this;\n  }\n\n  _logDrawCallStart(logLevel) {\n    const logDrawTimeout = logLevel > 3 ? 0 : LOG_DRAW_TIMEOUT;\n    if (Date.now() - this.lastLogTime < logDrawTimeout) {\n      return undefined;\n    }\n\n    this.lastLogTime = Date.now();\n\n    log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, {collapsed: log.level <= 2})();\n\n    return logLevel;\n  }\n\n  _logDrawCallEnd(logLevel, vertexArray, uniforms, framebuffer) {\n    // HACK: logLevel === undefined means logDrawCallStart didn't run\n    if (logLevel === undefined) {\n      return;\n    }\n\n    const attributeTable = getDebugTableForVertexArray({\n      vertexArray,\n      header: `${this.id} attributes`,\n      attributes: this._attributes\n    });\n\n    const {table: uniformTable, unusedTable, unusedCount} = getDebugTableForUniforms({\n      header: `${this.id} uniforms`,\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms)\n    });\n\n    // log missing uniforms\n    const {table: missingTable, count: missingCount} = getDebugTableForUniforms({\n      header: `${this.id} uniforms`,\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms),\n      undefinedOnly: true\n    });\n\n    if (missingCount > 0) {\n      log.log('MISSING UNIFORMS', Object.keys(missingTable))();\n      // log.table(logLevel, missingTable)();\n    }\n    if (unusedCount > 0) {\n      log.log('UNUSED UNIFORMS', Object.keys(unusedTable))();\n      // log.log(logLevel, 'Unused uniforms ', unusedTable)();\n    }\n\n    const configTable = getDebugTableForProgramConfiguration(this.vertexArray.configuration);\n\n    log.table(logLevel, attributeTable)();\n\n    log.table(logLevel, uniformTable)();\n\n    log.table(logLevel + 1, configTable)();\n\n    if (framebuffer) {\n      framebuffer.log({logLevel: LOG_DRAW_PRIORITY, message: `Rendered to ${framebuffer.id}`});\n    }\n\n    log.groupEnd(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`)();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}