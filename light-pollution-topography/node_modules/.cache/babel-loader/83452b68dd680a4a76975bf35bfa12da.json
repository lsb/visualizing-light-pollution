{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { Vector3, Matrix4, toRadians, toDegrees, assert, equals, _MathUtils } from 'math.gl';\nimport * as vec3 from 'gl-matrix/vec3';\nimport { WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z } from '../constants';\nimport { fromCartographicToRadians, toCartographicFromRadians } from '../type-utils';\nimport _scaleToGeodeticSurface from './helpers/scale-to-geodetic-surface';\nimport _localFrameToFixedFrame from './helpers/ellipsoid-transform';\nvar scratchVector = new Vector3();\nvar scratchNormal = new Vector3();\nvar scratchK = new Vector3();\nvar scratchPosition = new Vector3();\nvar scratchHeight = new Vector3();\nvar scratchCartesian = new Vector3();\nvar wgs84;\n\nvar Ellipsoid = function () {\n  _createClass(Ellipsoid, null, [{\n    key: \"WGS84\",\n    get: function get() {\n      wgs84 = wgs84 || new Ellipsoid(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z);\n      return wgs84;\n    }\n  }]);\n\n  function Ellipsoid() {\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.0;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;\n    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.0;\n\n    _classCallCheck(this, Ellipsoid);\n\n    assert(x >= 0.0);\n    assert(y >= 0.0);\n    assert(z >= 0.0);\n    this.radii = new Vector3(x, y, z);\n    this.radiiSquared = new Vector3(x * x, y * y, z * z);\n    this.radiiToTheFourth = new Vector3(x * x * x * x, y * y * y * y, z * z * z * z);\n    this.oneOverRadii = new Vector3(x === 0.0 ? 0.0 : 1.0 / x, y === 0.0 ? 0.0 : 1.0 / y, z === 0.0 ? 0.0 : 1.0 / z);\n    this.oneOverRadiiSquared = new Vector3(x === 0.0 ? 0.0 : 1.0 / (x * x), y === 0.0 ? 0.0 : 1.0 / (y * y), z === 0.0 ? 0.0 : 1.0 / (z * z));\n    this.minimumRadius = Math.min(x, y, z);\n    this.maximumRadius = Math.max(x, y, z);\n    this.centerToleranceSquared = _MathUtils.EPSILON1;\n\n    if (this.radiiSquared.z !== 0) {\n      this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z;\n    }\n\n    Object.freeze(this);\n  }\n\n  _createClass(Ellipsoid, [{\n    key: \"equals\",\n    value: function equals(right) {\n      return this === right || Boolean(right && this.radii.equals(right.radii));\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.radii.toString();\n    }\n  }, {\n    key: \"cartographicToCartesian\",\n    value: function cartographicToCartesian(cartographic) {\n      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n      var normal = scratchNormal;\n      var k = scratchK;\n\n      var _cartographic = _slicedToArray(cartographic, 3),\n          height = _cartographic[2];\n\n      this.geodeticSurfaceNormalCartographic(cartographic, normal);\n      k.copy(this.radiiSquared).scale(normal);\n      var gamma = Math.sqrt(normal.dot(k));\n      k.scale(1 / gamma);\n      normal.scale(height);\n      k.add(normal);\n      return k.to(result);\n    }\n  }, {\n    key: \"cartesianToCartographic\",\n    value: function cartesianToCartographic(cartesian) {\n      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n      scratchCartesian.from(cartesian);\n      var point = this.scaleToGeodeticSurface(scratchCartesian, scratchPosition);\n\n      if (!point) {\n        return undefined;\n      }\n\n      var normal = this.geodeticSurfaceNormal(point, scratchNormal);\n      var h = scratchHeight;\n      h.copy(scratchCartesian).subtract(point);\n      var longitude = Math.atan2(normal.y, normal.x);\n      var latitude = Math.asin(normal.z);\n      var height = Math.sign(vec3.dot(h, scratchCartesian)) * vec3.length(h);\n      return toCartographicFromRadians([longitude, latitude, height], result);\n    }\n  }, {\n    key: \"eastNorthUpToFixedFrame\",\n    value: function eastNorthUpToFixedFrame(origin) {\n      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Matrix4();\n      return _localFrameToFixedFrame(this, 'east', 'north', 'up', origin, result);\n    }\n  }, {\n    key: \"localFrameToFixedFrame\",\n    value: function localFrameToFixedFrame(firstAxis, secondAxis, thirdAxis, origin) {\n      var result = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new Matrix4();\n      return _localFrameToFixedFrame(this, firstAxis, secondAxis, thirdAxis, origin, result);\n    }\n  }, {\n    key: \"geocentricSurfaceNormal\",\n    value: function geocentricSurfaceNormal(cartesian) {\n      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n      return scratchVector.from(cartesian).normalize().to(result);\n    }\n  }, {\n    key: \"geodeticSurfaceNormalCartographic\",\n    value: function geodeticSurfaceNormalCartographic(cartographic) {\n      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n      var cartographicVectorRadians = fromCartographicToRadians(cartographic);\n      var longitude = cartographicVectorRadians[0];\n      var latitude = cartographicVectorRadians[1];\n      var cosLatitude = Math.cos(latitude);\n      scratchVector.set(cosLatitude * Math.cos(longitude), cosLatitude * Math.sin(longitude), Math.sin(latitude)).normalize();\n      return scratchVector.to(result);\n    }\n  }, {\n    key: \"geodeticSurfaceNormal\",\n    value: function geodeticSurfaceNormal(cartesian) {\n      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n      return scratchVector.from(cartesian).scale(this.oneOverRadiiSquared).normalize().to(result);\n    }\n  }, {\n    key: \"scaleToGeodeticSurface\",\n    value: function scaleToGeodeticSurface(cartesian, result) {\n      return _scaleToGeodeticSurface(cartesian, this, result);\n    }\n  }, {\n    key: \"scaleToGeocentricSurface\",\n    value: function scaleToGeocentricSurface(cartesian) {\n      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n      scratchPosition.from(cartesian);\n      var positionX = scratchPosition.x;\n      var positionY = scratchPosition.y;\n      var positionZ = scratchPosition.z;\n      var oneOverRadiiSquared = this.oneOverRadiiSquared;\n      var beta = 1.0 / Math.sqrt(positionX * positionX * oneOverRadiiSquared.x + positionY * positionY * oneOverRadiiSquared.y + positionZ * positionZ * oneOverRadiiSquared.z);\n      return scratchPosition.multiplyScalar(beta).to(result);\n    }\n  }, {\n    key: \"transformPositionToScaledSpace\",\n    value: function transformPositionToScaledSpace(position) {\n      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n      return scratchPosition.from(position).scale(this.oneOverRadii).to(result);\n    }\n  }, {\n    key: \"transformPositionFromScaledSpace\",\n    value: function transformPositionFromScaledSpace(position) {\n      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n      return scratchPosition.from(position).scale(this.radii).to(result);\n    }\n  }, {\n    key: \"getSurfaceNormalIntersectionWithZAxis\",\n    value: function getSurfaceNormalIntersectionWithZAxis(position) {\n      var buffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;\n      var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0, 0];\n      assert(equals(this.radii.x, this.radii.y, _MathUtils.EPSILON15));\n      assert(this.radii.z > 0);\n      scratchPosition.from(position);\n      var z = scratchPosition.z * (1 - this.squaredXOverSquaredZ);\n\n      if (Math.abs(z) >= this.radii.z - buffer) {\n        return undefined;\n      }\n\n      return scratchPosition.set(0.0, 0.0, z).to(result);\n    }\n  }]);\n\n  return Ellipsoid;\n}();\n\nexport { Ellipsoid as default };","map":{"version":3,"sources":["../../../src/ellipsoid/ellipsoid.js"],"names":["scratchVector","scratchNormal","scratchK","scratchPosition","scratchHeight","scratchCartesian","Ellipsoid","wgs84","x","y","z","assert","Math","_MathUtils","Object","right","Boolean","cartographic","result","normal","k","height","gamma","cartesian","point","h","longitude","latitude","vec3","toCartographicFromRadians","origin","localFrameToFixedFrame","firstAxis","secondAxis","thirdAxis","cartographicVectorRadians","fromCartographicToRadians","cosLatitude","scaleToGeodeticSurface","positionX","positionY","positionZ","oneOverRadiiSquared","beta","position","buffer","equals"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/* eslint-disable */\nimport {Vector3, Matrix4, toRadians, toDegrees, assert, equals, _MathUtils} from 'math.gl';\nimport * as vec3 from 'gl-matrix/vec3';\n\nimport {WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z} from '../constants';\nimport {fromCartographicToRadians, toCartographicFromRadians} from '../type-utils';\n\nimport scaleToGeodeticSurface from './helpers/scale-to-geodetic-surface';\nimport localFrameToFixedFrame from './helpers/ellipsoid-transform';\n\nconst scratchVector = new Vector3();\nconst scratchNormal = new Vector3();\nconst scratchK = new Vector3();\nconst scratchPosition = new Vector3();\nconst scratchHeight = new Vector3();\nconst scratchCartesian = new Vector3();\n\nlet wgs84;\n\n// A quadratic surface defined in Cartesian coordinates by the equation\n// <code>(x / a)^2 + (y / b)^2 + (z / c)^2 = 1</code>.  Primarily used\n// to represent the shape of planetary bodies.\nexport default class Ellipsoid {\n  // An Ellipsoid instance initialized to the WGS84 standard.\n  static get WGS84() {\n    wgs84 = wgs84 || new Ellipsoid(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z);\n    return wgs84;\n  }\n\n  // Creates an Ellipsoid from a Cartesian specifying the radii in x, y, and z directions.\n  constructor(x = 0.0, y = 0.0, z = 0.0) {\n    assert(x >= 0.0);\n    assert(y >= 0.0);\n    assert(z >= 0.0);\n\n    this.radii = new Vector3(x, y, z);\n\n    this.radiiSquared = new Vector3(x * x, y * y, z * z);\n\n    this.radiiToTheFourth = new Vector3(x * x * x * x, y * y * y * y, z * z * z * z);\n\n    this.oneOverRadii = new Vector3(\n      x === 0.0 ? 0.0 : 1.0 / x,\n      y === 0.0 ? 0.0 : 1.0 / y,\n      z === 0.0 ? 0.0 : 1.0 / z\n    );\n\n    this.oneOverRadiiSquared = new Vector3(\n      x === 0.0 ? 0.0 : 1.0 / (x * x),\n      y === 0.0 ? 0.0 : 1.0 / (y * y),\n      z === 0.0 ? 0.0 : 1.0 / (z * z)\n    );\n\n    this.minimumRadius = Math.min(x, y, z);\n\n    this.maximumRadius = Math.max(x, y, z);\n\n    this.centerToleranceSquared = _MathUtils.EPSILON1;\n\n    if (this.radiiSquared.z !== 0) {\n      this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z;\n    }\n\n    Object.freeze(this);\n  }\n\n  // Compares this Ellipsoid against the provided Ellipsoid componentwise and returns\n  equals(right) {\n    return this === right || Boolean(right && this.radii.equals(right.radii));\n  }\n\n  // Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'.\n  toString() {\n    return this.radii.toString();\n  }\n\n  // Converts the provided cartographic to Cartesian representation.\n  cartographicToCartesian(cartographic, result = [0, 0, 0]) {\n    const normal = scratchNormal;\n    const k = scratchK;\n\n    const [, , height] = cartographic;\n    this.geodeticSurfaceNormalCartographic(cartographic, normal);\n    k.copy(this.radiiSquared).scale(normal);\n\n    const gamma = Math.sqrt(normal.dot(k));\n    k.scale(1 / gamma);\n\n    normal.scale(height);\n\n    k.add(normal);\n\n    return k.to(result);\n  }\n\n  // Converts the provided cartesian to cartographic (lng/lat/z) representation.\n  // The cartesian is undefined at the center of the ellipsoid.\n  cartesianToCartographic(cartesian, result = [0, 0, 0]) {\n    scratchCartesian.from(cartesian);\n    const point = this.scaleToGeodeticSurface(scratchCartesian, scratchPosition);\n\n    if (!point) {\n      return undefined;\n    }\n\n    const normal = this.geodeticSurfaceNormal(point, scratchNormal);\n\n    const h = scratchHeight;\n    h.copy(scratchCartesian).subtract(point);\n\n    const longitude = Math.atan2(normal.y, normal.x);\n    const latitude = Math.asin(normal.z);\n    const height = Math.sign(vec3.dot(h, scratchCartesian)) * vec3.length(h);\n\n    return toCartographicFromRadians([longitude, latitude, height], result);\n  }\n\n  // Computes a 4x4 transformation matrix from a reference frame with an east-north-up axes\n  // centered at the provided origin to the provided ellipsoid's fixed reference frame.\n  eastNorthUpToFixedFrame(origin, result = new Matrix4()) {\n    return localFrameToFixedFrame(this, 'east', 'north', 'up', origin, result);\n  }\n\n  // Computes a 4x4 transformation matrix from a reference frame centered at\n  // the provided origin to the ellipsoid's fixed reference frame.\n  localFrameToFixedFrame(firstAxis, secondAxis, thirdAxis, origin, result = new Matrix4()) {\n    return localFrameToFixedFrame(this, firstAxis, secondAxis, thirdAxis, origin, result);\n  }\n\n  // Computes the unit vector directed from the center of this ellipsoid toward\n  // the provided Cartesian position.\n  geocentricSurfaceNormal(cartesian, result = [0, 0, 0]) {\n    return scratchVector\n      .from(cartesian)\n      .normalize()\n      .to(result);\n  }\n\n  // Computes the normal of the plane tangent to the surface of the ellipsoid at provided position.\n  geodeticSurfaceNormalCartographic(cartographic, result = [0, 0, 0]) {\n    const cartographicVectorRadians = fromCartographicToRadians(cartographic);\n\n    const longitude = cartographicVectorRadians[0];\n    const latitude = cartographicVectorRadians[1];\n\n    const cosLatitude = Math.cos(latitude);\n\n    scratchVector\n      .set(cosLatitude * Math.cos(longitude), cosLatitude * Math.sin(longitude), Math.sin(latitude))\n      .normalize();\n\n    return scratchVector.to(result);\n  }\n\n  // Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\n  geodeticSurfaceNormal(cartesian, result = [0, 0, 0]) {\n    return scratchVector\n      .from(cartesian)\n      .scale(this.oneOverRadiiSquared)\n      .normalize()\n      .to(result);\n  }\n\n  // Scales the provided Cartesian position along the geodetic surface normal\n  // so that it is on the surface of this ellipsoid.  If the position is\n  // at the center of the ellipsoid, this function returns undefined.\n  scaleToGeodeticSurface(cartesian, result) {\n    return scaleToGeodeticSurface(cartesian, this, result);\n  }\n\n  // Scales the provided Cartesian position along the geocentric surface normal\n  // so that it is on the surface of this ellipsoid.\n  scaleToGeocentricSurface(cartesian, result = [0, 0, 0]) {\n    scratchPosition.from(cartesian);\n\n    const positionX = scratchPosition.x;\n    const positionY = scratchPosition.y;\n    const positionZ = scratchPosition.z;\n    const oneOverRadiiSquared = this.oneOverRadiiSquared;\n\n    const beta =\n      1.0 /\n      Math.sqrt(\n        positionX * positionX * oneOverRadiiSquared.x +\n          positionY * positionY * oneOverRadiiSquared.y +\n          positionZ * positionZ * oneOverRadiiSquared.z\n      );\n\n    return scratchPosition.multiplyScalar(beta).to(result);\n  }\n\n  // Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying\n  // its components by the result of `Ellipsoid#oneOverRadii`\n  transformPositionToScaledSpace(position, result = [0, 0, 0]) {\n    return scratchPosition\n      .from(position)\n      .scale(this.oneOverRadii)\n      .to(result);\n  }\n\n  // Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying\n  // its components by the result of `Ellipsoid#radii`.\n  transformPositionFromScaledSpace(position, result = [0, 0, 0]) {\n    return scratchPosition\n      .from(position)\n      .scale(this.radii)\n      .to(result);\n  }\n\n  // Computes a point which is the intersection of the surface normal with the z-axis.\n  getSurfaceNormalIntersectionWithZAxis(position, buffer = 0.0, result = [0, 0, 0]) {\n    // Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\n    assert(equals(this.radii.x, this.radii.y, _MathUtils.EPSILON15));\n    assert(this.radii.z > 0);\n\n    scratchPosition.from(position);\n    const z = scratchPosition.z * (1 - this.squaredXOverSquaredZ);\n\n    if (Math.abs(z) >= this.radii.z - buffer) {\n      return undefined;\n    }\n\n    return scratchPosition.set(0.0, 0.0, z).to(result);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}