{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { Texture2D } from '@luma.gl/core';\nimport TinySDF from '@mapbox/tiny-sdf';\nimport { buildMapping } from './utils';\nimport LRUCache from './lru-cache';\n\nfunction getDefaultCharacterSet() {\n  var charSet = [];\n\n  for (var i = 32; i < 128; i++) {\n    charSet.push(String.fromCharCode(i));\n  }\n\n  return charSet;\n}\n\nexport var DEFAULT_CHAR_SET = getDefaultCharacterSet();\nexport var DEFAULT_FONT_FAMILY = 'Monaco, monospace';\nexport var DEFAULT_FONT_WEIGHT = 'normal';\nexport var DEFAULT_FONT_SIZE = 64;\nexport var DEFAULT_BUFFER = 2;\nexport var DEFAULT_CUTOFF = 0.25;\nexport var DEFAULT_RADIUS = 3;\nvar GL_TEXTURE_WRAP_S = 0x2802;\nvar GL_TEXTURE_WRAP_T = 0x2803;\nvar GL_CLAMP_TO_EDGE = 0x812f;\nvar MAX_CANVAS_WIDTH = 1024;\nvar BASELINE_SCALE = 0.9;\nvar HEIGHT_SCALE = 1.2;\nvar CACHE_LIMIT = 3;\nvar cache = new LRUCache(CACHE_LIMIT);\nvar VALID_PROPS = ['fontFamily', 'fontWeight', 'characterSet', 'fontSize', 'sdf', 'buffer', 'cutoff', 'radius'];\n\nfunction getNewChars(key, characterSet) {\n  var cachedFontAtlas = cache.get(key);\n\n  if (!cachedFontAtlas) {\n    return characterSet;\n  }\n\n  var newChars = [];\n  var cachedMapping = cachedFontAtlas.mapping;\n  var cachedCharSet = Object.keys(cachedMapping);\n  cachedCharSet = new Set(cachedCharSet);\n  var charSet = characterSet;\n\n  if (charSet instanceof Array) {\n    charSet = new Set(charSet);\n  }\n\n  charSet.forEach(function (_char) {\n    if (!cachedCharSet.has(_char)) {\n      newChars.push(_char);\n    }\n  });\n  return newChars;\n}\n\nfunction populateAlphaChannel(alphaChannel, imageData) {\n  for (var i = 0; i < alphaChannel.length; i++) {\n    imageData.data[4 * i + 3] = alphaChannel[i];\n  }\n}\n\nfunction setTextStyle(ctx, fontFamily, fontSize, fontWeight) {\n  ctx.font = \"\".concat(fontWeight, \" \").concat(fontSize, \"px \").concat(fontFamily);\n  ctx.fillStyle = '#000';\n  ctx.textBaseline = 'baseline';\n  ctx.textAlign = 'left';\n}\n\nvar FontAtlasManager = function () {\n  function FontAtlasManager(gl) {\n    _classCallCheck(this, FontAtlasManager);\n\n    this.gl = gl;\n    this.props = {\n      fontFamily: DEFAULT_FONT_FAMILY,\n      fontWeight: DEFAULT_FONT_WEIGHT,\n      characterSet: DEFAULT_CHAR_SET,\n      fontSize: DEFAULT_FONT_SIZE,\n      buffer: DEFAULT_BUFFER,\n      sdf: false,\n      cutoff: DEFAULT_CUTOFF,\n      radius: DEFAULT_RADIUS\n    };\n    this._key = null;\n    this._texture = new Texture2D(this.gl);\n  }\n\n  _createClass(FontAtlasManager, [{\n    key: \"finalize\",\n    value: function finalize() {\n      this._texture[\"delete\"]();\n    }\n  }, {\n    key: \"setProps\",\n    value: function setProps() {\n      var _this = this;\n\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      VALID_PROPS.forEach(function (prop) {\n        if (prop in props) {\n          _this.props[prop] = props[prop];\n        }\n      });\n      var oldKey = this._key;\n      this._key = this._getKey();\n      var charSet = getNewChars(this._key, this.props.characterSet);\n      var cachedFontAtlas = cache.get(this._key);\n\n      if (cachedFontAtlas && charSet.length === 0) {\n        if (this._key !== oldKey) {\n          this._updateTexture(cachedFontAtlas);\n        }\n\n        return;\n      }\n\n      var fontAtlas = this._generateFontAtlas(this._key, charSet, cachedFontAtlas);\n\n      this._updateTexture(fontAtlas);\n\n      cache.set(this._key, fontAtlas);\n    }\n  }, {\n    key: \"_updateTexture\",\n    value: function _updateTexture(_ref) {\n      var _parameters;\n\n      var canvas = _ref.data,\n          width = _ref.width,\n          height = _ref.height;\n\n      if (this._texture.width !== width || this._texture.height !== height) {\n        this._texture.resize({\n          width: width,\n          height: height\n        });\n      }\n\n      this._texture.setImageData({\n        data: canvas,\n        width: width,\n        height: height,\n        parameters: (_parameters = {}, _defineProperty(_parameters, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE), _defineProperty(_parameters, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE), _parameters)\n      });\n\n      this._texture.generateMipmap();\n    }\n  }, {\n    key: \"_generateFontAtlas\",\n    value: function _generateFontAtlas(key, characterSet, cachedFontAtlas) {\n      var _this$props = this.props,\n          fontFamily = _this$props.fontFamily,\n          fontWeight = _this$props.fontWeight,\n          fontSize = _this$props.fontSize,\n          buffer = _this$props.buffer,\n          sdf = _this$props.sdf,\n          radius = _this$props.radius,\n          cutoff = _this$props.cutoff;\n      var canvas = cachedFontAtlas && cachedFontAtlas.data;\n\n      if (!canvas) {\n        canvas = document.createElement('canvas');\n        canvas.width = MAX_CANVAS_WIDTH;\n      }\n\n      var ctx = canvas.getContext('2d');\n      setTextStyle(ctx, fontFamily, fontSize, fontWeight);\n\n      var _buildMapping = buildMapping(Object.assign({\n        getFontWidth: function getFontWidth(_char2) {\n          return ctx.measureText(_char2).width;\n        },\n        fontHeight: fontSize * HEIGHT_SCALE,\n        buffer: buffer,\n        characterSet: characterSet,\n        maxCanvasWidth: MAX_CANVAS_WIDTH\n      }, cachedFontAtlas && {\n        mapping: cachedFontAtlas.mapping,\n        xOffset: cachedFontAtlas.xOffset,\n        yOffset: cachedFontAtlas.yOffset\n      })),\n          mapping = _buildMapping.mapping,\n          canvasHeight = _buildMapping.canvasHeight,\n          xOffset = _buildMapping.xOffset,\n          yOffset = _buildMapping.yOffset;\n\n      if (canvas.height !== canvasHeight) {\n        var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        canvas.height = canvasHeight;\n        ctx.putImageData(imageData, 0, 0);\n      }\n\n      setTextStyle(ctx, fontFamily, fontSize, fontWeight);\n\n      if (sdf) {\n        var tinySDF = new TinySDF(fontSize, buffer, radius, cutoff, fontFamily, fontWeight);\n\n        var _imageData = ctx.getImageData(0, 0, tinySDF.size, tinySDF.size);\n\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = characterSet[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var _char3 = _step.value;\n            populateAlphaChannel(tinySDF.draw(_char3), _imageData);\n            ctx.putImageData(_imageData, mapping[_char3].x - buffer, mapping[_char3].y - buffer);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n              _iterator[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } else {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = characterSet[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var _char4 = _step2.value;\n            ctx.fillText(_char4, mapping[_char4].x, mapping[_char4].y + fontSize * BASELINE_SCALE);\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n              _iterator2[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n\n      return {\n        xOffset: xOffset,\n        yOffset: yOffset,\n        mapping: mapping,\n        data: canvas,\n        width: canvas.width,\n        height: canvas.height\n      };\n    }\n  }, {\n    key: \"_getKey\",\n    value: function _getKey() {\n      var _this$props2 = this.props,\n          gl = _this$props2.gl,\n          fontFamily = _this$props2.fontFamily,\n          fontWeight = _this$props2.fontWeight,\n          fontSize = _this$props2.fontSize,\n          buffer = _this$props2.buffer,\n          sdf = _this$props2.sdf,\n          radius = _this$props2.radius,\n          cutoff = _this$props2.cutoff;\n\n      if (sdf) {\n        return \"\".concat(gl, \" \").concat(fontFamily, \" \").concat(fontWeight, \" \").concat(fontSize, \" \").concat(buffer, \" \").concat(radius, \" \").concat(cutoff);\n      }\n\n      return \"\".concat(gl, \" \").concat(fontFamily, \" \").concat(fontWeight, \" \").concat(fontSize, \" \").concat(buffer);\n    }\n  }, {\n    key: \"texture\",\n    get: function get() {\n      return this._texture;\n    }\n  }, {\n    key: \"mapping\",\n    get: function get() {\n      var data = cache.get(this._key);\n      return data && data.mapping;\n    }\n  }, {\n    key: \"scale\",\n    get: function get() {\n      return HEIGHT_SCALE;\n    }\n  }]);\n\n  return FontAtlasManager;\n}();\n\nexport { FontAtlasManager as default };","map":{"version":3,"sources":["../../../src/text-layer/font-atlas-manager.js"],"names":["charSet","i","String","DEFAULT_CHAR_SET","getDefaultCharacterSet","DEFAULT_FONT_FAMILY","DEFAULT_FONT_WEIGHT","DEFAULT_FONT_SIZE","DEFAULT_BUFFER","DEFAULT_CUTOFF","DEFAULT_RADIUS","GL_TEXTURE_WRAP_S","GL_TEXTURE_WRAP_T","GL_CLAMP_TO_EDGE","MAX_CANVAS_WIDTH","BASELINE_SCALE","HEIGHT_SCALE","CACHE_LIMIT","cache","VALID_PROPS","cachedFontAtlas","newChars","cachedMapping","cachedCharSet","Object","alphaChannel","imageData","ctx","FontAtlasManager","fontFamily","fontWeight","characterSet","fontSize","buffer","sdf","cutoff","radius","data","props","prop","oldKey","getNewChars","fontAtlas","canvas","width","height","parameters","key","document","setTextStyle","mapping","canvasHeight","xOffset","yOffset","buildMapping","getFontWidth","fontHeight","maxCanvasWidth","tinySDF","char","populateAlphaChannel","gl"],"mappings":"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","sourcesContent":["/* global document */\n\nimport {Texture2D} from '@luma.gl/core';\nimport TinySDF from '@mapbox/tiny-sdf';\n\nimport {buildMapping} from './utils';\nimport LRUCache from './lru-cache';\n\nfunction getDefaultCharacterSet() {\n  const charSet = [];\n  for (let i = 32; i < 128; i++) {\n    charSet.push(String.fromCharCode(i));\n  }\n  return charSet;\n}\n\nexport const DEFAULT_CHAR_SET = getDefaultCharacterSet();\nexport const DEFAULT_FONT_FAMILY = 'Monaco, monospace';\nexport const DEFAULT_FONT_WEIGHT = 'normal';\nexport const DEFAULT_FONT_SIZE = 64;\nexport const DEFAULT_BUFFER = 2;\nexport const DEFAULT_CUTOFF = 0.25;\nexport const DEFAULT_RADIUS = 3;\n\nconst GL_TEXTURE_WRAP_S = 0x2802;\nconst GL_TEXTURE_WRAP_T = 0x2803;\nconst GL_CLAMP_TO_EDGE = 0x812f;\nconst MAX_CANVAS_WIDTH = 1024;\n\nconst BASELINE_SCALE = 0.9;\nconst HEIGHT_SCALE = 1.2;\n\n// only preserve latest three fontAtlas\nconst CACHE_LIMIT = 3;\n\n/**\n * [key]: {\n *   xOffset, // x position of last character in mapping\n *   yOffset, // y position of last character in mapping\n *   mapping, // x, y coordinate of each character in shared `fontAtlas`\n *   data, // canvas\n *   width. // canvas.width,\n *   height, // canvas.height\n * }\n *\n */\nconst cache = new LRUCache(CACHE_LIMIT);\n\nconst VALID_PROPS = [\n  'fontFamily',\n  'fontWeight',\n  'characterSet',\n  'fontSize',\n  'sdf',\n  'buffer',\n  'cutoff',\n  'radius'\n];\n\n/**\n * get all the chars not in cache\n * @param key cache key\n * @param characterSet (Array|Set)\n * @returns {Array} chars not in cache\n */\nfunction getNewChars(key, characterSet) {\n  const cachedFontAtlas = cache.get(key);\n  if (!cachedFontAtlas) {\n    return characterSet;\n  }\n\n  const newChars = [];\n  const cachedMapping = cachedFontAtlas.mapping;\n  let cachedCharSet = Object.keys(cachedMapping);\n  cachedCharSet = new Set(cachedCharSet);\n\n  let charSet = characterSet;\n  if (charSet instanceof Array) {\n    charSet = new Set(charSet);\n  }\n\n  charSet.forEach(char => {\n    if (!cachedCharSet.has(char)) {\n      newChars.push(char);\n    }\n  });\n\n  return newChars;\n}\n\nfunction populateAlphaChannel(alphaChannel, imageData) {\n  // populate distance value from tinySDF to image alpha channel\n  for (let i = 0; i < alphaChannel.length; i++) {\n    imageData.data[4 * i + 3] = alphaChannel[i];\n  }\n}\n\nfunction setTextStyle(ctx, fontFamily, fontSize, fontWeight) {\n  ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;\n  ctx.fillStyle = '#000';\n  ctx.textBaseline = 'baseline';\n  ctx.textAlign = 'left';\n}\n\nexport default class FontAtlasManager {\n  constructor(gl) {\n    this.gl = gl;\n\n    // font settings\n    this.props = {\n      fontFamily: DEFAULT_FONT_FAMILY,\n      fontWeight: DEFAULT_FONT_WEIGHT,\n      characterSet: DEFAULT_CHAR_SET,\n      fontSize: DEFAULT_FONT_SIZE,\n      buffer: DEFAULT_BUFFER,\n      // sdf only props\n      // https://github.com/mapbox/tiny-sdf\n      sdf: false,\n      cutoff: DEFAULT_CUTOFF,\n      radius: DEFAULT_RADIUS\n    };\n\n    // key is used for caching generated fontAtlas\n    this._key = null;\n    this._texture = new Texture2D(this.gl);\n  }\n\n  finalize() {\n    this._texture.delete();\n  }\n\n  get texture() {\n    return this._texture;\n  }\n\n  get mapping() {\n    const data = cache.get(this._key);\n    return data && data.mapping;\n  }\n\n  get scale() {\n    return HEIGHT_SCALE;\n  }\n\n  setProps(props = {}) {\n    VALID_PROPS.forEach(prop => {\n      if (prop in props) {\n        this.props[prop] = props[prop];\n      }\n    });\n\n    // update cache key\n    const oldKey = this._key;\n    this._key = this._getKey();\n\n    const charSet = getNewChars(this._key, this.props.characterSet);\n    const cachedFontAtlas = cache.get(this._key);\n\n    // if a fontAtlas associated with the new settings is cached and\n    // there are no new chars\n    if (cachedFontAtlas && charSet.length === 0) {\n      // update texture with cached fontAtlas\n      if (this._key !== oldKey) {\n        this._updateTexture(cachedFontAtlas);\n      }\n      return;\n    }\n\n    // update fontAtlas with new settings\n    const fontAtlas = this._generateFontAtlas(this._key, charSet, cachedFontAtlas);\n    this._updateTexture(fontAtlas);\n\n    // update cache\n    cache.set(this._key, fontAtlas);\n  }\n\n  _updateTexture({data: canvas, width, height}) {\n    // resize texture\n    if (this._texture.width !== width || this._texture.height !== height) {\n      this._texture.resize({width, height});\n    }\n\n    // update image data\n    this._texture.setImageData({\n      data: canvas,\n      width,\n      height,\n      parameters: {\n        [GL_TEXTURE_WRAP_S]: GL_CLAMP_TO_EDGE,\n        [GL_TEXTURE_WRAP_T]: GL_CLAMP_TO_EDGE\n      }\n    });\n\n    // this is required step after texture data changed\n    this._texture.generateMipmap();\n  }\n\n  _generateFontAtlas(key, characterSet, cachedFontAtlas) {\n    const {fontFamily, fontWeight, fontSize, buffer, sdf, radius, cutoff} = this.props;\n    let canvas = cachedFontAtlas && cachedFontAtlas.data;\n    if (!canvas) {\n      canvas = document.createElement('canvas');\n      canvas.width = MAX_CANVAS_WIDTH;\n    }\n    const ctx = canvas.getContext('2d');\n\n    setTextStyle(ctx, fontFamily, fontSize, fontWeight);\n\n    // 1. build mapping\n    const {mapping, canvasHeight, xOffset, yOffset} = buildMapping(\n      Object.assign(\n        {\n          getFontWidth: char => ctx.measureText(char).width,\n          fontHeight: fontSize * HEIGHT_SCALE,\n          buffer,\n          characterSet,\n          maxCanvasWidth: MAX_CANVAS_WIDTH\n        },\n        cachedFontAtlas && {\n          mapping: cachedFontAtlas.mapping,\n          xOffset: cachedFontAtlas.xOffset,\n          yOffset: cachedFontAtlas.yOffset\n        }\n      )\n    );\n\n    // 2. update canvas\n    // copy old canvas data to new canvas only when height changed\n    if (canvas.height !== canvasHeight) {\n      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n      canvas.height = canvasHeight;\n      ctx.putImageData(imageData, 0, 0);\n    }\n    setTextStyle(ctx, fontFamily, fontSize, fontWeight);\n\n    // 3. layout characters\n    if (sdf) {\n      const tinySDF = new TinySDF(fontSize, buffer, radius, cutoff, fontFamily, fontWeight);\n      // used to store distance values from tinySDF\n      // tinySDF.size equals `fontSize + buffer * 2`\n      const imageData = ctx.getImageData(0, 0, tinySDF.size, tinySDF.size);\n\n      for (const char of characterSet) {\n        populateAlphaChannel(tinySDF.draw(char), imageData);\n        ctx.putImageData(imageData, mapping[char].x - buffer, mapping[char].y - buffer);\n      }\n    } else {\n      for (const char of characterSet) {\n        ctx.fillText(char, mapping[char].x, mapping[char].y + fontSize * BASELINE_SCALE);\n      }\n    }\n\n    return {\n      xOffset,\n      yOffset,\n      mapping,\n      data: canvas,\n      width: canvas.width,\n      height: canvas.height\n    };\n  }\n\n  _getKey() {\n    const {gl, fontFamily, fontWeight, fontSize, buffer, sdf, radius, cutoff} = this.props;\n    if (sdf) {\n      return `${gl} ${fontFamily} ${fontWeight} ${fontSize} ${buffer} ${radius} ${cutoff}`;\n    }\n    return `${gl} ${fontFamily} ${fontWeight} ${fontSize} ${buffer}`;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}