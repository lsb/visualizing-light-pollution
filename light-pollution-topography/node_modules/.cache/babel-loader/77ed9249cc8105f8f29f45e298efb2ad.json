{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { LayerExtension } from '@deck.gl/core';\nvar defaultProps = {\n  clipBounds: [0, 0, 1, 1]\n};\nvar shaderFunction = \"\\nuniform vec4 clip_bounds;\\n\\nbool clip_isInBounds(vec2 position) {\\n  return position.x >= clip_bounds[0] && position.y >= clip_bounds[1] && position.x < clip_bounds[2] && position.y < clip_bounds[3];\\n}\\n\";\nvar shaderModuleVs = {\n  name: 'clip-vs',\n  vs: shaderFunction\n};\nvar injectionVs = {\n  'vs:#decl': \"\\nvarying float clip_isVisible;\\n\",\n  'vs:DECKGL_FILTER_GL_POSITION': \"\\n  clip_isVisible = float(clip_isInBounds(geometry.position.xy));\\n\",\n  'fs:#decl': \"\\nvarying float clip_isVisible;\\n\",\n  'fs:DECKGL_FILTER_COLOR': \"\\n  if (clip_isVisible < 0.5) discard;\\n\"\n};\nvar shaderModuleFs = {\n  name: 'clip-fs',\n  fs: shaderFunction\n};\nvar injectionFs = {\n  'vs:#decl': \"\\nvarying vec2 clip_commonPosition;\\n\",\n  'vs:DECKGL_FILTER_GL_POSITION': \"\\n  clip_commonPosition = geometry.position.xy;\\n\",\n  'fs:#decl': \"\\nvarying vec2 clip_commonPosition;\\n\",\n  'fs:DECKGL_FILTER_COLOR': \"\\n  if (!clip_isInBounds(clip_commonPosition)) discard;\\n\"\n};\n\nvar ClipExtension = function (_LayerExtension) {\n  _inherits(ClipExtension, _LayerExtension);\n\n  function ClipExtension() {\n    _classCallCheck(this, ClipExtension);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ClipExtension).apply(this, arguments));\n  }\n\n  _createClass(ClipExtension, [{\n    key: \"getShaders\",\n    value: function getShaders(opts) {\n      var hasAnchor = ('instancePositions' in this.getAttributeManager().attributes);\n      return hasAnchor ? {\n        modules: [shaderModuleVs],\n        inject: injectionVs\n      } : {\n        modules: [shaderModuleFs],\n        inject: injectionFs\n      };\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(_ref) {\n      var uniforms = _ref.uniforms;\n      var _this$props$clipBound = this.props.clipBounds,\n          clipBounds = _this$props$clipBound === void 0 ? defaultProps.clipBounds : _this$props$clipBound;\n      var corner0 = this.projectPosition([clipBounds[0], clipBounds[1], 0]);\n      var corner1 = this.projectPosition([clipBounds[2], clipBounds[3], 0]);\n      uniforms.clip_bounds = [Math.min(corner0[0], corner1[0]), Math.min(corner0[1], corner1[1]), Math.max(corner0[0], corner1[0]), Math.max(corner0[1], corner1[1])];\n    }\n  }]);\n\n  return ClipExtension;\n}(LayerExtension);\n\nexport { ClipExtension as default };\nClipExtension.extensionName = 'ClipExtension';\nClipExtension.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/mvt-layer/clip-extension.js"],"names":["defaultProps","clipBounds","shaderFunction","shaderModuleVs","name","vs","injectionVs","shaderModuleFs","fs","injectionFs","ClipExtension","LayerExtension","opts","hasAnchor","modules","inject","uniforms","corner0","corner1","Math"],"mappings":";;;;;AAoBA,SAAA,cAAA,QAAA,eAAA;AAEA,IAAMA,YAAY,GAAG;AACnBC,EAAAA,UAAU,EAAE,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA;AADO,CAArB;AAIA,IAAMC,cAAc,GAApB,iNAAA;AAYA,IAAMC,cAAc,GAAG;AACrBC,EAAAA,IAAI,EADiB,SAAA;AAErBC,EAAAA,EAAE,EAAEH;AAFiB,CAAvB;AAKA,IAAMI,WAAW,GAAG;AAClB,cADkB,mCAAA;AAIlB,kCAJkB,sEAAA;AAOlB,cAPkB,mCAAA;AAUlB,4BAAA;AAVkB,CAApB;AAmBA,IAAMC,cAAc,GAAG;AACrBH,EAAAA,IAAI,EADiB,SAAA;AAErBI,EAAAA,EAAE,EAAEN;AAFiB,CAAvB;AAKA,IAAMO,WAAW,GAAG;AAClB,cADkB,uCAAA;AAIlB,kCAJkB,mDAAA;AAOlB,cAPkB,uCAAA;AAUlB,4BAAA;AAVkB,CAApB;;IAeqBC,a;;;;;;;;;;;+BACRE,I,EAAM;AACf,UAAMC,SAAS,IAAG,uBAAuB,KAAA,mBAAA,GAAzC,UAAe,CAAf;AAEA,aAAOA,SAAS,GACZ;AACEC,QAAAA,OAAO,EAAE,CADX,cACW,CADX;AAEEC,QAAAA,MAAM,EAAET;AAFV,OADY,GAKZ;AACEQ,QAAAA,OAAO,EAAE,CADX,cACW,CADX;AAEEC,QAAAA,MAAM,EAAEN;AAFV,OALJ;AASD;;;+BAEgB;AAAA,UAAXO,QAAW,GAAA,IAAA,CAAXA,QAAW;AAAA,UAAA,qBAAA,GACgC,KADhC,KACgC,CADhC,UAAA;AAAA,UACRf,UADQ,GAAA,qBAAA,KAAA,KAAA,CAAA,GACKD,YAAY,CADjB,UAAA,GAAA,qBAAA;AAEf,UAAMiB,OAAO,GAAG,KAAA,eAAA,CAAqB,CAAChB,UAAU,CAAX,CAAW,CAAX,EAAgBA,UAAU,CAA1B,CAA0B,CAA1B,EAArC,CAAqC,CAArB,CAAhB;AACA,UAAMiB,OAAO,GAAG,KAAA,eAAA,CAAqB,CAACjB,UAAU,CAAX,CAAW,CAAX,EAAgBA,UAAU,CAA1B,CAA0B,CAA1B,EAArC,CAAqC,CAArB,CAAhB;AAEAe,MAAAA,QAAQ,CAARA,WAAAA,GAAuB,CACrBG,IAAI,CAAJA,GAAAA,CAASF,OAAO,CAAhBE,CAAgB,CAAhBA,EAAqBD,OAAO,CADP,CACO,CAA5BC,CADqB,EAErBA,IAAI,CAAJA,GAAAA,CAASF,OAAO,CAAhBE,CAAgB,CAAhBA,EAAqBD,OAAO,CAFP,CAEO,CAA5BC,CAFqB,EAGrBA,IAAI,CAAJA,GAAAA,CAASF,OAAO,CAAhBE,CAAgB,CAAhBA,EAAqBD,OAAO,CAHP,CAGO,CAA5BC,CAHqB,EAIrBA,IAAI,CAAJA,GAAAA,CAASF,OAAO,CAAhBE,CAAgB,CAAhBA,EAAqBD,OAAO,CAJ9BF,CAI8B,CAA5BG,CAJqB,CAAvBH;AAMD;;;;EA1BwCL,c;;SAAtBD,a;AA6BrBA,aAAa,CAAbA,aAAAA,GAAAA,eAAAA;AACAA,aAAa,CAAbA,YAAAA,GAAAA,YAAAA","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {LayerExtension} from '@deck.gl/core';\n\nconst defaultProps = {\n  clipBounds: [0, 0, 1, 1]\n};\n\nconst shaderFunction = `\nuniform vec4 clip_bounds;\n\nbool clip_isInBounds(vec2 position) {\n  return position.x >= clip_bounds[0] && position.y >= clip_bounds[1] && position.x < clip_bounds[2] && position.y < clip_bounds[3];\n}\n`;\n\n/*\n * The vertex-shader version clips geometries by their anchor position\n * e.g. ScatterplotLayer - show if the center of a circle is within bounds\n */\nconst shaderModuleVs = {\n  name: 'clip-vs',\n  vs: shaderFunction\n};\n\nconst injectionVs = {\n  'vs:#decl': `\nvarying float clip_isVisible;\n`,\n  'vs:DECKGL_FILTER_GL_POSITION': `\n  clip_isVisible = float(clip_isInBounds(geometry.position.xy));\n`,\n  'fs:#decl': `\nvarying float clip_isVisible;\n`,\n  'fs:DECKGL_FILTER_COLOR': `\n  if (clip_isVisible < 0.5) discard;\n`\n};\n\n/*\n * The fragment-shader version clips pixels at the bounds\n * e.g. PolygonLayer - show the part of the polygon that intersect with the bounds \n */\nconst shaderModuleFs = {\n  name: 'clip-fs',\n  fs: shaderFunction\n};\n\nconst injectionFs = {\n  'vs:#decl': `\nvarying vec2 clip_commonPosition;\n`,\n  'vs:DECKGL_FILTER_GL_POSITION': `\n  clip_commonPosition = geometry.position.xy;\n`,\n  'fs:#decl': `\nvarying vec2 clip_commonPosition;\n`,\n  'fs:DECKGL_FILTER_COLOR': `\n  if (!clip_isInBounds(clip_commonPosition)) discard;\n`\n};\n\nexport default class ClipExtension extends LayerExtension {\n  getShaders(opts) {\n    const hasAnchor = 'instancePositions' in this.getAttributeManager().attributes;\n\n    return hasAnchor\n      ? {\n          modules: [shaderModuleVs],\n          inject: injectionVs\n        }\n      : {\n          modules: [shaderModuleFs],\n          inject: injectionFs\n        };\n  }\n\n  draw({uniforms}) {\n    const {clipBounds = defaultProps.clipBounds} = this.props;\n    const corner0 = this.projectPosition([clipBounds[0], clipBounds[1], 0]);\n    const corner1 = this.projectPosition([clipBounds[2], clipBounds[3], 0]);\n\n    uniforms.clip_bounds = [\n      Math.min(corner0[0], corner1[0]),\n      Math.min(corner0[1], corner1[1]),\n      Math.max(corner0[0], corner1[0]),\n      Math.max(corner0[1], corner1[1])\n    ];\n  }\n}\n\nClipExtension.extensionName = 'ClipExtension';\nClipExtension.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}