{"ast":null,"code":"import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _construct from \"@babel/runtime/helpers/esm/construct\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport assert from './assert';\nvar RADIANS_TO_DEGREES = 1 / Math.PI * 180;\nvar DEGREES_TO_RADIANS = 1 / 180 * Math.PI;\nvar config = {};\nconfig.EPSILON = 1e-12;\nconfig.debug = false;\nconfig.precision = 4;\nconfig.printTypes = false;\nconfig.printDegrees = false;\nconfig.printRowMajor = true;\nexport { config };\nexport function configure() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  for (var key in options) {\n    assert(key in config);\n    config[key] = options[key];\n  }\n\n  return config;\n}\n\nfunction round(value) {\n  return Math.round(value / config.EPSILON) * config.EPSILON;\n}\n\nexport function formatValue(value) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$precision = _ref.precision,\n      precision = _ref$precision === void 0 ? config.precision || 4 : _ref$precision;\n\n  value = round(value);\n  return \"\".concat(parseFloat(value.toPrecision(precision)));\n}\nexport function isArray(value) {\n  return Array.isArray(value) || ArrayBuffer.isView(value) && value.length !== undefined;\n}\n\nfunction duplicateArray(array) {\n  return array.clone ? array.clone() : new Array(array.length);\n}\n\nexport function clone(array) {\n  return array.clone ? array.clone() : _construct(Array, _toConsumableArray(array));\n}\n\nfunction map(value, func, result) {\n  if (isArray(value)) {\n    result = result || duplicateArray(value);\n\n    for (var i = 0; i < result.length && i < value.length; ++i) {\n      result[i] = func(value[i], i, result);\n    }\n\n    return result;\n  }\n\n  return func(value);\n}\n\nexport function toRadians(degrees) {\n  return radians(degrees);\n}\nexport function toDegrees(radians) {\n  return degrees(radians);\n}\nexport function radians(degrees, result) {\n  return map(degrees, function (degrees) {\n    return degrees * DEGREES_TO_RADIANS;\n  }, result);\n}\nexport function degrees(radians, result) {\n  return map(radians, function (radians) {\n    return radians * RADIANS_TO_DEGREES;\n  }, result);\n}\nexport function sin(radians) {\n  return map(radians, function (angle) {\n    return Math.sin(angle);\n  });\n}\nexport function cos(radians) {\n  return map(radians, function (angle) {\n    return Math.cos(angle);\n  });\n}\nexport function tan(radians) {\n  return map(radians, function (angle) {\n    return Math.tan(angle);\n  });\n}\nexport function asin(radians) {\n  return map(radians, function (angle) {\n    return Math.asin(angle);\n  });\n}\nexport function acos(radians) {\n  return map(radians, function (angle) {\n    return Math.acos(angle);\n  });\n}\nexport function atan(radians) {\n  return map(radians, function (angle) {\n    return Math.atan(angle);\n  });\n}\nexport function clamp(value, min, max) {\n  return map(value, function (value) {\n    return Math.max(min, Math.min(max, value));\n  });\n}\nexport function lerp(a, b, t) {\n  if (isArray(a)) {\n    return a.map(function (ai, i) {\n      return lerp(ai, b[i], t);\n    });\n  }\n\n  return t * b + (1 - t) * a;\n}\nexport function equals(a, b, epsilon) {\n  var oldEpsilon = config.EPSILON;\n\n  if (epsilon) {\n    config.EPSILON = epsilon;\n  }\n\n  try {\n    if (a === b) {\n      return true;\n    }\n\n    if (isArray(a) && isArray(b)) {\n      if (a.length !== b.length) {\n        return false;\n      }\n\n      for (var i = 0; i < a.length; ++i) {\n        if (!equals(a[i], b[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    if (a && a.equals) {\n      return a.equals(b);\n    }\n\n    if (b && b.equals) {\n      return b.equals(a);\n    }\n\n    if (Number.isFinite(a) && Number.isFinite(b)) {\n      return Math.abs(a - b) <= config.EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n    }\n\n    return false;\n  } finally {\n    config.EPSILON = oldEpsilon;\n  }\n}\nexport function exactEquals(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (a && _typeof(a) === 'object' && b && _typeof(b) === 'object') {\n    if (a.constructor !== b.constructor) {\n      return false;\n    }\n\n    if (a.exactEquals) {\n      return a.exactEquals(b);\n    }\n  }\n\n  if (isArray(a) && isArray(b)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (var i = 0; i < a.length; ++i) {\n      if (!exactEquals(a[i], b[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\nexport function withEpsilon(EPSILON, func) {\n  var oldPrecision = config.EPSILON;\n  config.EPSILON = EPSILON;\n  var value;\n\n  try {\n    value = func();\n  } finally {\n    config.EPSILON = oldPrecision;\n  }\n\n  return value;\n}","map":{"version":3,"sources":["../../../src/lib/common.js"],"names":["RADIANS_TO_DEGREES","Math","DEGREES_TO_RADIANS","config","options","assert","key","value","precision","round","parseFloat","Array","ArrayBuffer","array","isArray","result","duplicateArray","i","func","radians","degrees","map","lerp","b","t","oldEpsilon","a","equals","Number","exactEquals","oldPrecision"],"mappings":"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","sourcesContent":["// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport assert from './assert';\n\nconst RADIANS_TO_DEGREES = (1 / Math.PI) * 180;\nconst DEGREES_TO_RADIANS = (1 / 180) * Math.PI;\n\n// TODO - remove\n/* eslint-disable no-shadow */\nconst config = {};\nconfig.EPSILON = 1e-12;\nconfig.debug = false;\nconfig.precision = 4;\nconfig.printTypes = false;\nconfig.printDegrees = false;\nconfig.printRowMajor = true;\n\nexport {config};\n\nexport function configure(options = {}) {\n  // Only copy existing keys\n  for (const key in options) {\n    assert(key in config);\n    config[key] = options[key];\n  }\n  return config;\n}\n\nfunction round(value) {\n  return Math.round(value / config.EPSILON) * config.EPSILON;\n}\n\nexport function formatValue(value, {precision = config.precision || 4} = {}) {\n  value = round(value);\n  // get rid of trailing zeros\n  return `${parseFloat(value.toPrecision(precision))}`;\n}\n\n// Returns true if value is either an array or a typed array\n// Note: does not return true for ArrayBuffers and DataViews\nexport function isArray(value) {\n  return Array.isArray(value) || (ArrayBuffer.isView(value) && value.length !== undefined);\n}\n\n// If the array has a clone function, calls it, otherwise returns a copy\nfunction duplicateArray(array) {\n  return array.clone ? array.clone() : new Array(array.length);\n}\n\nexport function clone(array) {\n  return array.clone ? array.clone() : new Array(...array);\n}\n\n// If the argument value is an array, applies the func element wise,\n// otherwise applies func to the argument value\nfunction map(value, func, result) {\n  if (isArray(value)) {\n    result = result || duplicateArray(value);\n    for (let i = 0; i < result.length && i < value.length; ++i) {\n      result[i] = func(value[i], i, result);\n    }\n    return result;\n  }\n  return func(value);\n}\n\nexport function toRadians(degrees) {\n  return radians(degrees);\n}\n\nexport function toDegrees(radians) {\n  return degrees(radians);\n}\n\n//\n// GLSL math function equivalents\n// Works on both single values and vectors\n//\n\nexport function radians(degrees, result) {\n  return map(degrees, degrees => degrees * DEGREES_TO_RADIANS, result);\n}\n\nexport function degrees(radians, result) {\n  return map(radians, radians => radians * RADIANS_TO_DEGREES, result);\n}\n\n// GLSL equivalent: Works on single values and vectors\nexport function sin(radians) {\n  return map(radians, angle => Math.sin(angle));\n}\n\n// GLSL equivalent: Works on single values and vectors\nexport function cos(radians) {\n  return map(radians, angle => Math.cos(angle));\n}\n\n// GLSL equivalent: Works on single values and vectors\nexport function tan(radians) {\n  return map(radians, angle => Math.tan(angle));\n}\n\n// GLSL equivalent: Works on single values and vectors\nexport function asin(radians) {\n  return map(radians, angle => Math.asin(angle));\n}\n\n// GLSL equivalent: Works on single values and vectors\nexport function acos(radians) {\n  return map(radians, angle => Math.acos(angle));\n}\n\n// GLSL equivalent: Works on single values and vectors\nexport function atan(radians) {\n  return map(radians, angle => Math.atan(angle));\n}\n\nexport function clamp(value, min, max) {\n  return map(value, value => Math.max(min, Math.min(max, value)));\n}\n\n// Interpolate between two numbers or two arrays\nexport function lerp(a, b, t) {\n  if (isArray(a)) {\n    return a.map((ai, i) => lerp(ai, b[i], t));\n  }\n  return t * b + (1 - t) * a;\n}\n\n// eslint-disable-next-line complexity\nexport function equals(a, b, epsilon) {\n  const oldEpsilon = config.EPSILON;\n  if (epsilon) {\n    config.EPSILON = epsilon;\n  }\n  try {\n    if (a === b) {\n      return true;\n    }\n    if (isArray(a) && isArray(b)) {\n      if (a.length !== b.length) {\n        return false;\n      }\n      for (let i = 0; i < a.length; ++i) {\n        // eslint-disable-next-line max-depth\n        if (!equals(a[i], b[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    if (a && a.equals) {\n      return a.equals(b);\n    }\n    if (b && b.equals) {\n      return b.equals(a);\n    }\n    if (Number.isFinite(a) && Number.isFinite(b)) {\n      return Math.abs(a - b) <= config.EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n    }\n    return false;\n  } finally {\n    config.EPSILON = oldEpsilon;\n  }\n}\n\n// eslint-disable-next-line complexity\nexport function exactEquals(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (a && typeof a === 'object' && b && typeof b === 'object') {\n    if (a.constructor !== b.constructor) {\n      return false;\n    }\n    if (a.exactEquals) {\n      return a.exactEquals(b);\n    }\n  }\n  if (isArray(a) && isArray(b)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (let i = 0; i < a.length; ++i) {\n      if (!exactEquals(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n}\n\nexport function withEpsilon(EPSILON, func) {\n  const oldPrecision = config.EPSILON;\n  config.EPSILON = EPSILON;\n  let value;\n  try {\n    value = func();\n  } finally {\n    config.EPSILON = oldPrecision;\n  }\n  return value;\n}\n"]},"metadata":{},"sourceType":"module"}