{"ast":null,"code":"import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nvar TYPE_DEFINITIONS = {\n  \"boolean\": {\n    validate: function validate(value, propType) {\n      return true;\n    },\n    equal: function equal(value1, value2, propType) {\n      return Boolean(value1) === Boolean(value2);\n    }\n  },\n  number: {\n    validate: function validate(value, propType) {\n      return Number.isFinite(value) && (!('max' in propType) || value <= propType.max) && (!('min' in propType) || value >= propType.min);\n    }\n  },\n  color: {\n    validate: function validate(value, propType) {\n      return propType.optional && !value || isArray(value) && (value.length === 3 || value.length === 4);\n    },\n    equal: function equal(value1, value2, propType) {\n      return arrayEqual(value1, value2);\n    }\n  },\n  accessor: {\n    validate: function validate(value, propType) {\n      var valueType = getTypeOf(value);\n      return valueType === 'function' || valueType === getTypeOf(propType.value);\n    },\n    equal: function equal(value1, value2, propType) {\n      if (typeof value2 === 'function') {\n        return true;\n      }\n\n      return arrayEqual(value1, value2);\n    }\n  },\n  array: {\n    validate: function validate(value, propType) {\n      return propType.optional && !value || isArray(value);\n    },\n    equal: function equal(value1, value2, propType) {\n      return propType.compare ? arrayEqual(value1, value2) : value1 === value2;\n    }\n  },\n  \"function\": {\n    validate: function validate(value, propType) {\n      return propType.optional && !value || typeof value === 'function';\n    },\n    equal: function equal(value1, value2, propType) {\n      return !propType.compare || value1 === value2;\n    }\n  }\n};\n\nfunction arrayEqual(array1, array2) {\n  if (array1 === array2) {\n    return true;\n  }\n\n  if (!isArray(array1) || !isArray(array2)) {\n    return false;\n  }\n\n  var len = array1.length;\n\n  if (len !== array2.length) {\n    return false;\n  }\n\n  for (var i = 0; i < len; i++) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function parsePropTypes(propDefs) {\n  var propTypes = {};\n  var defaultProps = {};\n  var deprecatedProps = {};\n\n  for (var _i = 0, _Object$entries = Object.entries(propDefs); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n        propName = _Object$entries$_i[0],\n        propDef = _Object$entries$_i[1];\n\n    if (propDef && propDef.deprecatedFor) {\n      deprecatedProps[propName] = Array.isArray(propDef.deprecatedFor) ? propDef.deprecatedFor : [propDef.deprecatedFor];\n    } else {\n      var propType = parsePropType(propName, propDef);\n      propTypes[propName] = propType;\n      defaultProps[propName] = propType.value;\n    }\n  }\n\n  return {\n    propTypes: propTypes,\n    defaultProps: defaultProps,\n    deprecatedProps: deprecatedProps\n  };\n}\n\nfunction parsePropType(name, propDef) {\n  switch (getTypeOf(propDef)) {\n    case 'object':\n      return normalizePropDefinition(name, propDef);\n\n    case 'array':\n      return normalizePropDefinition(name, {\n        type: 'array',\n        value: propDef,\n        compare: false\n      });\n\n    case 'boolean':\n      return normalizePropDefinition(name, {\n        type: 'boolean',\n        value: propDef\n      });\n\n    case 'number':\n      return normalizePropDefinition(name, {\n        type: 'number',\n        value: propDef\n      });\n\n    case 'function':\n      return normalizePropDefinition(name, {\n        type: 'function',\n        value: propDef,\n        compare: true\n      });\n\n    default:\n      return {\n        name: name,\n        type: 'unknown',\n        value: propDef\n      };\n  }\n}\n\nfunction normalizePropDefinition(name, propDef) {\n  if (!('type' in propDef)) {\n    if (!('value' in propDef)) {\n      return {\n        name: name,\n        type: 'object',\n        value: propDef\n      };\n    }\n\n    return Object.assign({\n      name: name,\n      type: getTypeOf(propDef.value)\n    }, propDef);\n  }\n\n  return Object.assign({\n    name: name\n  }, TYPE_DEFINITIONS[propDef.type], propDef);\n}\n\nfunction isArray(value) {\n  return Array.isArray(value) || ArrayBuffer.isView(value);\n}\n\nfunction getTypeOf(value) {\n  if (isArray(value)) {\n    return 'array';\n  }\n\n  if (value === null) {\n    return 'null';\n  }\n\n  return _typeof(value);\n}","map":{"version":3,"sources":["../../../src/lifecycle/prop-types.js"],"names":["TYPE_DEFINITIONS","validate","equal","Boolean","number","Number","value","propType","color","isArray","arrayEqual","accessor","valueType","getTypeOf","array","value1","array1","len","array2","i","propTypes","defaultProps","deprecatedProps","propName","propDef","Object","Array","parsePropType","normalizePropDefinition","type","compare","name","ArrayBuffer"],"mappings":"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","sourcesContent":["const TYPE_DEFINITIONS = {\n  boolean: {\n    validate(value, propType) {\n      return true;\n    },\n    equal(value1, value2, propType) {\n      return Boolean(value1) === Boolean(value2);\n    }\n  },\n  number: {\n    validate(value, propType) {\n      return (\n        Number.isFinite(value) &&\n        (!('max' in propType) || value <= propType.max) &&\n        (!('min' in propType) || value >= propType.min)\n      );\n    }\n  },\n  color: {\n    validate(value, propType) {\n      return (\n        (propType.optional && !value) ||\n        (isArray(value) && (value.length === 3 || value.length === 4))\n      );\n    },\n    equal(value1, value2, propType) {\n      return arrayEqual(value1, value2);\n    }\n  },\n  accessor: {\n    validate(value, propType) {\n      const valueType = getTypeOf(value);\n      return valueType === 'function' || valueType === getTypeOf(propType.value);\n    },\n    equal(value1, value2, propType) {\n      if (typeof value2 === 'function') {\n        return true;\n      }\n      return arrayEqual(value1, value2);\n    }\n  },\n  array: {\n    validate(value, propType) {\n      return (propType.optional && !value) || isArray(value);\n    },\n    equal(value1, value2, propType) {\n      return propType.compare ? arrayEqual(value1, value2) : value1 === value2;\n    }\n  },\n  function: {\n    validate(value, propType) {\n      return (propType.optional && !value) || typeof value === 'function';\n    },\n    equal(value1, value2, propType) {\n      return !propType.compare || value1 === value2;\n    }\n  }\n};\n\nfunction arrayEqual(array1, array2) {\n  if (array1 === array2) {\n    return true;\n  }\n  if (!isArray(array1) || !isArray(array2)) {\n    return false;\n  }\n  const len = array1.length;\n  if (len !== array2.length) {\n    return false;\n  }\n  for (let i = 0; i < len; i++) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function parsePropTypes(propDefs) {\n  const propTypes = {};\n  const defaultProps = {};\n  const deprecatedProps = {};\n\n  for (const [propName, propDef] of Object.entries(propDefs)) {\n    if (propDef && propDef.deprecatedFor) {\n      deprecatedProps[propName] = Array.isArray(propDef.deprecatedFor)\n        ? propDef.deprecatedFor\n        : [propDef.deprecatedFor];\n    } else {\n      const propType = parsePropType(propName, propDef);\n      propTypes[propName] = propType;\n      defaultProps[propName] = propType.value;\n    }\n  }\n  return {propTypes, defaultProps, deprecatedProps};\n}\n\n// Parses one property definition entry. Either contains:\n// * a valid prop type object ({type, ...})\n// * or just a default value, in which case type and name inference is used\nfunction parsePropType(name, propDef) {\n  switch (getTypeOf(propDef)) {\n    case 'object':\n      return normalizePropDefinition(name, propDef);\n\n    case 'array':\n      return normalizePropDefinition(name, {type: 'array', value: propDef, compare: false});\n\n    case 'boolean':\n      return normalizePropDefinition(name, {type: 'boolean', value: propDef});\n\n    case 'number':\n      return normalizePropDefinition(name, {type: 'number', value: propDef});\n\n    case 'function':\n      return normalizePropDefinition(name, {type: 'function', value: propDef, compare: true});\n    // return guessFunctionType(name, propDef);\n\n    default:\n      return {name, type: 'unknown', value: propDef};\n  }\n}\n\nfunction normalizePropDefinition(name, propDef) {\n  if (!('type' in propDef)) {\n    if (!('value' in propDef)) {\n      // If no type and value this object is likely the value\n      return {name, type: 'object', value: propDef};\n    }\n    return Object.assign({name, type: getTypeOf(propDef.value)}, propDef);\n  }\n  return Object.assign({name}, TYPE_DEFINITIONS[propDef.type], propDef);\n}\n\nfunction isArray(value) {\n  return Array.isArray(value) || ArrayBuffer.isView(value);\n}\n\n// improved version of javascript typeof that can distinguish arrays and null values\nfunction getTypeOf(value) {\n  if (isArray(value)) {\n    return 'array';\n  }\n  if (value === null) {\n    return 'null';\n  }\n  return typeof value;\n}\n"]},"metadata":{},"sourceType":"module"}