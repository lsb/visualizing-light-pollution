{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { DictionaryVector } from '../vector/dictionary';\n/** @ignore */\n\nexport class Value {\n  eq(other) {\n    if (!(other instanceof Value)) {\n      other = new Literal(other);\n    }\n\n    return new Equals(this, other);\n  }\n\n  le(other) {\n    if (!(other instanceof Value)) {\n      other = new Literal(other);\n    }\n\n    return new LTeq(this, other);\n  }\n\n  ge(other) {\n    if (!(other instanceof Value)) {\n      other = new Literal(other);\n    }\n\n    return new GTeq(this, other);\n  }\n\n  lt(other) {\n    return new Not(this.ge(other));\n  }\n\n  gt(other) {\n    return new Not(this.le(other));\n  }\n\n  ne(other) {\n    return new Not(this.eq(other));\n  }\n\n}\n/** @ignore */\n\nexport class Literal extends Value {\n  constructor(v) {\n    super();\n    this.v = v;\n  }\n\n}\n/** @ignore */\n\nexport class Col extends Value {\n  constructor(name) {\n    super();\n    this.name = name;\n  }\n\n  bind(batch) {\n    if (!this.colidx) {\n      // Assume column index doesn't change between calls to bind\n      //this.colidx = cols.findIndex(v => v.name.indexOf(this.name) != -1);\n      this.colidx = -1;\n      const fields = batch.schema.fields;\n\n      for (let idx = -1; ++idx < fields.length;) {\n        if (fields[idx].name === this.name) {\n          this.colidx = idx;\n          break;\n        }\n      }\n\n      if (this.colidx < 0) {\n        throw new Error(`Failed to bind Col \"${this.name}\"`);\n      }\n    }\n\n    const vec = this.vector = batch.getChildAt(this.colidx);\n    return idx => vec.get(idx);\n  }\n\n}\n/** @ignore */\n\nexport class Predicate {\n  and(...expr) {\n    return new And(this, ...expr);\n  }\n\n  or(...expr) {\n    return new Or(this, ...expr);\n  }\n\n  not() {\n    return new Not(this);\n  }\n\n}\n/** @ignore */\n\nexport class ComparisonPredicate extends Predicate {\n  constructor(left, right) {\n    super();\n    this.left = left;\n    this.right = right;\n  }\n\n  bind(batch) {\n    if (this.left instanceof Literal) {\n      if (this.right instanceof Literal) {\n        return this._bindLitLit(batch, this.left, this.right);\n      } else {\n        // right is a Col\n        return this._bindLitCol(batch, this.left, this.right);\n      }\n    } else {\n      // left is a Col\n      if (this.right instanceof Literal) {\n        return this._bindColLit(batch, this.left, this.right);\n      } else {\n        // right is a Col\n        return this._bindColCol(batch, this.left, this.right);\n      }\n    }\n  }\n\n}\n/** @ignore */\n\nexport class CombinationPredicate extends Predicate {\n  constructor(...children) {\n    super();\n    this.children = children;\n  }\n\n} // add children to prototype so it doesn't get mangled in es2015/umd\n\nCombinationPredicate.prototype.children = Object.freeze([]); // freeze for safety\n\n/** @ignore */\n\nexport class And extends CombinationPredicate {\n  constructor(...children) {\n    // Flatten any Ands\n    children = children.reduce((accum, p) => {\n      return accum.concat(p instanceof And ? p.children : p);\n    }, []);\n    super(...children);\n  }\n\n  bind(batch) {\n    const bound = this.children.map(p => p.bind(batch));\n    return (idx, batch) => bound.every(p => p(idx, batch));\n  }\n\n}\n/** @ignore */\n\nexport class Or extends CombinationPredicate {\n  constructor(...children) {\n    // Flatten any Ors\n    children = children.reduce((accum, p) => {\n      return accum.concat(p instanceof Or ? p.children : p);\n    }, []);\n    super(...children);\n  }\n\n  bind(batch) {\n    const bound = this.children.map(p => p.bind(batch));\n    return (idx, batch) => bound.some(p => p(idx, batch));\n  }\n\n}\n/** @ignore */\n\nexport class Equals extends ComparisonPredicate {\n  _bindLitLit(_batch, left, right) {\n    const rtrn = left.v == right.v;\n    return () => rtrn;\n  }\n\n  _bindColCol(batch, left, right) {\n    const left_func = left.bind(batch);\n    const right_func = right.bind(batch);\n    return (idx, batch) => left_func(idx, batch) == right_func(idx, batch);\n  }\n\n  _bindColLit(batch, col, lit) {\n    const col_func = col.bind(batch);\n\n    if (col.vector instanceof DictionaryVector) {\n      let key;\n      const vector = col.vector;\n\n      if (vector.dictionary !== this.lastDictionary) {\n        key = vector.reverseLookup(lit.v);\n        this.lastDictionary = vector.dictionary;\n        this.lastKey = key;\n      } else {\n        key = this.lastKey;\n      }\n\n      if (key === -1) {\n        // the value doesn't exist in the dictionary - always return\n        // false\n        // TODO: special-case of PredicateFunc that encapsulates this\n        // \"always false\" behavior. That way filtering operations don't\n        // have to bother checking\n        return () => false;\n      } else {\n        return idx => {\n          return vector.getKey(idx) === key;\n        };\n      }\n    } else {\n      return (idx, cols) => col_func(idx, cols) == lit.v;\n    }\n  }\n\n  _bindLitCol(batch, lit, col) {\n    // Equals is commutative\n    return this._bindColLit(batch, col, lit);\n  }\n\n}\n/** @ignore */\n\nexport class LTeq extends ComparisonPredicate {\n  _bindLitLit(_batch, left, right) {\n    const rtrn = left.v <= right.v;\n    return () => rtrn;\n  }\n\n  _bindColCol(batch, left, right) {\n    const left_func = left.bind(batch);\n    const right_func = right.bind(batch);\n    return (idx, cols) => left_func(idx, cols) <= right_func(idx, cols);\n  }\n\n  _bindColLit(batch, col, lit) {\n    const col_func = col.bind(batch);\n    return (idx, cols) => col_func(idx, cols) <= lit.v;\n  }\n\n  _bindLitCol(batch, lit, col) {\n    const col_func = col.bind(batch);\n    return (idx, cols) => lit.v <= col_func(idx, cols);\n  }\n\n}\n/** @ignore */\n\nexport class GTeq extends ComparisonPredicate {\n  _bindLitLit(_batch, left, right) {\n    const rtrn = left.v >= right.v;\n    return () => rtrn;\n  }\n\n  _bindColCol(batch, left, right) {\n    const left_func = left.bind(batch);\n    const right_func = right.bind(batch);\n    return (idx, cols) => left_func(idx, cols) >= right_func(idx, cols);\n  }\n\n  _bindColLit(batch, col, lit) {\n    const col_func = col.bind(batch);\n    return (idx, cols) => col_func(idx, cols) >= lit.v;\n  }\n\n  _bindLitCol(batch, lit, col) {\n    const col_func = col.bind(batch);\n    return (idx, cols) => lit.v >= col_func(idx, cols);\n  }\n\n}\n/** @ignore */\n\nexport class Not extends Predicate {\n  constructor(child) {\n    super();\n    this.child = child;\n  }\n\n  bind(batch) {\n    const func = this.child.bind(batch);\n    return (idx, batch) => !func(idx, batch);\n  }\n\n}\n/** @ignore */\n\nexport class CustomPredicate extends Predicate {\n  constructor(next, bind_) {\n    super();\n    this.next = next;\n    this.bind_ = bind_;\n  }\n\n  bind(batch) {\n    this.bind_(batch);\n    return this.next;\n  }\n\n}\nexport function lit(v) {\n  return new Literal(v);\n}\nexport function col(n) {\n  return new Col(n);\n}\nexport function and(...p) {\n  return new And(...p);\n}\nexport function or(...p) {\n  return new Or(...p);\n}\nexport function custom(next, bind) {\n  return new CustomPredicate(next, bind);\n}","map":{"version":3,"sources":["compute/predicate.ts"],"names":[],"mappings":"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","sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Vector } from '../vector';\nimport { RecordBatch } from '../recordbatch';\nimport { DictionaryVector } from '../vector/dictionary';\n\n/** @ignore */\nexport type ValueFunc<T> = (idx: number, cols: RecordBatch) => T | null;\n/** @ignore */\nexport type PredicateFunc = (idx: number, cols: RecordBatch) => boolean;\n\n/** @ignore */\nexport abstract class Value<T> {\n    eq(other: Value<T> | T): Predicate {\n        if (!(other instanceof Value)) { other = new Literal(other); }\n        return new Equals(this, other);\n    }\n    le(other: Value<T> | T): Predicate {\n        if (!(other instanceof Value)) { other = new Literal(other); }\n        return new LTeq(this, other);\n    }\n    ge(other: Value<T> | T): Predicate {\n        if (!(other instanceof Value)) { other = new Literal(other); }\n        return new GTeq(this, other);\n    }\n    lt(other: Value<T> | T): Predicate {\n        return new Not(this.ge(other));\n    }\n    gt(other: Value<T> | T): Predicate {\n        return new Not(this.le(other));\n    }\n    ne(other: Value<T> | T): Predicate {\n        return new Not(this.eq(other));\n    }\n}\n\n/** @ignore */\nexport class Literal<T= any> extends Value<T> {\n    constructor(public v: T) { super(); }\n}\n\n/** @ignore */\nexport class Col<T= any> extends Value<T> {\n    // @ts-ignore\n    public vector: Vector;\n    // @ts-ignore\n    public colidx: number;\n\n    constructor(public name: string) { super(); }\n    bind(batch: RecordBatch): (idx: number, batch?: RecordBatch) => any {\n        if (!this.colidx) {\n            // Assume column index doesn't change between calls to bind\n            //this.colidx = cols.findIndex(v => v.name.indexOf(this.name) != -1);\n            this.colidx = -1;\n            const fields = batch.schema.fields;\n            for (let idx = -1; ++idx < fields.length;) {\n                if (fields[idx].name === this.name) {\n                    this.colidx = idx;\n                    break;\n                }\n            }\n            if (this.colidx < 0) { throw new Error(`Failed to bind Col \"${this.name}\"`); }\n        }\n\n        const vec = this.vector = batch.getChildAt(this.colidx)!;\n        return (idx: number) => vec.get(idx);\n    }\n}\n\n/** @ignore */\nexport abstract class Predicate {\n    abstract bind(batch: RecordBatch): PredicateFunc;\n    and(...expr: Predicate[]): And { return new And(this, ...expr); }\n    or(...expr: Predicate[]): Or { return new Or(this, ...expr); }\n    not(): Predicate { return new Not(this); }\n}\n\n/** @ignore */\nexport abstract class ComparisonPredicate<T= any> extends Predicate {\n    constructor(public readonly left: Value<T>, public readonly right: Value<T>) {\n        super();\n    }\n\n    bind(batch: RecordBatch) {\n        if (this.left instanceof Literal) {\n            if (this.right instanceof Literal) {\n                return this._bindLitLit(batch, this.left, this.right);\n            } else { // right is a Col\n\n                return this._bindLitCol(batch, this.left, this.right as Col);\n            }\n        } else { // left is a Col\n            if (this.right instanceof Literal) {\n                return this._bindColLit(batch, this.left as Col, this.right);\n            } else { // right is a Col\n                return this._bindColCol(batch, this.left as Col, this.right as Col);\n            }\n        }\n    }\n\n    protected abstract _bindLitLit(batch: RecordBatch, left: Literal, right: Literal): PredicateFunc;\n    protected abstract _bindColCol(batch: RecordBatch, left: Col, right: Col): PredicateFunc;\n    protected abstract _bindColLit(batch: RecordBatch, col: Col, lit: Literal): PredicateFunc;\n    protected abstract _bindLitCol(batch: RecordBatch, lit: Literal, col: Col): PredicateFunc;\n}\n\n/** @ignore */\nexport abstract class CombinationPredicate extends Predicate {\n    readonly children: Predicate[];\n    constructor(...children: Predicate[]) {\n        super();\n        this.children = children;\n    }\n}\n// add children to prototype so it doesn't get mangled in es2015/umd\n(<any> CombinationPredicate.prototype).children = Object.freeze([]); // freeze for safety\n\n/** @ignore */\nexport class And extends CombinationPredicate {\n    constructor(...children: Predicate[]) {\n        // Flatten any Ands\n        children = children.reduce((accum: Predicate[], p: Predicate): Predicate[] => {\n            return accum.concat(p instanceof And ? p.children : p);\n        }, []);\n        super(...children);\n    }\n    bind(batch: RecordBatch) {\n        const bound = this.children.map((p) => p.bind(batch));\n        return (idx: number, batch: RecordBatch) => bound.every((p) => p(idx, batch));\n    }\n}\n\n/** @ignore */\nexport class Or extends CombinationPredicate {\n    constructor(...children: Predicate[]) {\n        // Flatten any Ors\n        children = children.reduce((accum: Predicate[], p: Predicate): Predicate[] => {\n            return accum.concat(p instanceof Or ? p.children : p);\n        }, []);\n        super(...children);\n    }\n    bind(batch: RecordBatch) {\n        const bound = this.children.map((p) => p.bind(batch));\n        return (idx: number, batch: RecordBatch) => bound.some((p) => p(idx, batch));\n    }\n}\n\n/** @ignore */\nexport class Equals extends ComparisonPredicate {\n    // Helpers used to cache dictionary reverse lookups between calls to bind\n    private lastDictionary: Vector|undefined;\n    private lastKey: number|undefined;\n\n    protected _bindLitLit(_batch: RecordBatch, left: Literal, right: Literal): PredicateFunc {\n        const rtrn: boolean = left.v == right.v;\n        return () => rtrn;\n    }\n\n    protected _bindColCol(batch: RecordBatch, left: Col, right: Col): PredicateFunc {\n        const left_func = left.bind(batch);\n        const right_func = right.bind(batch);\n        return (idx: number, batch: RecordBatch) => left_func(idx, batch) == right_func(idx, batch);\n    }\n\n    protected _bindColLit(batch: RecordBatch, col: Col, lit: Literal): PredicateFunc {\n        const col_func = col.bind(batch);\n        if (col.vector instanceof DictionaryVector) {\n            let key: any;\n            const vector = col.vector as DictionaryVector;\n            if (vector.dictionary !== this.lastDictionary) {\n                key = vector.reverseLookup(lit.v);\n                this.lastDictionary = vector.dictionary;\n                this.lastKey = key;\n            } else {\n                key = this.lastKey;\n            }\n\n            if (key === -1) {\n                // the value doesn't exist in the dictionary - always return\n                // false\n                // TODO: special-case of PredicateFunc that encapsulates this\n                // \"always false\" behavior. That way filtering operations don't\n                // have to bother checking\n                return () => false;\n            } else {\n                return (idx: number) => {\n                    return vector.getKey(idx) === key;\n                };\n            }\n        } else {\n            return (idx: number, cols: RecordBatch) => col_func(idx, cols) == lit.v;\n        }\n    }\n\n    protected _bindLitCol(batch: RecordBatch, lit: Literal, col: Col) {\n        // Equals is commutative\n        return this._bindColLit(batch, col, lit);\n    }\n}\n\n/** @ignore */\nexport class LTeq extends ComparisonPredicate {\n    protected _bindLitLit(_batch: RecordBatch, left: Literal, right: Literal): PredicateFunc {\n        const rtrn: boolean = left.v <= right.v;\n        return () => rtrn;\n    }\n\n    protected _bindColCol(batch: RecordBatch, left: Col, right: Col): PredicateFunc {\n        const left_func = left.bind(batch);\n        const right_func = right.bind(batch);\n        return (idx: number, cols: RecordBatch) => left_func(idx, cols) <= right_func(idx, cols);\n    }\n\n    protected _bindColLit(batch: RecordBatch, col: Col, lit: Literal): PredicateFunc {\n        const col_func = col.bind(batch);\n        return (idx: number, cols: RecordBatch) => col_func(idx, cols) <= lit.v;\n    }\n\n    protected _bindLitCol(batch: RecordBatch, lit: Literal, col: Col) {\n        const col_func = col.bind(batch);\n        return (idx: number, cols: RecordBatch) => lit.v <= col_func(idx, cols);\n    }\n}\n\n/** @ignore */\nexport class GTeq extends ComparisonPredicate {\n    protected _bindLitLit(_batch: RecordBatch, left: Literal, right: Literal): PredicateFunc {\n        const rtrn: boolean = left.v >= right.v;\n        return () => rtrn;\n    }\n\n    protected _bindColCol(batch: RecordBatch, left: Col, right: Col): PredicateFunc {\n        const left_func = left.bind(batch);\n        const right_func = right.bind(batch);\n        return (idx: number, cols: RecordBatch) => left_func(idx, cols) >= right_func(idx, cols);\n    }\n\n    protected _bindColLit(batch: RecordBatch, col: Col, lit: Literal): PredicateFunc {\n        const col_func = col.bind(batch);\n        return (idx: number, cols: RecordBatch) => col_func(idx, cols) >= lit.v;\n    }\n\n    protected _bindLitCol(batch: RecordBatch, lit: Literal, col: Col) {\n        const col_func = col.bind(batch);\n        return (idx: number, cols: RecordBatch) => lit.v >= col_func(idx, cols);\n    }\n}\n\n/** @ignore */\nexport class Not extends Predicate {\n    constructor(public readonly child: Predicate) {\n        super();\n    }\n\n    bind(batch: RecordBatch) {\n        const func = this.child.bind(batch);\n        return (idx: number, batch: RecordBatch) => !func(idx, batch);\n    }\n}\n\n/** @ignore */\nexport class CustomPredicate extends Predicate {\n    constructor(private next: PredicateFunc, private bind_: (batch: RecordBatch) => void) {\n        super();\n    }\n\n    bind(batch: RecordBatch) {\n        this.bind_(batch);\n        return this.next;\n    }\n}\n\nexport function lit(v: any): Value<any> { return new Literal(v); }\nexport function col(n: string): Col<any> { return new Col(n); }\nexport function and(...p: Predicate[]): And { return new And(...p); }\nexport function or(...p: Predicate[]): Or { return new Or(...p); }\nexport function custom(next: PredicateFunc, bind: (batch: RecordBatch) => void) {\n    return new CustomPredicate(next, bind);\n}\n"]},"metadata":{},"sourceType":"module"}