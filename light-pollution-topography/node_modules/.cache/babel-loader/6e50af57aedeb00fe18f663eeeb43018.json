{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { Vector3 } from '@math.gl/core';\nimport { Geometry } from '@luma.gl/core';\nimport { COORDINATE_SYSTEM, CompositeLayer } from '@deck.gl/core';\nimport { PointCloudLayer } from '@deck.gl/layers';\nimport { ScenegraphLayer, SimpleMeshLayer } from '@deck.gl/mesh-layers';\nimport { log } from '@deck.gl/core';\nimport { load } from '@loaders.gl/core';\nimport { Tileset3D, TILE_TYPE } from '@loaders.gl/tiles';\nimport { Tiles3DLoader } from '@loaders.gl/3d-tiles';\nvar scratchOffset = new Vector3();\nvar defaultProps = {\n  getPointColor: [0, 0, 0],\n  pointSize: 1.0,\n  data: null,\n  loadOptions: {},\n  loader: Tiles3DLoader,\n  onTilesetLoad: function onTilesetLoad(tileset3d) {},\n  onTileLoad: function onTileLoad(tileHeader) {},\n  onTileUnload: function onTileUnload(tileHeader) {},\n  onTileError: function onTileError(tile, message, url) {}\n};\n\nvar Tile3DLayer = function (_CompositeLayer) {\n  _inherits(Tile3DLayer, _CompositeLayer);\n\n  function Tile3DLayer() {\n    _classCallCheck(this, Tile3DLayer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Tile3DLayer).apply(this, arguments));\n  }\n\n  _createClass(Tile3DLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      if ('onTileLoadFail' in this.props) {\n        log.removed('onTileLoadFail', 'onTileError')();\n      }\n\n      this.state = {\n        layerMap: {},\n        tileset3d: null\n      };\n    }\n  }, {\n    key: \"shouldUpdateState\",\n    value: function shouldUpdateState(_ref) {\n      var changeFlags = _ref.changeFlags;\n      return changeFlags.somethingChanged;\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref2) {\n      var props = _ref2.props,\n          oldProps = _ref2.oldProps,\n          changeFlags = _ref2.changeFlags;\n\n      if (props.data && props.data !== oldProps.data) {\n        this._loadTileset(props.data);\n      }\n\n      if (changeFlags.viewportChanged) {\n        var tileset3d = this.state.tileset3d;\n\n        this._updateTileset(tileset3d);\n      }\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref3) {\n      var info = _ref3.info,\n          sourceLayer = _ref3.sourceLayer;\n      var layerMap = this.state.layerMap;\n      var layerId = sourceLayer && sourceLayer.id;\n\n      if (layerId) {\n        var substr = layerId.substring(this.id.length + 1);\n        var tileId = substr.substring(substr.indexOf('-') + 1);\n        info.object = layerMap[tileId] && layerMap[tileId].tile;\n      }\n\n      return info;\n    }\n  }, {\n    key: \"_loadTileset\",\n    value: function () {\n      var _loadTileset2 = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(tilesetUrl) {\n        var _this$props, loader, loadOptions, options, preloadOptions, tilesetJson, tileset3d;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _this$props = this.props, loader = _this$props.loader, loadOptions = _this$props.loadOptions;\n                options = _objectSpread({}, loadOptions);\n\n                if (!loader.preload) {\n                  _context.next = 7;\n                  break;\n                }\n\n                _context.next = 5;\n                return loader.preload(tilesetUrl, loadOptions);\n\n              case 5:\n                preloadOptions = _context.sent;\n                Object.assign(options, preloadOptions);\n\n              case 7:\n                _context.next = 9;\n                return load(tilesetUrl, loader, options);\n\n              case 9:\n                tilesetJson = _context.sent;\n                tileset3d = new Tileset3D(tilesetJson, _objectSpread({\n                  onTileLoad: this._onTileLoad.bind(this),\n                  onTileUnload: this._onTileUnload.bind(this),\n                  onTileLoadFail: this.props.onTileError\n                }, options));\n                this.setState({\n                  tileset3d: tileset3d,\n                  layerMap: {}\n                });\n\n                this._updateTileset(tileset3d);\n\n                this.props.onTilesetLoad(tileset3d);\n\n              case 14:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _loadTileset(_x) {\n        return _loadTileset2.apply(this, arguments);\n      }\n\n      return _loadTileset;\n    }()\n  }, {\n    key: \"_onTileLoad\",\n    value: function _onTileLoad(tileHeader) {\n      this.props.onTileLoad(tileHeader);\n\n      this._updateTileset(this.state.tileset3d);\n\n      this.setNeedsUpdate();\n    }\n  }, {\n    key: \"_onTileUnload\",\n    value: function _onTileUnload(tileHeader) {\n      delete this.state.layerMap[tileHeader.id];\n      this.props.onTileUnload(tileHeader);\n    }\n  }, {\n    key: \"_updateTileset\",\n    value: function _updateTileset(tileset3d) {\n      var _this$context = this.context,\n          timeline = _this$context.timeline,\n          viewport = _this$context.viewport;\n\n      if (!timeline || !viewport || !tileset3d) {\n        return;\n      }\n\n      var frameNumber = tileset3d.update(viewport);\n      var tilesetChanged = this.state.frameNumber !== frameNumber;\n\n      if (tilesetChanged) {\n        this.setState({\n          frameNumber: frameNumber\n        });\n      }\n    }\n  }, {\n    key: \"_create3DTileLayer\",\n    value: function _create3DTileLayer(tileHeader) {\n      if (!tileHeader.content) {\n        return null;\n      }\n\n      switch (tileHeader.type) {\n        case TILE_TYPE.POINTCLOUD:\n          return this._createPointCloudTileLayer(tileHeader);\n\n        case TILE_TYPE.SCENEGRAPH:\n          return this._create3DModelTileLayer(tileHeader);\n\n        case TILE_TYPE.MESH:\n          return this._createSimpleMeshLayer(tileHeader);\n\n        default:\n          throw new Error(\"Tile3DLayer: Failed to render layer of type \".concat(tileHeader.content.type));\n      }\n    }\n  }, {\n    key: \"_createPointCloudTileLayer\",\n    value: function _createPointCloudTileLayer(tileHeader) {\n      var _tileHeader$content = tileHeader.content,\n          attributes = _tileHeader$content.attributes,\n          pointCount = _tileHeader$content.pointCount,\n          constantRGBA = _tileHeader$content.constantRGBA,\n          cartographicOrigin = _tileHeader$content.cartographicOrigin,\n          modelMatrix = _tileHeader$content.modelMatrix;\n      var positions = attributes.positions,\n          normals = attributes.normals,\n          colors = attributes.colors;\n\n      if (!positions) {\n        return null;\n      }\n\n      var _this$props2 = this.props,\n          pointSize = _this$props2.pointSize,\n          getPointColor = _this$props2.getPointColor;\n      var SubLayerClass = this.getSubLayerClass('pointcloud', PointCloudLayer);\n      return new SubLayerClass({\n        pointSize: pointSize\n      }, this.getSubLayerProps({\n        id: 'pointcloud'\n      }), {\n        id: \"\".concat(this.id, \"-pointcloud-\").concat(tileHeader.id),\n        data: {\n          header: {\n            vertexCount: pointCount\n          },\n          attributes: {\n            POSITION: positions,\n            NORMAL: normals,\n            COLOR_0: colors\n          }\n        },\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        coordinateOrigin: cartographicOrigin,\n        modelMatrix: modelMatrix,\n        getColor: constantRGBA || getPointColor\n      });\n    }\n  }, {\n    key: \"_create3DModelTileLayer\",\n    value: function _create3DModelTileLayer(tileHeader) {\n      var _tileHeader$content2 = tileHeader.content,\n          gltf = _tileHeader$content2.gltf,\n          instances = _tileHeader$content2.instances,\n          cartographicOrigin = _tileHeader$content2.cartographicOrigin,\n          modelMatrix = _tileHeader$content2.modelMatrix;\n      var SubLayerClass = this.getSubLayerClass('scenegraph', ScenegraphLayer);\n      return new SubLayerClass({\n        _lighting: 'pbr'\n      }, this.getSubLayerProps({\n        id: 'scenegraph'\n      }), {\n        id: \"\".concat(this.id, \"-scenegraph-\").concat(tileHeader.id),\n        data: instances || [{}],\n        scenegraph: gltf,\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        coordinateOrigin: cartographicOrigin,\n        modelMatrix: modelMatrix,\n        getTransformMatrix: function getTransformMatrix(instance) {\n          return instance.modelMatrix;\n        },\n        getPosition: function getPosition(instance) {\n          return [0, 0, 0];\n        }\n      });\n    }\n  }, {\n    key: \"_createSimpleMeshLayer\",\n    value: function _createSimpleMeshLayer(tileHeader) {\n      var content = tileHeader.content;\n      var attributes = content.attributes,\n          modelMatrix = content.modelMatrix,\n          cartographicOrigin = content.cartographicOrigin,\n          texture = content.texture;\n      var normals = attributes.normals,\n          texCoords = attributes.texCoords;\n      var positions = new Float32Array(attributes.positions.value.length);\n\n      for (var i = 0; i < positions.length; i += 3) {\n        scratchOffset.copy(attributes.positions.value.subarray(i, i + 3));\n        positions.set(scratchOffset, i);\n      }\n\n      var geometry = new Geometry({\n        drawMode: 4,\n        attributes: {\n          positions: positions,\n          normals: normals,\n          texCoords: texCoords\n        }\n      });\n      var SubLayerClass = this.getSubLayerClass('mesh', SimpleMeshLayer);\n      return new SubLayerClass(this.getSubLayerProps({\n        id: 'mesh'\n      }), {\n        id: \"\".concat(this.id, \"-mesh-\").concat(tileHeader.id),\n        mesh: geometry,\n        data: [{}],\n        getPosition: [0, 0, 0],\n        getColor: [255, 255, 255],\n        texture: texture,\n        modelMatrix: modelMatrix,\n        coordinateOrigin: cartographicOrigin,\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS\n      });\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      var _this = this;\n\n      var _this$state = this.state,\n          tileset3d = _this$state.tileset3d,\n          layerMap = _this$state.layerMap;\n\n      if (!tileset3d) {\n        return null;\n      }\n\n      return tileset3d.tiles.map(function (tile) {\n        var layer = layerMap[tile.id] && layerMap[tile.id].layer;\n\n        if (tile.selected) {\n          if (!layer) {\n            layer = _this._create3DTileLayer(tile);\n            layerMap[tile.id] = {\n              layer: layer,\n              tile: tile\n            };\n          }\n\n          if (layer && layer.props && !layer.props.visible) {\n            layer = layer.clone({\n              visible: true\n            });\n            layerMap[tile.id].layer = layer;\n          }\n\n          return layer;\n        }\n\n        if (layer && layer.props && layer.props.visible) {\n          layer = layer.clone({\n            visible: false\n          });\n          layerMap[tile.id].layer = layer;\n        }\n\n        return layer;\n      }).filter(Boolean);\n    }\n  }]);\n\n  return Tile3DLayer;\n}(CompositeLayer);\n\nexport { Tile3DLayer as default };\nTile3DLayer.layerName = 'Tile3DLayer';\nTile3DLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../src/tile-3d-layer/tile-3d-layer.js"],"names":["scratchOffset","defaultProps","getPointColor","pointSize","data","loadOptions","loader","onTilesetLoad","onTileLoad","onTileUnload","onTileError","Tile3DLayer","CompositeLayer","log","layerMap","tileset3d","changeFlags","props","oldProps","info","sourceLayer","layerId","substr","tileId","tilesetUrl","options","preload","preloadOptions","Object","tilesetJson","load","onTileLoadFail","tileHeader","timeline","viewport","frameNumber","tilesetChanged","TILE_TYPE","attributes","pointCount","constantRGBA","cartographicOrigin","modelMatrix","positions","normals","colors","SubLayerClass","id","header","vertexCount","POSITION","NORMAL","COLOR_0","coordinateSystem","COORDINATE_SYSTEM","coordinateOrigin","getColor","gltf","instances","_lighting","scenegraph","getTransformMatrix","instance","getPosition","content","texture","texCoords","i","geometry","drawMode","mesh","METER_OFFSETS","layer","tile","visible"],"mappings":"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","sourcesContent":["import {Vector3} from '@math.gl/core';\nimport GL from '@luma.gl/constants';\nimport {Geometry} from '@luma.gl/core';\nimport {COORDINATE_SYSTEM, CompositeLayer} from '@deck.gl/core';\nimport {PointCloudLayer} from '@deck.gl/layers';\nimport {ScenegraphLayer, SimpleMeshLayer} from '@deck.gl/mesh-layers';\nimport {log} from '@deck.gl/core';\n\nimport {load} from '@loaders.gl/core';\nimport {Tileset3D, TILE_TYPE} from '@loaders.gl/tiles';\nimport {Tiles3DLoader} from '@loaders.gl/3d-tiles';\n\nconst scratchOffset = new Vector3();\n\nconst defaultProps = {\n  getPointColor: [0, 0, 0],\n  pointSize: 1.0,\n\n  data: null,\n  loadOptions: {},\n  loader: Tiles3DLoader,\n\n  onTilesetLoad: tileset3d => {},\n  onTileLoad: tileHeader => {},\n  onTileUnload: tileHeader => {},\n  onTileError: (tile, message, url) => {}\n};\n\nexport default class Tile3DLayer extends CompositeLayer {\n  initializeState() {\n    if ('onTileLoadFail' in this.props) {\n      log.removed('onTileLoadFail', 'onTileError')();\n    }\n    // prop verification\n    this.state = {\n      layerMap: {},\n      tileset3d: null\n    };\n  }\n\n  shouldUpdateState({changeFlags}) {\n    return changeFlags.somethingChanged;\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    if (props.data && props.data !== oldProps.data) {\n      this._loadTileset(props.data);\n    }\n\n    if (changeFlags.viewportChanged) {\n      const {tileset3d} = this.state;\n      this._updateTileset(tileset3d);\n    }\n  }\n\n  getPickingInfo({info, sourceLayer}) {\n    const {layerMap} = this.state;\n    const layerId = sourceLayer && sourceLayer.id;\n    if (layerId) {\n      // layerId: this.id-[scenegraph|pointcloud]-tileId\n      const substr = layerId.substring(this.id.length + 1);\n      const tileId = substr.substring(substr.indexOf('-') + 1);\n      info.object = layerMap[tileId] && layerMap[tileId].tile;\n    }\n\n    return info;\n  }\n\n  async _loadTileset(tilesetUrl) {\n    const {loader, loadOptions} = this.props;\n    const options = {...loadOptions};\n    if (loader.preload) {\n      const preloadOptions = await loader.preload(tilesetUrl, loadOptions);\n      Object.assign(options, preloadOptions);\n    }\n    const tilesetJson = await load(tilesetUrl, loader, options);\n\n    const tileset3d = new Tileset3D(tilesetJson, {\n      onTileLoad: this._onTileLoad.bind(this),\n      onTileUnload: this._onTileUnload.bind(this),\n      onTileLoadFail: this.props.onTileError,\n      ...options\n    });\n\n    this.setState({\n      tileset3d,\n      layerMap: {}\n    });\n\n    this._updateTileset(tileset3d);\n    this.props.onTilesetLoad(tileset3d);\n  }\n\n  _onTileLoad(tileHeader) {\n    this.props.onTileLoad(tileHeader);\n    this._updateTileset(this.state.tileset3d);\n    this.setNeedsUpdate();\n  }\n\n  _onTileUnload(tileHeader) {\n    // Was cleaned up from tileset cache. We no longer need to track it.\n    delete this.state.layerMap[tileHeader.id];\n    this.props.onTileUnload(tileHeader);\n  }\n\n  _updateTileset(tileset3d) {\n    const {timeline, viewport} = this.context;\n    if (!timeline || !viewport || !tileset3d) {\n      return;\n    }\n    const frameNumber = tileset3d.update(viewport);\n    const tilesetChanged = this.state.frameNumber !== frameNumber;\n    if (tilesetChanged) {\n      this.setState({frameNumber});\n    }\n  }\n\n  _create3DTileLayer(tileHeader) {\n    if (!tileHeader.content) {\n      return null;\n    }\n\n    switch (tileHeader.type) {\n      case TILE_TYPE.POINTCLOUD:\n        return this._createPointCloudTileLayer(tileHeader);\n      case TILE_TYPE.SCENEGRAPH:\n        return this._create3DModelTileLayer(tileHeader);\n      case TILE_TYPE.MESH:\n        return this._createSimpleMeshLayer(tileHeader);\n      default:\n        throw new Error(`Tile3DLayer: Failed to render layer of type ${tileHeader.content.type}`);\n    }\n  }\n\n  _createPointCloudTileLayer(tileHeader) {\n    const {\n      attributes,\n      pointCount,\n      constantRGBA,\n      cartographicOrigin,\n      modelMatrix\n    } = tileHeader.content;\n    const {positions, normals, colors} = attributes;\n\n    if (!positions) {\n      return null;\n    }\n\n    const {pointSize, getPointColor} = this.props;\n    const SubLayerClass = this.getSubLayerClass('pointcloud', PointCloudLayer);\n    return new SubLayerClass(\n      {\n        pointSize\n      },\n      this.getSubLayerProps({\n        id: 'pointcloud'\n      }),\n      {\n        id: `${this.id}-pointcloud-${tileHeader.id}`,\n        data: {\n          header: {\n            vertexCount: pointCount\n          },\n          attributes: {\n            POSITION: positions,\n            NORMAL: normals,\n            COLOR_0: colors\n          }\n        },\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        coordinateOrigin: cartographicOrigin,\n        modelMatrix,\n\n        getColor: constantRGBA || getPointColor\n      }\n    );\n  }\n\n  _create3DModelTileLayer(tileHeader) {\n    const {gltf, instances, cartographicOrigin, modelMatrix} = tileHeader.content;\n\n    const SubLayerClass = this.getSubLayerClass('scenegraph', ScenegraphLayer);\n\n    return new SubLayerClass(\n      {\n        _lighting: 'pbr'\n      },\n      this.getSubLayerProps({\n        id: 'scenegraph'\n      }),\n      {\n        id: `${this.id}-scenegraph-${tileHeader.id}`,\n        data: instances || [{}],\n        scenegraph: gltf,\n\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        coordinateOrigin: cartographicOrigin,\n        modelMatrix,\n        getTransformMatrix: instance => instance.modelMatrix,\n        getPosition: instance => [0, 0, 0]\n      }\n    );\n  }\n\n  _createSimpleMeshLayer(tileHeader) {\n    const content = tileHeader.content;\n    const {attributes, modelMatrix, cartographicOrigin, texture} = content;\n    const {normals, texCoords} = attributes;\n    const positions = new Float32Array(attributes.positions.value.length);\n    for (let i = 0; i < positions.length; i += 3) {\n      scratchOffset.copy(attributes.positions.value.subarray(i, i + 3));\n      positions.set(scratchOffset, i);\n    }\n\n    const geometry = new Geometry({\n      drawMode: GL.TRIANGLES,\n      attributes: {\n        positions,\n        normals,\n        texCoords\n      }\n    });\n\n    const SubLayerClass = this.getSubLayerClass('mesh', SimpleMeshLayer);\n\n    return new SubLayerClass(\n      this.getSubLayerProps({\n        id: 'mesh'\n      }),\n      {\n        id: `${this.id}-mesh-${tileHeader.id}`,\n        mesh: geometry,\n        data: [{}],\n        getPosition: [0, 0, 0],\n        getColor: [255, 255, 255],\n        texture,\n        modelMatrix,\n        coordinateOrigin: cartographicOrigin,\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS\n      }\n    );\n  }\n\n  renderLayers() {\n    const {tileset3d, layerMap} = this.state;\n    if (!tileset3d) {\n      return null;\n    }\n\n    return tileset3d.tiles\n      .map(tile => {\n        let layer = layerMap[tile.id] && layerMap[tile.id].layer;\n        // render selected tiles\n        if (tile.selected) {\n          // create layer\n          if (!layer) {\n            layer = this._create3DTileLayer(tile);\n            layerMap[tile.id] = {layer, tile};\n          }\n          // update layer visibility\n          if (layer && layer.props && !layer.props.visible) {\n            // Still has GPU resource but visibility is turned off so turn it back on so we can render it.\n            layer = layer.clone({visible: true});\n            layerMap[tile.id].layer = layer;\n          }\n          return layer;\n        }\n\n        // hide non-selected tiles\n        if (layer && layer.props && layer.props.visible) {\n          // Still in tileset cache but doesn't need to render this frame. Keep the GPU resource bound but don't render it.\n          layer = layer.clone({visible: false});\n          layerMap[tile.id].layer = layer;\n        }\n        return layer;\n      })\n      .filter(Boolean);\n  }\n}\n\nTile3DLayer.layerName = 'Tile3DLayer';\nTile3DLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}