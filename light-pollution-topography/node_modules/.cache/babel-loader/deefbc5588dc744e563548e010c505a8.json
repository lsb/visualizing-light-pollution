{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { padTo4Bytes, copyToArray } from '@loaders.gl/loader-utils';\nimport { isImage as _isImage } from '@loaders.gl/images';\nimport { getAccessorTypeFromSize, getComponentTypeFromArray } from '../gltf-utils/gltf-utils';\nimport encodeGLBSync from '../encode-glb';\n\nvar GLBBuilder = function () {\n  function GLBBuilder() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, GLBBuilder);\n\n    this.byteLength = 0;\n    this.json = {\n      buffers: [{\n        byteLength: 0\n      }],\n      bufferViews: [],\n      accessors: [],\n      images: [],\n      meshes: []\n    };\n    this.sourceBuffers = [];\n    this.log = options.log || console;\n  }\n\n  _createClass(GLBBuilder, [{\n    key: \"getByteLength\",\n    value: function getByteLength() {\n      return this.byteLength;\n    }\n  }, {\n    key: \"isImage\",\n    value: function isImage(imageData) {\n      return _isImage(imageData);\n    }\n  }, {\n    key: \"encodeSync\",\n    value: function encodeSync() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.encodeAsGLB(options);\n    }\n  }, {\n    key: \"encodeAsGLB\",\n    value: function encodeAsGLB() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      this._packBinaryChunk();\n\n      if (options.magic) {\n        console.warn('Custom glTF magic number no longer supported');\n      }\n\n      var glb = {\n        version: 2,\n        json: this.json,\n        binary: this.arrayBuffer\n      };\n      var byteLength = encodeGLBSync(glb, null, 0, options);\n      var glbArrayBuffer = new ArrayBuffer(byteLength);\n      var dataView = new DataView(glbArrayBuffer);\n      encodeGLBSync(glb, dataView, 0, options);\n      return glbArrayBuffer;\n    }\n  }, {\n    key: \"addApplicationData\",\n    value: function addApplicationData(key, data) {\n      var packOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      this.json[key] = data;\n      return this;\n    }\n  }, {\n    key: \"addBuffer\",\n    value: function addBuffer(sourceBuffer) {\n      var accessor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        size: 3\n      };\n      var bufferViewIndex = this.addBufferView(sourceBuffer);\n      var accessorDefaults = {\n        size: accessor.size,\n        componentType: getComponentTypeFromArray(sourceBuffer),\n        count: Math.round(sourceBuffer.length / accessor.size)\n      };\n      return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));\n    }\n  }, {\n    key: \"addBufferView\",\n    value: function addBufferView(buffer) {\n      var byteLength = buffer.byteLength || buffer.length;\n      this.json.bufferViews.push({\n        buffer: 0,\n        byteOffset: this.byteLength,\n        byteLength: byteLength\n      });\n      this.byteLength += padTo4Bytes(byteLength);\n      this.sourceBuffers.push(buffer);\n      return this.json.bufferViews.length - 1;\n    }\n  }, {\n    key: \"addAccessor\",\n    value: function addAccessor(bufferViewIndex, accessor) {\n      this.json.accessors.push({\n        bufferView: bufferViewIndex,\n        type: getAccessorTypeFromSize(accessor.size),\n        componentType: accessor.componentType,\n        count: accessor.count\n      });\n      return this.json.accessors.length - 1;\n    }\n  }, {\n    key: \"_pack\",\n    value: function _pack() {\n      this._packBinaryChunk();\n\n      return {\n        arrayBuffer: this.arrayBuffer,\n        json: this.json\n      };\n    }\n  }, {\n    key: \"_packBinaryChunk\",\n    value: function _packBinaryChunk() {\n      if (this.arrayBuffer) {\n        return;\n      }\n\n      var totalByteLength = this.byteLength;\n      var arrayBuffer = new ArrayBuffer(totalByteLength);\n      var targetArray = new Uint8Array(arrayBuffer);\n      var dstByteOffset = 0;\n\n      for (var i = 0; i < this.sourceBuffers.length; i++) {\n        var sourceBuffer = this.sourceBuffers[i];\n        dstByteOffset = copyToArray(sourceBuffer, targetArray, dstByteOffset);\n      }\n\n      this.json.buffers[0].byteLength = totalByteLength;\n      this.arrayBuffer = arrayBuffer;\n      this.sourceBuffers = [];\n    }\n  }, {\n    key: \"_getInternalCounts\",\n    value: function _getInternalCounts() {\n      return {\n        buffers: this.json.buffers.length,\n        bufferViews: this.json.bufferViews.length,\n        accessors: this.json.accessors.length,\n        images: this.json.images.length\n      };\n    }\n  }]);\n\n  return GLBBuilder;\n}();\n\nexport { GLBBuilder as default };","map":{"version":3,"sources":["../../../../src/lib/deprecated/glb-builder.js"],"names":["isImage","GLBBuilder","options","buffers","byteLength","bufferViews","accessors","images","meshes","imageData","console","glb","version","json","binary","arrayBuffer","encodeGLBSync","glbArrayBuffer","dataView","key","data","packOptions","sourceBuffer","accessor","size","bufferViewIndex","accessorDefaults","componentType","getComponentTypeFromArray","count","Math","Object","buffer","byteOffset","padTo4Bytes","bufferView","type","getAccessorTypeFromSize","totalByteLength","targetArray","dstByteOffset","i","copyToArray","length"],"mappings":"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","sourcesContent":["/* eslint-disable camelcase, max-statements */\nimport {padTo4Bytes, copyToArray} from '@loaders.gl/loader-utils';\nimport {isImage} from '@loaders.gl/images';\nimport {getAccessorTypeFromSize, getComponentTypeFromArray} from '../gltf-utils/gltf-utils';\nimport encodeGLBSync from '../encode-glb';\n\nexport default class GLBBuilder {\n  constructor(options = {}) {\n    // Lets us keep track of how large the body will be, as well as the offset for each of the\n    // original buffers.\n    this.byteLength = 0;\n\n    this.json = {\n      buffers: [\n        {\n          // Just the single BIN chunk buffer\n          byteLength: 0 // Updated at end of conversion\n        }\n      ],\n      bufferViews: [],\n      accessors: [],\n      images: [],\n      meshes: []\n    };\n\n    // list of binary buffers to be written to the BIN chunk\n    // (Each call to addBuffer, addImage etc adds an entry here)\n    this.sourceBuffers = [];\n\n    this.log = options.log || console; // eslint-disable-line\n  }\n\n  // ACCESSORS\n\n  getByteLength() {\n    return this.byteLength;\n  }\n\n  // Checks if a binary buffer is a recognized image format (PNG, JPG, GIF, ...)\n  isImage(imageData) {\n    return isImage(imageData);\n  }\n\n  // MODIFERS\n  encodeSync(options = {}) {\n    return this.encodeAsGLB(options);\n  }\n\n  // Encode the full glTF file as a binary GLB file\n  // Returns an ArrayBuffer that represents the complete GLB image that can be saved to file\n  // Encode the full GLB buffer with header etc\n  // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#\n  // glb-file-format-specification\n  encodeAsGLB(options = {}) {\n    // TODO - avoid double array buffer creation\n    this._packBinaryChunk();\n\n    if (options.magic) {\n      console.warn('Custom glTF magic number no longer supported'); // eslint-disable-line\n    }\n\n    const glb = {\n      version: 2,\n      json: this.json,\n      binary: this.arrayBuffer\n    };\n\n    // Calculate length and allocate buffer\n    const byteLength = encodeGLBSync(glb, null, 0, options);\n    const glbArrayBuffer = new ArrayBuffer(byteLength);\n\n    // Encode into buffer\n    const dataView = new DataView(glbArrayBuffer);\n    encodeGLBSync(glb, dataView, 0, options);\n\n    return glbArrayBuffer;\n  }\n\n  // Add an extra application-defined key to the top-level data structure\n  // By default packs JSON by extracting binary data and replacing it with JSON pointers\n  addApplicationData(key, data, packOptions = {}) {\n    this.json[key] = data;\n    return this;\n  }\n\n  // Add a binary buffer. Builds glTF \"JSON metadata\" and saves buffer reference\n  // Buffer will be copied into BIN chunk during \"pack\"\n  // Currently encodes buffers as glTF accessors, but this could be optimized\n  addBuffer(sourceBuffer, accessor = {size: 3}) {\n    const bufferViewIndex = this.addBufferView(sourceBuffer);\n\n    const accessorDefaults = {\n      size: accessor.size,\n      componentType: getComponentTypeFromArray(sourceBuffer),\n      count: Math.round(sourceBuffer.length / accessor.size)\n    };\n\n    return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));\n  }\n\n  // Basic glTF adders: basic memory buffer/image type fields\n  // Scenegraph specific adders are placed in glTFBuilder\n  // TODO: These should be moved to glTFBuilder once addBuffer\n  // have been rewritten to not depend on these.\n\n  // Add one untyped source buffer, create a matching glTF `bufferView`, and return its index\n  addBufferView(buffer) {\n    const byteLength = buffer.byteLength || buffer.length;\n\n    // Add a bufferView indicating start and length of this binary sub-chunk\n    this.json.bufferViews.push({\n      buffer: 0,\n      // Write offset from the start of the binary body\n      byteOffset: this.byteLength,\n      byteLength\n    });\n\n    // We've now written the contents to the body, so update the total length\n    // Every sub-chunk needs to be 4-byte aligned\n    this.byteLength += padTo4Bytes(byteLength);\n\n    // Add this buffer to the list of buffers to be written to the body.\n    this.sourceBuffers.push(buffer);\n\n    // Return the index to the just created bufferView\n    return this.json.bufferViews.length - 1;\n  }\n\n  // Adds an accessor to a bufferView\n  addAccessor(bufferViewIndex, accessor) {\n    // Add an accessor pointing to the new buffer view\n    this.json.accessors.push({\n      bufferView: bufferViewIndex,\n      type: getAccessorTypeFromSize(accessor.size),\n      componentType: accessor.componentType,\n      count: accessor.count\n    });\n\n    return this.json.accessors.length - 1;\n  }\n\n  // PRIVATE\n\n  // For testing\n  _pack() {\n    this._packBinaryChunk();\n    return {arrayBuffer: this.arrayBuffer, json: this.json};\n  }\n\n  // Pack the binary chunk\n  _packBinaryChunk() {\n    // Already packed\n    if (this.arrayBuffer) {\n      return;\n    }\n\n    // Allocate total array\n    const totalByteLength = this.byteLength;\n    const arrayBuffer = new ArrayBuffer(totalByteLength);\n    const targetArray = new Uint8Array(arrayBuffer);\n\n    // Copy each array into\n    let dstByteOffset = 0;\n    for (let i = 0; i < this.sourceBuffers.length; i++) {\n      const sourceBuffer = this.sourceBuffers[i];\n      dstByteOffset = copyToArray(sourceBuffer, targetArray, dstByteOffset);\n    }\n\n    // Update the glTF BIN CHUNK byte length\n    this.json.buffers[0].byteLength = totalByteLength;\n\n    // Save generated arrayBuffer\n    this.arrayBuffer = arrayBuffer;\n\n    // Clear out sourceBuffers\n    this.sourceBuffers = [];\n  }\n\n  // Report internal buffer sizes for debug and testing purposes\n  _getInternalCounts() {\n    return {\n      buffers: this.json.buffers.length,\n      bufferViews: this.json.bufferViews.length,\n      accessors: this.json.accessors.length,\n      images: this.json.images.length\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}