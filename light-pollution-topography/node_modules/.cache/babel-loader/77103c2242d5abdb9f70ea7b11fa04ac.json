{"ast":null,"code":"export function padTo4Bytes(byteLength) {\n  return byteLength + 3 & ~3;\n}\nexport function getZeroOffsetArrayBuffer(arrayBuffer, byteOffset, byteLength) {\n  var subArray = byteLength ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength) : new Uint8Array(arrayBuffer).subarray(byteOffset);\n  var arrayCopy = new Uint8Array(subArray);\n  return arrayCopy.buffer;\n}\nexport function copyArrayBuffer(targetBuffer, sourceBuffer, byteOffset) {\n  var byteLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : sourceBuffer.byteLength;\n  var targetArray = new Uint8Array(targetBuffer, byteOffset, byteLength);\n  var sourceArray = new Uint8Array(sourceBuffer);\n  targetArray.set(sourceArray);\n  return targetBuffer;\n}\nexport function copyToArray(source, target, targetOffset) {\n  var sourceArray;\n\n  if (source instanceof ArrayBuffer) {\n    sourceArray = new Uint8Array(source);\n  } else {\n    var srcByteOffset = source.byteOffset;\n    var srcByteLength = source.byteLength;\n    sourceArray = new Uint8Array(source.buffer, srcByteOffset, srcByteLength);\n  }\n\n  target.set(sourceArray, targetOffset);\n  return targetOffset + padTo4Bytes(sourceArray.byteLength);\n}","map":{"version":3,"sources":["../../../../src/lib/binary-utils/memory-copy-utils.js"],"names":["byteLength","subArray","byteOffset","arrayCopy","sourceBuffer","targetArray","sourceArray","source","srcByteOffset","srcByteLength","target","targetOffset","padTo4Bytes"],"mappings":"AAAA,OAAO,SAAA,WAAA,CAAA,UAAA,EAAiC;AACtC,SAAQA,UAAU,GAAX,CAACA,GAAkB,CAA1B,CAAA;AACD;AAGD,OAAO,SAAA,wBAAA,CAAA,WAAA,EAAA,UAAA,EAAA,UAAA,EAAuE;AAC5E,MAAMC,QAAQ,GAAGD,UAAU,GACvB,IAAA,UAAA,CAAA,WAAA,EAAA,QAAA,CAAA,UAAA,EAAiDE,UAAU,GADpC,UACvB,CADuB,GAEvB,IAAA,UAAA,CAAA,WAAA,EAAA,QAAA,CAFJ,UAEI,CAFJ;AAGA,MAAMC,SAAS,GAAG,IAAA,UAAA,CAAlB,QAAkB,CAAlB;AACA,SAAOA,SAAS,CAAhB,MAAA;AACD;AAQD,OAAO,SAAA,eAAA,CAAA,YAAA,EAAA,YAAA,EAAA,UAAA,EAKL;AAAA,MADAH,UACA,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GADaI,YAAY,CAACJ,UAC1B;AACA,MAAMK,WAAW,GAAG,IAAA,UAAA,CAAA,YAAA,EAAA,UAAA,EAApB,UAAoB,CAApB;AACA,MAAMC,WAAW,GAAG,IAAA,UAAA,CAApB,YAAoB,CAApB;AACAD,EAAAA,WAAW,CAAXA,GAAAA,CAAAA,WAAAA;AACA,SAAA,YAAA;AACD;AAWD,OAAO,SAAA,WAAA,CAAA,MAAA,EAAA,MAAA,EAAA,YAAA,EAAmD;AACxD,MAAA,WAAA;;AAEA,MAAIE,MAAM,YAAV,WAAA,EAAmC;AACjCD,IAAAA,WAAW,GAAG,IAAA,UAAA,CAAdA,MAAc,CAAdA;AADF,GAAA,MAEO;AAOL,QAAME,aAAa,GAAGD,MAAM,CAA5B,UAAA;AACA,QAAME,aAAa,GAAGF,MAAM,CAA5B,UAAA;AACAD,IAAAA,WAAW,GAAG,IAAA,UAAA,CAAeC,MAAM,CAArB,MAAA,EAAA,aAAA,EAAdD,aAAc,CAAdA;AACD;;AAGDI,EAAAA,MAAM,CAANA,GAAAA,CAAAA,WAAAA,EAAAA,YAAAA;AAEA,SAAOC,YAAY,GAAGC,WAAW,CAACN,WAAW,CAA7C,UAAiC,CAAjC;AACD","sourcesContent":["export function padTo4Bytes(byteLength) {\n  return (byteLength + 3) & ~3;\n}\n\n// Copy a view of an ArrayBuffer into new ArrayBuffer with byteOffset = 0\nexport function getZeroOffsetArrayBuffer(arrayBuffer, byteOffset, byteLength) {\n  const subArray = byteLength\n    ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength)\n    : new Uint8Array(arrayBuffer).subarray(byteOffset);\n  const arrayCopy = new Uint8Array(subArray);\n  return arrayCopy.buffer;\n}\n\n/* Creates a new Uint8Array based on two different ArrayBuffers\n * @private\n * @param {ArrayBuffers} buffer1 The first buffer.\n * @param {ArrayBuffers} buffer2 The second buffer.\n * @return {ArrayBuffers} The new ArrayBuffer created out of the two.\n */\nexport function copyArrayBuffer(\n  targetBuffer,\n  sourceBuffer,\n  byteOffset,\n  byteLength = sourceBuffer.byteLength\n) {\n  const targetArray = new Uint8Array(targetBuffer, byteOffset, byteLength);\n  const sourceArray = new Uint8Array(sourceBuffer);\n  targetArray.set(sourceArray);\n  return targetBuffer;\n}\n\n/**\n * Copy from source to target at the targetOffset\n *\n * @param {ArrayBuffer|any} source - The data to copy\n * @param {any} target - The destination to copy data into\n * @param {Number} targetOffset - The start offset into target to place the copied data\n *\n * @return {Number} Returns the new offset taking into account proper padding\n */\nexport function copyToArray(source, target, targetOffset) {\n  let sourceArray;\n\n  if (source instanceof ArrayBuffer) {\n    sourceArray = new Uint8Array(source);\n  } else {\n    // Pack buffer onto the big target array\n    //\n    // 'source.data.buffer' could be a view onto a larger buffer.\n    // We MUST use this constructor to ensure the byteOffset and byteLength is\n    // set to correct values from 'source.data' and not the underlying\n    // buffer for target.set() to work properly.\n    const srcByteOffset = source.byteOffset;\n    const srcByteLength = source.byteLength;\n    sourceArray = new Uint8Array(source.buffer, srcByteOffset, srcByteLength);\n  }\n\n  // Pack buffer onto the big target array\n  target.set(sourceArray, targetOffset);\n\n  return targetOffset + padTo4Bytes(sourceArray.byteLength);\n}\n"]},"metadata":{},"sourceType":"module"}