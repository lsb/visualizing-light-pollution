{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { assert, log } from '@luma.gl/webgl';\nimport { Matrix4, Quaternion } from 'math.gl';\nexport var ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nexport var ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\n\nfunction accessorToJsArray(accessor) {\n  if (!accessor._animation) {\n    var ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];\n    var components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];\n    var length = components * accessor.count;\n    var _accessor$bufferView$ = accessor.bufferView.data,\n        buffer = _accessor$bufferView$.buffer,\n        byteOffset = _accessor$bufferView$.byteOffset;\n    var array = new ArrayType(buffer, byteOffset + (accessor.byteOffset || 0), length);\n\n    if (components === 1) {\n      accessor._animation = Array.from(array);\n    } else {\n      var slicedArray = [];\n\n      for (var i = 0; i < array.length; i += components) {\n        slicedArray.push(Array.from(array.slice(i, i + components)));\n      }\n\n      accessor._animation = slicedArray;\n    }\n  }\n\n  return accessor._animation;\n}\n\nvar helperMatrix = new Matrix4();\n\nfunction applyTranslationRotationScale(gltfNode, node) {\n  node.matrix.identity();\n\n  if (gltfNode.translation) {\n    node.matrix.translate(gltfNode.translation);\n  }\n\n  if (gltfNode.rotation) {\n    var rotationMatrix = helperMatrix.fromQuaternion(gltfNode.rotation);\n    node.matrix.multiplyRight(rotationMatrix);\n  }\n\n  if (gltfNode.scale) {\n    node.matrix.scale(gltfNode.scale);\n  }\n}\n\nvar quaternion = new Quaternion();\n\nfunction linearInterpolate(target, path, start, stop, ratio) {\n  if (path === 'rotation') {\n    quaternion.slerp({\n      start: start,\n      target: stop,\n      ratio: ratio\n    });\n\n    for (var i = 0; i < quaternion.length; i++) {\n      target[path][i] = quaternion[i];\n    }\n  } else {\n    for (var _i = 0; _i < start.length; _i++) {\n      target[path][_i] = ratio * stop[_i] + (1 - ratio) * start[_i];\n    }\n  }\n}\n\nfunction cubicsplineInterpolate(target, path, _ref) {\n  var p0 = _ref.p0,\n      outTangent0 = _ref.outTangent0,\n      inTangent1 = _ref.inTangent1,\n      p1 = _ref.p1,\n      tDiff = _ref.tDiff,\n      t = _ref.ratio;\n\n  for (var i = 0; i < target[path].length; i++) {\n    var m0 = outTangent0[i] * tDiff;\n    var m1 = inTangent1[i] * tDiff;\n    target[path][i] = (2 * Math.pow(t, 3) - 3 * Math.pow(t, 2) + 1) * p0[i] + (Math.pow(t, 3) - 2 * Math.pow(t, 2) + t) * m0 + (-2 * Math.pow(t, 3) + 3 * Math.pow(t, 2)) * p1[i] + (Math.pow(t, 3) - Math.pow(t, 2)) * m1;\n  }\n}\n\nfunction stepInterpolate(target, path, value) {\n  for (var i = 0; i < value.length; i++) {\n    target[path][i] = value[i];\n  }\n}\n\nfunction interpolate(time, _ref2, target, path) {\n  var input = _ref2.input,\n      interpolation = _ref2.interpolation,\n      output = _ref2.output;\n  var maxTime = input[input.length - 1];\n  var animationTime = time % maxTime;\n  var nextIndex = input.findIndex(function (t) {\n    return t >= animationTime;\n  });\n  var previousIndex = Math.max(0, nextIndex - 1);\n\n  if (!Array.isArray(target[path])) {\n    switch (path) {\n      case 'translation':\n        target[path] = [0, 0, 0];\n        break;\n\n      case 'rotation':\n        target[path] = [0, 0, 0, 1];\n        break;\n\n      case 'scale':\n        target[path] = [1, 1, 1];\n        break;\n\n      default:\n        log.warn(\"Bad animation path \".concat(path))();\n    }\n  }\n\n  assert(target[path].length === output[previousIndex].length);\n  var previousTime = input[previousIndex];\n  var nextTime = input[nextIndex];\n\n  switch (interpolation) {\n    case 'STEP':\n      stepInterpolate(target, path, output[previousIndex]);\n      break;\n\n    case 'LINEAR':\n      if (nextTime > previousTime) {\n        var ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        linearInterpolate(target, path, output[previousIndex], output[nextIndex], ratio);\n      }\n\n      break;\n\n    case 'CUBICSPLINE':\n      if (nextTime > previousTime) {\n        var _ratio = (animationTime - previousTime) / (nextTime - previousTime);\n\n        var tDiff = nextTime - previousTime;\n        var p0 = output[3 * previousIndex + 1];\n        var outTangent0 = output[3 * previousIndex + 2];\n        var inTangent1 = output[3 * nextIndex + 0];\n        var p1 = output[3 * nextIndex + 1];\n        cubicsplineInterpolate(target, path, {\n          p0: p0,\n          outTangent0: outTangent0,\n          inTangent1: inTangent1,\n          p1: p1,\n          tDiff: tDiff,\n          ratio: _ratio\n        });\n      }\n\n      break;\n\n    default:\n      log.warn(\"Interpolation \".concat(interpolation, \" not supported\"))();\n      break;\n  }\n}\n\nvar GLTFAnimation = function () {\n  function GLTFAnimation(props) {\n    _classCallCheck(this, GLTFAnimation);\n\n    this.startTime = 0;\n    this.playing = true;\n    this.speed = 1;\n    Object.assign(this, props);\n  }\n\n  _createClass(GLTFAnimation, [{\n    key: \"animate\",\n    value: function animate(timeMs) {\n      if (!this.playing) {\n        return;\n      }\n\n      var absTime = timeMs / 1000;\n      var time = (absTime - this.startTime) * this.speed;\n      this.channels.forEach(function (_ref3) {\n        var sampler = _ref3.sampler,\n            target = _ref3.target,\n            path = _ref3.path;\n        interpolate(time, sampler, target, path);\n        applyTranslationRotationScale(target, target._node);\n      });\n    }\n  }]);\n\n  return GLTFAnimation;\n}();\n\nvar GLTFAnimator = function () {\n  function GLTFAnimator(gltf) {\n    _classCallCheck(this, GLTFAnimator);\n\n    this.animations = gltf.animations.map(function (animation, index) {\n      var name = animation.name || \"Animation-\".concat(index);\n      var samplers = animation.samplers.map(function (_ref4) {\n        var input = _ref4.input,\n            _ref4$interpolation = _ref4.interpolation,\n            interpolation = _ref4$interpolation === void 0 ? 'LINEAR' : _ref4$interpolation,\n            output = _ref4.output;\n        return {\n          input: accessorToJsArray(gltf.accessors[input]),\n          interpolation: interpolation,\n          output: accessorToJsArray(gltf.accessors[output])\n        };\n      });\n      var channels = animation.channels.map(function (_ref5) {\n        var sampler = _ref5.sampler,\n            target = _ref5.target;\n        return {\n          sampler: samplers[sampler],\n          target: gltf.nodes[target.node],\n          path: target.path\n        };\n      });\n      return new GLTFAnimation({\n        name: name,\n        channels: channels\n      });\n    });\n  }\n\n  _createClass(GLTFAnimator, [{\n    key: \"animate\",\n    value: function animate(time) {\n      this.setTime(time);\n    }\n  }, {\n    key: \"setTime\",\n    value: function setTime(time) {\n      this.animations.forEach(function (animation) {\n        return animation.animate(time);\n      });\n    }\n  }, {\n    key: \"getAnimations\",\n    value: function getAnimations() {\n      return this.animations;\n    }\n  }]);\n\n  return GLTFAnimator;\n}();\n\nexport { GLTFAnimator as default };","map":{"version":3,"sources":["../../../src/gltf/gltf-animator.js"],"names":["ATTRIBUTE_TYPE_TO_COMPONENTS","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY","Float32Array","accessor","ArrayType","components","length","buffer","byteOffset","array","Array","slicedArray","i","helperMatrix","node","gltfNode","rotationMatrix","quaternion","path","start","target","ratio","stop","p0","outTangent0","inTangent1","p1","tDiff","t","m0","m1","Math","value","input","interpolation","output","maxTime","animationTime","time","nextIndex","previousIndex","log","assert","previousTime","nextTime","stepInterpolate","linearInterpolate","cubicsplineInterpolate","GLTFAnimation","Object","timeMs","absTime","sampler","interpolate","applyTranslationRotationScale","GLTFAnimator","name","animation","samplers","accessorToJsArray","gltf","channels"],"mappings":"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","sourcesContent":["import {assert, log} from '@luma.gl/webgl';\nimport {Matrix4, Quaternion} from 'math.gl';\n\n// TODO: import from loaders.gl?\nexport const ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nexport const ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\n//\n\nfunction accessorToJsArray(accessor) {\n  if (!accessor._animation) {\n    const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];\n    const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];\n    const length = components * accessor.count;\n    const {buffer, byteOffset} = accessor.bufferView.data;\n\n    const array = new ArrayType(buffer, byteOffset + (accessor.byteOffset || 0), length);\n\n    if (components === 1) {\n      accessor._animation = Array.from(array);\n    } else {\n      // Slice array\n      const slicedArray = [];\n      for (let i = 0; i < array.length; i += components) {\n        slicedArray.push(Array.from(array.slice(i, i + components)));\n      }\n      accessor._animation = slicedArray;\n    }\n  }\n\n  return accessor._animation;\n}\n\n// TODO: share with GLTFInstantiator\nconst helperMatrix = new Matrix4();\nfunction applyTranslationRotationScale(gltfNode, node) {\n  node.matrix.identity();\n\n  if (gltfNode.translation) {\n    node.matrix.translate(gltfNode.translation);\n  }\n\n  if (gltfNode.rotation) {\n    const rotationMatrix = helperMatrix.fromQuaternion(gltfNode.rotation);\n    node.matrix.multiplyRight(rotationMatrix);\n  }\n\n  if (gltfNode.scale) {\n    node.matrix.scale(gltfNode.scale);\n  }\n}\n\nconst quaternion = new Quaternion();\nfunction linearInterpolate(target, path, start, stop, ratio) {\n  if (path === 'rotation') {\n    // SLERP when path is rotation\n    quaternion.slerp({start, target: stop, ratio});\n    for (let i = 0; i < quaternion.length; i++) {\n      target[path][i] = quaternion[i];\n    }\n  } else {\n    // regular interpolation\n    for (let i = 0; i < start.length; i++) {\n      target[path][i] = ratio * stop[i] + (1 - ratio) * start[i];\n    }\n  }\n}\n\nfunction cubicsplineInterpolate(target, path, {p0, outTangent0, inTangent1, p1, tDiff, ratio: t}) {\n  // TODO: Quaternion might need normalization\n  for (let i = 0; i < target[path].length; i++) {\n    const m0 = outTangent0[i] * tDiff;\n    const m1 = inTangent1[i] * tDiff;\n    target[path][i] =\n      (2 * Math.pow(t, 3) - 3 * Math.pow(t, 2) + 1) * p0[i] +\n      (Math.pow(t, 3) - 2 * Math.pow(t, 2) + t) * m0 +\n      (-2 * Math.pow(t, 3) + 3 * Math.pow(t, 2)) * p1[i] +\n      (Math.pow(t, 3) - Math.pow(t, 2)) * m1;\n  }\n}\n\nfunction stepInterpolate(target, path, value) {\n  for (let i = 0; i < value.length; i++) {\n    target[path][i] = value[i];\n  }\n}\n\nfunction interpolate(time, {input, interpolation, output}, target, path) {\n  const maxTime = input[input.length - 1];\n  const animationTime = time % maxTime;\n\n  const nextIndex = input.findIndex(t => t >= animationTime);\n  const previousIndex = Math.max(0, nextIndex - 1);\n\n  if (!Array.isArray(target[path])) {\n    switch (path) {\n      case 'translation':\n        target[path] = [0, 0, 0];\n        break;\n\n      case 'rotation':\n        target[path] = [0, 0, 0, 1];\n        break;\n\n      case 'scale':\n        target[path] = [1, 1, 1];\n        break;\n\n      default:\n        log.warn(`Bad animation path ${path}`)();\n    }\n  }\n\n  assert(target[path].length === output[previousIndex].length);\n  const previousTime = input[previousIndex];\n  const nextTime = input[nextIndex];\n\n  switch (interpolation) {\n    case 'STEP':\n      stepInterpolate(target, path, output[previousIndex]);\n      break;\n\n    case 'LINEAR':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        linearInterpolate(target, path, output[previousIndex], output[nextIndex], ratio);\n      }\n      break;\n\n    case 'CUBICSPLINE':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        const tDiff = nextTime - previousTime;\n\n        const p0 = output[3 * previousIndex + 1];\n        const outTangent0 = output[3 * previousIndex + 2];\n        const inTangent1 = output[3 * nextIndex + 0];\n        const p1 = output[3 * nextIndex + 1];\n\n        cubicsplineInterpolate(target, path, {p0, outTangent0, inTangent1, p1, tDiff, ratio});\n      }\n      break;\n\n    default:\n      log.warn(`Interpolation ${interpolation} not supported`)();\n      break;\n  }\n}\n\nclass GLTFAnimation {\n  constructor(props) {\n    this.startTime = 0;\n    this.playing = true;\n    this.speed = 1;\n\n    Object.assign(this, props);\n  }\n\n  animate(timeMs) {\n    if (!this.playing) {\n      return;\n    }\n\n    const absTime = timeMs / 1000;\n    const time = (absTime - this.startTime) * this.speed;\n\n    this.channels.forEach(({sampler, target, path}) => {\n      interpolate(time, sampler, target, path);\n      applyTranslationRotationScale(target, target._node);\n    });\n  }\n}\n\nexport default class GLTFAnimator {\n  constructor(gltf) {\n    this.animations = gltf.animations.map((animation, index) => {\n      const name = animation.name || `Animation-${index}`;\n      const samplers = animation.samplers.map(({input, interpolation = 'LINEAR', output}) => ({\n        input: accessorToJsArray(gltf.accessors[input]),\n        interpolation,\n        output: accessorToJsArray(gltf.accessors[output])\n      }));\n      const channels = animation.channels.map(({sampler, target}) => ({\n        sampler: samplers[sampler],\n        target: gltf.nodes[target.node],\n        path: target.path\n      }));\n      return new GLTFAnimation({name, channels});\n    });\n  }\n\n  // TODO(Tarek): This should be removed? (deck.gl is using this)\n  animate(time) {\n    this.setTime(time);\n  }\n\n  setTime(time) {\n    this.animations.forEach(animation => animation.animate(time));\n  }\n\n  getAnimations() {\n    return this.animations;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}