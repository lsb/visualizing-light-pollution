{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/** @ignore */\nconst carryBit16 = 1 << 16;\n/** @ignore */\n\nfunction intAsHex(value) {\n  if (value < 0) {\n    value = 0xFFFFFFFF + value + 1;\n  }\n\n  return `0x${value.toString(16)}`;\n}\n/** @ignore */\n\n\nconst kInt32DecimalDigits = 8;\n/** @ignore */\n\nconst kPowersOfTen = [1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000];\n/** @ignore */\n\nexport class BaseInt64 {\n  constructor(buffer) {\n    this.buffer = buffer;\n  }\n\n  high() {\n    return this.buffer[1];\n  }\n\n  low() {\n    return this.buffer[0];\n  }\n\n  _times(other) {\n    // Break the left and right numbers into 16 bit chunks\n    // so that we can multiply them without overflow.\n    const L = new Uint32Array([this.buffer[1] >>> 16, this.buffer[1] & 0xFFFF, this.buffer[0] >>> 16, this.buffer[0] & 0xFFFF]);\n    const R = new Uint32Array([other.buffer[1] >>> 16, other.buffer[1] & 0xFFFF, other.buffer[0] >>> 16, other.buffer[0] & 0xFFFF]);\n    let product = L[3] * R[3];\n    this.buffer[0] = product & 0xFFFF;\n    let sum = product >>> 16;\n    product = L[2] * R[3];\n    sum += product;\n    product = L[3] * R[2] >>> 0;\n    sum += product;\n    this.buffer[0] += sum << 16;\n    this.buffer[1] = sum >>> 0 < product ? carryBit16 : 0;\n    this.buffer[1] += sum >>> 16;\n    this.buffer[1] += L[1] * R[3] + L[2] * R[2] + L[3] * R[1];\n    this.buffer[1] += L[0] * R[3] + L[1] * R[2] + L[2] * R[1] + L[3] * R[0] << 16;\n    return this;\n  }\n\n  _plus(other) {\n    const sum = this.buffer[0] + other.buffer[0] >>> 0;\n    this.buffer[1] += other.buffer[1];\n\n    if (sum < this.buffer[0] >>> 0) {\n      ++this.buffer[1];\n    }\n\n    this.buffer[0] = sum;\n  }\n\n  lessThan(other) {\n    return this.buffer[1] < other.buffer[1] || this.buffer[1] === other.buffer[1] && this.buffer[0] < other.buffer[0];\n  }\n\n  equals(other) {\n    return this.buffer[1] === other.buffer[1] && this.buffer[0] == other.buffer[0];\n  }\n\n  greaterThan(other) {\n    return other.lessThan(this);\n  }\n\n  hex() {\n    return `${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;\n  }\n\n}\n/** @ignore */\n\nexport class Uint64 extends BaseInt64 {\n  times(other) {\n    this._times(other);\n\n    return this;\n  }\n\n  plus(other) {\n    this._plus(other);\n\n    return this;\n  }\n  /** @nocollapse */\n\n\n  static from(val, out_buffer = new Uint32Array(2)) {\n    return Uint64.fromString(typeof val === 'string' ? val : val.toString(), out_buffer);\n  }\n  /** @nocollapse */\n\n\n  static fromNumber(num, out_buffer = new Uint32Array(2)) {\n    // Always parse numbers as strings - pulling out high and low bits\n    // directly seems to lose precision sometimes\n    // For example:\n    //     > -4613034156400212000 >>> 0\n    //     721782784\n    // The correct lower 32-bits are 721782752\n    return Uint64.fromString(num.toString(), out_buffer);\n  }\n  /** @nocollapse */\n\n\n  static fromString(str, out_buffer = new Uint32Array(2)) {\n    const length = str.length;\n    let out = new Uint64(out_buffer);\n\n    for (let posn = 0; posn < length;) {\n      const group = kInt32DecimalDigits < length - posn ? kInt32DecimalDigits : length - posn;\n      const chunk = new Uint64(new Uint32Array([parseInt(str.substr(posn, group), 10), 0]));\n      const multiple = new Uint64(new Uint32Array([kPowersOfTen[group], 0]));\n      out.times(multiple);\n      out.plus(chunk);\n      posn += group;\n    }\n\n    return out;\n  }\n  /** @nocollapse */\n\n\n  static convertArray(values) {\n    const data = new Uint32Array(values.length * 2);\n\n    for (let i = -1, n = values.length; ++i < n;) {\n      Uint64.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));\n    }\n\n    return data;\n  }\n  /** @nocollapse */\n\n\n  static multiply(left, right) {\n    let rtrn = new Uint64(new Uint32Array(left.buffer));\n    return rtrn.times(right);\n  }\n  /** @nocollapse */\n\n\n  static add(left, right) {\n    let rtrn = new Uint64(new Uint32Array(left.buffer));\n    return rtrn.plus(right);\n  }\n\n}\n/** @ignore */\n\nexport class Int64 extends BaseInt64 {\n  negate() {\n    this.buffer[0] = ~this.buffer[0] + 1;\n    this.buffer[1] = ~this.buffer[1];\n\n    if (this.buffer[0] == 0) {\n      ++this.buffer[1];\n    }\n\n    return this;\n  }\n\n  times(other) {\n    this._times(other);\n\n    return this;\n  }\n\n  plus(other) {\n    this._plus(other);\n\n    return this;\n  }\n\n  lessThan(other) {\n    // force high bytes to be signed\n    const this_high = this.buffer[1] << 0;\n    const other_high = other.buffer[1] << 0;\n    return this_high < other_high || this_high === other_high && this.buffer[0] < other.buffer[0];\n  }\n  /** @nocollapse */\n\n\n  static from(val, out_buffer = new Uint32Array(2)) {\n    return Int64.fromString(typeof val === 'string' ? val : val.toString(), out_buffer);\n  }\n  /** @nocollapse */\n\n\n  static fromNumber(num, out_buffer = new Uint32Array(2)) {\n    // Always parse numbers as strings - pulling out high and low bits\n    // directly seems to lose precision sometimes\n    // For example:\n    //     > -4613034156400212000 >>> 0\n    //     721782784\n    // The correct lower 32-bits are 721782752\n    return Int64.fromString(num.toString(), out_buffer);\n  }\n  /** @nocollapse */\n\n\n  static fromString(str, out_buffer = new Uint32Array(2)) {\n    // TODO: Assert that out_buffer is 0 and length = 2\n    const negate = str.startsWith('-');\n    const length = str.length;\n    let out = new Int64(out_buffer);\n\n    for (let posn = negate ? 1 : 0; posn < length;) {\n      const group = kInt32DecimalDigits < length - posn ? kInt32DecimalDigits : length - posn;\n      const chunk = new Int64(new Uint32Array([parseInt(str.substr(posn, group), 10), 0]));\n      const multiple = new Int64(new Uint32Array([kPowersOfTen[group], 0]));\n      out.times(multiple);\n      out.plus(chunk);\n      posn += group;\n    }\n\n    return negate ? out.negate() : out;\n  }\n  /** @nocollapse */\n\n\n  static convertArray(values) {\n    const data = new Uint32Array(values.length * 2);\n\n    for (let i = -1, n = values.length; ++i < n;) {\n      Int64.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));\n    }\n\n    return data;\n  }\n  /** @nocollapse */\n\n\n  static multiply(left, right) {\n    let rtrn = new Int64(new Uint32Array(left.buffer));\n    return rtrn.times(right);\n  }\n  /** @nocollapse */\n\n\n  static add(left, right) {\n    let rtrn = new Int64(new Uint32Array(left.buffer));\n    return rtrn.plus(right);\n  }\n\n}\n/** @ignore */\n\nexport class Int128 {\n  constructor(buffer) {\n    this.buffer = buffer; // buffer[3] MSB (high)\n    // buffer[2]\n    // buffer[1]\n    // buffer[0] LSB (low)\n  }\n\n  high() {\n    return new Int64(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));\n  }\n\n  low() {\n    return new Int64(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset, 2));\n  }\n\n  negate() {\n    this.buffer[0] = ~this.buffer[0] + 1;\n    this.buffer[1] = ~this.buffer[1];\n    this.buffer[2] = ~this.buffer[2];\n    this.buffer[3] = ~this.buffer[3];\n\n    if (this.buffer[0] == 0) {\n      ++this.buffer[1];\n    }\n\n    if (this.buffer[1] == 0) {\n      ++this.buffer[2];\n    }\n\n    if (this.buffer[2] == 0) {\n      ++this.buffer[3];\n    }\n\n    return this;\n  }\n\n  times(other) {\n    // Break the left and right numbers into 32 bit chunks\n    // so that we can multiply them without overflow.\n    const L0 = new Uint64(new Uint32Array([this.buffer[3], 0]));\n    const L1 = new Uint64(new Uint32Array([this.buffer[2], 0]));\n    const L2 = new Uint64(new Uint32Array([this.buffer[1], 0]));\n    const L3 = new Uint64(new Uint32Array([this.buffer[0], 0]));\n    const R0 = new Uint64(new Uint32Array([other.buffer[3], 0]));\n    const R1 = new Uint64(new Uint32Array([other.buffer[2], 0]));\n    const R2 = new Uint64(new Uint32Array([other.buffer[1], 0]));\n    const R3 = new Uint64(new Uint32Array([other.buffer[0], 0]));\n    let product = Uint64.multiply(L3, R3);\n    this.buffer[0] = product.low();\n    let sum = new Uint64(new Uint32Array([product.high(), 0]));\n    product = Uint64.multiply(L2, R3);\n    sum.plus(product);\n    product = Uint64.multiply(L3, R2);\n    sum.plus(product);\n    this.buffer[1] = sum.low();\n    this.buffer[3] = sum.lessThan(product) ? 1 : 0;\n    this.buffer[2] = sum.high();\n    let high = new Uint64(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));\n    high.plus(Uint64.multiply(L1, R3)).plus(Uint64.multiply(L2, R2)).plus(Uint64.multiply(L3, R1));\n    this.buffer[3] += Uint64.multiply(L0, R3).plus(Uint64.multiply(L1, R2)).plus(Uint64.multiply(L2, R1)).plus(Uint64.multiply(L3, R0)).low();\n    return this;\n  }\n\n  plus(other) {\n    let sums = new Uint32Array(4);\n    sums[3] = this.buffer[3] + other.buffer[3] >>> 0;\n    sums[2] = this.buffer[2] + other.buffer[2] >>> 0;\n    sums[1] = this.buffer[1] + other.buffer[1] >>> 0;\n    sums[0] = this.buffer[0] + other.buffer[0] >>> 0;\n\n    if (sums[0] < this.buffer[0] >>> 0) {\n      ++sums[1];\n    }\n\n    if (sums[1] < this.buffer[1] >>> 0) {\n      ++sums[2];\n    }\n\n    if (sums[2] < this.buffer[2] >>> 0) {\n      ++sums[3];\n    }\n\n    this.buffer[3] = sums[3];\n    this.buffer[2] = sums[2];\n    this.buffer[1] = sums[1];\n    this.buffer[0] = sums[0];\n    return this;\n  }\n\n  hex() {\n    return `${intAsHex(this.buffer[3])} ${intAsHex(this.buffer[2])} ${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;\n  }\n  /** @nocollapse */\n\n\n  static multiply(left, right) {\n    let rtrn = new Int128(new Uint32Array(left.buffer));\n    return rtrn.times(right);\n  }\n  /** @nocollapse */\n\n\n  static add(left, right) {\n    let rtrn = new Int128(new Uint32Array(left.buffer));\n    return rtrn.plus(right);\n  }\n  /** @nocollapse */\n\n\n  static from(val, out_buffer = new Uint32Array(4)) {\n    return Int128.fromString(typeof val === 'string' ? val : val.toString(), out_buffer);\n  }\n  /** @nocollapse */\n\n\n  static fromNumber(num, out_buffer = new Uint32Array(4)) {\n    // Always parse numbers as strings - pulling out high and low bits\n    // directly seems to lose precision sometimes\n    // For example:\n    //     > -4613034156400212000 >>> 0\n    //     721782784\n    // The correct lower 32-bits are 721782752\n    return Int128.fromString(num.toString(), out_buffer);\n  }\n  /** @nocollapse */\n\n\n  static fromString(str, out_buffer = new Uint32Array(4)) {\n    // TODO: Assert that out_buffer is 0 and length = 4\n    const negate = str.startsWith('-');\n    const length = str.length;\n    let out = new Int128(out_buffer);\n\n    for (let posn = negate ? 1 : 0; posn < length;) {\n      const group = kInt32DecimalDigits < length - posn ? kInt32DecimalDigits : length - posn;\n      const chunk = new Int128(new Uint32Array([parseInt(str.substr(posn, group), 10), 0, 0, 0]));\n      const multiple = new Int128(new Uint32Array([kPowersOfTen[group], 0, 0, 0]));\n      out.times(multiple);\n      out.plus(chunk);\n      posn += group;\n    }\n\n    return negate ? out.negate() : out;\n  }\n  /** @nocollapse */\n\n\n  static convertArray(values) {\n    // TODO: Distinguish between string and number at compile-time\n    const data = new Uint32Array(values.length * 4);\n\n    for (let i = -1, n = values.length; ++i < n;) {\n      Int128.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 4 * 4 * i, 4));\n    }\n\n    return data;\n  }\n\n}","map":{"version":3,"sources":["util/int.ts"],"names":[],"mappings":"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","sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/** @ignore */\nconst carryBit16 = 1 << 16;\n\n/** @ignore */\nfunction intAsHex(value: number): string {\n    if (value < 0) {\n        value = 0xFFFFFFFF + value + 1;\n    }\n    return `0x${value.toString(16)}`;\n}\n\n/** @ignore */\nconst kInt32DecimalDigits = 8;\n/** @ignore */\nconst kPowersOfTen = [1,\n                      10,\n                      100,\n                      1000,\n                      10000,\n                      100000,\n                      1000000,\n                      10000000,\n                      100000000];\n\n/** @ignore */\nexport class BaseInt64 {\n    constructor (protected buffer: Uint32Array) {}\n\n    public high(): number { return this.buffer[1]; }\n    public low (): number { return this.buffer[0]; }\n\n    protected _times(other: BaseInt64) {\n        // Break the left and right numbers into 16 bit chunks\n        // so that we can multiply them without overflow.\n        const L = new Uint32Array([\n            this.buffer[1] >>> 16,\n            this.buffer[1] & 0xFFFF,\n            this.buffer[0] >>> 16,\n            this.buffer[0] & 0xFFFF\n        ]);\n\n        const R = new Uint32Array([\n            other.buffer[1] >>> 16,\n            other.buffer[1] & 0xFFFF,\n            other.buffer[0] >>> 16,\n            other.buffer[0] & 0xFFFF\n        ]);\n\n        let product = L[3] * R[3];\n        this.buffer[0] = product & 0xFFFF;\n\n        let sum = product >>> 16;\n\n        product = L[2] * R[3];\n        sum += product;\n\n        product = (L[3] * R[2]) >>> 0;\n        sum += product;\n\n        this.buffer[0] += sum << 16;\n\n        this.buffer[1] = (sum >>> 0 < product ? carryBit16 : 0);\n\n        this.buffer[1] += sum >>> 16;\n        this.buffer[1] += L[1] * R[3] + L[2] * R[2] + L[3] * R[1];\n        this.buffer[1] += (L[0] * R[3] + L[1] * R[2] + L[2] * R[1] + L[3] * R[0]) << 16;\n\n        return this;\n      }\n\n    protected _plus(other: BaseInt64) {\n        const sum = (this.buffer[0] + other.buffer[0]) >>> 0;\n        this.buffer[1] += other.buffer[1];\n        if (sum < (this.buffer[0] >>> 0)) {\n          ++this.buffer[1];\n        }\n        this.buffer[0] = sum;\n    }\n\n    public lessThan(other: BaseInt64): boolean {\n        return this.buffer[1] < other.buffer[1] ||\n            (this.buffer[1] === other.buffer[1] && this.buffer[0] < other.buffer[0]);\n    }\n\n    public equals(other: BaseInt64): boolean {\n        return this.buffer[1] === other.buffer[1] && this.buffer[0] == other.buffer[0];\n    }\n\n    public greaterThan(other: BaseInt64): boolean {\n        return other.lessThan(this);\n    }\n\n    public hex(): string {\n        return `${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;\n    }\n}\n\n/** @ignore */\nexport class Uint64 extends BaseInt64 {\n    public times(other: Uint64): Uint64 {\n        this._times(other);\n        return this;\n    }\n\n    public plus(other: Uint64): Uint64 {\n        this._plus(other);\n        return this;\n    }\n\n    /** @nocollapse */\n    public static from(val: any, out_buffer = new Uint32Array(2)): Uint64 {\n        return Uint64.fromString(\n            typeof(val) === 'string' ? val : val.toString(),\n            out_buffer\n        );\n    }\n\n    /** @nocollapse */\n    public static fromNumber(num: number, out_buffer = new Uint32Array(2)): Uint64 {\n        // Always parse numbers as strings - pulling out high and low bits\n        // directly seems to lose precision sometimes\n        // For example:\n        //     > -4613034156400212000 >>> 0\n        //     721782784\n        // The correct lower 32-bits are 721782752\n        return Uint64.fromString(num.toString(), out_buffer);\n    }\n\n    /** @nocollapse */\n    public static fromString(str: string, out_buffer = new Uint32Array(2)): Uint64 {\n        const length = str.length;\n\n        let out = new Uint64(out_buffer);\n        for (let posn = 0; posn < length;) {\n            const group = kInt32DecimalDigits < length - posn ?\n                          kInt32DecimalDigits : length - posn;\n            const chunk = new Uint64(new Uint32Array([parseInt(str.substr(posn, group), 10), 0]));\n            const multiple = new Uint64(new Uint32Array([kPowersOfTen[group], 0]));\n\n            out.times(multiple);\n            out.plus(chunk);\n\n            posn += group;\n        }\n\n        return out;\n    }\n\n    /** @nocollapse */\n    public static convertArray(values: (string|number)[]): Uint32Array {\n        const data = new Uint32Array(values.length * 2);\n        for (let i = -1, n = values.length; ++i < n;) {\n            Uint64.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));\n        }\n        return data;\n    }\n\n    /** @nocollapse */\n    public static multiply(left: Uint64, right: Uint64): Uint64 {\n        let rtrn = new Uint64(new Uint32Array(left.buffer));\n        return rtrn.times(right);\n    }\n\n    /** @nocollapse */\n    public static add(left: Uint64, right: Uint64): Uint64 {\n        let rtrn = new Uint64(new Uint32Array(left.buffer));\n        return rtrn.plus(right);\n    }\n}\n\n/** @ignore */\nexport class Int64 extends BaseInt64 {\n    public negate(): Int64 {\n        this.buffer[0] = ~this.buffer[0] + 1;\n        this.buffer[1] = ~this.buffer[1];\n\n        if (this.buffer[0] == 0) { ++this.buffer[1]; }\n        return this;\n    }\n\n    public times(other: Int64): Int64 {\n        this._times(other);\n        return this;\n    }\n\n    public plus(other: Int64): Int64 {\n        this._plus(other);\n        return this;\n    }\n\n    public lessThan(other: Int64): boolean {\n        // force high bytes to be signed\n        const this_high = this.buffer[1] << 0;\n        const other_high = other.buffer[1] << 0;\n        return this_high < other_high ||\n            (this_high === other_high && this.buffer[0] < other.buffer[0]);\n    }\n\n    /** @nocollapse */\n    public static from(val: any, out_buffer = new Uint32Array(2)): Int64 {\n        return Int64.fromString(\n            typeof(val) === 'string' ? val : val.toString(),\n            out_buffer\n        );\n    }\n\n    /** @nocollapse */\n    public static fromNumber(num: number, out_buffer = new Uint32Array(2)): Int64 {\n        // Always parse numbers as strings - pulling out high and low bits\n        // directly seems to lose precision sometimes\n        // For example:\n        //     > -4613034156400212000 >>> 0\n        //     721782784\n        // The correct lower 32-bits are 721782752\n        return Int64.fromString(num.toString(), out_buffer);\n    }\n\n    /** @nocollapse */\n    public static fromString(str: string, out_buffer = new Uint32Array(2)): Int64 {\n        // TODO: Assert that out_buffer is 0 and length = 2\n        const negate = str.startsWith('-');\n        const length = str.length;\n\n        let out = new Int64(out_buffer);\n        for (let posn = negate ? 1 : 0; posn < length;) {\n            const group = kInt32DecimalDigits < length - posn ?\n                          kInt32DecimalDigits : length - posn;\n            const chunk = new Int64(new Uint32Array([parseInt(str.substr(posn, group), 10), 0]));\n            const multiple = new Int64(new Uint32Array([kPowersOfTen[group], 0]));\n\n            out.times(multiple);\n            out.plus(chunk);\n\n            posn += group;\n        }\n        return negate ? out.negate() : out;\n    }\n\n    /** @nocollapse */\n    public static convertArray(values: (string|number)[]): Uint32Array {\n        const data = new Uint32Array(values.length * 2);\n        for (let i = -1, n = values.length; ++i < n;) {\n            Int64.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));\n        }\n        return data;\n    }\n\n    /** @nocollapse */\n    public static multiply(left: Int64, right: Int64): Int64 {\n        let rtrn = new Int64(new Uint32Array(left.buffer));\n        return rtrn.times(right);\n    }\n\n    /** @nocollapse */\n    public static add(left: Int64, right: Int64): Int64 {\n        let rtrn = new Int64(new Uint32Array(left.buffer));\n        return rtrn.plus(right);\n    }\n}\n\n/** @ignore */\nexport class Int128 {\n    constructor (private buffer: Uint32Array) {\n        // buffer[3] MSB (high)\n        // buffer[2]\n        // buffer[1]\n        // buffer[0] LSB (low)\n    }\n\n    public high(): Int64 {\n        return new Int64(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));\n    }\n\n    public low(): Int64 {\n        return new Int64(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset, 2));\n    }\n\n    public negate(): Int128 {\n        this.buffer[0] = ~this.buffer[0] + 1;\n        this.buffer[1] = ~this.buffer[1];\n        this.buffer[2] = ~this.buffer[2];\n        this.buffer[3] = ~this.buffer[3];\n\n        if (this.buffer[0] == 0) { ++this.buffer[1]; }\n        if (this.buffer[1] == 0) { ++this.buffer[2]; }\n        if (this.buffer[2] == 0) { ++this.buffer[3]; }\n        return this;\n    }\n\n    public times(other: Int128): Int128 {\n        // Break the left and right numbers into 32 bit chunks\n        // so that we can multiply them without overflow.\n        const L0 = new Uint64(new Uint32Array([this.buffer[3],  0]));\n        const L1 = new Uint64(new Uint32Array([this.buffer[2],  0]));\n        const L2 = new Uint64(new Uint32Array([this.buffer[1],  0]));\n        const L3 = new Uint64(new Uint32Array([this.buffer[0],  0]));\n\n        const R0 = new Uint64(new Uint32Array([other.buffer[3], 0]));\n        const R1 = new Uint64(new Uint32Array([other.buffer[2], 0]));\n        const R2 = new Uint64(new Uint32Array([other.buffer[1], 0]));\n        const R3 = new Uint64(new Uint32Array([other.buffer[0], 0]));\n\n        let product = Uint64.multiply(L3, R3);\n        this.buffer[0] = product.low();\n\n        let sum = new Uint64(new Uint32Array([product.high(), 0]));\n\n        product = Uint64.multiply(L2, R3);\n        sum.plus(product);\n\n        product = Uint64.multiply(L3, R2);\n        sum.plus(product);\n\n        this.buffer[1] = sum.low();\n\n        this.buffer[3] = (sum.lessThan(product) ? 1 : 0);\n\n        this.buffer[2] = sum.high();\n        let high = new Uint64(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));\n\n        high.plus(Uint64.multiply(L1, R3))\n            .plus(Uint64.multiply(L2, R2))\n            .plus(Uint64.multiply(L3, R1));\n        this.buffer[3] += Uint64.multiply(L0, R3)\n                        .plus(Uint64.multiply(L1, R2))\n                        .plus(Uint64.multiply(L2, R1))\n                        .plus(Uint64.multiply(L3, R0)).low();\n\n        return this;\n    }\n\n    public plus(other: Int128): Int128 {\n        let sums = new Uint32Array(4);\n        sums[3] = (this.buffer[3] + other.buffer[3]) >>> 0;\n        sums[2] = (this.buffer[2] + other.buffer[2]) >>> 0;\n        sums[1] = (this.buffer[1] + other.buffer[1]) >>> 0;\n        sums[0] = (this.buffer[0] + other.buffer[0]) >>> 0;\n\n        if (sums[0] < (this.buffer[0] >>> 0)) {\n            ++sums[1];\n        }\n        if (sums[1] < (this.buffer[1] >>> 0)) {\n            ++sums[2];\n        }\n        if (sums[2] < (this.buffer[2] >>> 0)) {\n            ++sums[3];\n        }\n\n        this.buffer[3] = sums[3];\n        this.buffer[2] = sums[2];\n        this.buffer[1] = sums[1];\n        this.buffer[0] = sums[0];\n\n        return this;\n    }\n\n    public hex(): string {\n        return `${intAsHex(this.buffer[3])} ${intAsHex(this.buffer[2])} ${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;\n    }\n\n    /** @nocollapse */\n    public static multiply(left: Int128, right: Int128): Int128 {\n        let rtrn = new Int128(new Uint32Array(left.buffer));\n        return rtrn.times(right);\n    }\n\n    /** @nocollapse */\n    public static add(left: Int128, right: Int128): Int128 {\n        let rtrn = new Int128(new Uint32Array(left.buffer));\n        return rtrn.plus(right);\n    }\n\n    /** @nocollapse */\n    public static from(val: any, out_buffer = new Uint32Array(4)): Int128 {\n        return Int128.fromString(\n            typeof(val) === 'string' ? val : val.toString(),\n            out_buffer\n        );\n    }\n\n    /** @nocollapse */\n    public static fromNumber(num: number, out_buffer = new Uint32Array(4)): Int128 {\n        // Always parse numbers as strings - pulling out high and low bits\n        // directly seems to lose precision sometimes\n        // For example:\n        //     > -4613034156400212000 >>> 0\n        //     721782784\n        // The correct lower 32-bits are 721782752\n        return Int128.fromString(num.toString(), out_buffer);\n    }\n\n    /** @nocollapse */\n    public static fromString(str: string, out_buffer = new Uint32Array(4)): Int128 {\n        // TODO: Assert that out_buffer is 0 and length = 4\n        const negate = str.startsWith('-');\n        const length = str.length;\n\n        let out = new Int128(out_buffer);\n        for (let posn = negate ? 1 : 0; posn < length;) {\n            const group = kInt32DecimalDigits < length - posn ?\n                          kInt32DecimalDigits : length - posn;\n            const chunk = new Int128(new Uint32Array([parseInt(str.substr(posn, group), 10), 0, 0, 0]));\n            const multiple = new Int128(new Uint32Array([kPowersOfTen[group], 0, 0, 0]));\n\n            out.times(multiple);\n            out.plus(chunk);\n\n            posn += group;\n        }\n\n        return negate ? out.negate() : out;\n    }\n\n    /** @nocollapse */\n    public static convertArray(values: (string|number)[]): Uint32Array {\n        // TODO: Distinguish between string and number at compile-time\n        const data = new Uint32Array(values.length * 4);\n        for (let i = -1, n = values.length; ++i < n;) {\n            Int128.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 4 * 4 * i, 4));\n        }\n        return data;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}