{"ast":null,"code":"export function unpackIndexedGeometry(geometry) {\n  var indices = geometry.indices,\n      attributes = geometry.attributes;\n\n  if (!indices) {\n    return geometry;\n  }\n\n  var vertexCount = indices.value.length;\n  var unpackedAttributes = {};\n\n  for (var attributeName in attributes) {\n    var attribute = attributes[attributeName];\n    var constant = attribute.constant,\n        value = attribute.value,\n        size = attribute.size;\n\n    if (constant || !size) {\n      continue;\n    }\n\n    var unpackedValue = new value.constructor(vertexCount * size);\n\n    for (var x = 0; x < vertexCount; ++x) {\n      var index = indices.value[x];\n\n      for (var i = 0; i < size; i++) {\n        unpackedValue[x * size + i] = value[index * size + i];\n      }\n    }\n\n    unpackedAttributes[attributeName] = {\n      size: size,\n      value: unpackedValue\n    };\n  }\n\n  return {\n    attributes: Object.assign({}, attributes, unpackedAttributes)\n  };\n}","map":{"version":3,"sources":["../../../src/geometry/geometry-utils.js"],"names":["indices","attributes","geometry","vertexCount","unpackedAttributes","attribute","constant","value","size","unpackedValue","x","index","i","Object"],"mappings":"AAAA,OAAO,SAAA,qBAAA,CAAA,QAAA,EAAyC;AAAA,MACvCA,OADuC,GAChBE,QADgB,CAAA,OAAA;AAAA,MAC9BD,UAD8B,GAChBC,QADgB,CAAA,UAAA;;AAE9C,MAAI,CAAJ,OAAA,EAAc;AACZ,WAAA,QAAA;AACD;;AAED,MAAMC,WAAW,GAAGH,OAAO,CAAPA,KAAAA,CAApB,MAAA;AACA,MAAMI,kBAAkB,GAAxB,EAAA;;AAEA,OAAK,IAAL,aAAA,IAAA,UAAA,EAAwC;AACtC,QAAMC,SAAS,GAAGJ,UAAU,CAA5B,aAA4B,CAA5B;AADsC,QAE/BK,QAF+B,GAEND,SAFM,CAAA,QAAA;AAAA,QAErBE,KAFqB,GAENF,SAFM,CAAA,KAAA;AAAA,QAEdG,IAFc,GAENH,SAFM,CAAA,IAAA;;AAGtC,QAAIC,QAAQ,IAAI,CAAhB,IAAA,EAAuB;AACrB;AACD;;AACD,QAAMG,aAAa,GAAG,IAAIF,KAAK,CAAT,WAAA,CAAsBJ,WAAW,GAAvD,IAAsB,CAAtB;;AACA,SAAK,IAAIO,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,WAAA,EAAiC,EAAjC,CAAA,EAAsC;AACpC,UAAMC,KAAK,GAAGX,OAAO,CAAPA,KAAAA,CAAd,CAAcA,CAAd;;AACA,WAAK,IAAIY,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,IAAA,EAA0BA,CAA1B,EAAA,EAA+B;AAC7BH,QAAAA,aAAa,CAACC,CAAC,GAADA,IAAAA,GAAdD,CAAa,CAAbA,GAA8BF,KAAK,CAACI,KAAK,GAALA,IAAAA,GAApCF,CAAmC,CAAnCA;AACD;AACF;;AACDL,IAAAA,kBAAkB,CAAlBA,aAAkB,CAAlBA,GAAoC;AAACI,MAAAA,IAAI,EAAL,IAAA;AAAOD,MAAAA,KAAK,EAAEE;AAAd,KAApCL;AACD;;AAED,SAAO;AACLH,IAAAA,UAAU,EAAEY,MAAM,CAANA,MAAAA,CAAAA,EAAAA,EAAAA,UAAAA,EAAAA,kBAAAA;AADP,GAAP;AAGD","sourcesContent":["export function unpackIndexedGeometry(geometry) {\n  const {indices, attributes} = geometry;\n  if (!indices) {\n    return geometry;\n  }\n\n  const vertexCount = indices.value.length;\n  const unpackedAttributes = {};\n\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    const {constant, value, size} = attribute;\n    if (constant || !size) {\n      continue; // eslint-disable-line\n    }\n    const unpackedValue = new value.constructor(vertexCount * size);\n    for (let x = 0; x < vertexCount; ++x) {\n      const index = indices.value[x];\n      for (let i = 0; i < size; i++) {\n        unpackedValue[x * size + i] = value[index * size + i];\n      }\n    }\n    unpackedAttributes[attributeName] = {size, value: unpackedValue};\n  }\n\n  return {\n    attributes: Object.assign({}, attributes, unpackedAttributes)\n  };\n}\n"]},"metadata":{},"sourceType":"module"}