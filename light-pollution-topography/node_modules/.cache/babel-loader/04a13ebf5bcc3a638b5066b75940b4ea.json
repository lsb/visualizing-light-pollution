{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { DataType } from './type';\nimport { selectArgs } from './util/args';\nimport { selectFieldArgs } from './util/args';\nimport { instance as comparer } from './visitor/typecomparator';\nexport class Schema {\n  constructor(fields = [], metadata, dictionaries) {\n    this.fields = fields || [];\n    this.metadata = metadata || new Map();\n\n    if (!dictionaries) {\n      dictionaries = generateDictionaryMap(fields);\n    }\n\n    this.dictionaries = dictionaries;\n  }\n  /** @nocollapse */\n\n\n  static from(...args) {\n    return Schema.new(args[0], args[1]);\n  }\n  /** @nocollapse */\n\n\n  static new(...args) {\n    return new Schema(selectFieldArgs(args)[0]);\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Schema';\n  }\n\n  toString() {\n    return `Schema<{ ${this.fields.map((f, i) => `${i}: ${f}`).join(', ')} }>`;\n  }\n\n  compareTo(other) {\n    return comparer.compareSchemas(this, other);\n  }\n\n  select(...columnNames) {\n    const names = columnNames.reduce((xs, x) => (xs[x] = true) && xs, Object.create(null));\n    return new Schema(this.fields.filter(f => names[f.name]), this.metadata);\n  }\n\n  selectAt(...columnIndices) {\n    return new Schema(columnIndices.map(i => this.fields[i]).filter(Boolean), this.metadata);\n  }\n\n  assign(...args) {\n    const other = args[0] instanceof Schema ? args[0] : new Schema(selectArgs(Field, args));\n    const curFields = [...this.fields];\n    const metadata = mergeMaps(mergeMaps(new Map(), this.metadata), other.metadata);\n    const newFields = other.fields.filter(f2 => {\n      const i = curFields.findIndex(f => f.name === f2.name);\n      return ~i ? (curFields[i] = f2.clone({\n        metadata: mergeMaps(mergeMaps(new Map(), curFields[i].metadata), f2.metadata)\n      })) && false : true;\n    });\n    const newDictionaries = generateDictionaryMap(newFields, new Map());\n    return new Schema([...curFields, ...newFields], metadata, new Map([...this.dictionaries, ...newDictionaries]));\n  }\n\n}\nexport class Field {\n  constructor(name, type, nullable = false, metadata) {\n    this.name = name;\n    this.type = type;\n    this.nullable = nullable;\n    this.metadata = metadata || new Map();\n  }\n  /** @nocollapse */\n\n\n  static new(...args) {\n    let [name, type, nullable, metadata] = args;\n\n    if (args[0] && typeof args[0] === 'object') {\n      ({\n        name\n      } = args[0]);\n      type === undefined && (type = args[0].type);\n      nullable === undefined && (nullable = args[0].nullable);\n      metadata === undefined && (metadata = args[0].metadata);\n    }\n\n    return new Field(`${name}`, type, nullable, metadata);\n  }\n\n  get typeId() {\n    return this.type.typeId;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Field';\n  }\n\n  toString() {\n    return `${this.name}: ${this.type}`;\n  }\n\n  compareTo(other) {\n    return comparer.compareField(this, other);\n  }\n\n  clone(...args) {\n    let [name, type, nullable, metadata] = args;\n    !args[0] || typeof args[0] !== 'object' ? [name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata] = args : ({\n      name = this.name,\n      type = this.type,\n      nullable = this.nullable,\n      metadata = this.metadata\n    } = args[0]);\n    return Field.new(name, type, nullable, metadata);\n  }\n\n}\n/** @ignore */\n\nfunction mergeMaps(m1, m2) {\n  return new Map([...(m1 || new Map()), ...(m2 || new Map())]);\n}\n/** @ignore */\n\n\nfunction generateDictionaryMap(fields, dictionaries = new Map()) {\n  for (let i = -1, n = fields.length; ++i < n;) {\n    const field = fields[i];\n    const type = field.type;\n\n    if (DataType.isDictionary(type)) {\n      if (!dictionaries.has(type.id)) {\n        dictionaries.set(type.id, type.dictionary);\n      } else if (dictionaries.get(type.id) !== type.dictionary) {\n        throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);\n      }\n    }\n\n    if (type.children && type.children.length > 0) {\n      generateDictionaryMap(type.children, dictionaries);\n    }\n  }\n\n  return dictionaries;\n} // Add these here so they're picked up by the externs creator\n// in the build, and closure-compiler doesn't minify them away\n\n\nSchema.prototype.fields = null;\nSchema.prototype.metadata = null;\nSchema.prototype.dictionaries = null;\nField.prototype.type = null;\nField.prototype.name = null;\nField.prototype.nullable = null;\nField.prototype.metadata = null;","map":{"version":3,"sources":["schema.ts"],"names":[],"mappings":"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","sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Data } from './data';\nimport { Vector } from './vector';\nimport { DataType } from './type';\nimport { selectArgs } from './util/args';\nimport { selectFieldArgs } from './util/args';\nimport { instance as comparer } from './visitor/typecomparator';\n\ntype VectorMap = { [key: string]: Vector };\ntype Fields<T extends { [key: string]: DataType }> = (keyof T)[] | Field<T[keyof T]>[];\ntype ChildData<T extends { [key: string]: DataType }> = T[keyof T][] | Data<T[keyof T]>[] | Vector<T[keyof T]>[];\n\nexport class Schema<T extends { [key: string]: DataType } = any> {\n\n    public static from<T extends { [key: string]: DataType } = any>(children: T): Schema<T>;\n    public static from<T extends VectorMap = any>(children: T): Schema<{ [P in keyof T]: T[P]['type'] }>;\n    public static from<T extends { [key: string]: DataType } = any>(children: ChildData<T>, fields?: Fields<T>): Schema<T>;\n    /** @nocollapse */\n    public static from(...args: any[]) {\n        return Schema.new(args[0], args[1]);\n    }\n\n    public static new<T extends { [key: string]: DataType } = any>(children: T): Schema<T>;\n    public static new<T extends VectorMap = any>(children: T): Schema<{ [P in keyof T]: T[P]['type'] }>;\n    public static new<T extends { [key: string]: DataType } = any>(children: ChildData<T>, fields?: Fields<T>): Schema<T>;\n    /** @nocollapse */\n    public static new(...args: any[]) {\n        return new Schema(selectFieldArgs(args)[0]);\n    }\n\n    public readonly fields: Field<T[keyof T]>[];\n    public readonly metadata: Map<string, string>;\n    public readonly dictionaries: Map<number, DataType>;\n\n    constructor(fields: Field[] = [],\n                metadata?: Map<string, string> | null,\n                dictionaries?: Map<number, DataType> | null) {\n        this.fields = (fields || []) as Field<T[keyof T]>[];\n        this.metadata = metadata || new Map();\n        if (!dictionaries) {\n            dictionaries = generateDictionaryMap(fields);\n        }\n        this.dictionaries = dictionaries;\n    }\n    public get [Symbol.toStringTag]() { return 'Schema'; }\n    public toString() {\n        return `Schema<{ ${this.fields.map((f, i) => `${i}: ${f}`).join(', ')} }>`;\n    }\n\n    public compareTo(other?: Schema | null): other is Schema<T> {\n        return comparer.compareSchemas(this, other);\n    }\n\n    public select<K extends keyof T = any>(...columnNames: K[]) {\n        const names = columnNames.reduce((xs, x) => (xs[x] = true) && xs, Object.create(null));\n        return new Schema<{ [P in K]: T[P] }>(this.fields.filter((f) => names[f.name]), this.metadata);\n    }\n    public selectAt<K extends T[keyof T] = any>(...columnIndices: number[]) {\n        return new Schema<{ [key: string]: K }>(columnIndices.map((i) => this.fields[i]).filter(Boolean), this.metadata);\n    }\n\n    public assign<R extends { [key: string]: DataType } = any>(schema: Schema<R>): Schema<T & R>;\n    public assign<R extends { [key: string]: DataType } = any>(...fields: (Field<R[keyof R]> | Field<R[keyof R]>[])[]): Schema<T & R>;\n    public assign<R extends { [key: string]: DataType } = any>(...args: (Schema<R> | Field<R[keyof R]> | Field<R[keyof R]>[])[]) {\n\n        const other = args[0] instanceof Schema ? args[0] as Schema<R>\n            : new Schema<R>(selectArgs<Field<R[keyof R]>>(Field, args));\n\n        const curFields = [...this.fields] as Field[];\n        const metadata = mergeMaps(mergeMaps(new Map(), this.metadata), other.metadata);\n        const newFields = other.fields.filter((f2) => {\n            const i = curFields.findIndex((f) => f.name === f2.name);\n            return ~i ? (curFields[i] = f2.clone({\n                metadata: mergeMaps(mergeMaps(new Map(), curFields[i].metadata), f2.metadata)\n            })) && false : true;\n        }) as Field[];\n\n        const newDictionaries = generateDictionaryMap(newFields, new Map());\n\n        return new Schema<T & R>(\n            [...curFields, ...newFields], metadata,\n            new Map([...this.dictionaries, ...newDictionaries])\n        );\n    }\n}\n\nexport class Field<T extends DataType = any> {\n\n    public static new<T extends DataType = any>(props: { name: string | number, type: T, nullable?: boolean, metadata?: Map<string, string> | null }): Field<T>;\n    public static new<T extends DataType = any>(name: string | number | Field<T>, type: T, nullable?: boolean, metadata?: Map<string, string> | null): Field<T>;\n    /** @nocollapse */\n    public static new<T extends DataType = any>(...args: any[]) {\n        let [name, type, nullable, metadata] = args;\n        if (args[0] && typeof args[0] === 'object') {\n            ({ name } = args[0]);\n            (type === undefined) && (type = args[0].type);\n            (nullable === undefined) && (nullable = args[0].nullable);\n            (metadata === undefined) && (metadata = args[0].metadata);\n        }\n        return new Field<T>(`${name}`, type, nullable, metadata);\n    }\n\n    public readonly type: T;\n    public readonly name: string;\n    public readonly nullable: boolean;\n    public readonly metadata: Map<string, string>;\n\n    constructor(name: string, type: T, nullable = false, metadata?: Map<string, string> | null) {\n        this.name = name;\n        this.type = type;\n        this.nullable = nullable;\n        this.metadata = metadata || new Map();\n    }\n\n    public get typeId() { return this.type.typeId; }\n    public get [Symbol.toStringTag]() { return 'Field'; }\n    public toString() { return `${this.name}: ${this.type}`; }\n    public compareTo(other?: Field | null): other is Field<T> {\n        return comparer.compareField(this, other);\n    }\n    public clone<R extends DataType = T>(props: { name?: string | number, type?: R, nullable?: boolean, metadata?: Map<string, string> | null }): Field<R>;\n    public clone<R extends DataType = T>(name?: string | number | Field<T>, type?: R, nullable?: boolean, metadata?: Map<string, string> | null): Field<R>;\n    public clone<R extends DataType = T>(...args: any[]) {\n        let [name, type, nullable, metadata] = args;\n        (!args[0] || typeof args[0] !== 'object')\n            ? ([name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata] = args)\n            : ({name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata} = args[0]);\n        return Field.new<R>(name, type, nullable, metadata);\n    }\n}\n\n/** @ignore */\nfunction mergeMaps<TKey, TVal>(m1?: Map<TKey, TVal> | null, m2?: Map<TKey, TVal> | null): Map<TKey, TVal> {\n    return new Map([...(m1 || new Map()), ...(m2 || new Map())]);\n}\n\n/** @ignore */\nfunction generateDictionaryMap(fields: Field[], dictionaries = new Map<number, DataType>()): Map<number, DataType> {\n\n    for (let i = -1, n = fields.length; ++i < n;) {\n        const field = fields[i];\n        const type = field.type;\n        if (DataType.isDictionary(type)) {\n            if (!dictionaries.has(type.id)) {\n                dictionaries.set(type.id, type.dictionary);\n            } else if (dictionaries.get(type.id) !== type.dictionary) {\n                throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);\n            }\n        }\n        if (type.children && type.children.length > 0) {\n            generateDictionaryMap(type.children, dictionaries);\n        }\n    }\n\n    return dictionaries;\n}\n\n// Add these here so they're picked up by the externs creator\n// in the build, and closure-compiler doesn't minify them away\n(Schema.prototype as any).fields = null;\n(Schema.prototype as any).metadata = null;\n(Schema.prototype as any).dictionaries = null;\n\n(Field.prototype as any).type = null;\n(Field.prototype as any).name = null;\n(Field.prototype as any).nullable = null;\n(Field.prototype as any).metadata = null;\n"]},"metadata":{},"sourceType":"module"}