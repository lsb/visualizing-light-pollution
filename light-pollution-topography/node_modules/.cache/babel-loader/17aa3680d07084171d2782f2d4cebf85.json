{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport assert from '../utils/assert';\nimport parseImage from '../parsers/parse-image';\nimport { getImageSize } from '../parsed-image-api/parsed-image-api';\nimport { generateUrl } from './generate-url';\nimport { deepLoad, shallowLoad } from './deep-load';\nexport function loadImage(_x) {\n  return _loadImage.apply(this, arguments);\n}\n\nfunction _loadImage() {\n  _loadImage = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(getUrl) {\n    var options,\n        imageUrls,\n        _args = arguments;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n            _context.next = 3;\n            return getImageUrls(getUrl, options);\n\n          case 3:\n            imageUrls = _context.sent;\n            _context.next = 6;\n            return deepLoad(imageUrls, parseImage, options);\n\n          case 6:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _loadImage.apply(this, arguments);\n}\n\nexport function getImageUrls(_x2, _x3) {\n  return _getImageUrls.apply(this, arguments);\n}\n\nfunction _getImageUrls() {\n  _getImageUrls = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(getUrl, options) {\n    var urlOptions,\n        mipLevels,\n        _args2 = arguments;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            urlOptions = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {};\n            mipLevels = options && options.image && options.image.mipLevels || 0;\n\n            if (!(mipLevels !== 0)) {\n              _context2.next = 8;\n              break;\n            }\n\n            _context2.next = 5;\n            return getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions);\n\n          case 5:\n            _context2.t0 = _context2.sent;\n            _context2.next = 9;\n            break;\n\n          case 8:\n            _context2.t0 = generateUrl(getUrl, options, urlOptions);\n\n          case 9:\n            return _context2.abrupt(\"return\", _context2.t0);\n\n          case 10:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _getImageUrls.apply(this, arguments);\n}\n\nfunction getMipmappedImageUrls(_x4, _x5, _x6, _x7) {\n  return _getMipmappedImageUrls.apply(this, arguments);\n}\n\nfunction _getMipmappedImageUrls() {\n  _getMipmappedImageUrls = _asyncToGenerator(_regeneratorRuntime.mark(function _callee3(getUrl, mipLevels, options, urlOptions) {\n    var urls, url, image, _getImageSize, width, height, mipLevel, _url;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            urls = [];\n\n            if (!(mipLevels === 'auto')) {\n              _context3.next = 9;\n              break;\n            }\n\n            url = generateUrl(getUrl, options, _objectSpread({}, urlOptions, {\n              lod: 0\n            }));\n            _context3.next = 5;\n            return shallowLoad(url, parseImage, options);\n\n          case 5:\n            image = _context3.sent;\n            _getImageSize = getImageSize(image), width = _getImageSize.width, height = _getImageSize.height;\n            mipLevels = getMipLevels({\n              width: width,\n              height: height\n            });\n            urls.push(url);\n\n          case 9:\n            assert(mipLevels > 0);\n\n            for (mipLevel = urls.length; mipLevel < mipLevels; ++mipLevel) {\n              _url = generateUrl(getUrl, options, _objectSpread({}, urlOptions, {\n                lod: mipLevel\n              }));\n              urls.push(_url);\n            }\n\n            return _context3.abrupt(\"return\", urls);\n\n          case 12:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _getMipmappedImageUrls.apply(this, arguments);\n}\n\nexport function getMipLevels(_ref) {\n  var width = _ref.width,\n      height = _ref.height;\n  return 1 + Math.floor(Math.log2(Math.max(width, height)));\n}","map":{"version":3,"sources":["../../../../src/lib/texture-loading-api/load-image.js"],"names":["options","imageUrls","getImageUrls","deepLoad","urlOptions","mipLevels","getMipmappedImageUrls","generateUrl","urls","url","lod","image","shallowLoad","width","height","getImageSize","getMipLevels","assert","mipLevel","Math"],"mappings":"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","sourcesContent":["import assert from '../utils/assert';\nimport parseImage from '../parsers/parse-image';\nimport {getImageSize} from '../parsed-image-api/parsed-image-api';\nimport {generateUrl} from './generate-url';\nimport {deepLoad, shallowLoad} from './deep-load';\n\nexport async function loadImage(getUrl, options = {}) {\n  const imageUrls = await getImageUrls(getUrl, options);\n  return await deepLoad(imageUrls, parseImage, options);\n}\n\nexport async function getImageUrls(getUrl, options, urlOptions = {}) {\n  const mipLevels = (options && options.image && options.image.mipLevels) || 0;\n  return mipLevels !== 0\n    ? await getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions)\n    : generateUrl(getUrl, options, urlOptions);\n}\n\nasync function getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions) {\n  const urls = [];\n\n  // If no mip levels supplied, we need to load the level 0 image and calculate based on size\n  if (mipLevels === 'auto') {\n    const url = generateUrl(getUrl, options, {...urlOptions, lod: 0});\n    const image = await shallowLoad(url, parseImage, options);\n\n    const {width, height} = getImageSize(image);\n    mipLevels = getMipLevels({width, height});\n\n    // TODO - push image and make `deepLoad` pass through non-url values, avoid loading twice?\n    urls.push(url);\n  }\n\n  // We now know how many mipLevels we need, remaining image urls can now be constructed\n  assert(mipLevels > 0);\n\n  for (let mipLevel = urls.length; mipLevel < mipLevels; ++mipLevel) {\n    const url = generateUrl(getUrl, options, {...urlOptions, lod: mipLevel});\n    urls.push(url);\n  }\n\n  return urls;\n}\n\n// Calculates number of mipmaps based on texture size (log2)\nexport function getMipLevels({width, height}) {\n  return 1 + Math.floor(Math.log2(Math.max(width, height)));\n}\n"]},"metadata":{},"sourceType":"module"}