{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { Vector } from '../vector';\nimport { MessageHeader } from '../enum';\nimport { Footer } from './metadata/file';\nimport streamAdapters from '../io/adapters';\nimport { ByteStream, AsyncByteStream } from '../io/stream';\nimport { RandomAccessFile, AsyncRandomAccessFile } from '../io/file';\nimport { VectorLoader, JSONVectorLoader } from '../visitor/vectorloader';\nimport { RecordBatch, _InternalEmptyPlaceholderRecordBatch } from '../recordbatch';\nimport { ITERATOR_DONE, ReadableInterop } from '../io/interfaces';\nimport { MessageReader, AsyncMessageReader, JSONMessageReader, checkForMagicArrowString, magicLength, magicAndPadding, magicX2AndPadding } from './message';\nimport { isPromise, isIterable, isAsyncIterable, isIteratorResult, isArrowJSON, isFileHandle, isFetchResponse, isReadableDOMStream, isReadableNodeStream } from '../util/compat';\nexport class RecordBatchReader extends ReadableInterop {\n  constructor(impl) {\n    super();\n    this._impl = impl;\n  }\n\n  get closed() {\n    return this._impl.closed;\n  }\n\n  get schema() {\n    return this._impl.schema;\n  }\n\n  get autoDestroy() {\n    return this._impl.autoDestroy;\n  }\n\n  get dictionaries() {\n    return this._impl.dictionaries;\n  }\n\n  get numDictionaries() {\n    return this._impl.numDictionaries;\n  }\n\n  get numRecordBatches() {\n    return this._impl.numRecordBatches;\n  }\n\n  get footer() {\n    return this._impl.isFile() ? this._impl.footer : null;\n  }\n\n  isSync() {\n    return this._impl.isSync();\n  }\n\n  isAsync() {\n    return this._impl.isAsync();\n  }\n\n  isFile() {\n    return this._impl.isFile();\n  }\n\n  isStream() {\n    return this._impl.isStream();\n  }\n\n  next() {\n    return this._impl.next();\n  }\n\n  throw(value) {\n    return this._impl.throw(value);\n  }\n\n  return(value) {\n    return this._impl.return(value);\n  }\n\n  cancel() {\n    return this._impl.cancel();\n  }\n\n  reset(schema) {\n    this._impl.reset(schema);\n\n    this._DOMStream = undefined;\n    this._nodeStream = undefined;\n    return this;\n  }\n\n  open(options) {\n    const opening = this._impl.open(options);\n\n    return isPromise(opening) ? opening.then(() => this) : this;\n  }\n\n  readRecordBatch(index) {\n    return this._impl.isFile() ? this._impl.readRecordBatch(index) : null;\n  }\n\n  [Symbol.iterator]() {\n    return this._impl[Symbol.iterator]();\n  }\n\n  [Symbol.asyncIterator]() {\n    return this._impl[Symbol.asyncIterator]();\n  }\n\n  toDOMStream() {\n    return streamAdapters.toDOMStream(this.isSync() ? {\n      [Symbol.iterator]: () => this\n    } : {\n      [Symbol.asyncIterator]: () => this\n    });\n  }\n\n  toNodeStream() {\n    return streamAdapters.toNodeStream(this.isSync() ? {\n      [Symbol.iterator]: () => this\n    } : {\n      [Symbol.asyncIterator]: () => this\n    }, {\n      objectMode: true\n    });\n  }\n  /** @nocollapse */\n  // @ts-ignore\n\n\n  static throughNode(options) {\n    throw new Error(`\"throughNode\" not available in this environment`);\n  }\n  /** @nocollapse */\n\n\n  static throughDOM( // @ts-ignore\n  writableStrategy, // @ts-ignore\n  readableStrategy) {\n    throw new Error(`\"throughDOM\" not available in this environment`);\n  }\n  /** @nocollapse */\n\n\n  static from(source) {\n    if (source instanceof RecordBatchReader) {\n      return source;\n    } else if (isArrowJSON(source)) {\n      return fromArrowJSON(source);\n    } else if (isFileHandle(source)) {\n      return fromFileHandle(source);\n    } else if (isPromise(source)) {\n      return (async () => await RecordBatchReader.from((await source)))();\n    } else if (isFetchResponse(source) || isReadableDOMStream(source) || isReadableNodeStream(source) || isAsyncIterable(source)) {\n      return fromAsyncByteStream(new AsyncByteStream(source));\n    }\n\n    return fromByteStream(new ByteStream(source));\n  }\n  /** @nocollapse */\n\n\n  static readAll(source) {\n    if (source instanceof RecordBatchReader) {\n      return source.isSync() ? readAllSync(source) : readAllAsync(source);\n    } else if (isArrowJSON(source) || ArrayBuffer.isView(source) || isIterable(source) || isIteratorResult(source)) {\n      return readAllSync(source);\n    }\n\n    return readAllAsync(source);\n  }\n\n} //\n// Since TS is a structural type system, we define the following subclass stubs\n// so that concrete types exist to associate with with the interfaces below.\n//\n// The implementation for each RecordBatchReader is hidden away in the set of\n// `RecordBatchReaderImpl` classes in the second half of this file. This allows\n// us to export a single RecordBatchReader class, and swap out the impl based\n// on the io primitives or underlying arrow (JSON, file, or stream) at runtime.\n//\n// Async/await makes our job a bit harder, since it forces everything to be\n// either fully sync or fully async. This is why the logic for the reader impls\n// has been duplicated into both sync and async variants. Since the RBR\n// delegates to its impl, an RBR with an AsyncRecordBatchFileReaderImpl for\n// example will return async/await-friendly Promises, but one with a (sync)\n// RecordBatchStreamReaderImpl will always return values. Nothing should be\n// different about their logic, aside from the async handling. This is also why\n// this code looks highly structured, as it should be nearly identical and easy\n// to follow.\n//\n\n/** @ignore */\n\nexport class RecordBatchStreamReader extends RecordBatchReader {\n  constructor(_impl) {\n    super(_impl);\n    this._impl = _impl;\n  }\n\n  [Symbol.iterator]() {\n    return this._impl[Symbol.iterator]();\n  }\n\n  async *[Symbol.asyncIterator]() {\n    yield* this[Symbol.iterator]();\n  }\n\n}\n/** @ignore */\n\nexport class AsyncRecordBatchStreamReader extends RecordBatchReader {\n  constructor(_impl) {\n    super(_impl);\n    this._impl = _impl;\n  }\n\n  [Symbol.iterator]() {\n    throw new Error(`AsyncRecordBatchStreamReader is not Iterable`);\n  }\n\n  [Symbol.asyncIterator]() {\n    return this._impl[Symbol.asyncIterator]();\n  }\n\n}\n/** @ignore */\n\nexport class RecordBatchFileReader extends RecordBatchStreamReader {\n  constructor(_impl) {\n    super(_impl);\n    this._impl = _impl;\n  }\n\n}\n/** @ignore */\n\nexport class AsyncRecordBatchFileReader extends AsyncRecordBatchStreamReader {\n  constructor(_impl) {\n    super(_impl);\n    this._impl = _impl;\n  }\n\n}\n/** @ignore */\n\nclass RecordBatchReaderImpl {\n  constructor(dictionaries = new Map()) {\n    this.closed = false;\n    this.autoDestroy = true;\n    this._dictionaryIndex = 0;\n    this._recordBatchIndex = 0;\n    this.dictionaries = dictionaries;\n  }\n\n  get numDictionaries() {\n    return this._dictionaryIndex;\n  }\n\n  get numRecordBatches() {\n    return this._recordBatchIndex;\n  }\n\n  isSync() {\n    return false;\n  }\n\n  isAsync() {\n    return false;\n  }\n\n  isFile() {\n    return false;\n  }\n\n  isStream() {\n    return false;\n  }\n\n  reset(schema) {\n    this._dictionaryIndex = 0;\n    this._recordBatchIndex = 0;\n    this.schema = schema;\n    this.dictionaries = new Map();\n    return this;\n  }\n\n  _loadRecordBatch(header, body) {\n    return new RecordBatch(this.schema, header.length, this._loadVectors(header, body, this.schema.fields));\n  }\n\n  _loadDictionaryBatch(header, body) {\n    const {\n      id,\n      isDelta,\n      data\n    } = header;\n    const {\n      dictionaries,\n      schema\n    } = this;\n    const dictionary = dictionaries.get(id);\n\n    if (isDelta || !dictionary) {\n      const type = schema.dictionaries.get(id);\n      return dictionary && isDelta ? dictionary.concat(Vector.new(this._loadVectors(data, body, [type])[0])) : Vector.new(this._loadVectors(data, body, [type])[0]);\n    }\n\n    return dictionary;\n  }\n\n  _loadVectors(header, body, types) {\n    return new VectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);\n  }\n\n}\n/** @ignore */\n\n\nclass RecordBatchStreamReaderImpl extends RecordBatchReaderImpl {\n  constructor(source, dictionaries) {\n    super(dictionaries);\n    this._reader = !isArrowJSON(source) ? new MessageReader(this._handle = source) : new JSONMessageReader(this._handle = source);\n  }\n\n  isSync() {\n    return true;\n  }\n\n  isStream() {\n    return true;\n  }\n\n  [Symbol.iterator]() {\n    return this;\n  }\n\n  cancel() {\n    if (!this.closed && (this.closed = true)) {\n      this.reset()._reader.return();\n\n      this._reader = null;\n      this.dictionaries = null;\n    }\n  }\n\n  open(options) {\n    if (!this.closed) {\n      this.autoDestroy = shouldAutoDestroy(this, options);\n\n      if (!(this.schema || (this.schema = this._reader.readSchema()))) {\n        this.cancel();\n      }\n    }\n\n    return this;\n  }\n\n  throw(value) {\n    if (!this.closed && this.autoDestroy && (this.closed = true)) {\n      return this.reset()._reader.throw(value);\n    }\n\n    return ITERATOR_DONE;\n  }\n\n  return(value) {\n    if (!this.closed && this.autoDestroy && (this.closed = true)) {\n      return this.reset()._reader.return(value);\n    }\n\n    return ITERATOR_DONE;\n  }\n\n  next() {\n    if (this.closed) {\n      return ITERATOR_DONE;\n    }\n\n    let message,\n        {\n      _reader: reader\n    } = this;\n\n    while (message = this._readNextMessageAndValidate()) {\n      if (message.isSchema()) {\n        this.reset(message.header());\n      } else if (message.isRecordBatch()) {\n        this._recordBatchIndex++;\n        const header = message.header();\n        const buffer = reader.readMessageBody(message.bodyLength);\n\n        const recordBatch = this._loadRecordBatch(header, buffer);\n\n        return {\n          done: false,\n          value: recordBatch\n        };\n      } else if (message.isDictionaryBatch()) {\n        this._dictionaryIndex++;\n        const header = message.header();\n        const buffer = reader.readMessageBody(message.bodyLength);\n\n        const vector = this._loadDictionaryBatch(header, buffer);\n\n        this.dictionaries.set(header.id, vector);\n      }\n    }\n\n    if (this.schema && this._recordBatchIndex === 0) {\n      this._recordBatchIndex++;\n      return {\n        done: false,\n        value: new _InternalEmptyPlaceholderRecordBatch(this.schema)\n      };\n    }\n\n    return this.return();\n  }\n\n  _readNextMessageAndValidate(type) {\n    return this._reader.readMessage(type);\n  }\n\n}\n/** @ignore */\n\n\nclass AsyncRecordBatchStreamReaderImpl extends RecordBatchReaderImpl {\n  constructor(source, dictionaries) {\n    super(dictionaries);\n    this._reader = new AsyncMessageReader(this._handle = source);\n  }\n\n  isAsync() {\n    return true;\n  }\n\n  isStream() {\n    return true;\n  }\n\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n\n  async cancel() {\n    if (!this.closed && (this.closed = true)) {\n      await this.reset()._reader.return();\n      this._reader = null;\n      this.dictionaries = null;\n    }\n  }\n\n  async open(options) {\n    if (!this.closed) {\n      this.autoDestroy = shouldAutoDestroy(this, options);\n\n      if (!(this.schema || (this.schema = await this._reader.readSchema()))) {\n        await this.cancel();\n      }\n    }\n\n    return this;\n  }\n\n  async throw(value) {\n    if (!this.closed && this.autoDestroy && (this.closed = true)) {\n      return await this.reset()._reader.throw(value);\n    }\n\n    return ITERATOR_DONE;\n  }\n\n  async return(value) {\n    if (!this.closed && this.autoDestroy && (this.closed = true)) {\n      return await this.reset()._reader.return(value);\n    }\n\n    return ITERATOR_DONE;\n  }\n\n  async next() {\n    if (this.closed) {\n      return ITERATOR_DONE;\n    }\n\n    let message,\n        {\n      _reader: reader\n    } = this;\n\n    while (message = await this._readNextMessageAndValidate()) {\n      if (message.isSchema()) {\n        await this.reset(message.header());\n      } else if (message.isRecordBatch()) {\n        this._recordBatchIndex++;\n        const header = message.header();\n        const buffer = await reader.readMessageBody(message.bodyLength);\n\n        const recordBatch = this._loadRecordBatch(header, buffer);\n\n        return {\n          done: false,\n          value: recordBatch\n        };\n      } else if (message.isDictionaryBatch()) {\n        this._dictionaryIndex++;\n        const header = message.header();\n        const buffer = await reader.readMessageBody(message.bodyLength);\n\n        const vector = this._loadDictionaryBatch(header, buffer);\n\n        this.dictionaries.set(header.id, vector);\n      }\n    }\n\n    if (this.schema && this._recordBatchIndex === 0) {\n      this._recordBatchIndex++;\n      return {\n        done: false,\n        value: new _InternalEmptyPlaceholderRecordBatch(this.schema)\n      };\n    }\n\n    return await this.return();\n  }\n\n  async _readNextMessageAndValidate(type) {\n    return await this._reader.readMessage(type);\n  }\n\n}\n/** @ignore */\n\n\nclass RecordBatchFileReaderImpl extends RecordBatchStreamReaderImpl {\n  constructor(source, dictionaries) {\n    super(source instanceof RandomAccessFile ? source : new RandomAccessFile(source), dictionaries);\n  }\n\n  get footer() {\n    return this._footer;\n  }\n\n  get numDictionaries() {\n    return this._footer ? this._footer.numDictionaries : 0;\n  }\n\n  get numRecordBatches() {\n    return this._footer ? this._footer.numRecordBatches : 0;\n  }\n\n  isSync() {\n    return true;\n  }\n\n  isFile() {\n    return true;\n  }\n\n  open(options) {\n    if (!this.closed && !this._footer) {\n      this.schema = (this._footer = this._readFooter()).schema;\n\n      for (const block of this._footer.dictionaryBatches()) {\n        block && this._readDictionaryBatch(this._dictionaryIndex++);\n      }\n    }\n\n    return super.open(options);\n  }\n\n  readRecordBatch(index) {\n    if (this.closed) {\n      return null;\n    }\n\n    if (!this._footer) {\n      this.open();\n    }\n\n    const block = this._footer && this._footer.getRecordBatch(index);\n\n    if (block && this._handle.seek(block.offset)) {\n      const message = this._reader.readMessage(MessageHeader.RecordBatch);\n\n      if (message && message.isRecordBatch()) {\n        const header = message.header();\n\n        const buffer = this._reader.readMessageBody(message.bodyLength);\n\n        const recordBatch = this._loadRecordBatch(header, buffer);\n\n        return recordBatch;\n      }\n    }\n\n    return null;\n  }\n\n  _readDictionaryBatch(index) {\n    const block = this._footer && this._footer.getDictionaryBatch(index);\n\n    if (block && this._handle.seek(block.offset)) {\n      const message = this._reader.readMessage(MessageHeader.DictionaryBatch);\n\n      if (message && message.isDictionaryBatch()) {\n        const header = message.header();\n\n        const buffer = this._reader.readMessageBody(message.bodyLength);\n\n        const vector = this._loadDictionaryBatch(header, buffer);\n\n        this.dictionaries.set(header.id, vector);\n      }\n    }\n  }\n\n  _readFooter() {\n    const {\n      _handle\n    } = this;\n    const offset = _handle.size - magicAndPadding;\n\n    const length = _handle.readInt32(offset);\n\n    const buffer = _handle.readAt(offset - length, length);\n\n    return Footer.decode(buffer);\n  }\n\n  _readNextMessageAndValidate(type) {\n    if (!this._footer) {\n      this.open();\n    }\n\n    if (this._footer && this._recordBatchIndex < this.numRecordBatches) {\n      const block = this._footer && this._footer.getRecordBatch(this._recordBatchIndex);\n\n      if (block && this._handle.seek(block.offset)) {\n        return this._reader.readMessage(type);\n      }\n    }\n\n    return null;\n  }\n\n}\n/** @ignore */\n\n\nclass AsyncRecordBatchFileReaderImpl extends AsyncRecordBatchStreamReaderImpl {\n  constructor(source, ...rest) {\n    const byteLength = typeof rest[0] !== 'number' ? rest.shift() : undefined;\n    const dictionaries = rest[0] instanceof Map ? rest.shift() : undefined;\n    super(source instanceof AsyncRandomAccessFile ? source : new AsyncRandomAccessFile(source, byteLength), dictionaries);\n  }\n\n  get footer() {\n    return this._footer;\n  }\n\n  get numDictionaries() {\n    return this._footer ? this._footer.numDictionaries : 0;\n  }\n\n  get numRecordBatches() {\n    return this._footer ? this._footer.numRecordBatches : 0;\n  }\n\n  isFile() {\n    return true;\n  }\n\n  isAsync() {\n    return true;\n  }\n\n  async open(options) {\n    if (!this.closed && !this._footer) {\n      this.schema = (this._footer = await this._readFooter()).schema;\n\n      for (const block of this._footer.dictionaryBatches()) {\n        block && (await this._readDictionaryBatch(this._dictionaryIndex++));\n      }\n    }\n\n    return await super.open(options);\n  }\n\n  async readRecordBatch(index) {\n    if (this.closed) {\n      return null;\n    }\n\n    if (!this._footer) {\n      await this.open();\n    }\n\n    const block = this._footer && this._footer.getRecordBatch(index);\n\n    if (block && (await this._handle.seek(block.offset))) {\n      const message = await this._reader.readMessage(MessageHeader.RecordBatch);\n\n      if (message && message.isRecordBatch()) {\n        const header = message.header();\n        const buffer = await this._reader.readMessageBody(message.bodyLength);\n\n        const recordBatch = this._loadRecordBatch(header, buffer);\n\n        return recordBatch;\n      }\n    }\n\n    return null;\n  }\n\n  async _readDictionaryBatch(index) {\n    const block = this._footer && this._footer.getDictionaryBatch(index);\n\n    if (block && (await this._handle.seek(block.offset))) {\n      const message = await this._reader.readMessage(MessageHeader.DictionaryBatch);\n\n      if (message && message.isDictionaryBatch()) {\n        const header = message.header();\n        const buffer = await this._reader.readMessageBody(message.bodyLength);\n\n        const vector = this._loadDictionaryBatch(header, buffer);\n\n        this.dictionaries.set(header.id, vector);\n      }\n    }\n  }\n\n  async _readFooter() {\n    const {\n      _handle\n    } = this;\n    _handle._pending && (await _handle._pending);\n    const offset = _handle.size - magicAndPadding;\n    const length = await _handle.readInt32(offset);\n    const buffer = await _handle.readAt(offset - length, length);\n    return Footer.decode(buffer);\n  }\n\n  async _readNextMessageAndValidate(type) {\n    if (!this._footer) {\n      await this.open();\n    }\n\n    if (this._footer && this._recordBatchIndex < this.numRecordBatches) {\n      const block = this._footer.getRecordBatch(this._recordBatchIndex);\n\n      if (block && (await this._handle.seek(block.offset))) {\n        return await this._reader.readMessage(type);\n      }\n    }\n\n    return null;\n  }\n\n}\n/** @ignore */\n\n\nclass RecordBatchJSONReaderImpl extends RecordBatchStreamReaderImpl {\n  constructor(source, dictionaries) {\n    super(source, dictionaries);\n  }\n\n  _loadVectors(header, body, types) {\n    return new JSONVectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);\n  }\n\n} //\n// Define some helper functions and static implementations down here. There's\n// a bit of branching in the static methods that can lead to the same routines\n// being executed, so we've broken those out here for readability.\n//\n\n/** @ignore */\n\n\nfunction shouldAutoDestroy(self, options) {\n  return options && typeof options['autoDestroy'] === 'boolean' ? options['autoDestroy'] : self['autoDestroy'];\n}\n/** @ignore */\n\n\nfunction* readAllSync(source) {\n  const reader = RecordBatchReader.from(source);\n\n  try {\n    if (!reader.open({\n      autoDestroy: false\n    }).closed) {\n      do {\n        yield reader;\n      } while (!reader.reset().open().closed);\n    }\n  } finally {\n    reader.cancel();\n  }\n}\n/** @ignore */\n\n\nasync function* readAllAsync(source) {\n  const reader = await RecordBatchReader.from(source);\n\n  try {\n    if (!(await reader.open({\n      autoDestroy: false\n    })).closed) {\n      do {\n        yield reader;\n      } while (!(await reader.reset().open()).closed);\n    }\n  } finally {\n    await reader.cancel();\n  }\n}\n/** @ignore */\n\n\nfunction fromArrowJSON(source) {\n  return new RecordBatchStreamReader(new RecordBatchJSONReaderImpl(source));\n}\n/** @ignore */\n\n\nfunction fromByteStream(source) {\n  const bytes = source.peek(magicLength + 7 & ~7);\n  return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes) ? new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(source.read())) : new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(function* () {}()));\n}\n/** @ignore */\n\n\nasync function fromAsyncByteStream(source) {\n  const bytes = await source.peek(magicLength + 7 & ~7);\n  return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes) ? new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl((await source.read()))) : new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(async function* () {}()));\n}\n/** @ignore */\n\n\nasync function fromFileHandle(source) {\n  const {\n    size\n  } = await source.stat();\n  const file = new AsyncRandomAccessFile(source, size);\n\n  if (size >= magicX2AndPadding) {\n    if (checkForMagicArrowString((await file.readAt(0, magicLength + 7 & ~7)))) {\n      return new AsyncRecordBatchFileReader(new AsyncRecordBatchFileReaderImpl(file));\n    }\n  }\n\n  return new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(file));\n}","map":{"version":3,"sources":["ipc/reader.ts"],"names":[],"mappings":"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","sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Vector } from '../vector';\nimport { DataType } from '../type';\nimport { MessageHeader } from '../enum';\nimport { Footer } from './metadata/file';\nimport { Schema, Field } from '../schema';\nimport streamAdapters from '../io/adapters';\nimport { Message } from './metadata/message';\nimport * as metadata from './metadata/message';\nimport { ArrayBufferViewInput } from '../util/buffer';\nimport { ByteStream, AsyncByteStream } from '../io/stream';\nimport { RandomAccessFile, AsyncRandomAccessFile } from '../io/file';\nimport { VectorLoader, JSONVectorLoader } from '../visitor/vectorloader';\nimport { RecordBatch, _InternalEmptyPlaceholderRecordBatch } from '../recordbatch';\nimport {\n    FileHandle,\n    ArrowJSONLike,\n    ITERATOR_DONE,\n    ReadableInterop,\n} from '../io/interfaces';\nimport {\n    MessageReader, AsyncMessageReader, JSONMessageReader,\n    checkForMagicArrowString, magicLength, magicAndPadding, magicX2AndPadding\n} from './message';\nimport {\n    isPromise,\n    isIterable, isAsyncIterable,\n    isIteratorResult, isArrowJSON,\n    isFileHandle, isFetchResponse,\n    isReadableDOMStream, isReadableNodeStream\n} from '../util/compat';\n\n/** @ignore */ export type FromArg0 = ArrowJSONLike;\n/** @ignore */ export type FromArg1 = PromiseLike<ArrowJSONLike>;\n/** @ignore */ export type FromArg2 = Iterable<ArrayBufferViewInput> | ArrayBufferViewInput;\n/** @ignore */ export type FromArg3 = PromiseLike<Iterable<ArrayBufferViewInput> | ArrayBufferViewInput>;\n/** @ignore */ export type FromArg4 = Response | NodeJS.ReadableStream | ReadableStream<ArrayBufferViewInput> | AsyncIterable<ArrayBufferViewInput>;\n/** @ignore */ export type FromArg5 = FileHandle | PromiseLike<FileHandle> | PromiseLike<FromArg4>;\n/** @ignore */ export type FromArgs = FromArg0 | FromArg1 | FromArg2 | FromArg3 | FromArg4 | FromArg5;\n\n/** @ignore */ type OpenOptions = { autoDestroy?: boolean; };\n/** @ignore */ type RecordBatchReaders<T extends { [key: string]: DataType } = any> = RecordBatchFileReader<T> | RecordBatchStreamReader<T>;\n/** @ignore */ type AsyncRecordBatchReaders<T extends { [key: string]: DataType } = any> = AsyncRecordBatchFileReader<T> | AsyncRecordBatchStreamReader<T>;\n/** @ignore */ type RecordBatchFileReaders<T extends { [key: string]: DataType } = any> = RecordBatchFileReader<T> | AsyncRecordBatchFileReader<T>;\n/** @ignore */ type RecordBatchStreamReaders<T extends { [key: string]: DataType } = any> = RecordBatchStreamReader<T> | AsyncRecordBatchStreamReader<T>;\n\nexport class RecordBatchReader<T extends { [key: string]: DataType } = any> extends ReadableInterop<RecordBatch<T>> {\n\n    protected _impl: RecordBatchReaderImpls<T>;\n    protected constructor(impl: RecordBatchReaderImpls<T>) {\n        super();\n        this._impl = impl;\n    }\n\n    public get closed() { return this._impl.closed; }\n    public get schema() { return this._impl.schema; }\n    public get autoDestroy() { return this._impl.autoDestroy; }\n    public get dictionaries() { return this._impl.dictionaries; }\n    public get numDictionaries() { return this._impl.numDictionaries; }\n    public get numRecordBatches() { return this._impl.numRecordBatches; }\n    public get footer() { return this._impl.isFile() ? this._impl.footer : null; }\n\n    public isSync(): this is RecordBatchReaders<T> { return this._impl.isSync(); }\n    public isAsync(): this is AsyncRecordBatchReaders<T> { return this._impl.isAsync(); }\n    public isFile(): this is RecordBatchFileReaders<T> { return this._impl.isFile(); }\n    public isStream(): this is RecordBatchStreamReaders<T> { return this._impl.isStream(); }\n\n    public next() {\n        return this._impl.next();\n    }\n    public throw(value?: any) {\n        return this._impl.throw(value);\n    }\n    public return(value?: any) {\n        return this._impl.return(value);\n    }\n    public cancel() {\n        return this._impl.cancel();\n    }\n    public reset(schema?: Schema<T> | null): this {\n        this._impl.reset(schema);\n        this._DOMStream = undefined;\n        this._nodeStream = undefined;\n        return this;\n    }\n    public open(options?: OpenOptions) {\n        const opening = this._impl.open(options);\n        return isPromise(opening) ? opening.then(() => this) : this;\n    }\n    public readRecordBatch(index: number): RecordBatch<T> | null | Promise<RecordBatch<T> | null> {\n        return this._impl.isFile() ? this._impl.readRecordBatch(index) : null;\n    }\n    public [Symbol.iterator](): IterableIterator<RecordBatch<T>> {\n        return (<IterableIterator<RecordBatch<T>>> this._impl)[Symbol.iterator]();\n    }\n    public [Symbol.asyncIterator](): AsyncIterableIterator<RecordBatch<T>> {\n        return (<AsyncIterableIterator<RecordBatch<T>>> this._impl)[Symbol.asyncIterator]();\n    }\n    public toDOMStream() {\n        return streamAdapters.toDOMStream<RecordBatch<T>>(\n            (this.isSync()\n                ? { [Symbol.iterator]: () => this } as Iterable<RecordBatch<T>>\n                : { [Symbol.asyncIterator]: () => this } as AsyncIterable<RecordBatch<T>>));\n    }\n    public toNodeStream() {\n        return streamAdapters.toNodeStream<RecordBatch<T>>(\n            (this.isSync()\n                ? { [Symbol.iterator]: () => this } as Iterable<RecordBatch<T>>\n                : { [Symbol.asyncIterator]: () => this } as AsyncIterable<RecordBatch<T>>),\n            { objectMode: true });\n    }\n\n    /** @nocollapse */\n    // @ts-ignore\n    public static throughNode(options?: import('stream').DuplexOptions & { autoDestroy: boolean }): import('stream').Duplex {\n        throw new Error(`\"throughNode\" not available in this environment`);\n    }\n    /** @nocollapse */\n    public static throughDOM<T extends { [key: string]: DataType }>(\n        // @ts-ignore\n        writableStrategy?: ByteLengthQueuingStrategy,\n        // @ts-ignore\n        readableStrategy?: { autoDestroy: boolean }\n    ): { writable: WritableStream<Uint8Array>, readable: ReadableStream<RecordBatch<T>> } {\n        throw new Error(`\"throughDOM\" not available in this environment`);\n    }\n\n    public static from<T extends RecordBatchReader>(source: T): T;\n    public static from<T extends { [key: string]: DataType } = any>(source: FromArg0): RecordBatchStreamReader<T>;\n    public static from<T extends { [key: string]: DataType } = any>(source: FromArg1): Promise<RecordBatchStreamReader<T>>;\n    public static from<T extends { [key: string]: DataType } = any>(source: FromArg2): RecordBatchFileReader<T> | RecordBatchStreamReader<T>;\n    public static from<T extends { [key: string]: DataType } = any>(source: FromArg3): Promise<RecordBatchFileReader<T> | RecordBatchStreamReader<T>>;\n    public static from<T extends { [key: string]: DataType } = any>(source: FromArg4): Promise<RecordBatchFileReader<T> | AsyncRecordBatchReaders<T>>;\n    public static from<T extends { [key: string]: DataType } = any>(source: FromArg5): Promise<AsyncRecordBatchFileReader<T> | AsyncRecordBatchStreamReader<T>>;\n    /** @nocollapse */\n    public static from<T extends { [key: string]: DataType } = any>(source: any) {\n        if (source instanceof RecordBatchReader) {\n            return source;\n        } else if (isArrowJSON(source)) {\n            return fromArrowJSON<T>(source);\n        } else if (isFileHandle(source)) {\n            return fromFileHandle<T>(source);\n        } else if (isPromise<any>(source)) {\n            return (async () => await RecordBatchReader.from<any>(await source))();\n        } else if (isFetchResponse(source) || isReadableDOMStream(source) || isReadableNodeStream(source) || isAsyncIterable(source)) {\n            return fromAsyncByteStream<T>(new AsyncByteStream(source));\n        }\n        return fromByteStream<T>(new ByteStream(source));\n    }\n\n    public static readAll<T extends RecordBatchReader>(source: T): T extends RecordBatchReaders ? IterableIterator<T> : AsyncIterableIterator<T>;\n    public static readAll<T extends { [key: string]: DataType } = any>(source: FromArg0): IterableIterator<RecordBatchStreamReader<T>>;\n    public static readAll<T extends { [key: string]: DataType } = any>(source: FromArg1): AsyncIterableIterator<RecordBatchStreamReader<T>>;\n    public static readAll<T extends { [key: string]: DataType } = any>(source: FromArg2): IterableIterator<RecordBatchFileReader<T> | RecordBatchStreamReader<T>>;\n    public static readAll<T extends { [key: string]: DataType } = any>(source: FromArg3): AsyncIterableIterator<RecordBatchFileReader<T> | RecordBatchStreamReader<T>>;\n    public static readAll<T extends { [key: string]: DataType } = any>(source: FromArg4): AsyncIterableIterator<RecordBatchFileReader<T> | AsyncRecordBatchReaders<T>>;\n    public static readAll<T extends { [key: string]: DataType } = any>(source: FromArg5): AsyncIterableIterator<AsyncRecordBatchFileReader<T> | AsyncRecordBatchStreamReader<T>>;\n    /** @nocollapse */\n    public static readAll<T extends { [key: string]: DataType } = any>(source: any) {\n        if (source instanceof RecordBatchReader) {\n            return source.isSync() ? readAllSync(source) : readAllAsync(source as AsyncRecordBatchReaders<T>);\n        } else if (isArrowJSON(source) || ArrayBuffer.isView(source) || isIterable<ArrayBufferViewInput>(source) || isIteratorResult(source)) {\n            return readAllSync<T>(source) as IterableIterator<RecordBatchReaders<T>>;\n        }\n        return readAllAsync<T>(source) as AsyncIterableIterator<RecordBatchReaders<T> | AsyncRecordBatchReaders<T>>;\n    }\n}\n\n//\n// Since TS is a structural type system, we define the following subclass stubs\n// so that concrete types exist to associate with with the interfaces below.\n//\n// The implementation for each RecordBatchReader is hidden away in the set of\n// `RecordBatchReaderImpl` classes in the second half of this file. This allows\n// us to export a single RecordBatchReader class, and swap out the impl based\n// on the io primitives or underlying arrow (JSON, file, or stream) at runtime.\n//\n// Async/await makes our job a bit harder, since it forces everything to be\n// either fully sync or fully async. This is why the logic for the reader impls\n// has been duplicated into both sync and async variants. Since the RBR\n// delegates to its impl, an RBR with an AsyncRecordBatchFileReaderImpl for\n// example will return async/await-friendly Promises, but one with a (sync)\n// RecordBatchStreamReaderImpl will always return values. Nothing should be\n// different about their logic, aside from the async handling. This is also why\n// this code looks highly structured, as it should be nearly identical and easy\n// to follow.\n//\n\n/** @ignore */\nexport class RecordBatchStreamReader<T extends { [key: string]: DataType } = any> extends RecordBatchReader<T> {\n    constructor(protected _impl: RecordBatchStreamReaderImpl<T>) { super (_impl); }\n    public [Symbol.iterator]() { return (this._impl as IterableIterator<RecordBatch<T>>)[Symbol.iterator](); }\n    public async *[Symbol.asyncIterator](): AsyncIterableIterator<RecordBatch<T>> { yield* this[Symbol.iterator](); }\n}\n/** @ignore */\nexport class AsyncRecordBatchStreamReader<T extends { [key: string]: DataType } = any> extends RecordBatchReader<T> {\n    constructor(protected _impl: AsyncRecordBatchStreamReaderImpl<T>) { super (_impl); }\n    public [Symbol.iterator](): IterableIterator<RecordBatch<T>> { throw new Error(`AsyncRecordBatchStreamReader is not Iterable`); }\n    public [Symbol.asyncIterator]() { return (this._impl as AsyncIterableIterator<RecordBatch<T>>)[Symbol.asyncIterator](); }\n}\n/** @ignore */\nexport class RecordBatchFileReader<T extends { [key: string]: DataType } = any> extends RecordBatchStreamReader<T> {\n    constructor(protected _impl: RecordBatchFileReaderImpl<T>) { super (_impl); }\n}\n/** @ignore */\nexport class AsyncRecordBatchFileReader<T extends { [key: string]: DataType } = any> extends AsyncRecordBatchStreamReader<T> {\n    constructor(protected _impl: AsyncRecordBatchFileReaderImpl<T>) { super (_impl); }\n}\n\n//\n// Now override the return types for each sync/async RecordBatchReader variant\n//\n\n/** @ignore */\nexport interface RecordBatchStreamReader<T extends { [key: string]: DataType } = any> extends RecordBatchReader<T> {\n    open(options?: OpenOptions | undefined): this;\n    cancel(): void;\n    throw(value?: any): IteratorResult<any>;\n    return(value?: any): IteratorResult<any>;\n    next(value?: any): IteratorResult<RecordBatch<T>>;\n}\n\n/** @ignore */\nexport interface AsyncRecordBatchStreamReader<T extends { [key: string]: DataType } = any> extends RecordBatchReader<T> {\n    open(options?: OpenOptions | undefined): Promise<this>;\n    cancel(): Promise<void>;\n    throw(value?: any): Promise<IteratorResult<any>>;\n    return(value?: any): Promise<IteratorResult<any>>;\n    next(value?: any): Promise<IteratorResult<RecordBatch<T>>>;\n}\n\n/** @ignore */\nexport interface RecordBatchFileReader<T extends { [key: string]: DataType } = any> extends RecordBatchStreamReader<T> {\n    footer: Footer;\n    readRecordBatch(index: number): RecordBatch<T> | null;\n}\n\n/** @ignore */\nexport interface AsyncRecordBatchFileReader<T extends { [key: string]: DataType } = any> extends AsyncRecordBatchStreamReader<T> {\n    footer: Footer;\n    readRecordBatch(index: number): Promise<RecordBatch<T> | null>;\n}\n\n/** @ignore */\ntype RecordBatchReaderImpls<T extends { [key: string]: DataType } = any> =\n     RecordBatchJSONReaderImpl<T> |\n     RecordBatchFileReaderImpl<T> |\n     RecordBatchStreamReaderImpl<T> |\n     AsyncRecordBatchFileReaderImpl<T> |\n     AsyncRecordBatchStreamReaderImpl<T>;\n\n/** @ignore */\ninterface RecordBatchReaderImpl<T extends { [key: string]: DataType } = any> {\n\n    closed: boolean;\n    schema: Schema<T>;\n    autoDestroy: boolean;\n    dictionaries: Map<number, Vector>;\n\n    isFile(): this is RecordBatchFileReaders<T>;\n    isStream(): this is RecordBatchStreamReaders<T>;\n    isSync(): this is RecordBatchReaders<T>;\n    isAsync(): this is AsyncRecordBatchReaders<T>;\n\n    reset(schema?: Schema<T> | null): this;\n}\n\n/** @ignore */\ninterface RecordBatchStreamReaderImpl<T extends { [key: string]: DataType } = any> extends RecordBatchReaderImpl<T> {\n\n    open(options?: OpenOptions): this;\n    cancel(): void;\n\n    throw(value?: any): IteratorResult<any>;\n    return(value?: any): IteratorResult<any>;\n    next(value?: any): IteratorResult<RecordBatch<T>>;\n\n    [Symbol.iterator](): IterableIterator<RecordBatch<T>>;\n}\n\n/** @ignore */\ninterface AsyncRecordBatchStreamReaderImpl<T extends { [key: string]: DataType } = any> extends RecordBatchReaderImpl<T> {\n\n    open(options?: OpenOptions): Promise<this>;\n    cancel(): Promise<void>;\n\n    throw(value?: any): Promise<IteratorResult<any>>;\n    return(value?: any): Promise<IteratorResult<any>>;\n    next(value?: any): Promise<IteratorResult<RecordBatch<T>>>;\n\n    [Symbol.asyncIterator](): AsyncIterableIterator<RecordBatch<T>>;\n}\n\n/** @ignore */\ninterface RecordBatchFileReaderImpl<T extends { [key: string]: DataType } = any> extends RecordBatchStreamReaderImpl<T> {\n    readRecordBatch(index: number): RecordBatch<T> | null;\n}\n\n/** @ignore */\ninterface AsyncRecordBatchFileReaderImpl<T extends { [key: string]: DataType } = any> extends AsyncRecordBatchStreamReaderImpl<T> {\n    readRecordBatch(index: number): Promise<RecordBatch<T> | null>;\n}\n\n/** @ignore */\nabstract class RecordBatchReaderImpl<T extends { [key: string]: DataType } = any> implements RecordBatchReaderImpl<T> {\n\n    // @ts-ignore\n    public schema: Schema;\n    public closed = false;\n    public autoDestroy = true;\n    public dictionaries: Map<number, Vector>;\n\n    protected _dictionaryIndex = 0;\n    protected _recordBatchIndex = 0;\n    public get numDictionaries() { return this._dictionaryIndex; }\n    public get numRecordBatches() { return this._recordBatchIndex; }\n\n    constructor(dictionaries = new Map<number, Vector>()) {\n        this.dictionaries = dictionaries;\n    }\n\n    public isSync(): this is RecordBatchReaders<T> { return false; }\n    public isAsync(): this is AsyncRecordBatchReaders<T> { return false; }\n    public isFile(): this is RecordBatchFileReaders<T> { return false; }\n    public isStream(): this is RecordBatchStreamReaders<T> { return false; }\n\n    public reset(schema?: Schema<T> | null) {\n        this._dictionaryIndex = 0;\n        this._recordBatchIndex = 0;\n        this.schema = <any> schema;\n        this.dictionaries = new Map();\n        return this;\n    }\n\n    protected _loadRecordBatch(header: metadata.RecordBatch, body: any) {\n        return new RecordBatch<T>(this.schema, header.length, this._loadVectors(header, body, this.schema.fields));\n    }\n    protected _loadDictionaryBatch(header: metadata.DictionaryBatch, body: any) {\n        const { id, isDelta, data } = header;\n        const { dictionaries, schema } = this;\n        const dictionary = dictionaries.get(id);\n        if (isDelta || !dictionary) {\n            const type = schema.dictionaries.get(id)!;\n            return (dictionary && isDelta ? dictionary.concat(\n                Vector.new(this._loadVectors(data, body, [type])[0])) :\n                Vector.new(this._loadVectors(data, body, [type])[0])) as Vector;\n        }\n        return dictionary;\n    }\n    protected _loadVectors(header: metadata.RecordBatch, body: any, types: (Field | DataType)[]) {\n        return new VectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);\n    }\n}\n\n/** @ignore */\nclass RecordBatchStreamReaderImpl<T extends { [key: string]: DataType } = any> extends RecordBatchReaderImpl<T> implements IterableIterator<RecordBatch<T>> {\n\n    protected _reader: MessageReader;\n    protected _handle: ByteStream | ArrowJSONLike;\n\n    constructor(source: ByteStream | ArrowJSONLike, dictionaries?: Map<number, Vector>) {\n        super(dictionaries);\n        this._reader = !isArrowJSON(source)\n            ? new MessageReader(this._handle = source)\n            : new JSONMessageReader(this._handle = source);\n    }\n\n    public isSync(): this is RecordBatchReaders<T> { return true; }\n    public isStream(): this is RecordBatchStreamReaders<T> { return true; }\n    public [Symbol.iterator](): IterableIterator<RecordBatch<T>> {\n        return this as IterableIterator<RecordBatch<T>>;\n    }\n    public cancel() {\n        if (!this.closed && (this.closed = true)) {\n            this.reset()._reader.return();\n            this._reader = <any> null;\n            this.dictionaries = <any> null;\n        }\n    }\n    public open(options?: OpenOptions) {\n        if (!this.closed) {\n            this.autoDestroy = shouldAutoDestroy(this, options);\n            if (!(this.schema || (this.schema = this._reader.readSchema()!))) {\n                this.cancel();\n            }\n        }\n        return this;\n    }\n    public throw(value?: any): IteratorResult<any> {\n        if (!this.closed && this.autoDestroy && (this.closed = true)) {\n            return this.reset()._reader.throw(value);\n        }\n        return ITERATOR_DONE;\n    }\n    public return(value?: any): IteratorResult<any> {\n        if (!this.closed && this.autoDestroy && (this.closed = true)) {\n            return this.reset()._reader.return(value);\n        }\n        return ITERATOR_DONE;\n    }\n    public next(): IteratorResult<RecordBatch<T>> {\n        if (this.closed) { return ITERATOR_DONE; }\n        let message: Message | null, { _reader: reader } = this;\n        while (message = this._readNextMessageAndValidate()) {\n            if (message.isSchema()) {\n                this.reset(message.header());\n            } else if (message.isRecordBatch()) {\n                this._recordBatchIndex++;\n                const header = message.header();\n                const buffer = reader.readMessageBody(message.bodyLength);\n                const recordBatch = this._loadRecordBatch(header, buffer);\n                return { done: false, value: recordBatch };\n            } else if (message.isDictionaryBatch()) {\n                this._dictionaryIndex++;\n                const header = message.header();\n                const buffer = reader.readMessageBody(message.bodyLength);\n                const vector = this._loadDictionaryBatch(header, buffer);\n                this.dictionaries.set(header.id, vector);\n            }\n        }\n        if (this.schema && this._recordBatchIndex === 0) {\n            this._recordBatchIndex++;\n            return { done: false, value: new _InternalEmptyPlaceholderRecordBatch<T>(this.schema) };\n        }\n        return this.return();\n    }\n    protected _readNextMessageAndValidate<T extends MessageHeader>(type?: T | null) {\n        return this._reader.readMessage<T>(type);\n    }\n}\n\n/** @ignore */\nclass AsyncRecordBatchStreamReaderImpl<T extends { [key: string]: DataType } = any> extends RecordBatchReaderImpl<T> implements AsyncIterableIterator<RecordBatch<T>> {\n\n    protected _handle: AsyncByteStream;\n    protected _reader: AsyncMessageReader;\n\n    constructor(source: AsyncByteStream, dictionaries?: Map<number, Vector>) {\n        super(dictionaries);\n        this._reader = new AsyncMessageReader(this._handle = source);\n    }\n    public isAsync(): this is AsyncRecordBatchReaders<T> { return true; }\n    public isStream(): this is RecordBatchStreamReaders<T> { return true; }\n    public [Symbol.asyncIterator](): AsyncIterableIterator<RecordBatch<T>> {\n        return this as AsyncIterableIterator<RecordBatch<T>>;\n    }\n    public async cancel() {\n        if (!this.closed && (this.closed = true)) {\n            await this.reset()._reader.return();\n            this._reader = <any> null;\n            this.dictionaries = <any> null;\n        }\n    }\n    public async open(options?: OpenOptions) {\n        if (!this.closed) {\n            this.autoDestroy = shouldAutoDestroy(this, options);\n            if (!(this.schema || (this.schema = (await this._reader.readSchema())!))) {\n                await this.cancel();\n            }\n        }\n        return this;\n    }\n    public async throw(value?: any): Promise<IteratorResult<any>> {\n        if (!this.closed && this.autoDestroy && (this.closed = true)) {\n            return await this.reset()._reader.throw(value);\n        }\n        return ITERATOR_DONE;\n    }\n    public async return(value?: any): Promise<IteratorResult<any>> {\n        if (!this.closed && this.autoDestroy && (this.closed = true)) {\n            return await this.reset()._reader.return(value);\n        }\n        return ITERATOR_DONE;\n    }\n    public async next() {\n        if (this.closed) { return ITERATOR_DONE; }\n        let message: Message | null, { _reader: reader } = this;\n        while (message = await this._readNextMessageAndValidate()) {\n            if (message.isSchema()) {\n                await this.reset(message.header());\n            } else if (message.isRecordBatch()) {\n                this._recordBatchIndex++;\n                const header = message.header();\n                const buffer = await reader.readMessageBody(message.bodyLength);\n                const recordBatch = this._loadRecordBatch(header, buffer);\n                return { done: false, value: recordBatch };\n            } else if (message.isDictionaryBatch()) {\n                this._dictionaryIndex++;\n                const header = message.header();\n                const buffer = await reader.readMessageBody(message.bodyLength);\n                const vector = this._loadDictionaryBatch(header, buffer);\n                this.dictionaries.set(header.id, vector);\n            }\n        }\n        if (this.schema && this._recordBatchIndex === 0) {\n            this._recordBatchIndex++;\n            return { done: false, value: new _InternalEmptyPlaceholderRecordBatch<T>(this.schema) };\n        }\n        return await this.return();\n    }\n    protected async _readNextMessageAndValidate<T extends MessageHeader>(type?: T | null) {\n        return await this._reader.readMessage<T>(type);\n    }\n}\n\n/** @ignore */\nclass RecordBatchFileReaderImpl<T extends { [key: string]: DataType } = any> extends RecordBatchStreamReaderImpl<T> {\n\n    // @ts-ignore\n    protected _footer?: Footer;\n    // @ts-ignore\n    protected _handle: RandomAccessFile;\n    public get footer() { return this._footer!; }\n    public get numDictionaries() { return this._footer ? this._footer.numDictionaries : 0; }\n    public get numRecordBatches() { return this._footer ? this._footer.numRecordBatches : 0; }\n\n    constructor(source: RandomAccessFile | ArrayBufferViewInput, dictionaries?: Map<number, Vector>) {\n        super(source instanceof RandomAccessFile ? source : new RandomAccessFile(source), dictionaries);\n    }\n    public isSync(): this is RecordBatchReaders<T> { return true; }\n    public isFile(): this is RecordBatchFileReaders<T> { return true; }\n    public open(options?: OpenOptions) {\n        if (!this.closed && !this._footer) {\n            this.schema = (this._footer = this._readFooter()).schema;\n            for (const block of this._footer.dictionaryBatches()) {\n                block && this._readDictionaryBatch(this._dictionaryIndex++);\n            }\n        }\n        return super.open(options);\n    }\n    public readRecordBatch(index: number) {\n        if (this.closed) { return null; }\n        if (!this._footer) { this.open(); }\n        const block = this._footer && this._footer.getRecordBatch(index);\n        if (block && this._handle.seek(block.offset)) {\n            const message = this._reader.readMessage(MessageHeader.RecordBatch);\n            if (message && message.isRecordBatch()) {\n                const header = message.header();\n                const buffer = this._reader.readMessageBody(message.bodyLength);\n                const recordBatch = this._loadRecordBatch(header, buffer);\n                return recordBatch;\n            }\n        }\n        return null;\n    }\n    protected _readDictionaryBatch(index: number) {\n        const block = this._footer && this._footer.getDictionaryBatch(index);\n        if (block && this._handle.seek(block.offset)) {\n            const message = this._reader.readMessage(MessageHeader.DictionaryBatch);\n            if (message && message.isDictionaryBatch()) {\n                const header = message.header();\n                const buffer = this._reader.readMessageBody(message.bodyLength);\n                const vector = this._loadDictionaryBatch(header, buffer);\n                this.dictionaries.set(header.id, vector);\n            }\n        }\n    }\n    protected _readFooter() {\n        const { _handle } = this;\n        const offset = _handle.size - magicAndPadding;\n        const length = _handle.readInt32(offset);\n        const buffer = _handle.readAt(offset - length, length);\n        return Footer.decode(buffer);\n    }\n    protected _readNextMessageAndValidate<T extends MessageHeader>(type?: T | null): Message<T> | null {\n        if (!this._footer) { this.open(); }\n        if (this._footer && this._recordBatchIndex < this.numRecordBatches) {\n            const block = this._footer && this._footer.getRecordBatch(this._recordBatchIndex);\n            if (block && this._handle.seek(block.offset)) {\n                return this._reader.readMessage(type);\n            }\n        }\n        return null;\n    }\n}\n\n/** @ignore */\nclass AsyncRecordBatchFileReaderImpl<T extends { [key: string]: DataType } = any> extends AsyncRecordBatchStreamReaderImpl<T>\n    implements AsyncRecordBatchFileReaderImpl<T> {\n\n    protected _footer?: Footer;\n    // @ts-ignore\n    protected _handle: AsyncRandomAccessFile;\n    public get footer() { return this._footer!; }\n    public get numDictionaries() { return this._footer ? this._footer.numDictionaries : 0; }\n    public get numRecordBatches() { return this._footer ? this._footer.numRecordBatches : 0; }\n\n    constructor(source: FileHandle, byteLength?: number, dictionaries?: Map<number, Vector>);\n    constructor(source: FileHandle | AsyncRandomAccessFile, dictionaries?: Map<number, Vector>);\n    constructor(source: FileHandle | AsyncRandomAccessFile, ...rest: any[]) {\n        const byteLength = typeof rest[0] !== 'number' ? <number> rest.shift() : undefined;\n        const dictionaries = rest[0] instanceof Map ? <Map<number, Vector>> rest.shift() : undefined;\n        super(source instanceof AsyncRandomAccessFile ? source : new AsyncRandomAccessFile(source, byteLength), dictionaries);\n    }\n    public isFile(): this is RecordBatchFileReaders<T> { return true; }\n    public isAsync(): this is AsyncRecordBatchReaders<T> { return true; }\n    public async open(options?: OpenOptions) {\n        if (!this.closed && !this._footer) {\n            this.schema = (this._footer = await this._readFooter()).schema;\n            for (const block of this._footer.dictionaryBatches()) {\n                block && await this._readDictionaryBatch(this._dictionaryIndex++);\n            }\n        }\n        return await super.open(options);\n    }\n    public async readRecordBatch(index: number) {\n        if (this.closed) { return null; }\n        if (!this._footer) { await this.open(); }\n        const block = this._footer && this._footer.getRecordBatch(index);\n        if (block && (await this._handle.seek(block.offset))) {\n            const message = await this._reader.readMessage(MessageHeader.RecordBatch);\n            if (message && message.isRecordBatch()) {\n                const header = message.header();\n                const buffer = await this._reader.readMessageBody(message.bodyLength);\n                const recordBatch = this._loadRecordBatch(header, buffer);\n                return recordBatch;\n            }\n        }\n        return null;\n    }\n    protected async _readDictionaryBatch(index: number) {\n        const block = this._footer && this._footer.getDictionaryBatch(index);\n        if (block && (await this._handle.seek(block.offset))) {\n            const message = await this._reader.readMessage(MessageHeader.DictionaryBatch);\n            if (message && message.isDictionaryBatch()) {\n                const header = message.header();\n                const buffer = await this._reader.readMessageBody(message.bodyLength);\n                const vector = this._loadDictionaryBatch(header, buffer);\n                this.dictionaries.set(header.id, vector);\n            }\n        }\n    }\n    protected async _readFooter() {\n        const { _handle } = this;\n        _handle._pending && await _handle._pending;\n        const offset = _handle.size - magicAndPadding;\n        const length = await _handle.readInt32(offset);\n        const buffer = await _handle.readAt(offset - length, length);\n        return Footer.decode(buffer);\n    }\n    protected async _readNextMessageAndValidate<T extends MessageHeader>(type?: T | null): Promise<Message<T> | null> {\n        if (!this._footer) { await this.open(); }\n        if (this._footer && this._recordBatchIndex < this.numRecordBatches) {\n            const block = this._footer.getRecordBatch(this._recordBatchIndex);\n            if (block && await this._handle.seek(block.offset)) {\n                return await this._reader.readMessage(type);\n            }\n        }\n        return null;\n    }\n}\n\n/** @ignore */\nclass RecordBatchJSONReaderImpl<T extends { [key: string]: DataType } = any> extends RecordBatchStreamReaderImpl<T> {\n    constructor(source: ArrowJSONLike, dictionaries?: Map<number, Vector>) {\n        super(source, dictionaries);\n    }\n    protected _loadVectors(header: metadata.RecordBatch, body: any, types: (Field | DataType)[]) {\n        return new JSONVectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);\n    }\n}\n\n//\n// Define some helper functions and static implementations down here. There's\n// a bit of branching in the static methods that can lead to the same routines\n// being executed, so we've broken those out here for readability.\n//\n\n/** @ignore */\nfunction shouldAutoDestroy(self: { autoDestroy: boolean }, options?: OpenOptions) {\n    return options && (typeof options['autoDestroy'] === 'boolean') ? options['autoDestroy'] : self['autoDestroy'];\n}\n\n/** @ignore */\nfunction* readAllSync<T extends { [key: string]: DataType } = any>(source: RecordBatchReaders<T> | FromArg0 | FromArg2) {\n    const reader = RecordBatchReader.from<T>(<any> source) as RecordBatchReaders<T>;\n    try {\n        if (!reader.open({ autoDestroy: false }).closed) {\n            do { yield reader; } while (!(reader.reset().open()).closed);\n        }\n    } finally { reader.cancel(); }\n}\n\n/** @ignore */\nasync function* readAllAsync<T extends { [key: string]: DataType } = any>(source: AsyncRecordBatchReaders<T> | FromArg1 | FromArg3 | FromArg4 | FromArg5) {\n    const reader = await RecordBatchReader.from<T>(<any> source) as RecordBatchReader<T>;\n    try {\n        if (!(await reader.open({ autoDestroy: false })).closed) {\n            do { yield reader; } while (!(await reader.reset().open()).closed);\n        }\n    } finally { await reader.cancel(); }\n}\n\n/** @ignore */\nfunction fromArrowJSON<T extends { [key: string]: DataType }>(source: ArrowJSONLike) {\n    return new RecordBatchStreamReader(new RecordBatchJSONReaderImpl<T>(source));\n}\n\n/** @ignore */\nfunction fromByteStream<T extends { [key: string]: DataType }>(source: ByteStream) {\n    const bytes = source.peek((magicLength + 7) & ~7);\n    return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes)\n        ? new RecordBatchStreamReader(new RecordBatchStreamReaderImpl<T>(source))\n        : new RecordBatchFileReader(new RecordBatchFileReaderImpl<T>(source.read()))\n        : new RecordBatchStreamReader(new RecordBatchStreamReaderImpl<T>(function*(): any {}()));\n}\n\n/** @ignore */\nasync function fromAsyncByteStream<T extends { [key: string]: DataType }>(source: AsyncByteStream) {\n    const bytes = await source.peek((magicLength + 7) & ~7);\n    return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes)\n        ? new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl<T>(source))\n        : new RecordBatchFileReader(new RecordBatchFileReaderImpl<T>(await source.read()))\n        : new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl<T>(async function*(): any {}()));\n}\n\n/** @ignore */\nasync function fromFileHandle<T extends { [key: string]: DataType }>(source: FileHandle) {\n    const { size } = await source.stat();\n    const file = new AsyncRandomAccessFile(source, size);\n    if (size >= magicX2AndPadding) {\n        if (checkForMagicArrowString(await file.readAt(0, (magicLength + 7) & ~7))) {\n            return new AsyncRecordBatchFileReader(new AsyncRecordBatchFileReaderImpl<T>(file));\n        }\n    }\n    return new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl<T>(file));\n}\n"]},"metadata":{},"sourceType":"module"}