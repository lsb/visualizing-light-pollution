{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _asyncIterator from \"@babel/runtime/helpers/esm/asyncIterator\";\n\nvar _marked = _regeneratorRuntime.mark(makeChunkIterator),\n    _marked2 = _regeneratorRuntime.mark(makeArrayBufferChunkIterator),\n    _marked3 = _regeneratorRuntime.mark(makeStringChunkIterator);\n\nimport { concatenateArrayBuffers } from '../javascript-utils/memory-copy-utils';\nexport function concatenateChunksAsync(_x) {\n  return _concatenateChunksAsync.apply(this, arguments);\n}\n\nfunction _concatenateChunksAsync() {\n  _concatenateChunksAsync = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(asyncIterator) {\n    var arrayBuffer, string, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            arrayBuffer = new ArrayBuffer(0);\n            string = '';\n            _iteratorNormalCompletion = true;\n            _didIteratorError = false;\n            _context4.prev = 4;\n            _iterator = _asyncIterator(asyncIterator);\n\n          case 6:\n            _context4.next = 8;\n            return _iterator.next();\n\n          case 8:\n            _step = _context4.sent;\n            _iteratorNormalCompletion = _step.done;\n            _context4.next = 12;\n            return _step.value;\n\n          case 12:\n            _value = _context4.sent;\n\n            if (_iteratorNormalCompletion) {\n              _context4.next = 19;\n              break;\n            }\n\n            chunk = _value;\n\n            if (typeof chunk === 'string') {\n              string += chunk;\n            } else {\n              arrayBuffer = concatenateArrayBuffers(arrayBuffer, chunk);\n            }\n\n          case 16:\n            _iteratorNormalCompletion = true;\n            _context4.next = 6;\n            break;\n\n          case 19:\n            _context4.next = 25;\n            break;\n\n          case 21:\n            _context4.prev = 21;\n            _context4.t0 = _context4[\"catch\"](4);\n            _didIteratorError = true;\n            _iteratorError = _context4.t0;\n\n          case 25:\n            _context4.prev = 25;\n            _context4.prev = 26;\n\n            if (!(!_iteratorNormalCompletion && _iterator[\"return\"] != null)) {\n              _context4.next = 30;\n              break;\n            }\n\n            _context4.next = 30;\n            return _iterator[\"return\"]();\n\n          case 30:\n            _context4.prev = 30;\n\n            if (!_didIteratorError) {\n              _context4.next = 33;\n              break;\n            }\n\n            throw _iteratorError;\n\n          case 33:\n            return _context4.finish(30);\n\n          case 34:\n            return _context4.finish(25);\n\n          case 35:\n            return _context4.abrupt(\"return\", string || arrayBuffer);\n\n          case 36:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee, null, [[4, 21, 25, 35], [26,, 30, 34]]);\n  }));\n  return _concatenateChunksAsync.apply(this, arguments);\n}\n\nexport function makeChunkIterator(bigArrayBufferOrString) {\n  var options,\n      _args = arguments;\n  return _regeneratorRuntime.wrap(function makeChunkIterator$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n\n          if (!(typeof bigArrayBufferOrString === 'string')) {\n            _context.next = 4;\n            break;\n          }\n\n          return _context.delegateYield(makeStringChunkIterator(bigArrayBufferOrString, options), \"t0\", 3);\n\n        case 3:\n          return _context.abrupt(\"return\");\n\n        case 4:\n          if (!(bigArrayBufferOrString instanceof ArrayBuffer)) {\n            _context.next = 7;\n            break;\n          }\n\n          return _context.delegateYield(makeArrayBufferChunkIterator(bigArrayBufferOrString, options), \"t1\", 6);\n\n        case 6:\n          return _context.abrupt(\"return\");\n\n        case 7:\n          throw new Error('assert');\n\n        case 8:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n\nfunction makeArrayBufferChunkIterator(arrayBuffer) {\n  var options,\n      _options$chunkSize,\n      chunkSize,\n      byteOffset,\n      chunkByteLength,\n      chunk,\n      sourceArray,\n      chunkArray,\n      _args2 = arguments;\n\n  return _regeneratorRuntime.wrap(function makeArrayBufferChunkIterator$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n          _options$chunkSize = options.chunkSize, chunkSize = _options$chunkSize === void 0 ? 256 * 1024 : _options$chunkSize;\n          byteOffset = 0;\n\n        case 3:\n          if (!(byteOffset < arrayBuffer.byteLength)) {\n            _context2.next = 14;\n            break;\n          }\n\n          chunkByteLength = Math.min(arrayBuffer.byteLength - byteOffset, chunkSize);\n          chunk = new ArrayBuffer(chunkByteLength);\n          sourceArray = new Uint8Array(arrayBuffer, byteOffset, chunkByteLength);\n          chunkArray = new Uint8Array(chunk);\n          chunkArray.set(sourceArray);\n          byteOffset += chunkByteLength;\n          _context2.next = 12;\n          return chunk;\n\n        case 12:\n          _context2.next = 3;\n          break;\n\n        case 14:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2);\n}\n\nfunction makeStringChunkIterator(string) {\n  var options,\n      _options$chunkSize2,\n      chunkSize,\n      offset,\n      chunkLength,\n      chunk,\n      _args3 = arguments;\n\n  return _regeneratorRuntime.wrap(function makeStringChunkIterator$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          options = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};\n          _options$chunkSize2 = options.chunkSize, chunkSize = _options$chunkSize2 === void 0 ? 256 * 1024 : _options$chunkSize2;\n          offset = 0;\n\n        case 3:\n          if (!(offset < string.length)) {\n            _context3.next = 11;\n            break;\n          }\n\n          chunkLength = Math.min(string.length - offset, chunkSize);\n          chunk = string.slice(offset, offset + chunkLength);\n          offset += chunkLength;\n          _context3.next = 9;\n          return chunk;\n\n        case 9:\n          _context3.next = 3;\n          break;\n\n        case 11:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, _marked3);\n}","map":{"version":3,"sources":["../../../src/iterator-utils/chunk-iteration.js"],"names":["arrayBuffer","string","chunk","concatenateArrayBuffers","makeChunkIterator","options","makeStringChunkIterator","bigArrayBufferOrString","makeArrayBufferChunkIterator","chunkSize","byteOffset","chunkByteLength","Math","sourceArray","chunkArray","offset","chunkLength"],"mappings":"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","sourcesContent":["// Breaking big data into iterable chunks, concatenating iterable chunks into big data objects\n\nimport {concatenateArrayBuffers} from '../javascript-utils/memory-copy-utils';\n\n/**\n * Concatenates all data chunks yielded by an (async) iterator\n * Supports strings and ArrayBuffers\n *\n * This function can e.g. be used to enable atomic parsers to work on (async) iterator inputs\n */\nexport async function concatenateChunksAsync(asyncIterator) {\n  let arrayBuffer = new ArrayBuffer(0);\n  let string = '';\n  for await (const chunk of asyncIterator) {\n    if (typeof chunk === 'string') {\n      string += chunk;\n    } else {\n      arrayBuffer = concatenateArrayBuffers(arrayBuffer, chunk);\n    }\n  }\n  return string || arrayBuffer;\n}\n\n/**\n * Returns an iterator that breaks a big `ArrayBuffer` or string into chunks and yields them one-by-one.\n *\n * @param bigArrayBufferOrString\n * @param options\n * @param options.chunkSize\n * @returns iterator that yields chunks of specified size\n *\n * This function can e.g. be used to enable data sources that can only be read atomically\n * (such as `Blob` and `File` via `FileReader`) to still be parsed in batches.\n */\nexport function* makeChunkIterator(bigArrayBufferOrString, options = {}) {\n  if (typeof bigArrayBufferOrString === 'string') {\n    yield* makeStringChunkIterator(bigArrayBufferOrString, options);\n    return;\n  }\n  if (bigArrayBufferOrString instanceof ArrayBuffer) {\n    yield* makeArrayBufferChunkIterator(bigArrayBufferOrString, options);\n    return;\n  }\n  throw new Error('assert');\n}\n\n/**\n * Helper: Breaks a big ArrayBuffer into chunks and returns an iterator that yields them one-by-one\n */\nfunction* makeArrayBufferChunkIterator(arrayBuffer, options = {}) {\n  const {chunkSize = 256 * 1024} = options;\n\n  let byteOffset = 0;\n\n  while (byteOffset < arrayBuffer.byteLength) {\n    // Create a chunk of the right size\n    const chunkByteLength = Math.min(arrayBuffer.byteLength - byteOffset, chunkSize);\n    const chunk = new ArrayBuffer(chunkByteLength);\n\n    // Copy data from the big chunk\n    const sourceArray = new Uint8Array(arrayBuffer, byteOffset, chunkByteLength);\n    const chunkArray = new Uint8Array(chunk);\n    chunkArray.set(sourceArray);\n\n    // yield the chunk\n    byteOffset += chunkByteLength;\n    yield chunk;\n  }\n}\n\n/**\n * Helper: Breaks a big string into chunks and returns an iterator that yields them one-by-one\n */\nfunction* makeStringChunkIterator(string, options = {}) {\n  const {chunkSize = 256 * 1024} = options;\n\n  let offset = 0;\n\n  while (offset < string.length) {\n    // Create a chunk of the right size\n    const chunkLength = Math.min(string.length - offset, chunkSize);\n    const chunk = string.slice(offset, offset + chunkLength);\n    offset += chunkLength;\n\n    // yield the chunk\n    yield chunk;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}