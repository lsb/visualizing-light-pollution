{"ast":null,"code":"import log from '../../utils/log';\nvar NO_PICKED_OBJECT = {\n  pickedColor: null,\n  pickedLayer: null,\n  pickedObjectIndex: -1\n};\nexport function getClosestObject(_ref) {\n  var pickedColors = _ref.pickedColors,\n      layers = _ref.layers,\n      deviceX = _ref.deviceX,\n      deviceY = _ref.deviceY,\n      deviceRadius = _ref.deviceRadius,\n      deviceRect = _ref.deviceRect;\n\n  if (pickedColors) {\n    var x = deviceRect.x,\n        y = deviceRect.y,\n        width = deviceRect.width,\n        height = deviceRect.height;\n    var minSquareDistanceToCenter = deviceRadius * deviceRadius;\n    var closestPixelIndex = -1;\n    var i = 0;\n\n    for (var row = 0; row < height; row++) {\n      var dy = row + y - deviceY;\n      var dy2 = dy * dy;\n\n      if (dy2 > minSquareDistanceToCenter) {\n        i += 4 * width;\n      } else {\n        for (var col = 0; col < width; col++) {\n          var pickedLayerIndex = pickedColors[i + 3] - 1;\n\n          if (pickedLayerIndex >= 0) {\n            var dx = col + x - deviceX;\n            var d2 = dx * dx + dy2;\n\n            if (d2 <= minSquareDistanceToCenter) {\n              minSquareDistanceToCenter = d2;\n              closestPixelIndex = i;\n            }\n          }\n\n          i += 4;\n        }\n      }\n    }\n\n    if (closestPixelIndex >= 0) {\n      var _pickedLayerIndex = pickedColors[closestPixelIndex + 3] - 1;\n\n      var pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);\n      var pickedLayer = layers[_pickedLayerIndex];\n\n      if (pickedLayer) {\n        var pickedObjectIndex = pickedLayer.decodePickingColor(pickedColor);\n\n        var _dy = Math.floor(closestPixelIndex / 4 / width);\n\n        var _dx = closestPixelIndex / 4 - _dy * width;\n\n        return {\n          pickedColor: pickedColor,\n          pickedLayer: pickedLayer,\n          pickedObjectIndex: pickedObjectIndex,\n          pickedX: x + _dx,\n          pickedY: y + _dy\n        };\n      }\n\n      log.error('Picked non-existent layer. Is picking buffer corrupt?')();\n    }\n  }\n\n  return NO_PICKED_OBJECT;\n}\nexport function getUniqueObjects(_ref2) {\n  var pickedColors = _ref2.pickedColors,\n      layers = _ref2.layers;\n  var uniqueColors = new Map();\n\n  if (pickedColors) {\n    for (var i = 0; i < pickedColors.length; i += 4) {\n      var pickedLayerIndex = pickedColors[i + 3] - 1;\n\n      if (pickedLayerIndex >= 0) {\n        var pickedColor = pickedColors.slice(i, i + 4);\n        var colorKey = pickedColor.join(',');\n\n        if (!uniqueColors.has(colorKey)) {\n          var pickedLayer = layers[pickedLayerIndex];\n\n          if (pickedLayer) {\n            uniqueColors.set(colorKey, {\n              pickedColor: pickedColor,\n              pickedLayer: pickedLayer,\n              pickedObjectIndex: pickedLayer.decodePickingColor(pickedColor)\n            });\n          } else {\n            log.error('Picked non-existent layer. Is picking buffer corrupt?')();\n          }\n        }\n      }\n    }\n  }\n\n  return Array.from(uniqueColors.values());\n}","map":{"version":3,"sources":["../../../../src/lib/picking/query-object.js"],"names":["NO_PICKED_OBJECT","pickedColor","pickedLayer","pickedObjectIndex","pickedColors","layers","deviceX","deviceY","deviceRadius","deviceRect","x","y","width","height","minSquareDistanceToCenter","closestPixelIndex","i","row","dy","dy2","col","pickedLayerIndex","dx","d2","Math","pickedX","pickedY","log","uniqueColors","colorKey","Array"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport log from '../../utils/log';\n\nconst NO_PICKED_OBJECT = {\n  pickedColor: null,\n  pickedLayer: null,\n  pickedObjectIndex: -1\n};\n\n/* eslint-disable max-depth, max-statements */\n/**\n * Pick at a specified pixel with a tolerance radius\n * Returns the closest object to the pixel in shape `{pickedColor, pickedLayer, pickedObjectIndex}`\n */\nexport function getClosestObject({\n  pickedColors,\n  layers,\n  deviceX,\n  deviceY,\n  deviceRadius,\n  deviceRect\n}) {\n  if (pickedColors) {\n    // Traverse all pixels in picking results and find the one closest to the supplied\n    // [deviceX, deviceY]\n    const {x, y, width, height} = deviceRect;\n    let minSquareDistanceToCenter = deviceRadius * deviceRadius;\n    let closestPixelIndex = -1;\n    let i = 0;\n\n    for (let row = 0; row < height; row++) {\n      const dy = row + y - deviceY;\n      const dy2 = dy * dy;\n\n      if (dy2 > minSquareDistanceToCenter) {\n        // skip this row\n        i += 4 * width;\n      } else {\n        for (let col = 0; col < width; col++) {\n          // Decode picked layer from color\n          const pickedLayerIndex = pickedColors[i + 3] - 1;\n\n          if (pickedLayerIndex >= 0) {\n            const dx = col + x - deviceX;\n            const d2 = dx * dx + dy2;\n\n            if (d2 <= minSquareDistanceToCenter) {\n              minSquareDistanceToCenter = d2;\n              closestPixelIndex = i;\n            }\n          }\n          i += 4;\n        }\n      }\n    }\n\n    if (closestPixelIndex >= 0) {\n      // Decode picked object index from color\n      const pickedLayerIndex = pickedColors[closestPixelIndex + 3] - 1;\n      const pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);\n      const pickedLayer = layers[pickedLayerIndex];\n      if (pickedLayer) {\n        const pickedObjectIndex = pickedLayer.decodePickingColor(pickedColor);\n        const dy = Math.floor(closestPixelIndex / 4 / width);\n        const dx = closestPixelIndex / 4 - dy * width;\n        return {pickedColor, pickedLayer, pickedObjectIndex, pickedX: x + dx, pickedY: y + dy};\n      }\n      log.error('Picked non-existent layer. Is picking buffer corrupt?')();\n    }\n  }\n  return NO_PICKED_OBJECT;\n}\n\n/**\n * Examines a picking buffer for unique colors\n * Returns array of unique objects in shape `{x, y, pickedColor, pickedLayer, pickedObjectIndex}`\n */\nexport function getUniqueObjects({pickedColors, layers}) {\n  const uniqueColors = new Map();\n\n  // Traverse all pixels in picking results and get unique colors\n  if (pickedColors) {\n    for (let i = 0; i < pickedColors.length; i += 4) {\n      // Decode picked layer from color\n      const pickedLayerIndex = pickedColors[i + 3] - 1;\n\n      if (pickedLayerIndex >= 0) {\n        const pickedColor = pickedColors.slice(i, i + 4);\n        const colorKey = pickedColor.join(',');\n        // eslint-disable-next-line\n        if (!uniqueColors.has(colorKey)) {\n          const pickedLayer = layers[pickedLayerIndex];\n          // eslint-disable-next-line\n          if (pickedLayer) {\n            uniqueColors.set(colorKey, {\n              pickedColor,\n              pickedLayer,\n              pickedObjectIndex: pickedLayer.decodePickingColor(pickedColor)\n            });\n          } else {\n            log.error('Picked non-existent layer. Is picking buffer corrupt?')();\n          }\n        }\n      }\n    }\n  }\n\n  return Array.from(uniqueColors.values());\n}\n"]},"metadata":{},"sourceType":"module"}