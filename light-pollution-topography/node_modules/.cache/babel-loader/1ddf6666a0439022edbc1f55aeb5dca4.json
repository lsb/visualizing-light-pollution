{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { assert } from '@loaders.gl/loader-utils';\n\nvar FileReadableResponse = function () {\n  function FileReadableResponse(fileOrBlob, options) {\n    _classCallCheck(this, FileReadableResponse);\n\n    this._fileOrBlob = fileOrBlob;\n    this.bodyUsed = false;\n  }\n\n  _createClass(FileReadableResponse, [{\n    key: \"arrayBuffer\",\n    value: function () {\n      var _arrayBuffer = _asyncToGenerator(_regeneratorRuntime.mark(function _callee() {\n        var _this$_getFileReader, reader, promise;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _this$_getFileReader = this._getFileReader(), reader = _this$_getFileReader.reader, promise = _this$_getFileReader.promise;\n                reader.readAsArrayBuffer(this._fileOrBlob);\n                return _context.abrupt(\"return\", promise);\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function arrayBuffer() {\n        return _arrayBuffer.apply(this, arguments);\n      }\n\n      return arrayBuffer;\n    }()\n  }, {\n    key: \"text\",\n    value: function () {\n      var _text = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2() {\n        var _this$_getFileReader2, reader, promise;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _this$_getFileReader2 = this._getFileReader(), reader = _this$_getFileReader2.reader, promise = _this$_getFileReader2.promise;\n                reader.readAsText(this._fileOrBlob);\n                return _context2.abrupt(\"return\", promise);\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function text() {\n        return _text.apply(this, arguments);\n      }\n\n      return text;\n    }()\n  }, {\n    key: \"json\",\n    value: function () {\n      var _json = _asyncToGenerator(_regeneratorRuntime.mark(function _callee3() {\n        var text;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.text();\n\n              case 2:\n                text = _context3.sent;\n                return _context3.abrupt(\"return\", JSON.parse(text));\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function json() {\n        return _json.apply(this, arguments);\n      }\n\n      return json;\n    }()\n  }, {\n    key: \"_getFileReader\",\n    value: function _getFileReader() {\n      assert(!this.bodyUsed);\n      this.bodyUsed = true;\n      var reader = new FileReader();\n      var promise = new Promise(function (resolve, reject) {\n        try {\n          reader.onerror = function (_) {\n            return reject(new Error('Read error'));\n          };\n\n          reader.onabort = function () {\n            return reject(new Error('Read aborted.'));\n          };\n\n          reader.onload = function () {\n            return resolve(reader.result);\n          };\n        } catch (error) {\n          reject(error);\n        }\n      });\n      return {\n        reader: reader,\n        promise: promise\n      };\n    }\n  }, {\n    key: \"headers\",\n    get: function get() {\n      return new Headers({\n        'Content-Length': this._fileOrBlob.size,\n        'Content-Type': this._fileOrBlob.type\n      });\n    }\n  }, {\n    key: \"ok\",\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: \"status\",\n    get: function get() {\n      return 200;\n    }\n  }, {\n    key: \"url\",\n    get: function get() {\n      return this._fileOrBlob.name || '';\n    }\n  }]);\n\n  return FileReadableResponse;\n}();\n\nexport default function fetchFileReadable(fileOrBlob, options) {\n  return Promise.resolve(new FileReadableResponse(fileOrBlob, options));\n}","map":{"version":3,"sources":["../../../../src/lib/fetch/fetch-file.browser.js"],"names":["FileReadableResponse","type","reader","promise","text","JSON","assert","reject","resolve","Promise"],"mappings":";;;;AACA,SAAA,MAAA,QAAA,0BAAA;;IAGMA,oB;AACJ,WAAA,oBAAA,CAAA,UAAA,EAAA,OAAA,EAAiC;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,oBAAA,CAAA;;AAC/B,SAAA,WAAA,GAAA,UAAA;AACA,SAAA,QAAA,GAAA,KAAA;AACD;;;;;;;;;;;;uCAwB2B,KAAA,cAAA,E,EAAnBE,M,wBAAAA,M,EAAQC,O,wBAAAA,O;AACfD,gBAAAA,MAAM,CAANA,iBAAAA,CAAyB,KAAzBA,WAAAA;iDACOC,O;;;;;;;;;;;;;;;;;;;;;;;;;;wCAImB,KAAA,cAAA,E,EAAnBD,M,yBAAAA,M,EAAQC,O,yBAAAA,O;AACfD,gBAAAA,MAAM,CAANA,UAAAA,CAAkB,KAAlBA,WAAAA;kDACOC,O;;;;;;;;;;;;;;;;;;;;;;;;;;uBAIY,KAAA,IAAA,E;;;AAAbC,gBAAAA,I,iBAAAA;kDACCC,IAAI,CAAJA,KAAAA,CAAAA,IAAAA,C;;;;;;;;;;;;;;;;;;qCAaQ;AACfC,MAAAA,MAAM,CAAC,CAAC,KAARA,QAAM,CAANA;AACA,WAAA,QAAA,GAAA,IAAA;AAEA,UAAMJ,MAAM,GAAG,IAAf,UAAe,EAAf;AACA,UAAMC,OAAO,GAAG,IAAA,OAAA,CAAY,UAAA,OAAA,EAAA,MAAA,EAAqB;AAC/C,YAAI;AACFD,UAAAA,MAAM,CAANA,OAAAA,GAAiB,UAAA,CAAA,EAAC;AAAA,mBAAIK,MAAM,CAAC,IAAA,KAAA,CAAX,YAAW,CAAD,CAAV;AAAlBL,WAAAA;;AACAA,UAAAA,MAAM,CAANA,OAAAA,GAAiB,YAAA;AAAA,mBAAMK,MAAM,CAAC,IAAA,KAAA,CAAb,eAAa,CAAD,CAAZ;AAAjBL,WAAAA;;AACAA,UAAAA,MAAM,CAANA,MAAAA,GAAgB,YAAA;AAAA,mBAAMM,OAAO,CAACN,MAAM,CAApB,MAAa,CAAb;AAAhBA,WAAAA;AAHF,SAAA,CAIE,OAAA,KAAA,EAAc;AACdK,UAAAA,MAAM,CAANA,KAAM,CAANA;AACD;AAPH,OAAgB,CAAhB;AASA,aAAO;AAACL,QAAAA,MAAM,EAAP,MAAA;AAASC,QAAAA,OAAO,EAAPA;AAAT,OAAP;AACD;;;wBA/Da;AACZ,aAAO,IAAA,OAAA,CAAY;AACjB,0BAAkB,KAAA,WAAA,CADD,IAAA;AAEjB,wBAAgB,KAAA,WAAA,CAAiBF;AAFhB,OAAZ,CAAP;AAID;;;wBAEQ;AACP,aAAA,IAAA;AACD;;;wBAEY;AACX,aAAA,GAAA;AACD;;;wBAES;AAGR,aAAO,KAAA,WAAA,CAAA,IAAA,IAAP,EAAA;AACD;;;;;;AAiDH,eAAe,SAAA,iBAAA,CAAA,UAAA,EAAA,OAAA,EAAgD;AAC7D,SAAOQ,OAAO,CAAPA,OAAAA,CAAgB,IAAA,oBAAA,CAAA,UAAA,EAAvB,OAAuB,CAAhBA,CAAP;AACD","sourcesContent":["/* global FileReader, Headers */\nimport {assert} from '@loaders.gl/loader-utils';\n\n// File reader fetch \"polyfill\" for the browser\nclass FileReadableResponse {\n  constructor(fileOrBlob, options) {\n    this._fileOrBlob = fileOrBlob;\n    this.bodyUsed = false;\n  }\n\n  get headers() {\n    return new Headers({\n      'Content-Length': this._fileOrBlob.size,\n      'Content-Type': this._fileOrBlob.type\n    });\n  }\n\n  get ok() {\n    return true; // Blob & File objects are already in memory\n  }\n\n  get status() {\n    return 200; // Blob & File objects are already in memory\n  }\n\n  get url() {\n    // Note: This is just the file name without path information\n    // Note: File has `name` field but the Blob baseclass does not\n    return this._fileOrBlob.name || '';\n  }\n\n  async arrayBuffer() {\n    const {reader, promise} = this._getFileReader();\n    reader.readAsArrayBuffer(this._fileOrBlob);\n    return promise;\n  }\n\n  async text() {\n    const {reader, promise} = this._getFileReader();\n    reader.readAsText(this._fileOrBlob);\n    return promise;\n  }\n\n  async json() {\n    const text = await this.text();\n    return JSON.parse(text);\n  }\n\n  // TODO - body, how to support stream?\n  // Can this be portable?\n  // eslint-disable-next-line\n  // https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Using_readable_streams#Creating_your_own_custom_readable_stream\n  // get body() {\n  //   assert(false);\n  // }\n\n  // PRIVATE\n\n  _getFileReader() {\n    assert(!this.bodyUsed);\n    this.bodyUsed = true;\n\n    const reader = new FileReader();\n    const promise = new Promise((resolve, reject) => {\n      try {\n        reader.onerror = _ => reject(new Error('Read error')); // TODO extract error\n        reader.onabort = () => reject(new Error('Read aborted.'));\n        reader.onload = () => resolve(reader.result);\n      } catch (error) {\n        reject(error);\n      }\n    });\n    return {reader, promise};\n  }\n}\n\n// @param {File|Blob} file  HTML File or Blob object to read as string\n// @returns {Promise.string}  Resolves to a string containing file contents\nexport default function fetchFileReadable(fileOrBlob, options) {\n  return Promise.resolve(new FileReadableResponse(fileOrBlob, options));\n}\n"]},"metadata":{},"sourceType":"module"}