{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { truncateBitmap } from './util/bit';\nimport { popcnt_bit_range } from './util/bit';\nimport { BufferType, UnionMode, Type } from './enum';\nimport { strideForType } from './type';\nimport { toArrayBufferView, toUint8Array, toInt32Array } from './util/buffer';\n/** @ignore */\n\nexport const kUnknownNullCount = -1;\n/** @ignore */\n\nexport class Data {\n  constructor(type, offset, length, nullCount, buffers, childData, dictionary) {\n    this.type = type;\n    this.dictionary = dictionary;\n    this.offset = Math.floor(Math.max(offset || 0, 0));\n    this.length = Math.floor(Math.max(length || 0, 0));\n    this._nullCount = Math.floor(Math.max(nullCount || 0, -1));\n    this.childData = (childData || []).map(x => x instanceof Data ? x : x.data);\n    let buffer;\n\n    if (buffers instanceof Data) {\n      this.stride = buffers.stride;\n      this.values = buffers.values;\n      this.typeIds = buffers.typeIds;\n      this.nullBitmap = buffers.nullBitmap;\n      this.valueOffsets = buffers.valueOffsets;\n    } else {\n      this.stride = strideForType(type);\n\n      if (buffers) {\n        (buffer = buffers[0]) && (this.valueOffsets = buffer);\n        (buffer = buffers[1]) && (this.values = buffer);\n        (buffer = buffers[2]) && (this.nullBitmap = buffer);\n        (buffer = buffers[3]) && (this.typeIds = buffer);\n      }\n    }\n  }\n\n  get typeId() {\n    return this.type.typeId;\n  }\n\n  get ArrayType() {\n    return this.type.ArrayType;\n  }\n\n  get buffers() {\n    return [this.valueOffsets, this.values, this.nullBitmap, this.typeIds];\n  }\n\n  get byteLength() {\n    let byteLength = 0;\n    let {\n      valueOffsets,\n      values,\n      nullBitmap,\n      typeIds\n    } = this;\n    valueOffsets && (byteLength += valueOffsets.byteLength);\n    values && (byteLength += values.byteLength);\n    nullBitmap && (byteLength += nullBitmap.byteLength);\n    typeIds && (byteLength += typeIds.byteLength);\n    return this.childData.reduce((byteLength, child) => byteLength + child.byteLength, byteLength);\n  }\n\n  get nullCount() {\n    let nullCount = this._nullCount;\n    let nullBitmap;\n\n    if (nullCount <= kUnknownNullCount && (nullBitmap = this.nullBitmap)) {\n      this._nullCount = nullCount = this.length - popcnt_bit_range(nullBitmap, this.offset, this.offset + this.length);\n    }\n\n    return nullCount;\n  }\n\n  clone(type, offset = this.offset, length = this.length, nullCount = this._nullCount, buffers = this, childData = this.childData) {\n    return new Data(type, offset, length, nullCount, buffers, childData, this.dictionary);\n  }\n\n  slice(offset, length) {\n    const {\n      stride,\n      typeId,\n      childData\n    } = this; // +true === 1, +false === 0, so this means\n    // we keep nullCount at 0 if it's already 0,\n    // otherwise set to the invalidated flag -1\n\n    const nullCount = +(this._nullCount === 0) - 1;\n    const childStride = typeId === 16\n    /* FixedSizeList */\n    ? stride : 1;\n\n    const buffers = this._sliceBuffers(offset, length, stride, typeId);\n\n    return this.clone(this.type, this.offset + offset, length, nullCount, buffers, // Don't slice children if we have value offsets (the variable-width types)\n    !childData.length || this.valueOffsets ? childData : this._sliceChildren(childData, childStride * offset, childStride * length));\n  }\n\n  _changeLengthAndBackfillNullBitmap(newLength) {\n    if (this.typeId === Type.Null) {\n      return this.clone(this.type, 0, newLength, 0);\n    }\n\n    const {\n      length,\n      nullCount\n    } = this; // start initialized with 0s (nulls), then fill from 0 to length with 1s (not null)\n\n    const bitmap = new Uint8Array((newLength + 63 & ~63) >> 3).fill(255, 0, length >> 3); // set all the bits in the last byte (up to bit `length - length % 8`) to 1 (not null)\n\n    bitmap[length >> 3] = (1 << length - (length & ~7)) - 1; // if we have a nullBitmap, truncate + slice and set it over the pre-filled 1s\n\n    if (nullCount > 0) {\n      bitmap.set(truncateBitmap(this.offset, length, this.nullBitmap), 0);\n    }\n\n    const buffers = this.buffers;\n    buffers[BufferType.VALIDITY] = bitmap;\n    return this.clone(this.type, 0, newLength, nullCount + (newLength - length), buffers);\n  }\n\n  _sliceBuffers(offset, length, stride, typeId) {\n    let arr,\n        {\n      buffers\n    } = this; // If typeIds exist, slice the typeIds buffer\n\n    (arr = buffers[BufferType.TYPE]) && (buffers[BufferType.TYPE] = arr.subarray(offset, offset + length)); // If offsets exist, only slice the offsets buffer\n\n    (arr = buffers[BufferType.OFFSET]) && (buffers[BufferType.OFFSET] = arr.subarray(offset, offset + length + 1)) || // Otherwise if no offsets, slice the data buffer. Don't slice the data vector for Booleans, since the offset goes by bits not bytes\n    (arr = buffers[BufferType.DATA]) && (buffers[BufferType.DATA] = typeId === 6 ? arr : arr.subarray(stride * offset, stride * (offset + length)));\n    return buffers;\n  }\n\n  _sliceChildren(childData, offset, length) {\n    return childData.map(child => child.slice(offset, length));\n  } //\n  // Convenience methods for creating Data instances for each of the Arrow Vector types\n  //\n\n  /** @nocollapse */\n\n\n  static new(type, offset, length, nullCount, buffers, childData, dictionary) {\n    if (buffers instanceof Data) {\n      buffers = buffers.buffers;\n    } else if (!buffers) {\n      buffers = [];\n    }\n\n    switch (type.typeId) {\n      case Type.Null:\n        return Data.Null(type, offset, length);\n\n      case Type.Int:\n        return Data.Int(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []);\n\n      case Type.Dictionary:\n        return Data.Dictionary(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || [], dictionary);\n\n      case Type.Float:\n        return Data.Float(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []);\n\n      case Type.Bool:\n        return Data.Bool(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []);\n\n      case Type.Decimal:\n        return Data.Decimal(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []);\n\n      case Type.Date:\n        return Data.Date(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []);\n\n      case Type.Time:\n        return Data.Time(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []);\n\n      case Type.Timestamp:\n        return Data.Timestamp(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []);\n\n      case Type.Interval:\n        return Data.Interval(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []);\n\n      case Type.FixedSizeBinary:\n        return Data.FixedSizeBinary(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []);\n\n      case Type.Binary:\n        return Data.Binary(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.OFFSET] || [], buffers[BufferType.DATA] || []);\n\n      case Type.Utf8:\n        return Data.Utf8(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.OFFSET] || [], buffers[BufferType.DATA] || []);\n\n      case Type.List:\n        return Data.List(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.OFFSET] || [], (childData || [])[0]);\n\n      case Type.FixedSizeList:\n        return Data.FixedSizeList(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], (childData || [])[0]);\n\n      case Type.Struct:\n        return Data.Struct(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], childData || []);\n\n      case Type.Map:\n        return Data.Map(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.OFFSET] || [], (childData || [])[0]);\n\n      case Type.Union:\n        return Data.Union(type, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.TYPE] || [], buffers[BufferType.OFFSET] || childData, childData);\n    }\n\n    throw new Error(`Unrecognized typeId ${type.typeId}`);\n  }\n  /** @nocollapse */\n\n\n  static Null(type, offset, length) {\n    return new Data(type, offset, length, 0);\n  }\n  /** @nocollapse */\n\n\n  static Int(type, offset, length, nullCount, nullBitmap, data) {\n    return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n  }\n  /** @nocollapse */\n\n\n  static Dictionary(type, offset, length, nullCount, nullBitmap, data, dictionary) {\n    return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.indices.ArrayType, data), toUint8Array(nullBitmap)], [], dictionary);\n  }\n  /** @nocollapse */\n\n\n  static Float(type, offset, length, nullCount, nullBitmap, data) {\n    return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n  }\n  /** @nocollapse */\n\n\n  static Bool(type, offset, length, nullCount, nullBitmap, data) {\n    return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n  }\n  /** @nocollapse */\n\n\n  static Decimal(type, offset, length, nullCount, nullBitmap, data) {\n    return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n  }\n  /** @nocollapse */\n\n\n  static Date(type, offset, length, nullCount, nullBitmap, data) {\n    return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n  }\n  /** @nocollapse */\n\n\n  static Time(type, offset, length, nullCount, nullBitmap, data) {\n    return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n  }\n  /** @nocollapse */\n\n\n  static Timestamp(type, offset, length, nullCount, nullBitmap, data) {\n    return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n  }\n  /** @nocollapse */\n\n\n  static Interval(type, offset, length, nullCount, nullBitmap, data) {\n    return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n  }\n  /** @nocollapse */\n\n\n  static FixedSizeBinary(type, offset, length, nullCount, nullBitmap, data) {\n    return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n  }\n  /** @nocollapse */\n\n\n  static Binary(type, offset, length, nullCount, nullBitmap, valueOffsets, data) {\n    return new Data(type, offset, length, nullCount, [toInt32Array(valueOffsets), toUint8Array(data), toUint8Array(nullBitmap)]);\n  }\n  /** @nocollapse */\n\n\n  static Utf8(type, offset, length, nullCount, nullBitmap, valueOffsets, data) {\n    return new Data(type, offset, length, nullCount, [toInt32Array(valueOffsets), toUint8Array(data), toUint8Array(nullBitmap)]);\n  }\n  /** @nocollapse */\n\n\n  static List(type, offset, length, nullCount, nullBitmap, valueOffsets, child) {\n    return new Data(type, offset, length, nullCount, [toInt32Array(valueOffsets), undefined, toUint8Array(nullBitmap)], [child]);\n  }\n  /** @nocollapse */\n\n\n  static FixedSizeList(type, offset, length, nullCount, nullBitmap, child) {\n    return new Data(type, offset, length, nullCount, [undefined, undefined, toUint8Array(nullBitmap)], [child]);\n  }\n  /** @nocollapse */\n\n\n  static Struct(type, offset, length, nullCount, nullBitmap, children) {\n    return new Data(type, offset, length, nullCount, [undefined, undefined, toUint8Array(nullBitmap)], children);\n  }\n  /** @nocollapse */\n\n\n  static Map(type, offset, length, nullCount, nullBitmap, valueOffsets, child) {\n    return new Data(type, offset, length, nullCount, [toInt32Array(valueOffsets), undefined, toUint8Array(nullBitmap)], [child]);\n  }\n  /** @nocollapse */\n\n\n  static Union(type, offset, length, nullCount, nullBitmap, typeIds, valueOffsetsOrChildren, children) {\n    const buffers = [undefined, undefined, toUint8Array(nullBitmap), toArrayBufferView(type.ArrayType, typeIds)];\n\n    if (type.mode === UnionMode.Sparse) {\n      return new Data(type, offset, length, nullCount, buffers, valueOffsetsOrChildren);\n    }\n\n    buffers[BufferType.OFFSET] = toInt32Array(valueOffsetsOrChildren);\n    return new Data(type, offset, length, nullCount, buffers, children);\n  }\n\n}\nData.prototype.childData = Object.freeze([]);","map":{"version":3,"sources":["data.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA,SAAS,cAAT,QAA+B,YAA/B;AACA,SAAS,gBAAT,QAAiC,YAAjC;AACA,SAAS,UAAT,EAAqB,SAArB,EAAgC,IAAhC,QAA4C,QAA5C;AACA,SAA4C,aAA5C,QAAiE,QAAjE;AACA,SAAS,iBAAT,EAA4B,YAA5B,EAA0C,YAA1C,QAA8D,eAA9D;AAcA;;AAAe,OAAO,MAAM,iBAAiB,GAAG,CAAC,CAA3B;AAsBtB;;AACA,OAAM,MAAO,IAAP,CAAW;AA+Cb,EAAA,WAAA,CAAY,IAAZ,EAAqB,MAArB,EAAqC,MAArC,EAAqD,SAArD,EAAyE,OAAzE,EAAkH,SAAlH,EAAiJ,UAAjJ,EAAoK;AAChK,SAAK,IAAL,GAAY,IAAZ;AACA,SAAK,UAAL,GAAkB,UAAlB;AACA,SAAK,MAAL,GAAc,IAAI,CAAC,KAAL,CAAW,IAAI,CAAC,GAAL,CAAS,MAAM,IAAI,CAAnB,EAAsB,CAAtB,CAAX,CAAd;AACA,SAAK,MAAL,GAAc,IAAI,CAAC,KAAL,CAAW,IAAI,CAAC,GAAL,CAAS,MAAM,IAAI,CAAnB,EAAsB,CAAtB,CAAX,CAAd;AACA,SAAK,UAAL,GAAkB,IAAI,CAAC,KAAL,CAAW,IAAI,CAAC,GAAL,CAAS,SAAS,IAAI,CAAtB,EAAyB,CAAC,CAA1B,CAAX,CAAlB;AACA,SAAK,SAAL,GAAiB,CAAC,SAAS,IAAI,EAAd,EAAkB,GAAlB,CAAuB,CAAD,IAAO,CAAC,YAAY,IAAb,GAAoB,CAApB,GAAwB,CAAC,CAAC,IAAvD,CAAjB;AACA,QAAI,MAAJ;;AACA,QAAI,OAAO,YAAY,IAAvB,EAA6B;AACzB,WAAK,MAAL,GAAc,OAAO,CAAC,MAAtB;AACA,WAAK,MAAL,GAAc,OAAO,CAAC,MAAtB;AACA,WAAK,OAAL,GAAe,OAAO,CAAC,OAAvB;AACA,WAAK,UAAL,GAAkB,OAAO,CAAC,UAA1B;AACA,WAAK,YAAL,GAAoB,OAAO,CAAC,YAA5B;AACH,KAND,MAMO;AACH,WAAK,MAAL,GAAc,aAAa,CAAC,IAAD,CAA3B;;AACA,UAAI,OAAJ,EAAa;AACT,SAAC,MAAM,GAAI,OAAsB,CAAC,CAAD,CAAjC,MAA0C,KAAK,YAAL,GAAoB,MAA9D;AACA,SAAC,MAAM,GAAI,OAAsB,CAAC,CAAD,CAAjC,MAA0C,KAAK,MAAL,GAAc,MAAxD;AACA,SAAC,MAAM,GAAI,OAAsB,CAAC,CAAD,CAAjC,MAA0C,KAAK,UAAL,GAAkB,MAA5D;AACA,SAAC,MAAM,GAAI,OAAsB,CAAC,CAAD,CAAjC,MAA0C,KAAK,OAAL,GAAe,MAAzD;AACH;AACJ;AACJ;;AAjDD,MAAW,MAAX,GAAiB;AAAiB,WAAO,KAAK,IAAL,CAAU,MAAjB;AAA0B;;AAC5D,MAAW,SAAX,GAAoB;AAAqB,WAAO,KAAK,IAAL,CAAU,SAAjB;AAA6B;;AACtE,MAAW,OAAX,GAAkB;AACd,WAAO,CAAC,KAAK,YAAN,EAAoB,KAAK,MAAzB,EAAiC,KAAK,UAAtC,EAAkD,KAAK,OAAvD,CAAP;AACH;;AACD,MAAW,UAAX,GAAqB;AACjB,QAAI,UAAU,GAAG,CAAjB;AACA,QAAI;AAAE,MAAA,YAAF;AAAgB,MAAA,MAAhB;AAAwB,MAAA,UAAxB;AAAoC,MAAA;AAApC,QAAgD,IAApD;AACA,IAAA,YAAY,KAAK,UAAU,IAAI,YAAY,CAAC,UAAhC,CAAZ;AACA,IAAA,MAAM,KAAW,UAAU,IAAI,MAAM,CAAC,UAAhC,CAAN;AACA,IAAA,UAAU,KAAO,UAAU,IAAI,UAAU,CAAC,UAAhC,CAAV;AACA,IAAA,OAAO,KAAU,UAAU,IAAI,OAAO,CAAC,UAAhC,CAAP;AACA,WAAO,KAAK,SAAL,CAAe,MAAf,CAAsB,CAAC,UAAD,EAAa,KAAb,KAAuB,UAAU,GAAG,KAAK,CAAC,UAAhE,EAA4E,UAA5E,CAAP;AACH;;AAID,MAAW,SAAX,GAAoB;AAChB,QAAI,SAAS,GAAG,KAAK,UAArB;AACA,QAAI,UAAJ;;AACA,QAAI,SAAS,IAAI,iBAAb,KAAmC,UAAU,GAAG,KAAK,UAArD,CAAJ,EAAsE;AAClE,WAAK,UAAL,GAAkB,SAAS,GAAG,KAAK,MAAL,GAAc,gBAAgB,CAAC,UAAD,EAAa,KAAK,MAAlB,EAA0B,KAAK,MAAL,GAAc,KAAK,MAA7C,CAA5D;AACH;;AACD,WAAO,SAAP;AACH;;AA2BM,EAAA,KAAK,CAAqB,IAArB,EAA8B,MAAM,GAAG,KAAK,MAA5C,EAAoD,MAAM,GAAG,KAAK,MAAlE,EAA0E,SAAS,GAAG,KAAK,UAA3F,EAAuG,OAAA,GAA4B,IAAnI,EAAyI,SAAA,GAA+B,KAAK,SAA7K,EAAsL;AAC9L,WAAO,IAAI,IAAJ,CAAS,IAAT,EAAe,MAAf,EAAuB,MAAvB,EAA+B,SAA/B,EAA0C,OAA1C,EAAmD,SAAnD,EAA8D,KAAK,UAAnE,CAAP;AACH;;AAEM,EAAA,KAAK,CAAC,MAAD,EAAiB,MAAjB,EAA+B;AACvC,UAAM;AAAE,MAAA,MAAF;AAAU,MAAA,MAAV;AAAkB,MAAA;AAAlB,QAAgC,IAAtC,CADuC,CAEvC;AACA;AACA;;AACA,UAAM,SAAS,GAAG,EAAE,KAAK,UAAL,KAAoB,CAAtB,IAA2B,CAA7C;AACA,UAAM,WAAW,GAAG,MAAM,KAAK;AAAG;AAAd,MAAoC,MAApC,GAA6C,CAAjE;;AACA,UAAM,OAAO,GAAG,KAAK,aAAL,CAAmB,MAAnB,EAA2B,MAA3B,EAAmC,MAAnC,EAA2C,MAA3C,CAAhB;;AACA,WAAO,KAAK,KAAL,CAAc,KAAK,IAAnB,EAAyB,KAAK,MAAL,GAAc,MAAvC,EAA+C,MAA/C,EAAuD,SAAvD,EAAkE,OAAlE,EACH;AACC,KAAC,SAAS,CAAC,MAAX,IAAqB,KAAK,YAA3B,GAA2C,SAA3C,GAAuD,KAAK,cAAL,CAAoB,SAApB,EAA+B,WAAW,GAAG,MAA7C,EAAqD,WAAW,GAAG,MAAnE,CAFpD,CAAP;AAGH;;AAEM,EAAA,kCAAkC,CAAC,SAAD,EAAkB;AACvD,QAAI,KAAK,MAAL,KAAgB,IAAI,CAAC,IAAzB,EAA+B;AAC3B,aAAO,KAAK,KAAL,CAAW,KAAK,IAAhB,EAAsB,CAAtB,EAAyB,SAAzB,EAAoC,CAApC,CAAP;AACH;;AACD,UAAM;AAAE,MAAA,MAAF;AAAU,MAAA;AAAV,QAAwB,IAA9B,CAJuD,CAKvD;;AACA,UAAM,MAAM,GAAG,IAAI,UAAJ,CAAe,CAAE,SAAS,GAAG,EAAb,GAAmB,CAAC,EAArB,KAA4B,CAA3C,EAA8C,IAA9C,CAAmD,GAAnD,EAAwD,CAAxD,EAA2D,MAAM,IAAI,CAArE,CAAf,CANuD,CAOvD;;AACA,IAAA,MAAM,CAAC,MAAM,IAAI,CAAX,CAAN,GAAsB,CAAC,KAAM,MAAM,IAAI,MAAM,GAAG,CAAC,CAAd,CAAb,IAAkC,CAAxD,CARuD,CASvD;;AACA,QAAI,SAAS,GAAG,CAAhB,EAAmB;AACf,MAAA,MAAM,CAAC,GAAP,CAAW,cAAc,CAAC,KAAK,MAAN,EAAc,MAAd,EAAsB,KAAK,UAA3B,CAAzB,EAAiE,CAAjE;AACH;;AACD,UAAM,OAAO,GAAG,KAAK,OAArB;AACA,IAAA,OAAO,CAAC,UAAU,CAAC,QAAZ,CAAP,GAA+B,MAA/B;AACA,WAAO,KAAK,KAAL,CAAW,KAAK,IAAhB,EAAsB,CAAtB,EAAyB,SAAzB,EAAoC,SAAS,IAAI,SAAS,GAAG,MAAhB,CAA7C,EAAsE,OAAtE,CAAP;AACH;;AAES,EAAA,aAAa,CAAC,MAAD,EAAiB,MAAjB,EAAiC,MAAjC,EAAiD,MAAjD,EAAmE;AACtF,QAAI,GAAJ;AAAA,QAAc;AAAE,MAAA;AAAF,QAAc,IAA5B,CADsF,CAEtF;;AACA,KAAC,GAAG,GAAG,OAAO,CAAC,UAAU,CAAC,IAAZ,CAAd,MAAqC,OAAO,CAAC,UAAU,CAAC,IAAZ,CAAP,GAA2B,GAAG,CAAC,QAAJ,CAAa,MAAb,EAAqB,MAAM,GAAG,MAA9B,CAAhE,EAHsF,CAItF;;AACA,KAAC,GAAG,GAAG,OAAO,CAAC,UAAU,CAAC,MAAZ,CAAd,MAAuC,OAAO,CAAC,UAAU,CAAC,MAAZ,CAAP,GAA6B,GAAG,CAAC,QAAJ,CAAa,MAAb,EAAqB,MAAM,GAAG,MAAT,GAAkB,CAAvC,CAApE,KACA;AACA,KAAC,GAAG,GAAG,OAAO,CAAC,UAAU,CAAC,IAAZ,CAAd,MAAqC,OAAO,CAAC,UAAU,CAAC,IAAZ,CAAP,GAA2B,MAAM,KAAK,CAAX,GAAe,GAAf,GAAqB,GAAG,CAAC,QAAJ,CAAa,MAAM,GAAG,MAAtB,EAA8B,MAAM,IAAI,MAAM,GAAG,MAAb,CAApC,CAArF,CAFA;AAGA,WAAO,OAAP;AACH;;AAES,EAAA,cAAc,CAAC,SAAD,EAAoB,MAApB,EAAoC,MAApC,EAAkD;AACtE,WAAO,SAAS,CAAC,GAAV,CAAe,KAAD,IAAW,KAAK,CAAC,KAAN,CAAY,MAAZ,EAAoB,MAApB,CAAzB,CAAP;AACH,GAxHY,CA0Hb;AACA;AACA;;AACA;;;AACO,SAAO,GAAP,CAA+B,IAA/B,EAAwC,MAAxC,EAAwD,MAAxD,EAAwE,SAAxE,EAA4F,OAA5F,EAAqI,SAArI,EAAoK,UAApK,EAAuL;AAC1L,QAAI,OAAO,YAAY,IAAvB,EAA6B;AAAE,MAAA,OAAO,GAAG,OAAO,CAAC,OAAlB;AAA4B,KAA3D,MAAiE,IAAI,CAAC,OAAL,EAAc;AAAE,MAAA,OAAO,GAAG,EAAV;AAAsC;;AACvH,YAAQ,IAAI,CAAC,MAAb;AACI,WAAK,IAAI,CAAC,IAAV;AAA2B,eAAiB,IAAI,CAAC,IAAL,CAAgC,IAAhC,EAAyD,MAAzD,EAAiE,MAAjE,CAAjB;;AAC3B,WAAK,IAAI,CAAC,GAAV;AAA2B,eAAiB,IAAI,CAAC,GAAL,CAAgC,IAAhC,EAAyD,MAAzD,EAAiE,MAAjE,EAAyE,SAAS,IAAI,CAAtF,EAAyF,OAAO,CAAC,UAAU,CAAC,QAAZ,CAAhG,EAAuH,OAAO,CAAC,UAAU,CAAC,IAAZ,CAAP,IAA4B,EAAnJ,CAAjB;;AAC3B,WAAK,IAAI,CAAC,UAAV;AAA2B,eAAiB,IAAI,CAAC,UAAL,CAAgC,IAAhC,EAAyD,MAAzD,EAAiE,MAAjE,EAAyE,SAAS,IAAI,CAAtF,EAAyF,OAAO,CAAC,UAAU,CAAC,QAAZ,CAAhG,EAAuH,OAAO,CAAC,UAAU,CAAC,IAAZ,CAAP,IAA4B,EAAnJ,EAAuJ,UAAvJ,CAAjB;;AAC3B,WAAK,IAAI,CAAC,KAAV;AAA2B,eAAiB,IAAI,CAAC,KAAL,CAAgC,IAAhC,EAAyD,MAAzD,EAAiE,MAAjE,EAAyE,SAAS,IAAI,CAAtF,EAAyF,OAAO,CAAC,UAAU,CAAC,QAAZ,CAAhG,EAAuH,OAAO,CAAC,UAAU,CAAC,IAAZ,CAAP,IAA4B,EAAnJ,CAAjB;;AAC3B,WAAK,IAAI,CAAC,IAAV;AAA2B,eAAiB,IAAI,CAAC,IAAL,CAAgC,IAAhC,EAAyD,MAAzD,EAAiE,MAAjE,EAAyE,SAAS,IAAI,CAAtF,EAAyF,OAAO,CAAC,UAAU,CAAC,QAAZ,CAAhG,EAAuH,OAAO,CAAC,UAAU,CAAC,IAAZ,CAAP,IAA4B,EAAnJ,CAAjB;;AAC3B,WAAK,IAAI,CAAC,OAAV;AAA2B,eAAiB,IAAI,CAAC,OAAL,CAAgC,IAAhC,EAAyD,MAAzD,EAAiE,MAAjE,EAAyE,SAAS,IAAI,CAAtF,EAAyF,OAAO,CAAC,UAAU,CAAC,QAAZ,CAAhG,EAAuH,OAAO,CAAC,UAAU,CAAC,IAAZ,CAAP,IAA4B,EAAnJ,CAAjB;;AAC3B,WAAK,IAAI,CAAC,IAAV;AAA2B,eAAiB,IAAI,CAAC,IAAL,CAAgC,IAAhC,EAAyD,MAAzD,EAAiE,MAAjE,EAAyE,SAAS,IAAI,CAAtF,EAAyF,OAAO,CAAC,UAAU,CAAC,QAAZ,CAAhG,EAAuH,OAAO,CAAC,UAAU,CAAC,IAAZ,CAAP,IAA4B,EAAnJ,CAAjB;;AAC3B,WAAK,IAAI,CAAC,IAAV;AAA2B,eAAiB,IAAI,CAAC,IAAL,CAAgC,IAAhC,EAAyD,MAAzD,EAAiE,MAAjE,EAAyE,SAAS,IAAI,CAAtF,EAAyF,OAAO,CAAC,UAAU,CAAC,QAAZ,CAAhG,EAAuH,OAAO,CAAC,UAAU,CAAC,IAAZ,CAAP,IAA4B,EAAnJ,CAAjB;;AAC3B,WAAK,IAAI,CAAC,SAAV;AAA2B,eAAiB,IAAI,CAAC,SAAL,CAAgC,IAAhC,EAAyD,MAAzD,EAAiE,MAAjE,EAAyE,SAAS,IAAI,CAAtF,EAAyF,OAAO,CAAC,UAAU,CAAC,QAAZ,CAAhG,EAAuH,OAAO,CAAC,UAAU,CAAC,IAAZ,CAAP,IAA4B,EAAnJ,CAAjB;;AAC3B,WAAK,IAAI,CAAC,QAAV;AAA2B,eAAiB,IAAI,CAAC,QAAL,CAAgC,IAAhC,EAAyD,MAAzD,EAAiE,MAAjE,EAAyE,SAAS,IAAI,CAAtF,EAAyF,OAAO,CAAC,UAAU,CAAC,QAAZ,CAAhG,EAAuH,OAAO,CAAC,UAAU,CAAC,IAAZ,CAAP,IAA4B,EAAnJ,CAAjB;;AAC3B,WAAK,IAAI,CAAC,eAAV;AAA2B,eAAiB,IAAI,CAAC,eAAL,CAAgC,IAAhC,EAAyD,MAAzD,EAAiE,MAAjE,EAAyE,SAAS,IAAI,CAAtF,EAAyF,OAAO,CAAC,UAAU,CAAC,QAAZ,CAAhG,EAAuH,OAAO,CAAC,UAAU,CAAC,IAAZ,CAAP,IAA4B,EAAnJ,CAAjB;;AAC3B,WAAK,IAAI,CAAC,MAAV;AAA2B,eAAiB,IAAI,CAAC,MAAL,CAAgC,IAAhC,EAAyD,MAAzD,EAAiE,MAAjE,EAAyE,SAAS,IAAI,CAAtF,EAAyF,OAAO,CAAC,UAAU,CAAC,QAAZ,CAAhG,EAAuH,OAAO,CAAC,UAAU,CAAC,MAAZ,CAAP,IAA8B,EAArJ,EAAyJ,OAAO,CAAC,UAAU,CAAC,IAAZ,CAAP,IAA4B,EAArL,CAAjB;;AAC3B,WAAK,IAAI,CAAC,IAAV;AAA2B,eAAiB,IAAI,CAAC,IAAL,CAAgC,IAAhC,EAAyD,MAAzD,EAAiE,MAAjE,EAAyE,SAAS,IAAI,CAAtF,EAAyF,OAAO,CAAC,UAAU,CAAC,QAAZ,CAAhG,EAAuH,OAAO,CAAC,UAAU,CAAC,MAAZ,CAAP,IAA8B,EAArJ,EAAyJ,OAAO,CAAC,UAAU,CAAC,IAAZ,CAAP,IAA4B,EAArL,CAAjB;;AAC3B,WAAK,IAAI,CAAC,IAAV;AAA2B,eAAiB,IAAI,CAAC,IAAL,CAAgC,IAAhC,EAAyD,MAAzD,EAAiE,MAAjE,EAAyE,SAAS,IAAI,CAAtF,EAAyF,OAAO,CAAC,UAAU,CAAC,QAAZ,CAAhG,EAAuH,OAAO,CAAC,UAAU,CAAC,MAAZ,CAAP,IAA8B,EAArJ,EAAyJ,CAAC,SAAS,IAAI,EAAd,EAAkB,CAAlB,CAAzJ,CAAjB;;AAC3B,WAAK,IAAI,CAAC,aAAV;AAA2B,eAAiB,IAAI,CAAC,aAAL,CAAgC,IAAhC,EAAyD,MAAzD,EAAiE,MAAjE,EAAyE,SAAS,IAAI,CAAtF,EAAyF,OAAO,CAAC,UAAU,CAAC,QAAZ,CAAhG,EAAuH,CAAC,SAAS,IAAI,EAAd,EAAkB,CAAlB,CAAvH,CAAjB;;AAC3B,WAAK,IAAI,CAAC,MAAV;AAA2B,eAAiB,IAAI,CAAC,MAAL,CAAgC,IAAhC,EAAyD,MAAzD,EAAiE,MAAjE,EAAyE,SAAS,IAAI,CAAtF,EAAyF,OAAO,CAAC,UAAU,CAAC,QAAZ,CAAhG,EAAuH,SAAS,IAAI,EAApI,CAAjB;;AAC3B,WAAK,IAAI,CAAC,GAAV;AAA2B,eAAiB,IAAI,CAAC,GAAL,CAAgC,IAAhC,EAAyD,MAAzD,EAAiE,MAAjE,EAAyE,SAAS,IAAI,CAAtF,EAAyF,OAAO,CAAC,UAAU,CAAC,QAAZ,CAAhG,EAAuH,OAAO,CAAC,UAAU,CAAC,MAAZ,CAAP,IAA8B,EAArJ,EAAyJ,CAAC,SAAS,IAAI,EAAd,EAAkB,CAAlB,CAAzJ,CAAjB;;AAC3B,WAAK,IAAI,CAAC,KAAV;AAA2B,eAAiB,IAAI,CAAC,KAAL,CAAgC,IAAhC,EAAyD,MAAzD,EAAiE,MAAjE,EAAyE,SAAS,IAAI,CAAtF,EAAyF,OAAO,CAAC,UAAU,CAAC,QAAZ,CAAhG,EAAuH,OAAO,CAAC,UAAU,CAAC,IAAZ,CAAP,IAA4B,EAAnJ,EAAuJ,OAAO,CAAC,UAAU,CAAC,MAAZ,CAAP,IAA8B,SAArL,EAAgM,SAAhM,CAAjB;AAlB/B;;AAoBA,UAAM,IAAI,KAAJ,CAAU,uBAAuB,IAAI,CAAC,MAAM,EAA5C,CAAN;AACH;AAED;;;AACO,SAAO,IAAP,CAA4B,IAA5B,EAAqC,MAArC,EAAqD,MAArD,EAAmE;AACtE,WAAO,IAAI,IAAJ,CAAS,IAAT,EAAe,MAAf,EAAuB,MAAvB,EAA+B,CAA/B,CAAP;AACH;AACD;;;AACO,SAAO,GAAP,CAA0B,IAA1B,EAAmC,MAAnC,EAAmD,MAAnD,EAAmE,SAAnE,EAAsF,UAAtF,EAA8G,IAA9G,EAAiI;AACpI,WAAO,IAAI,IAAJ,CAAS,IAAT,EAAe,MAAf,EAAuB,MAAvB,EAA+B,SAA/B,EAA0C,CAAC,SAAD,EAAY,iBAAiB,CAAC,IAAI,CAAC,SAAN,EAAiB,IAAjB,CAA7B,EAAqD,YAAY,CAAC,UAAD,CAAjE,CAA1C,CAAP;AACH;AACD;;;AACO,SAAO,UAAP,CAAwC,IAAxC,EAAiD,MAAjD,EAAiE,MAAjE,EAAiF,SAAjF,EAAoG,UAApG,EAA4H,IAA5H,EAAiJ,UAAjJ,EAAoL;AACvL,WAAO,IAAI,IAAJ,CAAS,IAAT,EAAe,MAAf,EAAuB,MAAvB,EAA+B,SAA/B,EAA0C,CAAC,SAAD,EAAY,iBAAiB,CAAc,IAAI,CAAC,OAAL,CAAa,SAA3B,EAAsC,IAAtC,CAA7B,EAA0E,YAAY,CAAC,UAAD,CAAtF,CAA1C,EAA+I,EAA/I,EAAmJ,UAAnJ,CAAP;AACH;AACD;;;AACO,SAAO,KAAP,CAA8B,IAA9B,EAAuC,MAAvC,EAAuD,MAAvD,EAAuE,SAAvE,EAA0F,UAA1F,EAAkH,IAAlH,EAAqI;AACxI,WAAO,IAAI,IAAJ,CAAS,IAAT,EAAe,MAAf,EAAuB,MAAvB,EAA+B,SAA/B,EAA0C,CAAC,SAAD,EAAY,iBAAiB,CAAC,IAAI,CAAC,SAAN,EAAiB,IAAjB,CAA7B,EAAqD,YAAY,CAAC,UAAD,CAAjE,CAA1C,CAAP;AACH;AACD;;;AACO,SAAO,IAAP,CAA4B,IAA5B,EAAqC,MAArC,EAAqD,MAArD,EAAqE,SAArE,EAAwF,UAAxF,EAAgH,IAAhH,EAAmI;AACtI,WAAO,IAAI,IAAJ,CAAS,IAAT,EAAe,MAAf,EAAuB,MAAvB,EAA+B,SAA/B,EAA0C,CAAC,SAAD,EAAY,iBAAiB,CAAC,IAAI,CAAC,SAAN,EAAiB,IAAjB,CAA7B,EAAqD,YAAY,CAAC,UAAD,CAAjE,CAA1C,CAAP;AACH;AACD;;;AACO,SAAO,OAAP,CAAkC,IAAlC,EAA2C,MAA3C,EAA2D,MAA3D,EAA2E,SAA3E,EAA8F,UAA9F,EAAsH,IAAtH,EAAyI;AAC5I,WAAO,IAAI,IAAJ,CAAS,IAAT,EAAe,MAAf,EAAuB,MAAvB,EAA+B,SAA/B,EAA0C,CAAC,SAAD,EAAY,iBAAiB,CAAC,IAAI,CAAC,SAAN,EAAiB,IAAjB,CAA7B,EAAqD,YAAY,CAAC,UAAD,CAAjE,CAA1C,CAAP;AACH;AACD;;;AACO,SAAO,IAAP,CAA6B,IAA7B,EAAsC,MAAtC,EAAsD,MAAtD,EAAsE,SAAtE,EAAyF,UAAzF,EAAiH,IAAjH,EAAoI;AACvI,WAAO,IAAI,IAAJ,CAAS,IAAT,EAAe,MAAf,EAAuB,MAAvB,EAA+B,SAA/B,EAA0C,CAAC,SAAD,EAAY,iBAAiB,CAAC,IAAI,CAAC,SAAN,EAAiB,IAAjB,CAA7B,EAAqD,YAAY,CAAC,UAAD,CAAjE,CAA1C,CAAP;AACH;AACD;;;AACO,SAAO,IAAP,CAA4B,IAA5B,EAAqC,MAArC,EAAqD,MAArD,EAAqE,SAArE,EAAwF,UAAxF,EAAgH,IAAhH,EAAmI;AACtI,WAAO,IAAI,IAAJ,CAAS,IAAT,EAAe,MAAf,EAAuB,MAAvB,EAA+B,SAA/B,EAA0C,CAAC,SAAD,EAAY,iBAAiB,CAAC,IAAI,CAAC,SAAN,EAAiB,IAAjB,CAA7B,EAAqD,YAAY,CAAC,UAAD,CAAjE,CAA1C,CAAP;AACH;AACD;;;AACO,SAAO,SAAP,CAAsC,IAAtC,EAA+C,MAA/C,EAA+D,MAA/D,EAA+E,SAA/E,EAAkG,UAAlG,EAA0H,IAA1H,EAA6I;AAChJ,WAAO,IAAI,IAAJ,CAAS,IAAT,EAAe,MAAf,EAAuB,MAAvB,EAA+B,SAA/B,EAA0C,CAAC,SAAD,EAAY,iBAAiB,CAAC,IAAI,CAAC,SAAN,EAAiB,IAAjB,CAA7B,EAAqD,YAAY,CAAC,UAAD,CAAjE,CAA1C,CAAP;AACH;AACD;;;AACO,SAAO,QAAP,CAAoC,IAApC,EAA6C,MAA7C,EAA6D,MAA7D,EAA6E,SAA7E,EAAgG,UAAhG,EAAwH,IAAxH,EAA2I;AAC9I,WAAO,IAAI,IAAJ,CAAS,IAAT,EAAe,MAAf,EAAuB,MAAvB,EAA+B,SAA/B,EAA0C,CAAC,SAAD,EAAY,iBAAiB,CAAC,IAAI,CAAC,SAAN,EAAiB,IAAjB,CAA7B,EAAqD,YAAY,CAAC,UAAD,CAAjE,CAA1C,CAAP;AACH;AACD;;;AACO,SAAO,eAAP,CAAkD,IAAlD,EAA2D,MAA3D,EAA2E,MAA3E,EAA2F,SAA3F,EAA8G,UAA9G,EAAsI,IAAtI,EAAyJ;AAC5J,WAAO,IAAI,IAAJ,CAAS,IAAT,EAAe,MAAf,EAAuB,MAAvB,EAA+B,SAA/B,EAA0C,CAAC,SAAD,EAAY,iBAAiB,CAAC,IAAI,CAAC,SAAN,EAAiB,IAAjB,CAA7B,EAAqD,YAAY,CAAC,UAAD,CAAjE,CAA1C,CAAP;AACH;AACD;;;AACO,SAAO,MAAP,CAAgC,IAAhC,EAAyC,MAAzC,EAAyD,MAAzD,EAAyE,SAAzE,EAA4F,UAA5F,EAAoH,YAApH,EAAsJ,IAAtJ,EAAsK;AACzK,WAAO,IAAI,IAAJ,CAAS,IAAT,EAAe,MAAf,EAAuB,MAAvB,EAA+B,SAA/B,EAA0C,CAAC,YAAY,CAAC,YAAD,CAAb,EAA6B,YAAY,CAAC,IAAD,CAAzC,EAAiD,YAAY,CAAC,UAAD,CAA7D,CAA1C,CAAP;AACH;AACD;;;AACO,SAAO,IAAP,CAA4B,IAA5B,EAAqC,MAArC,EAAqD,MAArD,EAAqE,SAArE,EAAwF,UAAxF,EAAgH,YAAhH,EAAkJ,IAAlJ,EAAkK;AACrK,WAAO,IAAI,IAAJ,CAAS,IAAT,EAAe,MAAf,EAAuB,MAAvB,EAA+B,SAA/B,EAA0C,CAAC,YAAY,CAAC,YAAD,CAAb,EAA6B,YAAY,CAAC,IAAD,CAAzC,EAAiD,YAAY,CAAC,UAAD,CAA7D,CAA1C,CAAP;AACH;AACD;;;AACO,SAAO,IAAP,CAA4B,IAA5B,EAAqC,MAArC,EAAqD,MAArD,EAAqE,SAArE,EAAwF,UAAxF,EAAgH,YAAhH,EAAkJ,KAAlJ,EAAsM;AACzM,WAAO,IAAI,IAAJ,CAAS,IAAT,EAAe,MAAf,EAAuB,MAAvB,EAA+B,SAA/B,EAA0C,CAAC,YAAY,CAAC,YAAD,CAAb,EAA6B,SAA7B,EAAwC,YAAY,CAAC,UAAD,CAApD,CAA1C,EAA6G,CAAC,KAAD,CAA7G,CAAP;AACH;AACD;;;AACO,SAAO,aAAP,CAA8C,IAA9C,EAAuD,MAAvD,EAAuE,MAAvE,EAAuF,SAAvF,EAA0G,UAA1G,EAAkI,KAAlI,EAAsL;AACzL,WAAO,IAAI,IAAJ,CAAS,IAAT,EAAe,MAAf,EAAuB,MAAvB,EAA+B,SAA/B,EAA0C,CAAC,SAAD,EAAY,SAAZ,EAAuB,YAAY,CAAC,UAAD,CAAnC,CAA1C,EAA4F,CAAC,KAAD,CAA5F,CAAP;AACH;AACD;;;AACO,SAAO,MAAP,CAAgC,IAAhC,EAAyC,MAAzC,EAAyD,MAAzD,EAAyE,SAAzE,EAA4F,UAA5F,EAAoH,QAApH,EAA+I;AAClJ,WAAO,IAAI,IAAJ,CAAS,IAAT,EAAe,MAAf,EAAuB,MAAvB,EAA+B,SAA/B,EAA0C,CAAC,SAAD,EAAY,SAAZ,EAAuB,YAAY,CAAC,UAAD,CAAnC,CAA1C,EAA4F,QAA5F,CAAP;AACH;AACD;;;AACO,SAAO,GAAP,CAA2B,IAA3B,EAAoC,MAApC,EAAoD,MAApD,EAAoE,SAApE,EAAuF,UAAvF,EAA+G,YAA/G,EAAiJ,KAAjJ,EAAuK;AAC1K,WAAO,IAAI,IAAJ,CAAS,IAAT,EAAe,MAAf,EAAuB,MAAvB,EAA+B,SAA/B,EAA0C,CAAC,YAAY,CAAC,YAAD,CAAb,EAA6B,SAA7B,EAAwC,YAAY,CAAC,UAAD,CAApD,CAA1C,EAA6G,CAAC,KAAD,CAA7G,CAAP;AACH;AAID;;;AACO,SAAO,KAAP,CAA8B,IAA9B,EAAuC,MAAvC,EAAuD,MAAvD,EAAuE,SAAvE,EAA0F,UAA1F,EAAkH,OAAlH,EAA0I,sBAA1I,EAA0M,QAA1M,EAAsO;AACzO,UAAM,OAAO,GAAa,CACtB,SADsB,EACX,SADW,EAEtB,YAAY,CAAC,UAAD,CAFU,EAGtB,iBAAiB,CAAC,IAAI,CAAC,SAAN,EAAiB,OAAjB,CAHK,CAA1B;;AAKA,QAAI,IAAI,CAAC,IAAL,KAAc,SAAS,CAAC,MAA5B,EAAoC;AAChC,aAAO,IAAI,IAAJ,CAAS,IAAT,EAAe,MAAf,EAAuB,MAAvB,EAA+B,SAA/B,EAA0C,OAA1C,EAAmD,sBAAnD,CAAP;AACH;;AACD,IAAA,OAAO,CAAC,UAAU,CAAC,MAAZ,CAAP,GAA6B,YAAY,CAAsB,sBAAtB,CAAzC;AACA,WAAO,IAAI,IAAJ,CAAS,IAAT,EAAe,MAAf,EAAuB,MAAvB,EAA+B,SAA/B,EAA0C,OAA1C,EAAmD,QAAnD,CAAP;AACH;;AA1OY;AA6OhB,IAAI,CAAC,SAAL,CAAuB,SAAvB,GAAmC,MAAM,CAAC,MAAP,CAAc,EAAd,CAAnC","sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Vector } from './vector';\nimport { truncateBitmap } from './util/bit';\nimport { popcnt_bit_range } from './util/bit';\nimport { BufferType, UnionMode, Type } from './enum';\nimport { DataType, SparseUnion, DenseUnion, strideForType } from './type';\nimport { toArrayBufferView, toUint8Array, toInt32Array } from './util/buffer';\nimport {\n    Dictionary,\n    Null, Int, Float,\n    Binary, Bool, Utf8, Decimal,\n    Date_, Time, Timestamp, Interval,\n    List, Struct, Union, FixedSizeBinary, FixedSizeList, Map_,\n} from './type';\n\n// When slicing, we do not know the null count of the sliced range without\n// doing some computation. To avoid doing this eagerly, we set the null count\n// to -1 (any negative number will do). When Vector.nullCount is called the\n// first time, the null count will be computed. See ARROW-33\n/** @ignore */ export type kUnknownNullCount = -1;\n/** @ignore */ export const kUnknownNullCount = -1;\n\n/** @ignore */ export type NullBuffer = Uint8Array | null | undefined;\n/** @ignore */ export type TypeIdsBuffer = Int8Array  | ArrayLike<number> | Iterable<number> | undefined;\n/** @ignore */ export type ValueOffsetsBuffer = Int32Array  | ArrayLike<number> | Iterable<number> | undefined;\n/** @ignore */ export type DataBuffer<T extends DataType> = T['TArray'] | ArrayLike<number> | Iterable<number> | undefined;\n\n/** @ignore */\nexport interface Buffers<T extends DataType> {\n      [BufferType.OFFSET]: Int32Array;\n        [BufferType.DATA]: T['TArray'];\n    [BufferType.VALIDITY]: Uint8Array;\n        [BufferType.TYPE]: T['TArray'];\n}\n\n/** @ignore */\nexport interface Data<T extends DataType = DataType> {\n    readonly TType: T['TType'];\n    readonly TArray: T['TArray'];\n    readonly TValue: T['TValue'];\n}\n\n/** @ignore */\nexport class Data<T extends DataType = DataType> {\n\n    public readonly type: T;\n    public readonly length: number;\n    public readonly offset: number;\n    public readonly stride: number;\n    public readonly childData: Data[];\n\n    /**\n     * The dictionary for this Vector, if any. Only used for Dictionary type.\n     */\n    public dictionary?: Vector;\n\n    public readonly values: Buffers<T>[BufferType.DATA];\n    // @ts-ignore\n    public readonly typeIds: Buffers<T>[BufferType.TYPE];\n    // @ts-ignore\n    public readonly nullBitmap: Buffers<T>[BufferType.VALIDITY];\n    // @ts-ignore\n    public readonly valueOffsets: Buffers<T>[BufferType.OFFSET];\n\n    public get typeId(): T['TType'] { return this.type.typeId; }\n    public get ArrayType(): T['ArrayType'] { return this.type.ArrayType; }\n    public get buffers() {\n        return [this.valueOffsets, this.values, this.nullBitmap, this.typeIds] as Buffers<T>;\n    }\n    public get byteLength(): number {\n        let byteLength = 0;\n        let { valueOffsets, values, nullBitmap, typeIds } = this;\n        valueOffsets && (byteLength += valueOffsets.byteLength);\n        values       && (byteLength += values.byteLength);\n        nullBitmap   && (byteLength += nullBitmap.byteLength);\n        typeIds      && (byteLength += typeIds.byteLength);\n        return this.childData.reduce((byteLength, child) => byteLength + child.byteLength, byteLength);\n    }\n\n    protected _nullCount: number | kUnknownNullCount;\n\n    public get nullCount() {\n        let nullCount = this._nullCount;\n        let nullBitmap: Uint8Array | undefined;\n        if (nullCount <= kUnknownNullCount && (nullBitmap = this.nullBitmap)) {\n            this._nullCount = nullCount = this.length - popcnt_bit_range(nullBitmap, this.offset, this.offset + this.length);\n        }\n        return nullCount;\n    }\n\n    constructor(type: T, offset: number, length: number, nullCount?: number, buffers?: Partial<Buffers<T>> | Data<T>, childData?: (Data | Vector)[], dictionary?: Vector) {\n        this.type = type;\n        this.dictionary = dictionary;\n        this.offset = Math.floor(Math.max(offset || 0, 0));\n        this.length = Math.floor(Math.max(length || 0, 0));\n        this._nullCount = Math.floor(Math.max(nullCount || 0, -1));\n        this.childData = (childData || []).map((x) => x instanceof Data ? x : x.data) as Data[];\n        let buffer: Buffers<T>[keyof Buffers<T>];\n        if (buffers instanceof Data) {\n            this.stride = buffers.stride;\n            this.values = buffers.values;\n            this.typeIds = buffers.typeIds;\n            this.nullBitmap = buffers.nullBitmap;\n            this.valueOffsets = buffers.valueOffsets;\n        } else {\n            this.stride = strideForType(type);\n            if (buffers) {\n                (buffer = (buffers as Buffers<T>)[0]) && (this.valueOffsets = buffer);\n                (buffer = (buffers as Buffers<T>)[1]) && (this.values = buffer);\n                (buffer = (buffers as Buffers<T>)[2]) && (this.nullBitmap = buffer);\n                (buffer = (buffers as Buffers<T>)[3]) && (this.typeIds = buffer);\n            }\n        }\n    }\n\n    public clone<R extends DataType>(type: R, offset = this.offset, length = this.length, nullCount = this._nullCount, buffers: Buffers<R> = <any> this, childData: (Data | Vector)[] = this.childData) {\n        return new Data(type, offset, length, nullCount, buffers, childData, this.dictionary);\n    }\n\n    public slice(offset: number, length: number): Data<T> {\n        const { stride, typeId, childData } = this;\n        // +true === 1, +false === 0, so this means\n        // we keep nullCount at 0 if it's already 0,\n        // otherwise set to the invalidated flag -1\n        const nullCount = +(this._nullCount === 0) - 1;\n        const childStride = typeId === 16 /* FixedSizeList */ ? stride : 1;\n        const buffers = this._sliceBuffers(offset, length, stride, typeId);\n        return this.clone<T>(this.type, this.offset + offset, length, nullCount, buffers,\n            // Don't slice children if we have value offsets (the variable-width types)\n            (!childData.length || this.valueOffsets) ? childData : this._sliceChildren(childData, childStride * offset, childStride * length));\n    }\n\n    public _changeLengthAndBackfillNullBitmap(newLength: number): Data<T> {\n        if (this.typeId === Type.Null) {\n            return this.clone(this.type, 0, newLength, 0);\n        }\n        const { length, nullCount } = this;\n        // start initialized with 0s (nulls), then fill from 0 to length with 1s (not null)\n        const bitmap = new Uint8Array(((newLength + 63) & ~63) >> 3).fill(255, 0, length >> 3);\n        // set all the bits in the last byte (up to bit `length - length % 8`) to 1 (not null)\n        bitmap[length >> 3] = (1 << (length - (length & ~7))) - 1;\n        // if we have a nullBitmap, truncate + slice and set it over the pre-filled 1s\n        if (nullCount > 0) {\n            bitmap.set(truncateBitmap(this.offset, length, this.nullBitmap), 0);\n        }\n        const buffers = this.buffers;\n        buffers[BufferType.VALIDITY] = bitmap;\n        return this.clone(this.type, 0, newLength, nullCount + (newLength - length), buffers);\n    }\n\n    protected _sliceBuffers(offset: number, length: number, stride: number, typeId: T['TType']): Buffers<T> {\n        let arr: any, { buffers } = this;\n        // If typeIds exist, slice the typeIds buffer\n        (arr = buffers[BufferType.TYPE]) && (buffers[BufferType.TYPE] = arr.subarray(offset, offset + length));\n        // If offsets exist, only slice the offsets buffer\n        (arr = buffers[BufferType.OFFSET]) && (buffers[BufferType.OFFSET] = arr.subarray(offset, offset + length + 1)) ||\n        // Otherwise if no offsets, slice the data buffer. Don't slice the data vector for Booleans, since the offset goes by bits not bytes\n        (arr = buffers[BufferType.DATA]) && (buffers[BufferType.DATA] = typeId === 6 ? arr : arr.subarray(stride * offset, stride * (offset + length)));\n        return buffers;\n    }\n\n    protected _sliceChildren(childData: Data[], offset: number, length: number): Data[] {\n        return childData.map((child) => child.slice(offset, length));\n    }\n\n    //\n    // Convenience methods for creating Data instances for each of the Arrow Vector types\n    //\n    /** @nocollapse */\n    public static new<T extends DataType>(type: T, offset: number, length: number, nullCount?: number, buffers?: Partial<Buffers<T>> | Data<T>, childData?: (Data | Vector)[], dictionary?: Vector): Data<T> {\n        if (buffers instanceof Data) { buffers = buffers.buffers; } else if (!buffers) { buffers = [] as Partial<Buffers<T>>; }\n        switch (type.typeId) {\n            case Type.Null:            return <unknown> Data.Null(            <unknown> type as Null,            offset, length) as Data<T>;\n            case Type.Int:             return <unknown> Data.Int(             <unknown> type as Int,             offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []) as Data<T>;\n            case Type.Dictionary:      return <unknown> Data.Dictionary(      <unknown> type as Dictionary,      offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || [], dictionary!) as Data<T>;\n            case Type.Float:           return <unknown> Data.Float(           <unknown> type as Float,           offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []) as Data<T>;\n            case Type.Bool:            return <unknown> Data.Bool(            <unknown> type as Bool,            offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []) as Data<T>;\n            case Type.Decimal:         return <unknown> Data.Decimal(         <unknown> type as Decimal,         offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []) as Data<T>;\n            case Type.Date:            return <unknown> Data.Date(            <unknown> type as Date_,           offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []) as Data<T>;\n            case Type.Time:            return <unknown> Data.Time(            <unknown> type as Time,            offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []) as Data<T>;\n            case Type.Timestamp:       return <unknown> Data.Timestamp(       <unknown> type as Timestamp,       offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []) as Data<T>;\n            case Type.Interval:        return <unknown> Data.Interval(        <unknown> type as Interval,        offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []) as Data<T>;\n            case Type.FixedSizeBinary: return <unknown> Data.FixedSizeBinary( <unknown> type as FixedSizeBinary, offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.DATA] || []) as Data<T>;\n            case Type.Binary:          return <unknown> Data.Binary(          <unknown> type as Binary,          offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.OFFSET] || [], buffers[BufferType.DATA] || []) as Data<T>;\n            case Type.Utf8:            return <unknown> Data.Utf8(            <unknown> type as Utf8,            offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.OFFSET] || [], buffers[BufferType.DATA] || []) as Data<T>;\n            case Type.List:            return <unknown> Data.List(            <unknown> type as List,            offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.OFFSET] || [], (childData || [])[0]) as Data<T>;\n            case Type.FixedSizeList:   return <unknown> Data.FixedSizeList(   <unknown> type as FixedSizeList,   offset, length, nullCount || 0, buffers[BufferType.VALIDITY], (childData || [])[0]) as Data<T>;\n            case Type.Struct:          return <unknown> Data.Struct(          <unknown> type as Struct,          offset, length, nullCount || 0, buffers[BufferType.VALIDITY], childData || []) as Data<T>;\n            case Type.Map:             return <unknown> Data.Map(             <unknown> type as Map_,            offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.OFFSET] || [], (childData || [])[0]) as Data<T>;\n            case Type.Union:           return <unknown> Data.Union(           <unknown> type as Union,           offset, length, nullCount || 0, buffers[BufferType.VALIDITY], buffers[BufferType.TYPE] || [], buffers[BufferType.OFFSET] || childData, childData) as Data<T>;\n        }\n        throw new Error(`Unrecognized typeId ${type.typeId}`);\n    }\n\n    /** @nocollapse */\n    public static Null<T extends Null>(type: T, offset: number, length: number) {\n        return new Data(type, offset, length, 0);\n    }\n    /** @nocollapse */\n    public static Int<T extends Int>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Dictionary<T extends Dictionary>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>, dictionary: Vector<T['dictionary']>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView<T['TArray']>(type.indices.ArrayType, data), toUint8Array(nullBitmap)], [], dictionary);\n    }\n    /** @nocollapse */\n    public static Float<T extends Float>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Bool<T extends Bool>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Decimal<T extends Decimal>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Date<T extends Date_>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Time<T extends Time>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Timestamp<T extends Timestamp>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Interval<T extends Interval>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static FixedSizeBinary<T extends FixedSizeBinary>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, data: DataBuffer<T>) {\n        return new Data(type, offset, length, nullCount, [undefined, toArrayBufferView(type.ArrayType, data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Binary<T extends Binary>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, valueOffsets: ValueOffsetsBuffer, data: Uint8Array) {\n        return new Data(type, offset, length, nullCount, [toInt32Array(valueOffsets), toUint8Array(data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static Utf8<T extends Utf8>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, valueOffsets: ValueOffsetsBuffer, data: Uint8Array) {\n        return new Data(type, offset, length, nullCount, [toInt32Array(valueOffsets), toUint8Array(data), toUint8Array(nullBitmap)]);\n    }\n    /** @nocollapse */\n    public static List<T extends List>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, valueOffsets: ValueOffsetsBuffer, child: Data<T['valueType']> | Vector<T['valueType']>) {\n        return new Data(type, offset, length, nullCount, [toInt32Array(valueOffsets), undefined, toUint8Array(nullBitmap)], [child]);\n    }\n    /** @nocollapse */\n    public static FixedSizeList<T extends FixedSizeList>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, child: Data<T['valueType']> | Vector<T['valueType']>) {\n        return new Data(type, offset, length, nullCount, [undefined, undefined, toUint8Array(nullBitmap)], [child]);\n    }\n    /** @nocollapse */\n    public static Struct<T extends Struct>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, children: (Data | Vector)[]) {\n        return new Data(type, offset, length, nullCount, [undefined, undefined, toUint8Array(nullBitmap)], children);\n    }\n    /** @nocollapse */\n    public static Map<T extends Map_>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, valueOffsets: ValueOffsetsBuffer, child: (Data | Vector)) {\n        return new Data(type, offset, length, nullCount, [toInt32Array(valueOffsets), undefined, toUint8Array(nullBitmap)], [child]);\n    }\n    public static Union<T extends SparseUnion>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, typeIds: TypeIdsBuffer, children: (Data | Vector)[], _?: any): Data<T>;\n    public static Union<T extends DenseUnion>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, typeIds: TypeIdsBuffer, valueOffsets: ValueOffsetsBuffer, children: (Data | Vector)[]): Data<T>;\n    public static Union<T extends Union>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, typeIds: TypeIdsBuffer, valueOffsetsOrChildren: ValueOffsetsBuffer | (Data | Vector)[], children?: (Data | Vector)[]): Data<T>;\n    /** @nocollapse */\n    public static Union<T extends Union>(type: T, offset: number, length: number, nullCount: number, nullBitmap: NullBuffer, typeIds: TypeIdsBuffer, valueOffsetsOrChildren: ValueOffsetsBuffer | (Data | Vector)[], children?: (Data | Vector)[]) {\n        const buffers = <unknown> [\n            undefined, undefined,\n            toUint8Array(nullBitmap),\n            toArrayBufferView(type.ArrayType, typeIds)\n        ] as Partial<Buffers<T>>;\n        if (type.mode === UnionMode.Sparse) {\n            return new Data(type, offset, length, nullCount, buffers, valueOffsetsOrChildren as (Data | Vector)[]);\n        }\n        buffers[BufferType.OFFSET] = toInt32Array(<ValueOffsetsBuffer> valueOffsetsOrChildren);\n        return new Data(type, offset, length, nullCount, buffers, children);\n    }\n}\n\n(Data.prototype as any).childData = Object.freeze([]);\n"]},"metadata":{},"sourceType":"module"}