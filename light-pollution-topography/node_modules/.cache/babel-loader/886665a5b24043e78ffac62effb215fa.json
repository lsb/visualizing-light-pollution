{"ast":null,"code":"import lightingShader from './lights.glsl';\nexport default {\n  name: 'lights',\n  vs: lightingShader,\n  fs: lightingShader,\n  getUniforms: getUniforms,\n  defines: {\n    MAX_LIGHTS: 3\n  }\n};\nvar INITIAL_MODULE_OPTIONS = {};\n\nfunction convertColor() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$color = _ref.color,\n      color = _ref$color === void 0 ? [0, 0, 0] : _ref$color,\n      _ref$intensity = _ref.intensity,\n      intensity = _ref$intensity === void 0 ? 1.0 : _ref$intensity;\n\n  return color.map(function (component) {\n    return component * intensity / 255.0;\n  });\n}\n\nfunction getLightSourceUniforms(_ref2) {\n  var ambientLight = _ref2.ambientLight,\n      _ref2$pointLights = _ref2.pointLights,\n      pointLights = _ref2$pointLights === void 0 ? [] : _ref2$pointLights,\n      _ref2$directionalLigh = _ref2.directionalLights,\n      directionalLights = _ref2$directionalLigh === void 0 ? [] : _ref2$directionalLigh;\n  var lightSourceUniforms = {};\n\n  if (ambientLight) {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = convertColor(ambientLight);\n  } else {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = [0, 0, 0];\n  }\n\n  pointLights.forEach(function (pointLight, index) {\n    lightSourceUniforms[\"lighting_uPointLight[\".concat(index, \"].color\")] = convertColor(pointLight);\n    lightSourceUniforms[\"lighting_uPointLight[\".concat(index, \"].position\")] = pointLight.position;\n    lightSourceUniforms[\"lighting_uPointLight[\".concat(index, \"].attenuation\")] = pointLight.attenuation || [1, 0, 0];\n  });\n  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;\n  directionalLights.forEach(function (directionalLight, index) {\n    lightSourceUniforms[\"lighting_uDirectionalLight[\".concat(index, \"].color\")] = convertColor(directionalLight);\n    lightSourceUniforms[\"lighting_uDirectionalLight[\".concat(index, \"].direction\")] = directionalLight.direction;\n  });\n  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;\n  return lightSourceUniforms;\n}\n\nfunction getUniforms() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_MODULE_OPTIONS;\n\n  if ('lightSources' in opts) {\n    var _ref3 = opts.lightSources || {},\n        ambientLight = _ref3.ambientLight,\n        pointLights = _ref3.pointLights,\n        directionalLights = _ref3.directionalLights;\n\n    var hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;\n\n    if (!hasLights) {\n      return {\n        lighting_uEnabled: false\n      };\n    }\n\n    return Object.assign({}, getLightSourceUniforms({\n      ambientLight: ambientLight,\n      pointLights: pointLights,\n      directionalLights: directionalLights\n    }), {\n      lighting_uEnabled: true\n    });\n  }\n\n  if ('lights' in opts) {\n    var lightSources = {\n      pointLights: [],\n      directionalLights: []\n    };\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = (opts.lights || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var light = _step.value;\n\n        switch (light.type) {\n          case 'ambient':\n            lightSources.ambientLight = light;\n            break;\n\n          case 'directional':\n            lightSources.directionalLights.push(light);\n            break;\n\n          case 'point':\n            lightSources.pointLights.push(light);\n            break;\n\n          default:\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return getUniforms({\n      lightSources: lightSources\n    });\n  }\n\n  return {};\n}","map":{"version":3,"sources":["../../../../src/modules/lights/lights.js"],"names":["name","vs","fs","getUniforms","defines","MAX_LIGHTS","INITIAL_MODULE_OPTIONS","color","intensity","component","ambientLight","pointLights","directionalLights","lightSourceUniforms","convertColor","pointLight","directionalLight","opts","hasLights","lighting_uEnabled","getLightSourceUniforms","lightSources","light"],"mappings":"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","sourcesContent":["import lightingShader from './lights.glsl';\n\nexport default {\n  name: 'lights',\n  vs: lightingShader,\n  fs: lightingShader,\n  getUniforms,\n  defines: {\n    MAX_LIGHTS: 3\n  }\n};\n\nconst INITIAL_MODULE_OPTIONS = {};\n\n// Take color 0-255 and intensity as input and output 0.0-1.0 range\nfunction convertColor({color = [0, 0, 0], intensity = 1.0} = {}) {\n  return color.map(component => (component * intensity) / 255.0);\n}\n\nfunction getLightSourceUniforms({ambientLight, pointLights = [], directionalLights = []}) {\n  const lightSourceUniforms = {};\n\n  if (ambientLight) {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = convertColor(ambientLight);\n  } else {\n    lightSourceUniforms['lighting_uAmbientLight.color'] = [0, 0, 0];\n  }\n\n  pointLights.forEach((pointLight, index) => {\n    lightSourceUniforms[`lighting_uPointLight[${index}].color`] = convertColor(pointLight);\n    lightSourceUniforms[`lighting_uPointLight[${index}].position`] = pointLight.position;\n    lightSourceUniforms[`lighting_uPointLight[${index}].attenuation`] = pointLight.attenuation || [\n      1,\n      0,\n      0\n    ];\n  });\n  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;\n\n  directionalLights.forEach((directionalLight, index) => {\n    lightSourceUniforms[`lighting_uDirectionalLight[${index}].color`] = convertColor(\n      directionalLight\n    );\n    lightSourceUniforms[`lighting_uDirectionalLight[${index}].direction`] =\n      directionalLight.direction;\n  });\n  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;\n\n  return lightSourceUniforms;\n}\n\n// eslint-disable-next-line complexity\nfunction getUniforms(opts = INITIAL_MODULE_OPTIONS) {\n  // Specify lights separately\n  if ('lightSources' in opts) {\n    const {ambientLight, pointLights, directionalLights} = opts.lightSources || {};\n    const hasLights =\n      ambientLight ||\n      (pointLights && pointLights.length > 0) ||\n      (directionalLights && directionalLights.length > 0);\n\n    if (!hasLights) {\n      return {lighting_uEnabled: false};\n    }\n\n    return Object.assign(\n      {},\n      getLightSourceUniforms({ambientLight, pointLights, directionalLights}),\n      {\n        lighting_uEnabled: true\n      }\n    );\n  }\n\n  // Support for array of lights. Type of light is detected by type field\n  if ('lights' in opts) {\n    const lightSources = {pointLights: [], directionalLights: []};\n    for (const light of opts.lights || []) {\n      switch (light.type) {\n        case 'ambient':\n          // Note: Only uses last ambient light\n          // TODO - add ambient light sources on CPU?\n          lightSources.ambientLight = light;\n          break;\n        case 'directional':\n          lightSources.directionalLights.push(light);\n          break;\n        case 'point':\n          lightSources.pointLights.push(light);\n          break;\n        default:\n        // eslint-disable-next-line\n        // console.warn(light.type);\n      }\n    }\n\n    // Call the `opts.lightSources`` version\n    return getUniforms({lightSources});\n  }\n\n  return {};\n}\n"]},"metadata":{},"sourceType":"module"}