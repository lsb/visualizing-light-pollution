{"ast":null,"code":"import { padTo4Bytes } from './memory-copy-utils';\nexport function copyPaddedArrayBufferToDataView(dataView, byteOffset, sourceBuffer, padding) {\n  var paddedLength = padTo4Bytes(sourceBuffer.byteLength);\n  var padLength = paddedLength - sourceBuffer.byteLength;\n\n  if (dataView) {\n    var targetArray = new Uint8Array(dataView.buffer, dataView.byteOffset + byteOffset, sourceBuffer.byteLength);\n    var sourceArray = new Uint8Array(sourceBuffer);\n    targetArray.set(sourceArray);\n\n    for (var i = 0; i < padLength; ++i) {\n      dataView.setUint8(byteOffset + sourceBuffer.byteLength + i, 0x20);\n    }\n  }\n\n  byteOffset += paddedLength;\n  return byteOffset;\n}\nexport function copyPaddedStringToDataView(dataView, byteOffset, string, padding) {\n  var textEncoder = new TextEncoder();\n  var stringBuffer = textEncoder.encode(string);\n  byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, stringBuffer, padding);\n  return byteOffset;\n}","map":{"version":3,"sources":["../../../../src/lib/binary-utils/binary-copy-utils.js"],"names":["paddedLength","padTo4Bytes","sourceBuffer","padLength","targetArray","dataView","sourceArray","i","byteOffset","textEncoder","stringBuffer","copyPaddedArrayBufferToDataView"],"mappings":"AACA,SAAA,WAAA,QAAA,qBAAA;AAEA,OAAO,SAAA,+BAAA,CAAA,QAAA,EAAA,UAAA,EAAA,YAAA,EAAA,OAAA,EAAsF;AAC3F,MAAMA,YAAY,GAAGC,WAAW,CAACC,YAAY,CAA7C,UAAgC,CAAhC;AACA,MAAMC,SAAS,GAAGH,YAAY,GAAGE,YAAY,CAA7C,UAAA;;AAEA,MAAA,QAAA,EAAc;AAEZ,QAAME,WAAW,GAAG,IAAA,UAAA,CAClBC,QAAQ,CADU,MAAA,EAElBA,QAAQ,CAARA,UAAAA,GAFkB,UAAA,EAGlBH,YAAY,CAHd,UAAoB,CAApB;AAKA,QAAMI,WAAW,GAAG,IAAA,UAAA,CAApB,YAAoB,CAApB;AACAF,IAAAA,WAAW,CAAXA,GAAAA,CAAAA,WAAAA;;AAGA,SAAK,IAAIG,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,SAAA,EAA+B,EAA/B,CAAA,EAAoC;AAElCF,MAAAA,QAAQ,CAARA,QAAAA,CAAkBG,UAAU,GAAGN,YAAY,CAAzBM,UAAAA,GAAlBH,CAAAA,EAAAA,IAAAA;AACD;AACF;;AACDG,EAAAA,UAAU,IAAVA,YAAAA;AACA,SAAA,UAAA;AACD;AAED,OAAO,SAAA,0BAAA,CAAA,QAAA,EAAA,UAAA,EAAA,MAAA,EAAA,OAAA,EAA2E;AAChF,MAAMC,WAAW,GAAG,IAApB,WAAoB,EAApB;AAGA,MAAMC,YAAY,GAAGD,WAAW,CAAXA,MAAAA,CAArB,MAAqBA,CAArB;AAEAD,EAAAA,UAAU,GAAGG,+BAA+B,CAAA,QAAA,EAAA,UAAA,EAAA,YAAA,EAA5CH,OAA4C,CAA5CA;AAEA,SAAA,UAAA;AACD","sourcesContent":["/* global TextEncoder */\nimport {padTo4Bytes} from './memory-copy-utils';\n\nexport function copyPaddedArrayBufferToDataView(dataView, byteOffset, sourceBuffer, padding) {\n  const paddedLength = padTo4Bytes(sourceBuffer.byteLength);\n  const padLength = paddedLength - sourceBuffer.byteLength;\n\n  if (dataView) {\n    // Copy array\n    const targetArray = new Uint8Array(\n      dataView.buffer,\n      dataView.byteOffset + byteOffset,\n      sourceBuffer.byteLength\n    );\n    const sourceArray = new Uint8Array(sourceBuffer);\n    targetArray.set(sourceArray);\n\n    // Add PADDING\n    for (let i = 0; i < padLength; ++i) {\n      // json chunk is padded with spaces (ASCII 0x20)\n      dataView.setUint8(byteOffset + sourceBuffer.byteLength + i, 0x20);\n    }\n  }\n  byteOffset += paddedLength;\n  return byteOffset;\n}\n\nexport function copyPaddedStringToDataView(dataView, byteOffset, string, padding) {\n  const textEncoder = new TextEncoder();\n  // PERFORMANCE IDEA: We encode twice, once to get size and once to store\n  // PERFORMANCE IDEA: Use TextEncoder.encodeInto() to avoid temporary copy\n  const stringBuffer = textEncoder.encode(string);\n\n  byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, stringBuffer, padding);\n\n  return byteOffset;\n}\n"]},"metadata":{},"sourceType":"module"}