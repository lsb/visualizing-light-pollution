{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { log } from '@deck.gl/core';\nimport { Geometry, uid } from '@luma.gl/core';\n\nvar ColumnGeometry = function (_Geometry) {\n  _inherits(ColumnGeometry, _Geometry);\n\n  function ColumnGeometry() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, ColumnGeometry);\n\n    var _props$id = props.id,\n        id = _props$id === void 0 ? uid('column-geometry') : _props$id;\n\n    var _tesselateColumn = tesselateColumn(props),\n        indices = _tesselateColumn.indices,\n        attributes = _tesselateColumn.attributes;\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ColumnGeometry).call(this, _objectSpread({}, props, {\n      id: id,\n      indices: indices,\n      attributes: attributes\n    })));\n  }\n\n  return ColumnGeometry;\n}(Geometry);\n\nexport { ColumnGeometry as default };\n\nfunction tesselateColumn(props) {\n  var radius = props.radius,\n      _props$height = props.height,\n      height = _props$height === void 0 ? 1 : _props$height,\n      _props$nradial = props.nradial,\n      nradial = _props$nradial === void 0 ? 10 : _props$nradial,\n      vertices = props.vertices;\n  log.assert(!vertices || vertices.length >= nradial);\n  var vertsAroundEdge = nradial + 1;\n  var numVertices = vertsAroundEdge * 3;\n  var stepAngle = Math.PI * 2 / nradial;\n  var indices = new Uint16Array(nradial * 3 * 2);\n  var positions = new Float32Array(numVertices * 3);\n  var normals = new Float32Array(numVertices * 3);\n  var i = 0;\n\n  for (var j = 0; j < vertsAroundEdge; j++) {\n    var a = j * stepAngle;\n    var vertex = vertices && vertices[j % nradial];\n    var nextVertex = vertices && vertices[(j + 1) % nradial];\n    var sin = Math.sin(a);\n    var cos = Math.cos(a);\n\n    for (var k = 0; k < 2; k++) {\n      positions[i + 0] = vertex ? vertex[0] : cos * radius;\n      positions[i + 1] = vertex ? vertex[1] : sin * radius;\n      positions[i + 2] = (1 / 2 - k) * height;\n      normals[i + 0] = vertex ? nextVertex[0] - vertex[0] : cos;\n      normals[i + 1] = vertex ? nextVertex[1] - vertex[1] : sin;\n      i += 3;\n    }\n  }\n\n  for (var _j = 0; _j < vertsAroundEdge; _j++) {\n    var v = Math.floor(_j / 2) * Math.sign(_j % 2 - 0.5);\n\n    var _a = v * stepAngle;\n\n    var _vertex = vertices && vertices[(v + nradial) % nradial];\n\n    var _sin = Math.sin(_a);\n\n    var _cos = Math.cos(_a);\n\n    positions[i + 0] = _vertex ? _vertex[0] : _cos * radius;\n    positions[i + 1] = _vertex ? _vertex[1] : _sin * radius;\n    positions[i + 2] = height / 2;\n    normals[i + 2] = 1;\n    i += 3;\n  }\n\n  var index = 0;\n\n  for (var _j2 = 0; _j2 < nradial; _j2++) {\n    indices[index++] = _j2 * 2 + 0;\n    indices[index++] = _j2 * 2 + 2;\n    indices[index++] = _j2 * 2 + 0;\n    indices[index++] = _j2 * 2 + 1;\n    indices[index++] = _j2 * 2 + 1;\n    indices[index++] = _j2 * 2 + 3;\n  }\n\n  return {\n    indices: indices,\n    attributes: {\n      POSITION: {\n        size: 3,\n        value: positions\n      },\n      NORMAL: {\n        size: 3,\n        value: normals\n      }\n    }\n  };\n}","map":{"version":3,"sources":["../../../src/column-layer/column-geometry.js"],"names":["ColumnGeometry","Geometry","props","id","uid","indices","attributes","tesselateColumn","radius","height","nradial","vertices","log","vertsAroundEdge","numVertices","stepAngle","Math","positions","normals","i","j","a","vertex","nextVertex","sin","cos","k","v","index","POSITION","size","value","NORMAL"],"mappings":"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","sourcesContent":["import {log} from '@deck.gl/core';\nimport {Geometry, uid} from '@luma.gl/core';\n\nexport default class ColumnGeometry extends Geometry {\n  constructor(props = {}) {\n    const {id = uid('column-geometry')} = props;\n    const {indices, attributes} = tesselateColumn(props);\n    super({\n      ...props,\n      id,\n      indices,\n      attributes\n    });\n  }\n}\n\n/* eslint-disable max-statements, complexity */\nfunction tesselateColumn(props) {\n  const {radius, height = 1, nradial = 10, vertices} = props;\n  log.assert(!vertices || vertices.length >= nradial);\n\n  const vertsAroundEdge = nradial + 1; // loop\n  const numVertices = vertsAroundEdge * 3; // top, side top edge, side bottom edge\n\n  const stepAngle = (Math.PI * 2) / nradial;\n\n  // Used for wireframe\n  const indices = new Uint16Array(nradial * 3 * 2); // top loop, side vertical, bottom loop\n\n  const positions = new Float32Array(numVertices * 3);\n  const normals = new Float32Array(numVertices * 3);\n\n  let i = 0;\n\n  // side tesselation: 0, 1, 2, 3, 4, 5, ...\n  //\n  // 0 - 2 - 4  ... top\n  // | / | / |\n  // 1 - 3 - 5  ... bottom\n  //\n  for (let j = 0; j < vertsAroundEdge; j++) {\n    const a = j * stepAngle;\n    const vertex = vertices && vertices[j % nradial];\n    const nextVertex = vertices && vertices[(j + 1) % nradial];\n    const sin = Math.sin(a);\n    const cos = Math.cos(a);\n\n    for (let k = 0; k < 2; k++) {\n      positions[i + 0] = vertex ? vertex[0] : cos * radius;\n      positions[i + 1] = vertex ? vertex[1] : sin * radius;\n      positions[i + 2] = (1 / 2 - k) * height;\n\n      normals[i + 0] = vertex ? nextVertex[0] - vertex[0] : cos;\n      normals[i + 1] = vertex ? nextVertex[1] - vertex[1] : sin;\n\n      i += 3;\n    }\n  }\n\n  // top tesselation: 0, -1, 1, -2, 2, -3, 3, ...\n  //\n  //    0 -- 1\n  //   /      \\\n  // -1        2\n  //  |        |\n  // -2        3\n  //   \\      /\n  //   -3 -- 4\n  //\n  for (let j = 0; j < vertsAroundEdge; j++) {\n    const v = Math.floor(j / 2) * Math.sign((j % 2) - 0.5);\n    const a = v * stepAngle;\n    const vertex = vertices && vertices[(v + nradial) % nradial];\n    const sin = Math.sin(a);\n    const cos = Math.cos(a);\n\n    positions[i + 0] = vertex ? vertex[0] : cos * radius;\n    positions[i + 1] = vertex ? vertex[1] : sin * radius;\n    positions[i + 2] = height / 2;\n\n    normals[i + 2] = 1;\n\n    i += 3;\n  }\n\n  let index = 0;\n  for (let j = 0; j < nradial; j++) {\n    // top loop\n    indices[index++] = j * 2 + 0;\n    indices[index++] = j * 2 + 2;\n    // side vertical\n    indices[index++] = j * 2 + 0;\n    indices[index++] = j * 2 + 1;\n    // bottom loop\n    indices[index++] = j * 2 + 1;\n    indices[index++] = j * 2 + 3;\n  }\n\n  return {\n    indices,\n    attributes: {\n      POSITION: {size: 3, value: positions},\n      NORMAL: {size: 3, value: normals}\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}