{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Buffer, copyToTexture, cloneTextureFrom } from '@luma.gl/webgl';\nimport { Transform } from '@luma.gl/engine';\nimport { HISTOPYRAMID_BUILD_VS_UTILS, HISTOPYRAMID_TRAVERSAL_UTILS, HISTOPYRAMID_BASE_BUILD_VS, HISTOPYRAMID_BUILD_VS, HISTOPYRAMID_TRAVERSAL_VS } from './histopyramid-shaders';\n\nfunction nextPowerOfTwo(x) {\n  var p = Math.ceil(Math.log2(x));\n  return Math.pow(2, p);\n}\n\nvar channelToIndexMap = {\n  r: 0,\n  x: 0,\n  g: 1,\n  y: 1,\n  b: 2,\n  z: 2,\n  a: 3,\n  w: 3\n};\nexport function buildHistopyramidBaseLevel(gl, opts) {\n  var _parameters;\n\n  var texture = opts.texture,\n      _opts$channel = opts.channel,\n      channel = _opts$channel === void 0 ? 'r' : _opts$channel,\n      _opts$_readData = opts._readData,\n      _readData = _opts$_readData === void 0 ? false : _opts$_readData;\n\n  var width = texture.width,\n      height = texture.height;\n  width = nextPowerOfTwo(width);\n  height = nextPowerOfTwo(height);\n  var size = (width > height ? width : height) / 2;\n  var baseTexture = cloneTextureFrom(texture, {\n    width: size,\n    height: size\n  });\n  var transform = new Transform(gl, {\n    _sourceTextures: {\n      inTexture: texture\n    },\n    _targetTexture: baseTexture,\n    _targetTextureVarying: 'outTexture',\n    vs: \"\".concat(HISTOPYRAMID_BUILD_VS_UTILS).concat(HISTOPYRAMID_BASE_BUILD_VS),\n    elementCount: baseTexture.width * baseTexture.height\n  });\n  transform.run({\n    uniforms: {\n      channel: channelToIndexMap[channel] || 0,\n      padingPixelValue: [0, 0, 0, 0]\n    }\n  });\n  var textureData;\n\n  if (_readData || size === 1) {\n    textureData = transform.getData({\n      packed: true\n    });\n  }\n\n  var flatPyramidSize = size * 2;\n  var flatPyramidTexture = cloneTextureFrom(texture, {\n    width: flatPyramidSize,\n    height: flatPyramidSize,\n    parameters: (_parameters = {}, _defineProperty(_parameters, 10240, 9728), _defineProperty(_parameters, 10241, 9728), _parameters)\n  });\n  var framebuffer = transform.getFramebuffer();\n  copyToTexture(framebuffer, flatPyramidTexture, {\n    targetX: 0,\n    width: size,\n    height: size\n  });\n  return {\n    textureData: textureData,\n    baseTexture: baseTexture,\n    flatPyramidTexture: flatPyramidTexture\n  };\n}\nexport function getHistoPyramid(gl, opts) {\n  var _buildHistopyramidBas = buildHistopyramidBaseLevel(gl, opts),\n      textureData = _buildHistopyramidBas.textureData,\n      baseTexture = _buildHistopyramidBas.baseTexture,\n      flatPyramidTexture = _buildHistopyramidBas.flatPyramidTexture;\n\n  var width = baseTexture.width;\n  var levelCount = Math.log2(width) + 1;\n  var pyramidTextures = [baseTexture];\n  var topLevelData = textureData;\n\n  if (levelCount > 1) {\n    for (var i = 1; i < levelCount; i++) {\n      var size = width / Math.pow(2, i);\n      pyramidTextures.push(cloneTextureFrom(baseTexture, {\n        width: size,\n        height: size\n      }));\n    }\n\n    var transform = new Transform(gl, {\n      _sourceTextures: {\n        inTexture: pyramidTextures[0]\n      },\n      _targetTexture: pyramidTextures[1],\n      _targetTextureVarying: 'outTexture',\n      vs: \"\".concat(HISTOPYRAMID_BUILD_VS_UTILS).concat(HISTOPYRAMID_BUILD_VS),\n      elementCount: pyramidTextures[1].width * pyramidTextures[1].height\n    });\n    var flatOffset = width;\n\n    for (var _i = 1; _i < levelCount; _i++) {\n      var outSize = [pyramidTextures[_i].width, pyramidTextures[_i].height];\n      transform.update({\n        _sourceTextures: {\n          inTexture: pyramidTextures[_i - 1]\n        },\n        _targetTexture: pyramidTextures[_i],\n        elementCount: pyramidTextures[_i].width * pyramidTextures[_i].height\n      });\n      transform.run();\n      var framebuffer = transform.getFramebuffer();\n      copyToTexture(framebuffer, flatPyramidTexture, {\n        targetX: flatOffset,\n        width: outSize[0],\n        height: outSize[1]\n      });\n      flatOffset += outSize[0];\n    }\n\n    topLevelData = transform.getData();\n  }\n\n  return {\n    pyramidTextures: pyramidTextures,\n    flatPyramidTexture: flatPyramidTexture,\n    levelCount: levelCount,\n    topLevelData: topLevelData\n  };\n}\nexport function histoPyramidGenerateIndices(gl, opts) {\n  var _getHistoPyramid = getHistoPyramid(gl, opts),\n      flatPyramidTexture = _getHistoPyramid.flatPyramidTexture,\n      levelCount = _getHistoPyramid.levelCount,\n      topLevelData = _getHistoPyramid.topLevelData;\n\n  var keyIndexCount = topLevelData[0] + topLevelData[1] + topLevelData[2] + topLevelData[3];\n  var keyIndex = new Buffer(gl, new Float32Array(keyIndexCount).map(function (_, index) {\n    return index;\n  }));\n  var locationAndIndex = new Buffer(gl, keyIndexCount * 4 * 4);\n  var transform = new Transform(gl, {\n    sourceBuffers: {\n      keyIndex: keyIndex\n    },\n    _sourceTextures: {\n      flatPyramidTexture: flatPyramidTexture\n    },\n    feedbackBuffers: {\n      locationAndIndex: locationAndIndex\n    },\n    varyings: ['locationAndIndex'],\n    vs: \"\".concat(HISTOPYRAMID_TRAVERSAL_UTILS).concat(HISTOPYRAMID_TRAVERSAL_VS),\n    elementCount: keyIndexCount\n  });\n  transform.run({\n    uniforms: {\n      numLevels: levelCount\n    }\n  });\n  return {\n    locationAndIndexBuffer: locationAndIndex\n  };\n}","map":{"version":3,"sources":["../../../../src/gpgpu/histopyramid/histopyramid.js"],"names":["p","Math","channelToIndexMap","r","x","g","y","b","z","a","w","texture","channel","_readData","opts","width","height","nextPowerOfTwo","size","baseTexture","cloneTextureFrom","transform","_sourceTextures","inTexture","_targetTexture","_targetTextureVarying","vs","elementCount","uniforms","padingPixelValue","textureData","packed","flatPyramidSize","flatPyramidTexture","parameters","framebuffer","copyToTexture","targetX","buildHistopyramidBaseLevel","levelCount","pyramidTextures","topLevelData","i","flatOffset","outSize","getHistoPyramid","keyIndexCount","keyIndex","locationAndIndex","sourceBuffers","feedbackBuffers","varyings","numLevels","locationAndIndexBuffer"],"mappings":"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","sourcesContent":["import {Buffer, copyToTexture, cloneTextureFrom} from '@luma.gl/webgl';\nimport {Transform} from '@luma.gl/engine';\nimport GL from '@luma.gl/constants';\nimport {\n  HISTOPYRAMID_BUILD_VS_UTILS,\n  HISTOPYRAMID_TRAVERSAL_UTILS,\n  HISTOPYRAMID_BASE_BUILD_VS,\n  HISTOPYRAMID_BUILD_VS,\n  HISTOPYRAMID_TRAVERSAL_VS\n} from './histopyramid-shaders';\n\n// Following methods implement Histopyramid operations as described in 'Highâ€speed marching cubes using histopyramids' by Dyken C, Ziegler G, Theobalt C and Seidel H\n// Link to the paper: http://olmozavala.com/Custom/OpenGL/Tutorials/OpenGL4_Examples/MarchingCubes_Dyken/Dyken_et_al-2008-Computer_Graphics_Forum.pdf\n\n// TODO: enable to assert on texture dimension\n// function isPowerOfTwo(x) {\n//     return ((x !== 0) && !(x & (x - 1)));\n// }\n\nfunction nextPowerOfTwo(x) {\n  const p = Math.ceil(Math.log2(x));\n  return Math.pow(2, p);\n}\n\nconst channelToIndexMap = {\n  r: 0,\n  x: 0,\n  g: 1,\n  y: 1,\n  b: 2,\n  z: 2,\n  a: 3,\n  w: 3\n};\n\n// returns a base level texture that packs given weight into a texture\n// each 2X2 region is mapped into RGBA channels of single pixel\n// returned texture is a squred power of two sized texture\n// R -> lower left, G -> lower right B -> upper left A -> upper right\nexport function buildHistopyramidBaseLevel(gl, opts) {\n  const {texture, channel = 'r', _readData = false} = opts;\n  let {width, height} = texture;\n  width = nextPowerOfTwo(width);\n  height = nextPowerOfTwo(height);\n  // Use sqaured next power of two size, then use half of it since we are packing 2X2 group into a single RGBA pixel\n  const size = (width > height ? width : height) / 2;\n  const baseTexture = cloneTextureFrom(texture, {\n    width: size,\n    height: size\n  });\n\n  // build individual pyramid textures\n  const transform = new Transform(gl, {\n    _sourceTextures: {\n      inTexture: texture\n    },\n    _targetTexture: baseTexture,\n    _targetTextureVarying: 'outTexture',\n    vs: `${HISTOPYRAMID_BUILD_VS_UTILS}${HISTOPYRAMID_BASE_BUILD_VS}`,\n    elementCount: baseTexture.width * baseTexture.height\n  });\n  transform.run({\n    uniforms: {\n      channel: channelToIndexMap[channel] || 0,\n      padingPixelValue: [0, 0, 0, 0]\n    }\n  });\n  // _readData is debug only option\n  let textureData;\n  // when base textuer size is 1X1, there are no more level to be generated\n  // so read the texture data to be provided as base level data.\n  if (_readData || size === 1) {\n    textureData = transform.getData({packed: true});\n  }\n  const flatPyramidSize = size * 2;\n  const flatPyramidTexture = cloneTextureFrom(texture, {\n    width: flatPyramidSize,\n    height: flatPyramidSize,\n    parameters: {\n      [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n      [GL.TEXTURE_MIN_FILTER]: GL.NEAREST\n    }\n  });\n  const framebuffer = transform.getFramebuffer();\n  copyToTexture(framebuffer, flatPyramidTexture, {\n    targetX: 0,\n    width: size,\n    height: size\n  });\n\n  return {textureData, baseTexture, flatPyramidTexture};\n}\n\n// builds histopyramid for a given texture and returns individual levels and flatended pyramid texture\n// Returns object\n// * pyramidTextures: Array with all individual mip levels\n// * flatPyramidTexture: Texture with all mip levels laid out horizontally\nexport function getHistoPyramid(gl, opts) {\n  const {textureData, baseTexture, flatPyramidTexture} = buildHistopyramidBaseLevel(gl, opts);\n  const {width} = baseTexture;\n  // assert(width === height && isPowerOfTwo(width));\n  const levelCount = Math.log2(width) + 1;\n  const pyramidTextures = [baseTexture];\n\n  let topLevelData = textureData;\n  if (levelCount > 1) {\n    // build empty textures for rest of the pyramid\n    for (let i = 1; i < levelCount; i++) {\n      const size = width / Math.pow(2, i);\n      pyramidTextures.push(\n        cloneTextureFrom(baseTexture, {\n          width: size,\n          height: size\n        })\n      );\n    }\n\n    // build individual pyramid textures\n    const transform = new Transform(gl, {\n      _sourceTextures: {\n        inTexture: pyramidTextures[0]\n      },\n      _targetTexture: pyramidTextures[1],\n      _targetTextureVarying: 'outTexture',\n      vs: `${HISTOPYRAMID_BUILD_VS_UTILS}${HISTOPYRAMID_BUILD_VS}`,\n      elementCount: pyramidTextures[1].width * pyramidTextures[1].height\n    });\n\n    let flatOffset = width;\n    for (let i = 1; i < levelCount; i++) {\n      const outSize = [pyramidTextures[i].width, pyramidTextures[i].height];\n      transform.update({\n        _sourceTextures: {inTexture: pyramidTextures[i - 1]},\n        _targetTexture: pyramidTextures[i],\n        elementCount: pyramidTextures[i].width * pyramidTextures[i].height\n      });\n      transform.run();\n\n      // copy the result to the flaten pyramid texture\n      const framebuffer = transform.getFramebuffer();\n      copyToTexture(framebuffer, flatPyramidTexture, {\n        targetX: flatOffset,\n        width: outSize[0],\n        height: outSize[1]\n      });\n\n      flatOffset += outSize[0];\n    }\n    topLevelData = transform.getData();\n  }\n\n  return {pyramidTextures, flatPyramidTexture, levelCount, topLevelData};\n}\n\n// builds and traverses a histopyramid for a given texture and returns pixel locations and local-key index for each non zero weight in input texture\n// Returns object\n// *locationAndIndexBuffer : Buffer contains one vec4 for each non zero weight. XY represent loation, Z represents local-key index and W represent key-index\nexport function histoPyramidGenerateIndices(gl, opts) {\n  const {flatPyramidTexture, levelCount, topLevelData} = getHistoPyramid(gl, opts);\n\n  const keyIndexCount = topLevelData[0] + topLevelData[1] + topLevelData[2] + topLevelData[3];\n  const keyIndex = new Buffer(gl, new Float32Array(keyIndexCount).map((_, index) => index));\n  const locationAndIndex = new Buffer(gl, keyIndexCount * 4 * 4); // 4 floats for each key index\n\n  const transform = new Transform(gl, {\n    sourceBuffers: {\n      keyIndex\n    },\n    _sourceTextures: {\n      flatPyramidTexture\n    },\n    feedbackBuffers: {\n      locationAndIndex\n    },\n    varyings: ['locationAndIndex'],\n    vs: `${HISTOPYRAMID_TRAVERSAL_UTILS}${HISTOPYRAMID_TRAVERSAL_VS}`,\n    elementCount: keyIndexCount\n  });\n  transform.run({\n    uniforms: {\n      numLevels: levelCount\n    }\n  });\n\n  return {locationAndIndexBuffer: locationAndIndex};\n}\n"]},"metadata":{},"sourceType":"module"}