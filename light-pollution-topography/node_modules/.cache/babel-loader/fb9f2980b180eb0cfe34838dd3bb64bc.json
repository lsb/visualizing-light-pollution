{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { Vector3 } from 'math.gl';\nimport { Intersect } from '../constants';\nvar scratchVector = new Vector3();\nvar scratchNormal = new Vector3();\n\nvar AxisAlignedBoundingBox = function () {\n  function AxisAlignedBoundingBox() {\n    var minimum = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0];\n    var maximum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n    var center = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    _classCallCheck(this, AxisAlignedBoundingBox);\n\n    center = center || scratchVector.copy(minimum).add(maximum).scale(0.5);\n    this.minimum = new Vector3(minimum);\n    this.maximum = new Vector3(maximum);\n    this.center = new Vector3(center);\n  }\n\n  _createClass(AxisAlignedBoundingBox, [{\n    key: \"fromPoints\",\n    value: function fromPoints(positions) {\n      if (!positions || positions.length === 0) {\n        this.minimum.set(0, 0, 0);\n        this.maximum.set(0, 0, 0);\n        this.center.set(0, 0, 0);\n        return this;\n      }\n\n      var minimumX = positions[0][0];\n      var minimumY = positions[0][1];\n      var minimumZ = positions[0][2];\n      var maximumX = positions[0][0];\n      var maximumY = positions[0][1];\n      var maximumZ = positions[0][2];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = positions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var p = _step.value;\n          var x = p[0];\n          var y = p[1];\n          var z = p[2];\n          minimumX = Math.min(x, minimumX);\n          maximumX = Math.max(x, maximumX);\n          minimumY = Math.min(y, minimumY);\n          maximumY = Math.max(y, maximumY);\n          minimumZ = Math.min(z, minimumZ);\n          maximumZ = Math.max(z, maximumZ);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      this.minimum.set(minimumX, minimumY, minimumZ);\n      this.maximum.set(maximumX, maximumY, maximumZ);\n      this.center.copy(this.minimum).add(this.maximum).scale(0.5);\n      return this;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(right) {\n      return this === right || Boolean(right) && this.center.equals(right.center) && this.minimum.equals(right.minimum) && this.maximum.equals(right.maximum);\n    }\n  }, {\n    key: \"intersectPlane\",\n    value: function intersectPlane(plane) {\n      var h = scratchVector.copy(this.maximum).subtract(this.minimum).scale(0.5);\n      var normal = scratchNormal.from(plane.normal);\n      var e = h.x * Math.abs(normal.x) + h.y * Math.abs(normal.y) + h.z * Math.abs(normal.z);\n      var s = this.center.dot(normal) + plane.distance;\n\n      if (s - e > 0) {\n        return Intersect.INSIDE;\n      }\n\n      if (s + e < 0) {\n        return Intersect.OUTSIDE;\n      }\n\n      return Intersect.INTERSECTING;\n    }\n  }]);\n\n  return AxisAlignedBoundingBox;\n}();\n\nexport { AxisAlignedBoundingBox as default };","map":{"version":3,"sources":["../../../src/lib/axis-aligned-bounding-box.js"],"names":["scratchVector","scratchNormal","AxisAlignedBoundingBox","minimum","maximum","center","positions","minimumX","minimumY","minimumZ","maximumX","maximumY","maximumZ","p","x","y","z","Math","right","Boolean","plane","h","normal","e","s","Intersect"],"mappings":"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","sourcesContent":["import {Vector3} from 'math.gl';\nimport {Intersect} from '../constants';\n\nconst scratchVector = new Vector3();\nconst scratchNormal = new Vector3();\n\n/**\n * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.\n * @alias AxisAlignedBoundingBox\n * @constructor\n *\n * @param {Vector3} [minimum=0, 0, 0] The minimum point along the x, y, and z axes.\n * @param {Vector3} [maximum=0, 0, 0] The maximum point along the x, y, and z axes.\n * @param {Vector3} [center] The center of the box; automatically computed if not supplied.\n *\n * @see BoundingSphere\n * @see BoundingRectangle\n */\nexport default class AxisAlignedBoundingBox {\n  constructor(minimum = [0, 0, 0], maximum = [0, 0, 0], center = null) {\n    // If center was not defined, compute it.\n    center =\n      center ||\n      scratchVector\n        .copy(minimum)\n        .add(maximum)\n        .scale(0.5);\n\n    /**\n     * The minimum point defining the bounding box.\n     * @type {Vector3}\n     * @default {@link 0, 0, 0}\n     */\n    this.minimum = new Vector3(minimum);\n\n    /**\n     * The maximum point defining the bounding box.\n     * @type {Vector3}\n     * @default {@link 0, 0, 0}\n     */\n    this.maximum = new Vector3(maximum);\n\n    /**\n     * The center point of the bounding box.\n     * @type {Vector3}\n     */\n    this.center = new Vector3(center);\n  }\n\n  /**\n   * Computes an instance of an AxisAlignedBoundingBox. The box is determined by\n   * finding the points spaced the farthest apart on the x, y, and z axes.\n   *\n   * @param {Vector3[]} positions List of points that the bounding box will enclose.  Each point must have a <code>x</code>, <code>y</code>, and <code>z</code> properties.\n   * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.\n   * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.\n   *\n   * @example\n   * // Compute an axis aligned bounding box enclosing two points.\n   * const box = Cesium.AxisAlignedBoundingBox.fromPoints([new Cesium.Vector3(2, 0, 0), new Cesium.Vector3(-2, 0, 0)]);\n   */\n  // eslint-disable-next-line\n  fromPoints(positions) {\n    if (!positions || positions.length === 0) {\n      this.minimum.set(0, 0, 0);\n      this.maximum.set(0, 0, 0);\n      this.center.set(0, 0, 0);\n      return this;\n    }\n\n    let minimumX = positions[0][0];\n    let minimumY = positions[0][1];\n    let minimumZ = positions[0][2];\n\n    let maximumX = positions[0][0];\n    let maximumY = positions[0][1];\n    let maximumZ = positions[0][2];\n\n    for (const p of positions) {\n      const x = p[0];\n      const y = p[1];\n      const z = p[2];\n\n      minimumX = Math.min(x, minimumX);\n      maximumX = Math.max(x, maximumX);\n      minimumY = Math.min(y, minimumY);\n      maximumY = Math.max(y, maximumY);\n      minimumZ = Math.min(z, minimumZ);\n      maximumZ = Math.max(z, maximumZ);\n    }\n\n    this.minimum.set(minimumX, minimumY, minimumZ);\n    this.maximum.set(maximumX, maximumY, maximumZ);\n    this.center\n      .copy(this.minimum)\n      .add(this.maximum)\n      .scale(0.5);\n\n    return this;\n  }\n\n  /**\n   * Duplicates a AxisAlignedBoundingBox instance.\n   *\n   * @returns {AxisAlignedBoundingBox} A new AxisAlignedBoundingBox instance.\n   */\n  clone() {\n    return new AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);\n  }\n\n  /**\n   * Compares the provided AxisAlignedBoundingBox componentwise and returns\n   * <code>true</code> if they are equal, <code>false</code> otherwise.\n   *\n   * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox to compare with.\n   * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n   */\n  equals(right) {\n    return (\n      this === right ||\n      (Boolean(right) &&\n        this.center.equals(right.center) &&\n        this.minimum.equals(right.minimum) &&\n        this.maximum.equals(right.maximum))\n    );\n  }\n\n  /**\n   * Determines which side of a plane a box is located.\n   *\n   * @param {Plane} plane The plane to test against.\n   * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\n   *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\n   *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\n   *                      intersects the plane.\n   */\n  intersectPlane(plane) {\n    const h = scratchVector\n      .copy(this.maximum)\n      .subtract(this.minimum)\n      .scale(0.5); // The positive half diagonal\n    const normal = scratchNormal.from(plane.normal);\n    const e = h.x * Math.abs(normal.x) + h.y * Math.abs(normal.y) + h.z * Math.abs(normal.z);\n    const s = this.center.dot(normal) + plane.distance; // signed distance from center\n\n    if (s - e > 0) {\n      return Intersect.INSIDE;\n    }\n\n    if (s + e < 0) {\n      // Not in front because normals point inward\n      return Intersect.OUTSIDE;\n    }\n\n    return Intersect.INTERSECTING;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}