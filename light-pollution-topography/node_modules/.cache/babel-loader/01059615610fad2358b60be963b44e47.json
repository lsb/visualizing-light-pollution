{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { Vector3, Vector4, assert } from 'math.gl';\nimport { Intersect } from '../constants';\nimport Plane from './plane';\nvar faces = [new Vector3([1, 0, 0]), new Vector3([0, 1, 0]), new Vector3([0, 0, 1])];\nvar scratchPlaneCenter = new Vector3();\nvar scratchPlaneNormal = new Vector3();\nvar scratchPlane = new Plane(new Vector3(1.0, 0.0, 0.0), 0.0);\n\nvar CullingVolume = function () {\n  _createClass(CullingVolume, null, [{\n    key: \"MASK_OUTSIDE\",\n    get: function get() {\n      return 0xffffffff;\n    }\n  }, {\n    key: \"MASK_INSIDE\",\n    get: function get() {\n      return 0x00000000;\n    }\n  }, {\n    key: \"MASK_INDETERMINATE\",\n    get: function get() {\n      return 0x7fffffff;\n    }\n  }]);\n\n  function CullingVolume() {\n    var planes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    _classCallCheck(this, CullingVolume);\n\n    this.planes = planes;\n    assert(this.planes.every(function (plane) {\n      return plane instanceof Plane;\n    }));\n  }\n\n  _createClass(CullingVolume, [{\n    key: \"fromBoundingSphere\",\n    value: function fromBoundingSphere(boundingSphere) {\n      this.planes.length = 2 * faces.length;\n      var center = boundingSphere.center;\n      var radius = boundingSphere.radius;\n      var planeIndex = 0;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = faces[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var faceNormal = _step.value;\n          var plane0 = this.planes[planeIndex];\n          var plane1 = this.planes[planeIndex + 1];\n\n          if (!plane0) {\n            plane0 = this.planes[planeIndex] = new Plane();\n          }\n\n          if (!plane1) {\n            plane1 = this.planes[planeIndex + 1] = new Plane();\n          }\n\n          var plane0Center = scratchPlaneCenter.copy(faceNormal).scale(-radius).add(center);\n          var plane0Distance = -faceNormal.dot(plane0Center);\n          plane0.fromPointNormal(plane0Center, faceNormal);\n          var plane1Center = scratchPlaneCenter.copy(faceNormal).scale(radius).add(center);\n          var negatedFaceNormal = scratchPlaneNormal.copy(faceNormal).negate();\n          var plane1Distance = -negatedFaceNormal.dot(plane1Center);\n          plane1.fromPointNormal(plane1Center, negatedFaceNormal);\n          planeIndex += 2;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"computeVisibility\",\n    value: function computeVisibility(boundingVolume) {\n      assert(boundingVolume);\n      var intersect = Intersect.INSIDE;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this.planes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var plane = _step2.value;\n          var result = boundingVolume.intersectPlane(plane);\n\n          switch (result) {\n            case Intersect.OUTSIDE:\n              return Intersect.OUTSIDE;\n\n            case Intersect.INTERSECTING:\n              intersect = Intersect.INTERSECTING;\n              break;\n\n            default:\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return intersect;\n    }\n  }, {\n    key: \"computeVisibilityWithPlaneMask\",\n    value: function computeVisibilityWithPlaneMask(boundingVolume, parentPlaneMask) {\n      assert(boundingVolume, 'boundingVolume is required.');\n      assert(Number.isFinite(parentPlaneMask), 'parentPlaneMask is required.');\n\n      if (parentPlaneMask === CullingVolume.MASK_OUTSIDE || parentPlaneMask === CullingVolume.MASK_INSIDE) {\n        return parentPlaneMask;\n      }\n\n      var mask = CullingVolume.MASK_INSIDE;\n      var planes = this.planes;\n\n      for (var k = 0; k < this.planes.length; ++k) {\n        var flag = k < 31 ? 1 << k : 0;\n\n        if (k < 31 && (parentPlaneMask & flag) === 0) {\n          continue;\n        }\n\n        var plane = planes[k];\n        var result = boundingVolume.intersectPlane(plane);\n\n        if (result === Intersect.OUTSIDE) {\n          return CullingVolume.MASK_OUTSIDE;\n        } else if (result === Intersect.INTERSECTING) {\n          mask |= flag;\n        }\n      }\n\n      return mask;\n    }\n  }]);\n\n  return CullingVolume;\n}();\n\nexport { CullingVolume as default };","map":{"version":3,"sources":["../../../src/lib/culling-volume.js"],"names":["faces","scratchPlaneCenter","scratchPlaneNormal","scratchPlane","CullingVolume","planes","assert","plane","boundingSphere","center","radius","planeIndex","faceNormal","plane0","plane1","plane0Center","plane0Distance","plane1Center","negatedFaceNormal","plane1Distance","boundingVolume","intersect","Intersect","result","parentPlaneMask","Number","mask","k","flag"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/* eslint-disable */\nimport {Vector3, Vector4, assert} from 'math.gl';\nimport {Intersect} from '../constants';\nimport Plane from './plane';\n\n// X, Y, Z Unit vectors\nconst faces = [new Vector3([1, 0, 0]), new Vector3([0, 1, 0]), new Vector3([0, 0, 1])];\n\nconst scratchPlaneCenter = new Vector3();\nconst scratchPlaneNormal = new Vector3();\nconst scratchPlane = new Plane(new Vector3(1.0, 0.0, 0.0), 0.0);\n\n// A culling volume defined by planes.\nexport default class CullingVolume {\n  // For plane masks (as used in {@link CullingVolume#computeVisibilityWithPlaneMask}), this special value\n  // represents the case where the object bounding volume is entirely outside the culling volume.\n  static get MASK_OUTSIDE() {\n    return 0xffffffff;\n  }\n\n  // For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\n  // represents the case where the object bounding volume is entirely inside the culling volume.\n  static get MASK_INSIDE() {\n    return 0x00000000;\n  }\n\n  // For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\n  // represents the case where the object bounding volume (may) intersect all planes of the culling volume.\n  static get MASK_INDETERMINATE() {\n    return 0x7fffffff;\n  }\n\n  constructor(planes = []) {\n    // {Cartesian4[]} [planes] An array of clipping planes.\n    this.planes = planes;\n    assert(this.planes.every(plane => plane instanceof Plane));\n  }\n\n  // Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.\n  // The planes are aligned to the x, y, and z axes in world coordinates.\n  fromBoundingSphere(boundingSphere) {\n    this.planes.length = 2 * faces.length;\n\n    const center = boundingSphere.center;\n    const radius = boundingSphere.radius;\n\n    let planeIndex = 0;\n\n    for (const faceNormal of faces) {\n      let plane0 = this.planes[planeIndex];\n      let plane1 = this.planes[planeIndex + 1];\n\n      if (!plane0) {\n        plane0 = this.planes[planeIndex] = new Plane();\n      }\n      if (!plane1) {\n        plane1 = this.planes[planeIndex + 1] = new Plane();\n      }\n\n      const plane0Center = scratchPlaneCenter\n        .copy(faceNormal)\n        .scale(-radius)\n        .add(center);\n      const plane0Distance = -faceNormal.dot(plane0Center);\n\n      plane0.fromPointNormal(plane0Center, faceNormal);\n\n      const plane1Center = scratchPlaneCenter\n        .copy(faceNormal)\n        .scale(radius)\n        .add(center);\n\n      const negatedFaceNormal = scratchPlaneNormal.copy(faceNormal).negate();\n\n      const plane1Distance = -negatedFaceNormal.dot(plane1Center);\n\n      plane1.fromPointNormal(plane1Center, negatedFaceNormal);\n\n      planeIndex += 2;\n    }\n\n    return this;\n  }\n\n  // Determines whether a bounding volume intersects the culling volume.\n  computeVisibility(boundingVolume) {\n    assert(boundingVolume);\n    // const planes = this.planes;\n    let intersect = Intersect.INSIDE;\n    for (const plane of this.planes) {\n      const result = boundingVolume.intersectPlane(plane);\n      switch (result) {\n        case Intersect.OUTSIDE:\n          // We are done\n          return Intersect.OUTSIDE;\n\n        case Intersect.INTERSECTING:\n          // If no other intersection is outside, return INTERSECTING\n          intersect = Intersect.INTERSECTING;\n          break;\n\n        default:\n      }\n    }\n\n    return intersect;\n  }\n\n  // Determines whether a bounding volume intersects the culling volume.\n  /*\n   * @param {Number} parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling\n   *                                 volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then\n   *                                 the parent (and therefore this) volume is completely inside plane[planeIndex]\n   *                                 and that plane check can be skipped.\n   */\n  computeVisibilityWithPlaneMask(boundingVolume, parentPlaneMask) {\n    assert(boundingVolume, 'boundingVolume is required.');\n    assert(Number.isFinite(parentPlaneMask), 'parentPlaneMask is required.');\n\n    if (\n      parentPlaneMask === CullingVolume.MASK_OUTSIDE ||\n      parentPlaneMask === CullingVolume.MASK_INSIDE\n    ) {\n      // parent is completely outside or completely inside, so this child is as well.\n      return parentPlaneMask;\n    }\n\n    // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.\n    // (Because if there are fewer than 31 planes, the upper bits wont be changed.)\n    let mask = CullingVolume.MASK_INSIDE;\n\n    const planes = this.planes;\n    for (let k = 0; k < this.planes.length; ++k) {\n      // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.\n      const flag = k < 31 ? 1 << k : 0;\n      if (k < 31 && (parentPlaneMask & flag) === 0) {\n        // boundingVolume is known to be INSIDE this plane.\n        continue;\n      }\n\n      const plane = planes[k];\n      const result = boundingVolume.intersectPlane(plane);\n      if (result === Intersect.OUTSIDE) {\n        return CullingVolume.MASK_OUTSIDE;\n      } else if (result === Intersect.INTERSECTING) {\n        mask |= flag;\n      }\n    }\n\n    return mask;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}