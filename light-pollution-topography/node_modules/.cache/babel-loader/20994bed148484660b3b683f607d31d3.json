{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { memcpy } from '../util/buffer';\nimport { BigIntAvailable, BigInt64Array, BigUint64Array } from '../util/compat';\n/** @ignore */\n\nconst roundLengthUpToNearest64Bytes = (len, BPE) => (len * BPE + 63 & ~63 || 64) / BPE;\n/** @ignore */\n\n\nconst sliceOrExtendArray = (arr, len = 0) => arr.length >= len ? arr.subarray(0, len) : memcpy(new arr.constructor(len), arr, 0);\n/** @ignore */\n\n\nexport class BufferBuilder {\n  constructor(buffer, stride = 1) {\n    this.buffer = buffer;\n    this.stride = stride;\n    this.BYTES_PER_ELEMENT = buffer.BYTES_PER_ELEMENT;\n    this.ArrayType = buffer.constructor;\n\n    this._resize(this.length = buffer.length / stride | 0);\n  }\n\n  get byteLength() {\n    return this.length * this.stride * this.BYTES_PER_ELEMENT | 0;\n  }\n\n  get reservedLength() {\n    return this.buffer.length / this.stride;\n  }\n\n  get reservedByteLength() {\n    return this.buffer.byteLength;\n  } // @ts-ignore\n\n\n  set(index, value) {\n    return this;\n  }\n\n  append(value) {\n    return this.set(this.length, value);\n  }\n\n  reserve(extra) {\n    if (extra > 0) {\n      this.length += extra;\n      const stride = this.stride;\n      const length = this.length * stride;\n      const reserved = this.buffer.length;\n\n      if (length >= reserved) {\n        this._resize(reserved === 0 ? roundLengthUpToNearest64Bytes(length * 1, this.BYTES_PER_ELEMENT) : roundLengthUpToNearest64Bytes(length * 2, this.BYTES_PER_ELEMENT));\n      }\n    }\n\n    return this;\n  }\n\n  flush(length = this.length) {\n    length = roundLengthUpToNearest64Bytes(length * this.stride, this.BYTES_PER_ELEMENT);\n    const array = sliceOrExtendArray(this.buffer, length);\n    this.clear();\n    return array;\n  }\n\n  clear() {\n    this.length = 0;\n\n    this._resize(0);\n\n    return this;\n  }\n\n  _resize(newLength) {\n    return this.buffer = memcpy(new this.ArrayType(newLength), this.buffer);\n  }\n\n}\nBufferBuilder.prototype.offset = 0;\n/** @ignore */\n\nexport class DataBufferBuilder extends BufferBuilder {\n  last() {\n    return this.get(this.length - 1);\n  }\n\n  get(index) {\n    return this.buffer[index];\n  }\n\n  set(index, value) {\n    this.reserve(index - this.length + 1);\n    this.buffer[index * this.stride] = value;\n    return this;\n  }\n\n}\n/** @ignore */\n\nexport class BitmapBufferBuilder extends DataBufferBuilder {\n  constructor(data = new Uint8Array(0)) {\n    super(data, 1 / 8);\n    this.numValid = 0;\n  }\n\n  get numInvalid() {\n    return this.length - this.numValid;\n  }\n\n  get(idx) {\n    return this.buffer[idx >> 3] >> idx % 8 & 1;\n  }\n\n  set(idx, val) {\n    const {\n      buffer\n    } = this.reserve(idx - this.length + 1);\n    const byte = idx >> 3,\n          bit = idx % 8,\n          cur = buffer[byte] >> bit & 1; // If `val` is truthy and the current bit is 0, flip it to 1 and increment `numValid`.\n    // If `val` is falsey and the current bit is 1, flip it to 0 and decrement `numValid`.\n\n    val ? cur === 0 && (buffer[byte] |= 1 << bit, ++this.numValid) : cur === 1 && (buffer[byte] &= ~(1 << bit), --this.numValid);\n    return this;\n  }\n\n  clear() {\n    this.numValid = 0;\n    return super.clear();\n  }\n\n}\n/** @ignore */\n\nexport class OffsetsBufferBuilder extends DataBufferBuilder {\n  constructor(data = new Int32Array(1)) {\n    super(data, 1);\n  }\n\n  append(value) {\n    return this.set(this.length - 1, value);\n  }\n\n  set(index, value) {\n    const offset = this.length - 1;\n    const buffer = this.reserve(index - offset + 1).buffer;\n\n    if (offset < index++) {\n      buffer.fill(buffer[offset], offset, index);\n    }\n\n    buffer[index] = buffer[index - 1] + value;\n    return this;\n  }\n\n  flush(length = this.length - 1) {\n    if (length > this.length) {\n      this.set(length - 1, 0);\n    }\n\n    return super.flush(length + 1);\n  }\n\n}\n/** @ignore */\n\nexport class WideBufferBuilder extends BufferBuilder {\n  get ArrayType64() {\n    return this._ArrayType64 || (this._ArrayType64 = this.buffer instanceof Int32Array ? BigInt64Array : BigUint64Array);\n  }\n\n  set(index, value) {\n    this.reserve(index - this.length + 1);\n\n    switch (typeof value) {\n      case 'bigint':\n        this.buffer64[index] = value;\n        break;\n\n      case 'number':\n        this.buffer[index * this.stride] = value;\n        break;\n\n      default:\n        this.buffer.set(value, index * this.stride);\n    }\n\n    return this;\n  }\n\n  _resize(newLength) {\n    const data = super._resize(newLength);\n\n    const length = data.byteLength / (this.BYTES_PER_ELEMENT * this.stride);\n\n    if (BigIntAvailable) {\n      this.buffer64 = new this.ArrayType64(data.buffer, data.byteOffset, length);\n    }\n\n    return data;\n  }\n\n}","map":{"version":3,"sources":["builder/buffer.ts"],"names":[],"mappings":"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","sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { memcpy } from '../util/buffer';\nimport { BigIntAvailable, BigInt64Array, BigUint64Array } from '../util/compat';\nimport {\n    TypedArray, TypedArrayConstructor,\n    BigIntArray, BigIntArrayConstructor\n} from '../interfaces';\n\n/** @ignore */ type DataValue<T> = T extends TypedArray ? number : T extends BigIntArray ? WideValue<T> : T;\n/** @ignore */ type WideValue<T extends BigIntArray> = T extends BigIntArray ? bigint | Int32Array | Uint32Array : never;\n/** @ignore */ type ArrayCtor<T extends TypedArray | BigIntArray> =\n    T extends TypedArray  ? TypedArrayConstructor<T>  :\n    T extends BigIntArray ? BigIntArrayConstructor<T> :\n    any;\n\n/** @ignore */\nconst roundLengthUpToNearest64Bytes = (len: number, BPE: number) => ((((len * BPE) + 63) & ~63) || 64) / BPE;\n/** @ignore */\nconst sliceOrExtendArray = <T extends TypedArray | BigIntArray>(arr: T, len = 0) => (\n    arr.length >= len ? arr.subarray(0, len) : memcpy(new (arr.constructor as any)(len), arr, 0)\n) as T;\n\n/** @ignore */\nexport interface BufferBuilder<T extends TypedArray | BigIntArray = any, TValue = DataValue<T>> {\n    readonly offset: number;\n}\n\n/** @ignore */\nexport class BufferBuilder<T extends TypedArray | BigIntArray = any, TValue = DataValue<T>> {\n\n    constructor(buffer: T, stride = 1) {\n        this.buffer = buffer;\n        this.stride = stride;\n        this.BYTES_PER_ELEMENT = buffer.BYTES_PER_ELEMENT;\n        this.ArrayType = buffer.constructor as ArrayCtor<T>;\n        this._resize(this.length = buffer.length / stride | 0);\n    }\n\n    public buffer: T;\n    public length: number;\n    public readonly stride: number;\n    public readonly ArrayType: ArrayCtor<T>;\n    public readonly BYTES_PER_ELEMENT: number;\n\n    public get byteLength() { return this.length * this.stride * this.BYTES_PER_ELEMENT | 0; }\n    public get reservedLength() { return this.buffer.length / this.stride; }\n    public get reservedByteLength() { return this.buffer.byteLength; }\n\n    // @ts-ignore\n    public set(index: number, value: TValue) { return this; }\n    public append(value: TValue) { return this.set(this.length, value); }\n    public reserve(extra: number) {\n        if (extra > 0) {\n            this.length += extra;\n            const stride = this.stride;\n            const length = this.length * stride;\n            const reserved = this.buffer.length;\n            if (length >= reserved) {\n                this._resize(reserved === 0\n                    ? roundLengthUpToNearest64Bytes(length * 1, this.BYTES_PER_ELEMENT)\n                    : roundLengthUpToNearest64Bytes(length * 2, this.BYTES_PER_ELEMENT)\n                );\n            }\n        }\n        return this;\n    }\n    public flush(length = this.length) {\n        length = roundLengthUpToNearest64Bytes(length * this.stride, this.BYTES_PER_ELEMENT);\n        const array = sliceOrExtendArray<T>(this.buffer, length);\n        this.clear();\n        return array;\n    }\n    public clear() {\n        this.length = 0;\n        this._resize(0);\n        return this;\n    }\n    protected _resize(newLength: number) {\n        return this.buffer = <T> memcpy(new this.ArrayType(newLength), this.buffer);\n    }\n}\n\n(BufferBuilder.prototype as any).offset = 0;\n\n/** @ignore */\nexport class DataBufferBuilder<T extends TypedArray> extends BufferBuilder<T, number> {\n    public last() { return this.get(this.length - 1); }\n    public get(index: number) { return this.buffer[index]; }\n    public set(index: number, value: number) {\n        this.reserve(index - this.length + 1);\n        this.buffer[index * this.stride] = value;\n        return this;\n    }\n}\n\n/** @ignore */\nexport class BitmapBufferBuilder extends DataBufferBuilder<Uint8Array> {\n\n    constructor(data = new Uint8Array(0)) { super(data, 1 / 8); }\n\n    public numValid = 0;\n    public get numInvalid() { return this.length - this.numValid; }\n    public get(idx: number) { return this.buffer[idx >> 3] >> idx % 8 & 1; }\n    public set(idx: number, val: number) {\n        const { buffer } = this.reserve(idx - this.length + 1);\n        const byte = idx >> 3, bit = idx % 8, cur = buffer[byte] >> bit & 1;\n        // If `val` is truthy and the current bit is 0, flip it to 1 and increment `numValid`.\n        // If `val` is falsey and the current bit is 1, flip it to 0 and decrement `numValid`.\n        val ? cur === 0 && ((buffer[byte] |=  (1 << bit)), ++this.numValid)\n            : cur === 1 && ((buffer[byte] &= ~(1 << bit)), --this.numValid);\n        return this;\n    }\n    public clear() {\n        this.numValid = 0;\n        return super.clear();\n    }\n}\n\n/** @ignore */\nexport class OffsetsBufferBuilder extends DataBufferBuilder<Int32Array> {\n    constructor(data = new Int32Array(1)) { super(data, 1); }\n    public append(value: number) {\n        return this.set(this.length - 1, value);\n    }\n    public set(index: number, value: number) {\n        const offset = this.length - 1;\n        const buffer = this.reserve(index - offset + 1).buffer;\n        if (offset < index++) {\n            buffer.fill(buffer[offset], offset, index);\n        }\n        buffer[index] = buffer[index - 1] + value;\n        return this;\n    }\n    public flush(length = this.length - 1) {\n        if (length > this.length) {\n            this.set(length - 1, 0);\n        }\n        return super.flush(length + 1);\n    }\n}\n\n/** @ignore */\nexport class WideBufferBuilder<T extends TypedArray, R extends BigIntArray> extends BufferBuilder<T, DataValue<T>> {\n    // @ts-ignore\n    public buffer64: R;\n    // @ts-ignore\n    protected _ArrayType64: BigIntArrayConstructor<R>;\n    public get ArrayType64() {\n        return this._ArrayType64 || (this._ArrayType64 = <BigIntArrayConstructor<R>> (this.buffer instanceof Int32Array ? BigInt64Array : BigUint64Array));\n    }\n    public set(index: number, value: DataValue<T>) {\n        this.reserve(index - this.length + 1);\n        switch (typeof value) {\n            case 'bigint': this.buffer64[index] = value; break;\n            case 'number': this.buffer[index * this.stride] = value; break;\n            default: this.buffer.set(value as TypedArray, index * this.stride);\n        }\n        return this;\n    }\n    protected _resize(newLength: number) {\n        const data = super._resize(newLength);\n        const length = data.byteLength / (this.BYTES_PER_ELEMENT * this.stride);\n        if (BigIntAvailable) {\n            this.buffer64 = new this.ArrayType64(data.buffer, data.byteOffset, length);\n        }\n        return data;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}