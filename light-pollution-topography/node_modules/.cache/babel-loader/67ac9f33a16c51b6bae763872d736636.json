{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nexport default function fetchProgress(_x, _x2) {\n  return _fetchProgress.apply(this, arguments);\n}\n\nfunction _fetchProgress() {\n  _fetchProgress = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(response, onProgress) {\n    var onDone,\n        onError,\n        contentLength,\n        totalBytes,\n        progressStream,\n        _args = arguments;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            onDone = _args.length > 2 && _args[2] !== undefined ? _args[2] : function () {};\n            onError = _args.length > 3 && _args[3] !== undefined ? _args[3] : function () {};\n            _context.next = 4;\n            return response;\n\n          case 4:\n            response = _context.sent;\n\n            if (response.ok) {\n              _context.next = 7;\n              break;\n            }\n\n            return _context.abrupt(\"return\", response);\n\n          case 7:\n            if (response.body) {\n              _context.next = 9;\n              break;\n            }\n\n            return _context.abrupt(\"return\", response);\n\n          case 9:\n            contentLength = response.headers.get('content-length');\n            totalBytes = contentLength && parseInt(contentLength, 10);\n\n            if (contentLength > 0) {\n              _context.next = 13;\n              break;\n            }\n\n            return _context.abrupt(\"return\", response);\n\n          case 13:\n            if (!(typeof ReadableStream === 'undefined')) {\n              _context.next = 15;\n              break;\n            }\n\n            return _context.abrupt(\"return\", response);\n\n          case 15:\n            progressStream = new ReadableStream({\n              start: function start(controller) {\n                var reader = response.body.getReader();\n                read(controller, reader, 0, totalBytes, onProgress, onDone, onError);\n              }\n            });\n            return _context.abrupt(\"return\", new Response(progressStream));\n\n          case 17:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _fetchProgress.apply(this, arguments);\n}\n\nfunction read(_x3, _x4, _x5, _x6, _x7, _x8, _x9) {\n  return _read.apply(this, arguments);\n}\n\nfunction _read() {\n  _read = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError) {\n    var _ref, done, value, percent;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            _context2.next = 3;\n            return reader.read();\n\n          case 3:\n            _ref = _context2.sent;\n            done = _ref.done;\n            value = _ref.value;\n\n            if (!done) {\n              _context2.next = 10;\n              break;\n            }\n\n            onDone();\n            controller.close();\n            return _context2.abrupt(\"return\");\n\n          case 10:\n            loadedBytes += value.byteLength;\n            percent = Math.round(loadedBytes / totalBytes * 100);\n            onProgress(percent, {\n              loadedBytes: loadedBytes,\n              totalBytes: totalBytes\n            });\n            controller.enqueue(value);\n            _context2.next = 16;\n            return read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError);\n\n          case 16:\n            _context2.next = 22;\n            break;\n\n          case 18:\n            _context2.prev = 18;\n            _context2.t0 = _context2[\"catch\"](0);\n            controller.error(_context2.t0);\n            onError(_context2.t0);\n\n          case 22:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[0, 18]]);\n  }));\n  return _read.apply(this, arguments);\n}","map":{"version":3,"sources":["../../../../src/lib/progress/fetch-progress.js"],"names":["onDone","onError","response","contentLength","totalBytes","parseInt","progressStream","start","reader","read","done","value","controller","loadedBytes","percent","Math","onProgress"],"mappings":"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","sourcesContent":["// Forked from github AnthumChris/fetch-progress-indicators under MIT license\n/* global Response, ReadableStream */\n\n// Intercepts the Response stream and creates a new Response\nexport default async function fetchProgress(\n  response,\n  onProgress,\n  onDone = () => {},\n  onError = () => {}\n) {\n  response = await response;\n  if (!response.ok) {\n    // ERROR checking needs to be done separately\n    return response;\n  }\n  if (!response.body) {\n    // 'ReadableStream not yet supported in this browser.\n    return response;\n  }\n  const contentLength = response.headers.get('content-length');\n  const totalBytes = contentLength && parseInt(contentLength, 10);\n  if (!(contentLength > 0)) {\n    return response;\n  }\n  // Currently override only implemented in browser\n  if (typeof ReadableStream === 'undefined') {\n    return response;\n  }\n\n  // Create a new stream that invisbly wraps original stream\n  const progressStream = new ReadableStream({\n    start(controller) {\n      const reader = response.body.getReader();\n      read(controller, reader, 0, totalBytes, onProgress, onDone, onError);\n    }\n  });\n\n  return new Response(progressStream);\n}\n\n// Forward to original streams controller\n// TODO - this causes a crazy deep \"async stack\"... rewrite as async iterator?\n// eslint-disable-next-line max-params\nasync function read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError) {\n  try {\n    const {done, value} = await reader.read();\n    if (done) {\n      onDone();\n      controller.close();\n      return;\n    }\n    loadedBytes += value.byteLength;\n    const percent = Math.round((loadedBytes / totalBytes) * 100);\n    onProgress(percent, {loadedBytes, totalBytes});\n    controller.enqueue(value);\n    await read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError);\n  } catch (error) {\n    controller.error(error);\n    onError(error);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}