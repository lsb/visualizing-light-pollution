{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { hasFeature, FEATURES, Buffer } from '@luma.gl/core';\nimport ShaderAttribute from './shader-attribute';\nimport { glArrayFromType } from './gl-utils';\nimport typedArrayManager from '../../utils/typed-array-manager';\nimport { toDoublePrecisionArray } from '../../utils/math-utils';\nimport log from '../../utils/log';\n\nfunction getStride(accessor) {\n  return accessor.stride || accessor.size * accessor.bytesPerElement;\n}\n\nfunction resolveShaderAttribute(baseAccessor, shaderAttributeOptions) {\n  if (shaderAttributeOptions.offset) {\n    log.removed('shaderAttribute.offset', 'vertexOffset, elementOffset')();\n  }\n\n  var stride = getStride(baseAccessor);\n  var vertexOffset = 'vertexOffset' in shaderAttributeOptions ? shaderAttributeOptions.vertexOffset : baseAccessor.vertexOffset || 0;\n  var elementOffset = shaderAttributeOptions.elementOffset || 0;\n  var offset = vertexOffset * stride + elementOffset * baseAccessor.bytesPerElement + (baseAccessor.offset || 0);\n  return _objectSpread({}, shaderAttributeOptions, {\n    offset: offset,\n    stride: stride\n  });\n}\n\nfunction resolveDoublePrecisionShaderAttributes(baseAccessor, shaderAttributeOptions) {\n  var resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);\n  return {\n    high: resolvedOptions,\n    low: _objectSpread({}, resolvedOptions, {\n      offset: resolvedOptions.offset + baseAccessor.size * 4\n    })\n  };\n}\n\nvar DataColumn = function () {\n  function DataColumn(gl, opts) {\n    _classCallCheck(this, DataColumn);\n\n    this.gl = gl;\n    this.id = opts.id;\n    this.size = opts.size;\n    var logicalType = opts.logicalType || opts.type;\n    var doublePrecision = logicalType === 5130;\n    var defaultValue = opts.defaultValue;\n    defaultValue = Number.isFinite(defaultValue) ? [defaultValue] : defaultValue || new Array(this.size).fill(0);\n    opts.defaultValue = defaultValue;\n    var bufferType = logicalType;\n\n    if (doublePrecision) {\n      bufferType = 5126;\n    } else if (!bufferType && opts.isIndexed) {\n      bufferType = gl && hasFeature(gl, FEATURES.ELEMENT_INDEX_UINT32) ? 5125 : 5123;\n    } else if (!bufferType) {\n      bufferType = 5126;\n    }\n\n    opts.logicalType = logicalType;\n    opts.type = bufferType;\n    var defaultType = glArrayFromType(logicalType || bufferType || 5126);\n    this.shaderAttributes = {};\n    this.doublePrecision = doublePrecision;\n\n    if (doublePrecision && opts.fp64 === false) {\n      defaultType = Float32Array;\n    }\n\n    opts.bytesPerElement = defaultType.BYTES_PER_ELEMENT;\n    this.defaultType = defaultType;\n    this.value = null;\n    this.settings = opts;\n    this.state = {\n      externalBuffer: null,\n      bufferAccessor: opts,\n      allocatedValue: null,\n      constant: false\n    };\n    this._buffer = null;\n    this.setData(opts);\n  }\n\n  _createClass(DataColumn, [{\n    key: \"delete\",\n    value: function _delete() {\n      if (this._buffer) {\n        this._buffer[\"delete\"]();\n\n        this._buffer = null;\n      }\n\n      typedArrayManager.release(this.state.allocatedValue);\n    }\n  }, {\n    key: \"getShaderAttributes\",\n    value: function getShaderAttributes(id, options) {\n      if (this.doublePrecision) {\n        var shaderAttributes = {};\n        var isBuffer64Bit = this.value instanceof Float64Array;\n        var doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(this.getAccessor(), options || {});\n        shaderAttributes[id] = new ShaderAttribute(this, doubleShaderAttributeDefs.high);\n        shaderAttributes[\"\".concat(id, \"64Low\")] = isBuffer64Bit ? new ShaderAttribute(this, doubleShaderAttributeDefs.low) : new Float32Array(this.size);\n        return shaderAttributes;\n      }\n\n      if (options) {\n        var shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options);\n        return _defineProperty({}, id, new ShaderAttribute(this, shaderAttributeDef));\n      }\n\n      return _defineProperty({}, id, this);\n    }\n  }, {\n    key: \"getBuffer\",\n    value: function getBuffer() {\n      if (this.state.constant) {\n        return null;\n      }\n\n      return this.state.externalBuffer || this._buffer;\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      if (this.state.constant) {\n        return this.value;\n      }\n\n      return [this.getBuffer(), this.getAccessor()];\n    }\n  }, {\n    key: \"getAccessor\",\n    value: function getAccessor() {\n      return this.state.bufferAccessor;\n    }\n  }, {\n    key: \"setData\",\n    value: function setData(opts) {\n      var state = this.state;\n\n      if (ArrayBuffer.isView(opts)) {\n        opts = {\n          value: opts\n        };\n      } else if (opts instanceof Buffer) {\n        opts = {\n          buffer: opts\n        };\n      }\n\n      var accessor = _objectSpread({}, this.settings, {}, opts);\n\n      state.bufferAccessor = accessor;\n\n      if (opts.constant) {\n        var value = opts.value;\n        value = this._normalizeValue(value, [], 0);\n\n        if (this.settings.normalized) {\n          value = this._normalizeConstant(value);\n        }\n\n        var hasChanged = !state.constant || !this._areValuesEqual(value, this.value);\n\n        if (!hasChanged) {\n          return false;\n        }\n\n        state.externalBuffer = null;\n        state.constant = true;\n        this.value = value;\n      } else if (opts.buffer) {\n        var buffer = opts.buffer;\n        state.externalBuffer = buffer;\n        state.constant = false;\n        this.value = opts.value;\n        var isBuffer64Bit = opts.value instanceof Float64Array;\n        accessor.type = opts.type || buffer.accessor.type;\n        accessor.bytesPerElement = buffer.accessor.BYTES_PER_ELEMENT * (isBuffer64Bit ? 2 : 1);\n        accessor.stride = getStride(accessor);\n      } else if (opts.value) {\n        this._checkExternalBuffer(opts);\n\n        var _value = opts.value;\n        state.externalBuffer = null;\n        state.constant = false;\n        this.value = _value;\n        accessor.bytesPerElement = _value.BYTES_PER_ELEMENT;\n        accessor.stride = getStride(accessor);\n        var _buffer = this.buffer,\n            byteOffset = this.byteOffset;\n\n        if (this.doublePrecision && _value instanceof Float64Array) {\n          _value = toDoublePrecisionArray(_value, accessor);\n        }\n\n        if (_buffer.byteLength < _value.byteLength + byteOffset) {\n          _buffer.reallocate((_value.byteLength + byteOffset) * 2);\n        }\n\n        _buffer.setAccessor(null);\n\n        _buffer.subData({\n          data: _value,\n          offset: byteOffset\n        });\n\n        accessor.type = opts.type || _buffer.accessor.type;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"updateSubBuffer\",\n    value: function updateSubBuffer() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var value = this.value;\n      var _opts$startOffset = opts.startOffset,\n          startOffset = _opts$startOffset === void 0 ? 0 : _opts$startOffset,\n          endOffset = opts.endOffset;\n      this.buffer.subData({\n        data: this.doublePrecision && value instanceof Float64Array ? toDoublePrecisionArray(value, {\n          size: this.size,\n          startIndex: startOffset,\n          endIndex: endOffset\n        }) : value.subarray(startOffset, endOffset),\n        offset: startOffset * value.BYTES_PER_ELEMENT + this.byteOffset\n      });\n    }\n  }, {\n    key: \"allocate\",\n    value: function allocate(_ref3) {\n      var numInstances = _ref3.numInstances,\n          _ref3$copy = _ref3.copy,\n          copy = _ref3$copy === void 0 ? false : _ref3$copy;\n      var state = this.state;\n      var oldValue = state.allocatedValue;\n      var value = typedArrayManager.allocate(oldValue, numInstances + 1, {\n        size: this.size,\n        type: this.defaultType,\n        copy: copy\n      });\n      this.value = value;\n      var buffer = this.buffer,\n          byteOffset = this.byteOffset;\n\n      if (buffer.byteLength < value.byteLength + byteOffset) {\n        buffer.reallocate(value.byteLength + byteOffset);\n\n        if (copy && oldValue) {\n          buffer.subData({\n            data: oldValue instanceof Float64Array ? toDoublePrecisionArray(oldValue, this) : oldValue,\n            offset: byteOffset\n          });\n        }\n      }\n\n      state.allocatedValue = value;\n      state.constant = false;\n      state.externalBuffer = null;\n      state.bufferAccessor = this.settings;\n      return true;\n    }\n  }, {\n    key: \"_checkExternalBuffer\",\n    value: function _checkExternalBuffer(opts) {\n      var value = opts.value;\n\n      if (!opts.constant && value) {\n        var ArrayType = this.defaultType;\n        var illegalArrayType = false;\n\n        if (this.doublePrecision) {\n          illegalArrayType = value.BYTES_PER_ELEMENT < 4;\n        }\n\n        if (illegalArrayType) {\n          throw new Error(\"Attribute \".concat(this.id, \" does not support \").concat(value.constructor.name));\n        }\n\n        if (!(value instanceof ArrayType) && this.settings.normalized && !('normalized' in opts)) {\n          log.warn(\"Attribute \".concat(this.id, \" is normalized\"))();\n        }\n      }\n    }\n  }, {\n    key: \"_normalizeConstant\",\n    value: function _normalizeConstant(value) {\n      switch (this.settings.type) {\n        case 5120:\n          return new Float32Array(value).map(function (x) {\n            return (x + 128) / 255 * 2 - 1;\n          });\n\n        case 5122:\n          return new Float32Array(value).map(function (x) {\n            return (x + 32768) / 65535 * 2 - 1;\n          });\n\n        case 5121:\n          return new Float32Array(value).map(function (x) {\n            return x / 255;\n          });\n\n        case 5123:\n          return new Float32Array(value).map(function (x) {\n            return x / 65535;\n          });\n\n        default:\n          return value;\n      }\n    }\n  }, {\n    key: \"_normalizeValue\",\n    value: function _normalizeValue(value, out, start) {\n      var _this$settings = this.settings,\n          defaultValue = _this$settings.defaultValue,\n          size = _this$settings.size;\n\n      if (Number.isFinite(value)) {\n        out[start] = value;\n        return out;\n      }\n\n      if (!value) {\n        out[start] = defaultValue[0];\n        return out;\n      }\n\n      switch (size) {\n        case 4:\n          out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];\n\n        case 3:\n          out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];\n\n        case 2:\n          out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];\n\n        case 1:\n          out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];\n          break;\n\n        default:\n          var i = size;\n\n          while (--i >= 0) {\n            out[start + i] = Number.isFinite(value[i]) ? value[i] : defaultValue[i];\n          }\n\n      }\n\n      return out;\n    }\n  }, {\n    key: \"_areValuesEqual\",\n    value: function _areValuesEqual(value1, value2) {\n      if (!value1 || !value2) {\n        return false;\n      }\n\n      var size = this.size;\n\n      for (var i = 0; i < size; i++) {\n        if (value1[i] !== value2[i]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"buffer\",\n    get: function get() {\n      if (!this._buffer) {\n        var _this$settings2 = this.settings,\n            isIndexed = _this$settings2.isIndexed,\n            type = _this$settings2.type;\n        this._buffer = new Buffer(this.gl, {\n          id: this.id,\n          target: isIndexed ? 34963 : 34962,\n          accessor: {\n            type: type\n          }\n        });\n      }\n\n      return this._buffer;\n    }\n  }, {\n    key: \"byteOffset\",\n    get: function get() {\n      var accessor = this.getAccessor();\n\n      if (accessor.vertexOffset) {\n        return accessor.vertexOffset * getStride(accessor);\n      }\n\n      return 0;\n    }\n  }]);\n\n  return DataColumn;\n}();\n\nexport { DataColumn as default };","map":{"version":3,"sources":["../../../../src/lib/attribute/data-column.js"],"names":["accessor","shaderAttributeOptions","log","stride","getStride","vertexOffset","baseAccessor","elementOffset","offset","resolvedOptions","resolveShaderAttribute","high","low","DataColumn","opts","logicalType","doublePrecision","defaultValue","Number","bufferType","gl","hasFeature","FEATURES","defaultType","glArrayFromType","externalBuffer","bufferAccessor","allocatedValue","constant","isIndexed","type","id","target","typedArrayManager","options","shaderAttributes","isBuffer64Bit","doubleShaderAttributeDefs","resolveDoublePrecisionShaderAttributes","shaderAttributeDef","state","ArrayBuffer","value","buffer","hasChanged","byteOffset","toDoublePrecisionArray","data","startOffset","endOffset","size","startIndex","endIndex","numInstances","copy","oldValue","ArrayType","illegalArrayType","x","out","start","i","value1","value2"],"mappings":"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","sourcesContent":["/* eslint-disable complexity */\nimport GL from '@luma.gl/constants';\nimport {hasFeature, FEATURES, Buffer} from '@luma.gl/core';\nimport ShaderAttribute from './shader-attribute';\nimport {glArrayFromType} from './gl-utils';\nimport typedArrayManager from '../../utils/typed-array-manager';\nimport {toDoublePrecisionArray} from '../../utils/math-utils';\nimport log from '../../utils/log';\n\nfunction getStride(accessor) {\n  return accessor.stride || accessor.size * accessor.bytesPerElement;\n}\n\nfunction resolveShaderAttribute(baseAccessor, shaderAttributeOptions) {\n  if (shaderAttributeOptions.offset) {\n    log.removed('shaderAttribute.offset', 'vertexOffset, elementOffset')();\n  }\n\n  // All shader attributes share the parent's stride\n  const stride = getStride(baseAccessor);\n  // `vertexOffset` is used to access the neighboring vertex's value\n  // e.g. `nextPositions` in polygon\n  const vertexOffset =\n    'vertexOffset' in shaderAttributeOptions\n      ? shaderAttributeOptions.vertexOffset\n      : baseAccessor.vertexOffset || 0;\n  // `elementOffset` is defined when shader attribute's size is smaller than the parent's\n  // e.g. `translations` in transform matrix\n  const elementOffset = shaderAttributeOptions.elementOffset || 0;\n  const offset =\n    // offsets defined by the attribute\n    vertexOffset * stride +\n    elementOffset * baseAccessor.bytesPerElement +\n    // offsets defined by external buffers if any\n    (baseAccessor.offset || 0);\n\n  return {\n    ...shaderAttributeOptions,\n    offset,\n    stride\n  };\n}\n\nfunction resolveDoublePrecisionShaderAttributes(baseAccessor, shaderAttributeOptions) {\n  const resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);\n\n  return {\n    high: resolvedOptions,\n    low: {\n      ...resolvedOptions,\n      offset: resolvedOptions.offset + baseAccessor.size * 4\n    }\n  };\n}\n\nexport default class DataColumn {\n  /* eslint-disable max-statements */\n  constructor(gl, opts) {\n    this.gl = gl;\n    this.id = opts.id;\n    this.size = opts.size;\n\n    const logicalType = opts.logicalType || opts.type;\n    const doublePrecision = logicalType === GL.DOUBLE;\n\n    let {defaultValue} = opts;\n    defaultValue = Number.isFinite(defaultValue)\n      ? [defaultValue]\n      : defaultValue || new Array(this.size).fill(0);\n    opts.defaultValue = defaultValue;\n\n    let bufferType = logicalType;\n    if (doublePrecision) {\n      bufferType = GL.FLOAT;\n    } else if (!bufferType && opts.isIndexed) {\n      bufferType =\n        gl && hasFeature(gl, FEATURES.ELEMENT_INDEX_UINT32) ? GL.UNSIGNED_INT : GL.UNSIGNED_SHORT;\n    } else if (!bufferType) {\n      bufferType = GL.FLOAT;\n    }\n    opts.logicalType = logicalType;\n    opts.type = bufferType;\n\n    // This is the attribute type defined by the layer\n    // If an external buffer is provided, this.type may be overwritten\n    // But we always want to use defaultType for allocation\n    let defaultType = glArrayFromType(logicalType || bufferType || GL.FLOAT);\n    this.shaderAttributes = {};\n    this.doublePrecision = doublePrecision;\n\n    // `fp64: false` tells a double-precision attribute to allocate Float32Arrays\n    // by default when using auto-packing. This is more efficient in use cases where\n    // high precision is unnecessary, but the `64Low` attribute is still required\n    // by the shader.\n    if (doublePrecision && opts.fp64 === false) {\n      defaultType = Float32Array;\n    }\n    opts.bytesPerElement = defaultType.BYTES_PER_ELEMENT;\n\n    this.defaultType = defaultType;\n    this.value = null;\n    this.settings = opts;\n    this.state = {\n      externalBuffer: null,\n      bufferAccessor: opts,\n      allocatedValue: null,\n      constant: false\n    };\n    this._buffer = null;\n\n    this.setData(opts);\n  }\n  /* eslint-enable max-statements */\n\n  get buffer() {\n    if (!this._buffer) {\n      const {isIndexed, type} = this.settings;\n      this._buffer = new Buffer(this.gl, {\n        id: this.id,\n        target: isIndexed ? GL.ELEMENT_ARRAY_BUFFER : GL.ARRAY_BUFFER,\n        accessor: {type}\n      });\n    }\n    return this._buffer;\n  }\n\n  get byteOffset() {\n    const accessor = this.getAccessor();\n    if (accessor.vertexOffset) {\n      return accessor.vertexOffset * getStride(accessor);\n    }\n    return 0;\n  }\n\n  delete() {\n    if (this._buffer) {\n      this._buffer.delete();\n      this._buffer = null;\n    }\n    typedArrayManager.release(this.state.allocatedValue);\n  }\n\n  getShaderAttributes(id, options) {\n    if (this.doublePrecision) {\n      const shaderAttributes = {};\n      const isBuffer64Bit = this.value instanceof Float64Array;\n\n      const doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(\n        this.getAccessor(),\n        options || {}\n      );\n\n      shaderAttributes[id] = new ShaderAttribute(this, doubleShaderAttributeDefs.high);\n      shaderAttributes[`${id}64Low`] = isBuffer64Bit\n        ? new ShaderAttribute(this, doubleShaderAttributeDefs.low)\n        : new Float32Array(this.size); // use constant for low part if buffer is 32-bit\n      return shaderAttributes;\n    }\n    if (options) {\n      const shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options);\n      return {[id]: new ShaderAttribute(this, shaderAttributeDef)};\n    }\n    return {[id]: this};\n  }\n\n  getBuffer() {\n    if (this.state.constant) {\n      return null;\n    }\n    return this.state.externalBuffer || this._buffer;\n  }\n\n  getValue() {\n    if (this.state.constant) {\n      return this.value;\n    }\n    return [this.getBuffer(), this.getAccessor()];\n  }\n\n  getAccessor() {\n    return this.state.bufferAccessor;\n  }\n\n  // returns true if success\n  // eslint-disable-next-line max-statements\n  setData(opts) {\n    const {state} = this;\n    if (ArrayBuffer.isView(opts)) {\n      opts = {value: opts};\n    } else if (opts instanceof Buffer) {\n      opts = {buffer: opts};\n    }\n\n    const accessor = {...this.settings, ...opts};\n    state.bufferAccessor = accessor;\n\n    if (opts.constant) {\n      // set constant\n      let value = opts.value;\n      value = this._normalizeValue(value, [], 0);\n      if (this.settings.normalized) {\n        value = this._normalizeConstant(value);\n      }\n      const hasChanged = !state.constant || !this._areValuesEqual(value, this.value);\n\n      if (!hasChanged) {\n        return false;\n      }\n      state.externalBuffer = null;\n      state.constant = true;\n      this.value = value;\n    } else if (opts.buffer) {\n      const buffer = opts.buffer;\n      state.externalBuffer = buffer;\n      state.constant = false;\n      this.value = opts.value;\n      const isBuffer64Bit = opts.value instanceof Float64Array;\n\n      // Copy the type of the buffer into the accessor\n      accessor.type = opts.type || buffer.accessor.type;\n      accessor.bytesPerElement = buffer.accessor.BYTES_PER_ELEMENT * (isBuffer64Bit ? 2 : 1);\n      accessor.stride = getStride(accessor);\n    } else if (opts.value) {\n      this._checkExternalBuffer(opts);\n\n      let value = opts.value;\n      state.externalBuffer = null;\n      state.constant = false;\n      this.value = value;\n\n      accessor.bytesPerElement = value.BYTES_PER_ELEMENT;\n      accessor.stride = getStride(accessor);\n\n      const {buffer, byteOffset} = this;\n\n      if (this.doublePrecision && value instanceof Float64Array) {\n        value = toDoublePrecisionArray(value, accessor);\n      }\n      // TODO: support offset in buffer.setData?\n      if (buffer.byteLength < value.byteLength + byteOffset) {\n        // Over allocation is required because shader attributes may have bigger offsets\n        buffer.reallocate((value.byteLength + byteOffset) * 2);\n      }\n      // Hack: force Buffer to infer data type\n      buffer.setAccessor(null);\n      buffer.subData({data: value, offset: byteOffset});\n      accessor.type = opts.type || buffer.accessor.type;\n    }\n\n    return true;\n  }\n\n  updateSubBuffer(opts = {}) {\n    const {value} = this;\n    const {startOffset = 0, endOffset} = opts;\n    this.buffer.subData({\n      data:\n        this.doublePrecision && value instanceof Float64Array\n          ? toDoublePrecisionArray(value, {\n              size: this.size,\n              startIndex: startOffset,\n              endIndex: endOffset\n            })\n          : value.subarray(startOffset, endOffset),\n      offset: startOffset * value.BYTES_PER_ELEMENT + this.byteOffset\n    });\n  }\n\n  allocate({numInstances, copy = false}) {\n    const {state} = this;\n    const oldValue = state.allocatedValue;\n\n    // Allocate at least one element to ensure a valid buffer\n    const value = typedArrayManager.allocate(oldValue, numInstances + 1, {\n      size: this.size,\n      type: this.defaultType,\n      copy\n    });\n    this.value = value;\n    const {buffer, byteOffset} = this;\n\n    if (buffer.byteLength < value.byteLength + byteOffset) {\n      buffer.reallocate(value.byteLength + byteOffset);\n\n      if (copy && oldValue) {\n        // Upload the full existing attribute value to the GPU, so that updateBuffer\n        // can choose to only update a partial range.\n        // TODO - copy old buffer to new buffer on the GPU\n        buffer.subData({\n          data:\n            oldValue instanceof Float64Array ? toDoublePrecisionArray(oldValue, this) : oldValue,\n          offset: byteOffset\n        });\n      }\n    }\n\n    state.allocatedValue = value;\n    state.constant = false;\n    state.externalBuffer = null;\n    state.bufferAccessor = this.settings;\n    return true;\n  }\n\n  // PRIVATE HELPER METHODS\n  _checkExternalBuffer(opts) {\n    const {value} = opts;\n    if (!opts.constant && value) {\n      const ArrayType = this.defaultType;\n\n      let illegalArrayType = false;\n      if (this.doublePrecision) {\n        // not 32bit or 64bit\n        illegalArrayType = value.BYTES_PER_ELEMENT < 4;\n      }\n      if (illegalArrayType) {\n        throw new Error(`Attribute ${this.id} does not support ${value.constructor.name}`);\n      }\n      if (!(value instanceof ArrayType) && this.settings.normalized && !('normalized' in opts)) {\n        log.warn(`Attribute ${this.id} is normalized`)();\n      }\n    }\n  }\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer\n  _normalizeConstant(value) {\n    switch (this.settings.type) {\n      case GL.BYTE:\n        // normalize [-128, 127] to [-1, 1]\n        return new Float32Array(value).map(x => ((x + 128) / 255) * 2 - 1);\n\n      case GL.SHORT:\n        // normalize [-32768, 32767] to [-1, 1]\n        return new Float32Array(value).map(x => ((x + 32768) / 65535) * 2 - 1);\n\n      case GL.UNSIGNED_BYTE:\n        // normalize [0, 255] to [0, 1]\n        return new Float32Array(value).map(x => x / 255);\n\n      case GL.UNSIGNED_SHORT:\n        // normalize [0, 65535] to [0, 1]\n        return new Float32Array(value).map(x => x / 65535);\n\n      default:\n        // No normalization for gl.FLOAT and gl.HALF_FLOAT\n        return value;\n    }\n  }\n\n  /* check user supplied values and apply fallback */\n  _normalizeValue(value, out, start) {\n    const {defaultValue, size} = this.settings;\n\n    if (Number.isFinite(value)) {\n      out[start] = value;\n      return out;\n    }\n    if (!value) {\n      out[start] = defaultValue[0];\n      return out;\n    }\n\n    // Important - switch cases are 5x more performant than a for loop!\n    /* eslint-disable no-fallthrough, default-case */\n    switch (size) {\n      case 4:\n        out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];\n      case 3:\n        out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];\n      case 2:\n        out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];\n      case 1:\n        out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];\n        break;\n\n      default:\n        // In the rare case where the attribute size > 4, do it the slow way\n        // This is used for e.g. transform matrices\n        let i = size;\n        while (--i >= 0) {\n          out[start + i] = Number.isFinite(value[i]) ? value[i] : defaultValue[i];\n        }\n    }\n\n    return out;\n  }\n\n  _areValuesEqual(value1, value2) {\n    if (!value1 || !value2) {\n      return false;\n    }\n    const {size} = this;\n    for (let i = 0; i < size; i++) {\n      if (value1[i] !== value2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}