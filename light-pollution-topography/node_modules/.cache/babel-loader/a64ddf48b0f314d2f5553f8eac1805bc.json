{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport assert from '../utils/assert';\nimport { Timeline } from '@luma.gl/core';\nimport Layer from './layer';\nimport { LIFECYCLE } from '../lifecycle/constants';\nimport log from '../utils/log';\nimport debug from '../debug';\nimport { flatten } from '../utils/flatten';\nimport { Stats } from 'probe.gl';\nimport Viewport from '../viewports/viewport';\nimport { createProgramManager } from '../shaderlib';\nvar TRACE_SET_LAYERS = 'layerManager.setLayers';\nvar TRACE_ACTIVATE_VIEWPORT = 'layerManager.activateViewport';\nvar INITIAL_CONTEXT = Object.seal({\n  layerManager: null,\n  deck: null,\n  gl: null,\n  stats: null,\n  shaderCache: null,\n  pickingFBO: null,\n  mousePosition: null,\n  userData: {}\n});\n\nvar layerName = function layerName(layer) {\n  return layer instanceof Layer ? \"\".concat(layer) : !layer ? 'null' : 'invalid';\n};\n\nvar LayerManager = function () {\n  function LayerManager(gl) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        deck = _ref.deck,\n        stats = _ref.stats,\n        _ref$viewport = _ref.viewport,\n        viewport = _ref$viewport === void 0 ? null : _ref$viewport,\n        _ref$timeline = _ref.timeline,\n        timeline = _ref$timeline === void 0 ? null : _ref$timeline;\n\n    _classCallCheck(this, LayerManager);\n\n    this.lastRenderedLayers = [];\n    this.layers = [];\n    this.context = Object.assign({}, INITIAL_CONTEXT, {\n      layerManager: this,\n      deck: deck,\n      gl: gl,\n      programManager: gl && createProgramManager(gl),\n      stats: stats || new Stats({\n        id: 'deck.gl'\n      }),\n      viewport: viewport || new Viewport({\n        id: 'DEFAULT-INITIAL-VIEWPORT'\n      }),\n      timeline: timeline || new Timeline()\n    });\n    this._needsRedraw = 'Initial render';\n    this._needsUpdate = false;\n    this._debug = false;\n    this._onError = null;\n    this.activateViewport = this.activateViewport.bind(this);\n    Object.seal(this);\n  }\n\n  _createClass(LayerManager, [{\n    key: \"finalize\",\n    value: function finalize() {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.layers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var layer = _step.value;\n\n          this._finalizeLayer(layer);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"needsRedraw\",\n    value: function needsRedraw() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        clearRedrawFlags: false\n      };\n      var redraw = this._needsRedraw;\n\n      if (opts.clearRedrawFlags) {\n        this._needsRedraw = false;\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this.layers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var layer = _step2.value;\n          var layerNeedsRedraw = layer.getNeedsRedraw(opts);\n          redraw = redraw || layerNeedsRedraw;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return redraw;\n    }\n  }, {\n    key: \"needsUpdate\",\n    value: function needsUpdate() {\n      return this._needsUpdate;\n    }\n  }, {\n    key: \"setNeedsRedraw\",\n    value: function setNeedsRedraw(reason) {\n      this._needsRedraw = this._needsRedraw || reason;\n    }\n  }, {\n    key: \"setNeedsUpdate\",\n    value: function setNeedsUpdate(reason) {\n      this._needsUpdate = this._needsUpdate || reason;\n    }\n  }, {\n    key: \"getLayers\",\n    value: function getLayers() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref2$layerIds = _ref2.layerIds,\n          layerIds = _ref2$layerIds === void 0 ? null : _ref2$layerIds;\n\n      return layerIds ? this.layers.filter(function (layer) {\n        return layerIds.find(function (layerId) {\n          return layer.id.indexOf(layerId) === 0;\n        });\n      }) : this.layers;\n    }\n  }, {\n    key: \"setProps\",\n    value: function setProps(props) {\n      if ('debug' in props) {\n        this._debug = props.debug;\n      }\n\n      if ('userData' in props) {\n        this.context.userData = props.userData;\n      }\n\n      if ('layers' in props) {\n        this.setLayers(props.layers);\n      }\n\n      if ('onError' in props) {\n        this._onError = props.onError;\n      }\n    }\n  }, {\n    key: \"setLayers\",\n    value: function setLayers(newLayers) {\n      var forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var shouldUpdate = forceUpdate || newLayers !== this.lastRenderedLayers;\n      debug(TRACE_SET_LAYERS, this, shouldUpdate, newLayers);\n\n      if (!shouldUpdate) {\n        return this;\n      }\n\n      this.lastRenderedLayers = newLayers;\n      newLayers = flatten(newLayers, Boolean);\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = newLayers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var layer = _step3.value;\n          layer.context = this.context;\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n            _iterator3[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      this._updateLayers(this.layers, newLayers);\n\n      return this;\n    }\n  }, {\n    key: \"updateLayers\",\n    value: function updateLayers() {\n      var reason = this.needsUpdate();\n\n      if (reason) {\n        this.setNeedsRedraw(\"updating layers: \".concat(reason));\n        var forceUpdate = true;\n        this.setLayers(this.lastRenderedLayers, forceUpdate);\n      }\n    }\n  }, {\n    key: \"activateViewport\",\n    value: function activateViewport(viewport) {\n      assert(viewport, 'LayerManager: viewport not set');\n      var oldViewport = this.context.viewport;\n      var viewportChanged = !oldViewport || !viewport.equals(oldViewport);\n\n      if (viewportChanged) {\n        debug(TRACE_ACTIVATE_VIEWPORT, this, viewport);\n        this.context.viewport = viewport;\n        var changeFlags = {\n          viewportChanged: true\n        };\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = this.layers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var layer = _step4.value;\n            layer.setChangeFlags(changeFlags);\n\n            this._updateLayer(layer);\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4[\"return\"] != null) {\n              _iterator4[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"_handleError\",\n    value: function _handleError(stage, error, layer) {\n      if (this._onError) {\n        this._onError(error, layer);\n      } else {\n        log.error(\"error during \".concat(stage, \" of \").concat(layerName(layer)), error)();\n      }\n    }\n  }, {\n    key: \"_updateLayers\",\n    value: function _updateLayers(oldLayers, newLayers) {\n      var oldLayerMap = {};\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = oldLayers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var oldLayer = _step5.value;\n\n          if (oldLayerMap[oldLayer.id]) {\n            log.warn(\"Multiple old layers with same id \".concat(layerName(oldLayer)))();\n          } else {\n            oldLayerMap[oldLayer.id] = oldLayer;\n          }\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5[\"return\"] != null) {\n            _iterator5[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      var generatedLayers = [];\n\n      this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);\n\n      this._finalizeOldLayers(oldLayerMap);\n\n      var needsUpdate = false;\n\n      for (var _i = 0, _generatedLayers = generatedLayers; _i < _generatedLayers.length; _i++) {\n        var layer = _generatedLayers[_i];\n\n        if (layer.hasUniformTransition()) {\n          needsUpdate = true;\n          break;\n        }\n      }\n\n      this._needsUpdate = needsUpdate;\n      this.layers = generatedLayers;\n    }\n  }, {\n    key: \"_updateSublayersRecursively\",\n    value: function _updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers) {\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = newLayers[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var newLayer = _step6.value;\n          newLayer.context = this.context;\n          var oldLayer = oldLayerMap[newLayer.id];\n\n          if (oldLayer === null) {\n            log.warn(\"Multiple new layers with same id \".concat(layerName(newLayer)))();\n          }\n\n          oldLayerMap[newLayer.id] = null;\n          var sublayers = null;\n\n          try {\n            if (this._debug && oldLayer !== newLayer) {\n              newLayer.validateProps();\n            }\n\n            if (!oldLayer) {\n              this._initializeLayer(newLayer);\n            } else {\n              this._transferLayerState(oldLayer, newLayer);\n\n              this._updateLayer(newLayer);\n            }\n\n            generatedLayers.push(newLayer);\n            sublayers = newLayer.isComposite && newLayer.getSubLayers();\n          } catch (err) {\n            this._handleError('matching', err, newLayer);\n          }\n\n          if (sublayers) {\n            this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);\n          }\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6[\"return\"] != null) {\n            _iterator6[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_finalizeOldLayers\",\n    value: function _finalizeOldLayers(oldLayerMap) {\n      for (var layerId in oldLayerMap) {\n        var layer = oldLayerMap[layerId];\n\n        if (layer) {\n          this._finalizeLayer(layer);\n        }\n      }\n    }\n  }, {\n    key: \"_initializeLayer\",\n    value: function _initializeLayer(layer) {\n      try {\n        layer._initialize();\n\n        layer.lifecycle = LIFECYCLE.INITIALIZED;\n      } catch (err) {\n        this._handleError('initialization', err, layer);\n      }\n    }\n  }, {\n    key: \"_transferLayerState\",\n    value: function _transferLayerState(oldLayer, newLayer) {\n      newLayer._transferState(oldLayer);\n\n      newLayer.lifecycle = LIFECYCLE.MATCHED;\n\n      if (newLayer !== oldLayer) {\n        oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;\n      }\n    }\n  }, {\n    key: \"_updateLayer\",\n    value: function _updateLayer(layer) {\n      try {\n        layer._update();\n      } catch (err) {\n        this._handleError('update', err, layer);\n      }\n    }\n  }, {\n    key: \"_finalizeLayer\",\n    value: function _finalizeLayer(layer) {\n      this._needsRedraw = this._needsRedraw || \"finalized \".concat(layerName(layer));\n      layer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;\n\n      try {\n        layer._finalize();\n\n        layer.lifecycle = LIFECYCLE.FINALIZED;\n      } catch (err) {\n        this._handleError('finalization', err, layer);\n      }\n    }\n  }]);\n\n  return LayerManager;\n}();\n\nexport { LayerManager as default };","map":{"version":3,"sources":["../../../src/lib/layer-manager.js"],"names":["TRACE_SET_LAYERS","TRACE_ACTIVATE_VIEWPORT","INITIAL_CONTEXT","layerManager","deck","gl","stats","shaderCache","pickingFBO","mousePosition","userData","layerName","layer","LayerManager","viewport","timeline","programManager","createProgramManager","id","Object","opts","clearRedrawFlags","redraw","layerNeedsRedraw","reason","layerIds","props","newLayers","forceUpdate","shouldUpdate","debug","flatten","assert","oldViewport","viewportChanged","changeFlags","stage","error","log","oldLayers","oldLayerMap","oldLayer","generatedLayers","needsUpdate","newLayer","sublayers","LIFECYCLE"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport assert from '../utils/assert';\nimport {Timeline} from '@luma.gl/core';\nimport Layer from './layer';\nimport {LIFECYCLE} from '../lifecycle/constants';\nimport log from '../utils/log';\nimport debug from '../debug';\nimport {flatten} from '../utils/flatten';\nimport {Stats} from 'probe.gl';\n\nimport Viewport from '../viewports/viewport';\nimport {createProgramManager} from '../shaderlib';\n\nconst TRACE_SET_LAYERS = 'layerManager.setLayers';\nconst TRACE_ACTIVATE_VIEWPORT = 'layerManager.activateViewport';\n\n// CONTEXT IS EXPOSED TO LAYERS\nconst INITIAL_CONTEXT = Object.seal({\n  layerManager: null,\n  deck: null,\n  gl: null,\n\n  // General resources\n  stats: null, // for tracking lifecycle performance\n\n  // GL Resources\n  shaderCache: null,\n  pickingFBO: null, // Screen-size framebuffer that layers can reuse\n\n  mousePosition: null,\n\n  userData: {} // Place for any custom app `context`\n});\n\nconst layerName = layer => (layer instanceof Layer ? `${layer}` : !layer ? 'null' : 'invalid');\n\nexport default class LayerManager {\n  // eslint-disable-next-line\n  constructor(gl, {deck, stats, viewport = null, timeline = null} = {}) {\n    // Currently deck.gl expects the DeckGL.layers array to be different\n    // whenever React rerenders. If the same layers array is used, the\n    // LayerManager's diffing algorithm will generate a fatal error and\n    // break the rendering.\n\n    // `this.lastRenderedLayers` stores the UNFILTERED layers sent\n    // down to LayerManager, so that `layers` reference can be compared.\n    // If it's the same across two React render calls, the diffing logic\n    // will be skipped.\n    this.lastRenderedLayers = [];\n    this.layers = [];\n\n    this.context = Object.assign({}, INITIAL_CONTEXT, {\n      layerManager: this,\n      deck,\n      gl,\n      // Enabling luma.gl Program caching using private API (_cachePrograms)\n      programManager: gl && createProgramManager(gl),\n      stats: stats || new Stats({id: 'deck.gl'}),\n      // Make sure context.viewport is not empty on the first layer initialization\n      viewport: viewport || new Viewport({id: 'DEFAULT-INITIAL-VIEWPORT'}), // Current viewport, exposed to layers for project* function\n      timeline: timeline || new Timeline()\n    });\n\n    this._needsRedraw = 'Initial render';\n    this._needsUpdate = false;\n    this._debug = false;\n    this._onError = null;\n\n    this.activateViewport = this.activateViewport.bind(this);\n\n    Object.seal(this);\n  }\n\n  // Method to call when the layer manager is not needed anymore.\n  finalize() {\n    // Finalize all layers\n    for (const layer of this.layers) {\n      this._finalizeLayer(layer);\n    }\n  }\n\n  // Check if a redraw is needed\n  needsRedraw(opts = {clearRedrawFlags: false}) {\n    let redraw = this._needsRedraw;\n    if (opts.clearRedrawFlags) {\n      this._needsRedraw = false;\n    }\n\n    // This layers list doesn't include sublayers, relying on composite layers\n    for (const layer of this.layers) {\n      // Call every layer to clear their flags\n      const layerNeedsRedraw = layer.getNeedsRedraw(opts);\n      redraw = redraw || layerNeedsRedraw;\n    }\n\n    return redraw;\n  }\n\n  // Check if a deep update of all layers is needed\n  needsUpdate() {\n    return this._needsUpdate;\n  }\n\n  // Layers will be redrawn (in next animation frame)\n  setNeedsRedraw(reason) {\n    this._needsRedraw = this._needsRedraw || reason;\n  }\n\n  // Layers will be updated deeply (in next animation frame)\n  // Potentially regenerating attributes and sub layers\n  setNeedsUpdate(reason) {\n    this._needsUpdate = this._needsUpdate || reason;\n  }\n\n  // Gets an (optionally) filtered list of layers\n  getLayers({layerIds = null} = {}) {\n    // Filtering by layerId compares beginning of strings, so that sublayers will be included\n    // Dependes on the convention of adding suffixes to the parent's layer name\n    return layerIds\n      ? this.layers.filter(layer => layerIds.find(layerId => layer.id.indexOf(layerId) === 0))\n      : this.layers;\n  }\n\n  // Set props needed for layer rendering and picking.\n  setProps(props) {\n    if ('debug' in props) {\n      this._debug = props.debug;\n    }\n\n    // A way for apps to add data to context that can be accessed in layers\n    if ('userData' in props) {\n      this.context.userData = props.userData;\n    }\n\n    // TODO - For now we set layers before viewports to preserve changeFlags\n    if ('layers' in props) {\n      this.setLayers(props.layers);\n    }\n\n    if ('onError' in props) {\n      this._onError = props.onError;\n    }\n  }\n\n  // Supply a new layer list, initiating sublayer generation and layer matching\n  setLayers(newLayers, forceUpdate = false) {\n    // TODO - something is generating state updates that cause rerender of the same\n    const shouldUpdate = forceUpdate || newLayers !== this.lastRenderedLayers;\n    debug(TRACE_SET_LAYERS, this, shouldUpdate, newLayers);\n\n    if (!shouldUpdate) {\n      return this;\n    }\n    this.lastRenderedLayers = newLayers;\n\n    newLayers = flatten(newLayers, Boolean);\n\n    for (const layer of newLayers) {\n      layer.context = this.context;\n    }\n\n    this._updateLayers(this.layers, newLayers);\n\n    return this;\n  }\n\n  // Update layers from last cycle if `setNeedsUpdate()` has been called\n  updateLayers() {\n    // NOTE: For now, even if only some layer has changed, we update all layers\n    // to ensure that layer id maps etc remain consistent even if different\n    // sublayers are rendered\n    const reason = this.needsUpdate();\n    if (reason) {\n      this.setNeedsRedraw(`updating layers: ${reason}`);\n      // Force a full update\n      const forceUpdate = true;\n      this.setLayers(this.lastRenderedLayers, forceUpdate);\n    }\n  }\n\n  //\n  // PRIVATE METHODS\n  //\n\n  // Make a viewport \"current\" in layer context, updating viewportChanged flags\n  activateViewport(viewport) {\n    assert(viewport, 'LayerManager: viewport not set');\n\n    const oldViewport = this.context.viewport;\n    const viewportChanged = !oldViewport || !viewport.equals(oldViewport);\n\n    if (viewportChanged) {\n      debug(TRACE_ACTIVATE_VIEWPORT, this, viewport);\n\n      this.context.viewport = viewport;\n      const changeFlags = {viewportChanged: true};\n\n      // Update layers states\n      // Let screen space layers update their state based on viewport\n      for (const layer of this.layers) {\n        layer.setChangeFlags(changeFlags);\n        this._updateLayer(layer);\n      }\n    }\n\n    return this;\n  }\n\n  _handleError(stage, error, layer) {\n    if (this._onError) {\n      this._onError(error, layer);\n    } else {\n      log.error(`error during ${stage} of ${layerName(layer)}`, error)();\n    }\n  }\n\n  // Match all layers, checking for caught errors\n  // To avoid having an exception in one layer disrupt other layers\n  // TODO - mark layers with exceptions as bad and remove from rendering cycle?\n  _updateLayers(oldLayers, newLayers) {\n    // Create old layer map\n    const oldLayerMap = {};\n    for (const oldLayer of oldLayers) {\n      if (oldLayerMap[oldLayer.id]) {\n        log.warn(`Multiple old layers with same id ${layerName(oldLayer)}`)();\n      } else {\n        oldLayerMap[oldLayer.id] = oldLayer;\n      }\n    }\n\n    // Allocate array for generated layers\n    const generatedLayers = [];\n\n    // Match sublayers\n    this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);\n\n    // Finalize unmatched layers\n    this._finalizeOldLayers(oldLayerMap);\n\n    let needsUpdate = false;\n    for (const layer of generatedLayers) {\n      if (layer.hasUniformTransition()) {\n        needsUpdate = true;\n        break;\n      }\n    }\n\n    this._needsUpdate = needsUpdate;\n    this.layers = generatedLayers;\n  }\n\n  /* eslint-disable complexity,max-statements */\n  // Note: adds generated layers to `generatedLayers` array parameter\n  _updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers) {\n    for (const newLayer of newLayers) {\n      newLayer.context = this.context;\n\n      // Given a new coming layer, find its matching old layer (if any)\n      const oldLayer = oldLayerMap[newLayer.id];\n      if (oldLayer === null) {\n        // null, rather than undefined, means this id was originally there\n        log.warn(`Multiple new layers with same id ${layerName(newLayer)}`)();\n      }\n      // Remove the old layer from candidates, as it has been matched with this layer\n      oldLayerMap[newLayer.id] = null;\n\n      let sublayers = null;\n\n      // We must not generate exceptions until after layer matching is complete\n      try {\n        if (this._debug && oldLayer !== newLayer) {\n          newLayer.validateProps();\n        }\n\n        if (!oldLayer) {\n          this._initializeLayer(newLayer);\n        } else {\n          this._transferLayerState(oldLayer, newLayer);\n          this._updateLayer(newLayer);\n        }\n        generatedLayers.push(newLayer);\n\n        // Call layer lifecycle method: render sublayers\n        sublayers = newLayer.isComposite && newLayer.getSubLayers();\n        // End layer lifecycle method: render sublayers\n      } catch (err) {\n        this._handleError('matching', err, newLayer); // Record first exception\n      }\n\n      if (sublayers) {\n        this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);\n      }\n    }\n  }\n  /* eslint-enable complexity,max-statements */\n\n  // Finalize any old layers that were not matched\n  _finalizeOldLayers(oldLayerMap) {\n    for (const layerId in oldLayerMap) {\n      const layer = oldLayerMap[layerId];\n      if (layer) {\n        this._finalizeLayer(layer);\n      }\n    }\n  }\n\n  // EXCEPTION SAFE LAYER ACCESS\n\n  // Initializes a single layer, calling layer methods\n  _initializeLayer(layer) {\n    try {\n      layer._initialize();\n      layer.lifecycle = LIFECYCLE.INITIALIZED;\n    } catch (err) {\n      this._handleError('initialization', err, layer);\n      // TODO - what should the lifecycle state be here? LIFECYCLE.INITIALIZATION_FAILED?\n    }\n  }\n\n  _transferLayerState(oldLayer, newLayer) {\n    newLayer._transferState(oldLayer);\n    newLayer.lifecycle = LIFECYCLE.MATCHED;\n\n    if (newLayer !== oldLayer) {\n      oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;\n    }\n  }\n\n  // Updates a single layer, cleaning all flags\n  _updateLayer(layer) {\n    try {\n      layer._update();\n    } catch (err) {\n      this._handleError('update', err, layer);\n    }\n  }\n\n  // Finalizes a single layer\n  _finalizeLayer(layer) {\n    this._needsRedraw = this._needsRedraw || `finalized ${layerName(layer)}`;\n\n    layer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;\n\n    try {\n      layer._finalize();\n      layer.lifecycle = LIFECYCLE.FINALIZED;\n    } catch (err) {\n      this._handleError('finalization', err, layer);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}