{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport LinearInterpolator from '../transitions/linear-interpolator';\nimport Transition from '../transitions/transition';\n\nvar noop = function noop() {};\n\nexport var TRANSITION_EVENTS = {\n  BREAK: 1,\n  SNAP_TO_END: 2,\n  IGNORE: 3\n};\nvar DEFAULT_PROPS = {\n  transitionDuration: 0,\n  transitionEasing: function transitionEasing(t) {\n    return t;\n  },\n  transitionInterpolator: new LinearInterpolator(),\n  transitionInterruption: TRANSITION_EVENTS.BREAK,\n  onTransitionStart: noop,\n  onTransitionInterrupt: noop,\n  onTransitionEnd: noop\n};\n\nvar TransitionManager = function () {\n  function TransitionManager(ControllerState) {\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, TransitionManager);\n\n    this.ControllerState = ControllerState;\n    this.props = Object.assign({}, DEFAULT_PROPS, props);\n    this.propsInTransition = null;\n    this.transition = new Transition(props.timeline);\n    this.onViewStateChange = props.onViewStateChange;\n    this._onTransitionUpdate = this._onTransitionUpdate.bind(this);\n  }\n\n  _createClass(TransitionManager, [{\n    key: \"finalize\",\n    value: function finalize() {\n      this.transition.cancel();\n    }\n  }, {\n    key: \"getViewportInTransition\",\n    value: function getViewportInTransition() {\n      return this.propsInTransition;\n    }\n  }, {\n    key: \"processViewStateChange\",\n    value: function processViewStateChange(nextProps) {\n      var transitionTriggered = false;\n      var currentProps = this.props;\n      nextProps = Object.assign({}, DEFAULT_PROPS, nextProps);\n      this.props = nextProps;\n\n      if (this._shouldIgnoreViewportChange(currentProps, nextProps)) {\n        return transitionTriggered;\n      }\n\n      if (this._isTransitionEnabled(nextProps)) {\n        var _this$transition$sett = this.transition.settings,\n            interruption = _this$transition$sett.interruption,\n            endProps = _this$transition$sett.endProps;\n        var startProps = Object.assign({}, currentProps, interruption === TRANSITION_EVENTS.SNAP_TO_END ? endProps : this.propsInTransition || currentProps);\n\n        this._triggerTransition(startProps, nextProps);\n\n        transitionTriggered = true;\n      } else {\n        this.transition.cancel();\n      }\n\n      return transitionTriggered;\n    }\n  }, {\n    key: \"updateTransition\",\n    value: function updateTransition() {\n      this.transition.update();\n    }\n  }, {\n    key: \"_isTransitionEnabled\",\n    value: function _isTransitionEnabled(props) {\n      var transitionDuration = props.transitionDuration,\n          transitionInterpolator = props.transitionInterpolator;\n      return (transitionDuration > 0 || transitionDuration === 'auto') && Boolean(transitionInterpolator);\n    }\n  }, {\n    key: \"_isUpdateDueToCurrentTransition\",\n    value: function _isUpdateDueToCurrentTransition(props) {\n      if (this.transition.inProgress) {\n        return this.transition.settings.interpolator.arePropsEqual(props, this.propsInTransition);\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_shouldIgnoreViewportChange\",\n    value: function _shouldIgnoreViewportChange(currentProps, nextProps) {\n      if (this.transition.inProgress) {\n        return this.transition.settings.interruption === TRANSITION_EVENTS.IGNORE || this._isUpdateDueToCurrentTransition(nextProps);\n      } else if (this._isTransitionEnabled(nextProps)) {\n        return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_triggerTransition\",\n    value: function _triggerTransition(startProps, endProps) {\n      var startViewstate = new this.ControllerState(startProps);\n      var endViewStateProps = new this.ControllerState(endProps).shortestPathFrom(startViewstate);\n      var transitionInterpolator = endProps.transitionInterpolator;\n      var duration = transitionInterpolator.getDuration ? transitionInterpolator.getDuration(startProps, endProps) : endProps.transitionDuration;\n      var initialProps = endProps.transitionInterpolator.initializeProps(startProps, endViewStateProps);\n      this.propsInTransition = {};\n      this.duration = duration;\n      this.transition.start({\n        duration: duration,\n        easing: endProps.transitionEasing,\n        interpolator: endProps.transitionInterpolator,\n        interruption: endProps.transitionInterruption,\n        startProps: initialProps.start,\n        endProps: initialProps.end,\n        onStart: endProps.onTransitionStart,\n        onUpdate: this._onTransitionUpdate,\n        onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),\n        onEnd: this._onTransitionEnd(endProps.onTransitionEnd)\n      });\n      this.updateTransition();\n    }\n  }, {\n    key: \"_onTransitionEnd\",\n    value: function _onTransitionEnd(callback) {\n      var _this = this;\n\n      return function (transition) {\n        _this.propsInTransition = null;\n        callback(transition);\n      };\n    }\n  }, {\n    key: \"_onTransitionUpdate\",\n    value: function _onTransitionUpdate(transition) {\n      var time = transition.time,\n          _transition$settings = transition.settings,\n          interpolator = _transition$settings.interpolator,\n          startProps = _transition$settings.startProps,\n          endProps = _transition$settings.endProps,\n          duration = _transition$settings.duration,\n          easing = _transition$settings.easing;\n      var t = easing(time / duration);\n      var viewport = interpolator.interpolateProps(startProps, endProps, t);\n      this.propsInTransition = new this.ControllerState(Object.assign({}, this.props, viewport)).getViewportProps();\n\n      if (this.onViewStateChange) {\n        this.onViewStateChange({\n          viewState: this.propsInTransition,\n          interactionState: {\n            inTransition: true\n          },\n          oldViewState: this.props\n        });\n      }\n    }\n  }]);\n\n  return TransitionManager;\n}();\n\nexport { TransitionManager as default };\nTransitionManager.defaultProps = DEFAULT_PROPS;","map":{"version":3,"sources":["../../../src/controllers/transition-manager.js"],"names":["noop","TRANSITION_EVENTS","BREAK","SNAP_TO_END","IGNORE","DEFAULT_PROPS","transitionDuration","transitionEasing","transitionInterpolator","transitionInterruption","onTransitionStart","onTransitionInterrupt","onTransitionEnd","TransitionManager","props","Object","nextProps","transitionTriggered","currentProps","interruption","endProps","startProps","Boolean","startViewstate","endViewStateProps","duration","initialProps","easing","interpolator","onStart","onUpdate","onInterrupt","onEnd","callback","transition","time","t","viewport","viewState","interactionState","inTransition","oldViewState"],"mappings":"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","sourcesContent":["import LinearInterpolator from '../transitions/linear-interpolator';\nimport Transition from '../transitions/transition';\n\nconst noop = () => {};\n\nexport const TRANSITION_EVENTS = {\n  BREAK: 1,\n  SNAP_TO_END: 2,\n  IGNORE: 3\n};\n\nconst DEFAULT_PROPS = {\n  transitionDuration: 0,\n  transitionEasing: t => t,\n  transitionInterpolator: new LinearInterpolator(),\n  transitionInterruption: TRANSITION_EVENTS.BREAK,\n  onTransitionStart: noop,\n  onTransitionInterrupt: noop,\n  onTransitionEnd: noop\n};\n\nexport default class TransitionManager {\n  constructor(ControllerState, props = {}) {\n    this.ControllerState = ControllerState;\n    this.props = Object.assign({}, DEFAULT_PROPS, props);\n    this.propsInTransition = null;\n    this.transition = new Transition(props.timeline);\n\n    this.onViewStateChange = props.onViewStateChange;\n\n    this._onTransitionUpdate = this._onTransitionUpdate.bind(this);\n  }\n\n  finalize() {\n    this.transition.cancel();\n  }\n\n  // Returns current transitioned viewport.\n  getViewportInTransition() {\n    return this.propsInTransition;\n  }\n\n  // Process the vewiport change, either ignore or trigger a new transition.\n  // Return true if a new transition is triggered, false otherwise.\n  processViewStateChange(nextProps) {\n    let transitionTriggered = false;\n    const currentProps = this.props;\n    // Set this.props here as '_triggerTransition' calls '_updateViewport' that uses this.props.\n    nextProps = Object.assign({}, DEFAULT_PROPS, nextProps);\n    this.props = nextProps;\n\n    // NOTE: Be cautious re-ordering statements in this function.\n    if (this._shouldIgnoreViewportChange(currentProps, nextProps)) {\n      return transitionTriggered;\n    }\n\n    if (this._isTransitionEnabled(nextProps)) {\n      const {interruption, endProps} = this.transition.settings;\n      const startProps = Object.assign(\n        {},\n        currentProps,\n        interruption === TRANSITION_EVENTS.SNAP_TO_END\n          ? endProps\n          : this.propsInTransition || currentProps\n      );\n\n      this._triggerTransition(startProps, nextProps);\n\n      transitionTriggered = true;\n    } else {\n      this.transition.cancel();\n    }\n\n    return transitionTriggered;\n  }\n\n  updateTransition() {\n    this.transition.update();\n  }\n\n  // Helper methods\n\n  _isTransitionEnabled(props) {\n    const {transitionDuration, transitionInterpolator} = props;\n    return (\n      (transitionDuration > 0 || transitionDuration === 'auto') && Boolean(transitionInterpolator)\n    );\n  }\n\n  _isUpdateDueToCurrentTransition(props) {\n    if (this.transition.inProgress) {\n      return this.transition.settings.interpolator.arePropsEqual(props, this.propsInTransition);\n    }\n    return false;\n  }\n\n  _shouldIgnoreViewportChange(currentProps, nextProps) {\n    if (this.transition.inProgress) {\n      // Ignore update if it is requested to be ignored\n      return (\n        this.transition.settings.interruption === TRANSITION_EVENTS.IGNORE ||\n        // Ignore update if it is due to current active transition.\n        this._isUpdateDueToCurrentTransition(nextProps)\n      );\n    } else if (this._isTransitionEnabled(nextProps)) {\n      // Ignore if none of the viewport props changed.\n      return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);\n    }\n    return true;\n  }\n\n  _triggerTransition(startProps, endProps) {\n    const startViewstate = new this.ControllerState(startProps);\n    const endViewStateProps = new this.ControllerState(endProps).shortestPathFrom(startViewstate);\n\n    // update transitionDuration for 'auto' mode\n    const {transitionInterpolator} = endProps;\n    const duration = transitionInterpolator.getDuration\n      ? transitionInterpolator.getDuration(startProps, endProps)\n      : endProps.transitionDuration;\n\n    const initialProps = endProps.transitionInterpolator.initializeProps(\n      startProps,\n      endViewStateProps\n    );\n\n    this.propsInTransition = {};\n    this.duration = duration;\n    this.transition.start({\n      duration,\n      easing: endProps.transitionEasing,\n      interpolator: endProps.transitionInterpolator,\n      interruption: endProps.transitionInterruption,\n\n      startProps: initialProps.start,\n      endProps: initialProps.end,\n\n      onStart: endProps.onTransitionStart,\n      onUpdate: this._onTransitionUpdate,\n      onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),\n      onEnd: this._onTransitionEnd(endProps.onTransitionEnd)\n    });\n    this.updateTransition();\n  }\n\n  _onTransitionEnd(callback) {\n    return transition => {\n      this.propsInTransition = null;\n      callback(transition);\n    };\n  }\n\n  _onTransitionUpdate(transition) {\n    // NOTE: Be cautious re-ordering statements in this function.\n    const {\n      time,\n      settings: {interpolator, startProps, endProps, duration, easing}\n    } = transition;\n    const t = easing(time / duration);\n    const viewport = interpolator.interpolateProps(startProps, endProps, t);\n\n    // This gurantees all props (e.g. bearing, longitude) are normalized\n    // So when viewports are compared they are in same range.\n    this.propsInTransition = new this.ControllerState(\n      Object.assign({}, this.props, viewport)\n    ).getViewportProps();\n\n    if (this.onViewStateChange) {\n      this.onViewStateChange({\n        viewState: this.propsInTransition,\n        interactionState: {inTransition: true},\n        oldViewState: this.props\n      });\n    }\n  }\n}\n\nTransitionManager.defaultProps = DEFAULT_PROPS;\n"]},"metadata":{},"sourceType":"module"}