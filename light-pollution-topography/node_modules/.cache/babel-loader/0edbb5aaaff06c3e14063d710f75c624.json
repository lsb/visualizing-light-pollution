{"ast":null,"code":"import { Vector3 } from 'math.gl';\nimport BoundingSphere from '../lib/bounding-sphere';\nvar fromPointsXMin = new Vector3();\nvar fromPointsYMin = new Vector3();\nvar fromPointsZMin = new Vector3();\nvar fromPointsXMax = new Vector3();\nvar fromPointsYMax = new Vector3();\nvar fromPointsZMax = new Vector3();\nvar fromPointsCurrentPos = new Vector3();\nvar fromPointsScratch = new Vector3();\nvar fromPointsRitterCenter = new Vector3();\nvar fromPointsMinBoxPt = new Vector3();\nvar fromPointsMaxBoxPt = new Vector3();\nvar fromPointsNaiveCenterScratch = new Vector3();\nvar volumeConstant = 4.0 / 3.0 * Math.PI;\nexport function makeBoundingSphereFromPoints(positions) {\n  var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new BoundingSphere();\n\n  if (!positions || positions.length === 0) {\n    return result.fromCenterRadius([0, 0, 0], 0);\n  }\n\n  var currentPos = fromPointsCurrentPos.copy(positions[0]);\n  var xMin = fromPointsXMin.copy(currentPos);\n  var yMin = fromPointsYMin.copy(currentPos);\n  var zMin = fromPointsZMin.copy(currentPos);\n  var xMax = fromPointsXMax.copy(currentPos);\n  var yMax = fromPointsYMax.copy(currentPos);\n  var zMax = fromPointsZMax.copy(currentPos);\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = positions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var position = _step.value;\n      currentPos.copy(position);\n      var x = currentPos.x;\n      var y = currentPos.y;\n      var z = currentPos.z;\n\n      if (x < xMin.x) {\n        currentPos.copy(xMin);\n      }\n\n      if (x > xMax.x) {\n        currentPos.copy(xMax);\n      }\n\n      if (y < yMin.y) {\n        currentPos.copy(yMin);\n      }\n\n      if (y > yMax.y) {\n        currentPos.copy(yMax);\n      }\n\n      if (z < zMin.z) {\n        currentPos.copy(zMin);\n      }\n\n      if (z > zMax.z) {\n        currentPos.copy(zMax);\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var xSpan = fromPointsScratch.copy(xMax).subtract(xMin).magnitudeSquared();\n  var ySpan = fromPointsScratch.copy(yMax).subtract(yMin).magnitudeSquared();\n  var zSpan = fromPointsScratch.copy(zMax).subtract(zMin).magnitudeSquared();\n  var diameter1 = xMin;\n  var diameter2 = xMax;\n  var maxSpan = xSpan;\n\n  if (ySpan > maxSpan) {\n    maxSpan = ySpan;\n    diameter1 = yMin;\n    diameter2 = yMax;\n  }\n\n  if (zSpan > maxSpan) {\n    maxSpan = zSpan;\n    diameter1 = zMin;\n    diameter2 = zMax;\n  }\n\n  var ritterCenter = fromPointsRitterCenter;\n  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n  var radiusSquared = fromPointsScratch.copy(diameter2).subtract(ritterCenter).magnitudeSquared();\n  var ritterRadius = Math.sqrt(radiusSquared);\n  var minBoxPt = fromPointsMinBoxPt;\n  minBoxPt.x = xMin.x;\n  minBoxPt.y = yMin.y;\n  minBoxPt.z = zMin.z;\n  var maxBoxPt = fromPointsMaxBoxPt;\n  maxBoxPt.x = xMax.x;\n  maxBoxPt.y = yMax.y;\n  maxBoxPt.z = zMax.z;\n  var naiveCenter = fromPointsNaiveCenterScratch.copy(minBoxPt).add(maxBoxPt).multiplyByScalar(0.5);\n  var naiveRadius = 0;\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = positions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var _position = _step2.value;\n      currentPos.copy(_position);\n      var r = fromPointsScratch.copy(currentPos).subtract(naiveCenter).magnitude();\n\n      if (r > naiveRadius) {\n        naiveRadius = r;\n      }\n\n      var oldCenterToPointSquared = fromPointsScratch.copy(currentPos).subtract(ritterCenter).magnitudeSquared();\n\n      if (oldCenterToPointSquared > radiusSquared) {\n        var oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n        ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n        radiusSquared = ritterRadius * ritterRadius;\n        var oldToNew = oldCenterToPoint - ritterRadius;\n        ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;\n        ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;\n        ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n        _iterator2[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  if (ritterRadius < naiveRadius) {\n    ritterCenter.to(result.center);\n    result.radius = ritterRadius;\n  } else {\n    naiveCenter.to(result.center);\n    result.radius = naiveRadius;\n  }\n\n  return result;\n}","map":{"version":3,"sources":["../../../src/algorithms/bounding-sphere-from-points.js"],"names":["fromPointsXMin","fromPointsYMin","fromPointsZMin","fromPointsXMax","fromPointsYMax","fromPointsZMax","fromPointsCurrentPos","fromPointsScratch","fromPointsRitterCenter","fromPointsMinBoxPt","fromPointsMaxBoxPt","fromPointsNaiveCenterScratch","volumeConstant","Math","result","positions","currentPos","xMin","yMin","zMin","xMax","yMax","zMax","position","x","y","z","xSpan","ySpan","zSpan","diameter1","diameter2","maxSpan","ritterCenter","radiusSquared","ritterRadius","minBoxPt","maxBoxPt","naiveCenter","naiveRadius","r","oldCenterToPointSquared","oldCenterToPoint","oldToNew"],"mappings":"AAGA,SAAA,OAAA,QAAA,SAAA;AACA,OAAA,cAAA,MAAA,wBAAA;AAGA,IAAMA,cAAc,GAAG,IAAvB,OAAuB,EAAvB;AACA,IAAMC,cAAc,GAAG,IAAvB,OAAuB,EAAvB;AACA,IAAMC,cAAc,GAAG,IAAvB,OAAuB,EAAvB;AACA,IAAMC,cAAc,GAAG,IAAvB,OAAuB,EAAvB;AACA,IAAMC,cAAc,GAAG,IAAvB,OAAuB,EAAvB;AACA,IAAMC,cAAc,GAAG,IAAvB,OAAuB,EAAvB;AACA,IAAMC,oBAAoB,GAAG,IAA7B,OAA6B,EAA7B;AACA,IAAMC,iBAAiB,GAAG,IAA1B,OAA0B,EAA1B;AACA,IAAMC,sBAAsB,GAAG,IAA/B,OAA+B,EAA/B;AACA,IAAMC,kBAAkB,GAAG,IAA3B,OAA2B,EAA3B;AACA,IAAMC,kBAAkB,GAAG,IAA3B,OAA2B,EAA3B;AACA,IAAMC,4BAA4B,GAAG,IAArC,OAAqC,EAArC;AACA,IAAMC,cAAc,GAAI,MAAD,GAAC,GAAaC,IAAI,CAAzC,EAAA;AAcA,OAAO,SAAA,4BAAA,CAAA,SAAA,EAAgF;AAAA,MAA/BC,MAA+B,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAtB,IAAA,cAAA,EAAsB;;AACrF,MAAI,CAAA,SAAA,IAAcC,SAAS,CAATA,MAAAA,KAAlB,CAAA,EAA0C;AACxC,WAAOD,MAAM,CAANA,gBAAAA,CAAwB,CAAA,CAAA,EAAA,CAAA,EAAxBA,CAAwB,CAAxBA,EAAP,CAAOA,CAAP;AACD;;AAED,MAAME,UAAU,GAAGV,oBAAoB,CAApBA,IAAAA,CAA0BS,SAAS,CAAtD,CAAsD,CAAnCT,CAAnB;AAEA,MAAMW,IAAI,GAAGjB,cAAc,CAAdA,IAAAA,CAAb,UAAaA,CAAb;AACA,MAAMkB,IAAI,GAAGjB,cAAc,CAAdA,IAAAA,CAAb,UAAaA,CAAb;AACA,MAAMkB,IAAI,GAAGjB,cAAc,CAAdA,IAAAA,CAAb,UAAaA,CAAb;AAEA,MAAMkB,IAAI,GAAGjB,cAAc,CAAdA,IAAAA,CAAb,UAAaA,CAAb;AACA,MAAMkB,IAAI,GAAGjB,cAAc,CAAdA,IAAAA,CAAb,UAAaA,CAAb;AACA,MAAMkB,IAAI,GAAGjB,cAAc,CAAdA,IAAAA,CAAb,UAAaA,CAAb;AAbqF,MAAA,yBAAA,GAAA,IAAA;AAAA,MAAA,iBAAA,GAAA,KAAA;AAAA,MAAA,cAAA,GAAA,SAAA;;AAAA,MAAA;AAerF,SAAA,IAAA,SAAA,GAAuBU,SAAvB,CAAA,MAAA,CAAA,QAAA,CAAuBA,EAAvB,EAAA,KAAA,EAAA,EAAA,yBAAA,GAAA,CAAA,KAAA,GAAA,SAAA,CAAA,IAAA,EAAA,EAAA,IAAA,CAAA,EAAA,yBAAA,GAAA,IAAA,EAAkC;AAAA,UAAvBQ,QAAuB,GAAA,KAAA,CAAA,KAAA;AAChCP,MAAAA,UAAU,CAAVA,IAAAA,CAAAA,QAAAA;AAEA,UAAMQ,CAAC,GAAGR,UAAU,CAApB,CAAA;AACA,UAAMS,CAAC,GAAGT,UAAU,CAApB,CAAA;AACA,UAAMU,CAAC,GAAGV,UAAU,CAApB,CAAA;;AAGA,UAAIQ,CAAC,GAAGP,IAAI,CAAZ,CAAA,EAAgB;AACdD,QAAAA,UAAU,CAAVA,IAAAA,CAAAA,IAAAA;AACD;;AAED,UAAIQ,CAAC,GAAGJ,IAAI,CAAZ,CAAA,EAAgB;AACdJ,QAAAA,UAAU,CAAVA,IAAAA,CAAAA,IAAAA;AACD;;AAED,UAAIS,CAAC,GAAGP,IAAI,CAAZ,CAAA,EAAgB;AACdF,QAAAA,UAAU,CAAVA,IAAAA,CAAAA,IAAAA;AACD;;AAED,UAAIS,CAAC,GAAGJ,IAAI,CAAZ,CAAA,EAAgB;AACdL,QAAAA,UAAU,CAAVA,IAAAA,CAAAA,IAAAA;AACD;;AAED,UAAIU,CAAC,GAAGP,IAAI,CAAZ,CAAA,EAAgB;AACdH,QAAAA,UAAU,CAAVA,IAAAA,CAAAA,IAAAA;AACD;;AAED,UAAIU,CAAC,GAAGJ,IAAI,CAAZ,CAAA,EAAgB;AACdN,QAAAA,UAAU,CAAVA,IAAAA,CAAAA,IAAAA;AACD;AACF;AA9CoF,GAAA,CAAA,OAAA,GAAA,EAAA;AAAA,IAAA,iBAAA,GAAA,IAAA;AAAA,IAAA,cAAA,GAAA,GAAA;AAAA,GAAA,SAAA;AAAA,QAAA;AAAA,UAAA,CAAA,yBAAA,IAAA,SAAA,CAAA,QAAA,CAAA,IAAA,IAAA,EAAA;AAAA,QAAA,SAAA,CAAA,QAAA,CAAA;AAAA;AAAA,KAAA,SAAA;AAAA,UAAA,iBAAA,EAAA;AAAA,cAAA,cAAA;AAAA;AAAA;AAAA;;AAiDrF,MAAMW,KAAK,GAAGpB,iBAAiB,CAAjBA,IAAAA,CAAAA,IAAAA,EAAAA,QAAAA,CAAAA,IAAAA,EAAd,gBAAcA,EAAd;AAIA,MAAMqB,KAAK,GAAGrB,iBAAiB,CAAjBA,IAAAA,CAAAA,IAAAA,EAAAA,QAAAA,CAAAA,IAAAA,EAAd,gBAAcA,EAAd;AAIA,MAAMsB,KAAK,GAAGtB,iBAAiB,CAAjBA,IAAAA,CAAAA,IAAAA,EAAAA,QAAAA,CAAAA,IAAAA,EAAd,gBAAcA,EAAd;AAMA,MAAIuB,SAAS,GAAb,IAAA;AACA,MAAIC,SAAS,GAAb,IAAA;AACA,MAAIC,OAAO,GAAX,KAAA;;AACA,MAAIJ,KAAK,GAAT,OAAA,EAAqB;AACnBI,IAAAA,OAAO,GAAPA,KAAAA;AACAF,IAAAA,SAAS,GAATA,IAAAA;AACAC,IAAAA,SAAS,GAATA,IAAAA;AACD;;AACD,MAAIF,KAAK,GAAT,OAAA,EAAqB;AACnBG,IAAAA,OAAO,GAAPA,KAAAA;AACAF,IAAAA,SAAS,GAATA,IAAAA;AACAC,IAAAA,SAAS,GAATA,IAAAA;AACD;;AAGD,MAAME,YAAY,GAAlB,sBAAA;AACAA,EAAAA,YAAY,CAAZA,CAAAA,GAAiB,CAACH,SAAS,CAATA,CAAAA,GAAcC,SAAS,CAAxB,CAAA,IAAjBE,GAAAA;AACAA,EAAAA,YAAY,CAAZA,CAAAA,GAAiB,CAACH,SAAS,CAATA,CAAAA,GAAcC,SAAS,CAAxB,CAAA,IAAjBE,GAAAA;AACAA,EAAAA,YAAY,CAAZA,CAAAA,GAAiB,CAACH,SAAS,CAATA,CAAAA,GAAcC,SAAS,CAAxB,CAAA,IAAjBE,GAAAA;AAGA,MAAIC,aAAa,GAAG3B,iBAAiB,CAAjBA,IAAAA,CAAAA,SAAAA,EAAAA,QAAAA,CAAAA,YAAAA,EAApB,gBAAoBA,EAApB;AAIA,MAAI4B,YAAY,GAAGtB,IAAI,CAAJA,IAAAA,CAAnB,aAAmBA,CAAnB;AAGA,MAAMuB,QAAQ,GAAd,kBAAA;AACAA,EAAAA,QAAQ,CAARA,CAAAA,GAAanB,IAAI,CAAjBmB,CAAAA;AACAA,EAAAA,QAAQ,CAARA,CAAAA,GAAalB,IAAI,CAAjBkB,CAAAA;AACAA,EAAAA,QAAQ,CAARA,CAAAA,GAAajB,IAAI,CAAjBiB,CAAAA;AAEA,MAAMC,QAAQ,GAAd,kBAAA;AACAA,EAAAA,QAAQ,CAARA,CAAAA,GAAajB,IAAI,CAAjBiB,CAAAA;AACAA,EAAAA,QAAQ,CAARA,CAAAA,GAAahB,IAAI,CAAjBgB,CAAAA;AACAA,EAAAA,QAAQ,CAARA,CAAAA,GAAaf,IAAI,CAAjBe,CAAAA;AAEA,MAAMC,WAAW,GAAG3B,4BAA4B,CAA5BA,IAAAA,CAAAA,QAAAA,EAAAA,GAAAA,CAAAA,QAAAA,EAAAA,gBAAAA,CAApB,GAAoBA,CAApB;AAMA,MAAI4B,WAAW,GAAf,CAAA;AA3GqF,MAAA,0BAAA,GAAA,IAAA;AAAA,MAAA,kBAAA,GAAA,KAAA;AAAA,MAAA,eAAA,GAAA,SAAA;;AAAA,MAAA;AA4GrF,SAAA,IAAA,UAAA,GAAuBxB,SAAvB,CAAA,MAAA,CAAA,QAAA,CAAuBA,EAAvB,EAAA,MAAA,EAAA,EAAA,0BAAA,GAAA,CAAA,MAAA,GAAA,UAAA,CAAA,IAAA,EAAA,EAAA,IAAA,CAAA,EAAA,0BAAA,GAAA,IAAA,EAAkC;AAAA,UAAvBQ,SAAuB,GAAA,MAAA,CAAA,KAAA;AAChCP,MAAAA,UAAU,CAAVA,IAAAA,CAAAA,SAAAA;AAGA,UAAMwB,CAAC,GAAGjC,iBAAiB,CAAjBA,IAAAA,CAAAA,UAAAA,EAAAA,QAAAA,CAAAA,WAAAA,EAAV,SAAUA,EAAV;;AAIA,UAAIiC,CAAC,GAAL,WAAA,EAAqB;AACnBD,QAAAA,WAAW,GAAXA,CAAAA;AACD;;AAGD,UAAME,uBAAuB,GAAGlC,iBAAiB,CAAjBA,IAAAA,CAAAA,UAAAA,EAAAA,QAAAA,CAAAA,YAAAA,EAAhC,gBAAgCA,EAAhC;;AAKA,UAAIkC,uBAAuB,GAA3B,aAAA,EAA6C;AAC3C,YAAMC,gBAAgB,GAAG7B,IAAI,CAAJA,IAAAA,CAAzB,uBAAyBA,CAAzB;AAEAsB,QAAAA,YAAY,GAAG,CAACA,YAAY,GAAb,gBAAA,IAAfA,GAAAA;AACAD,QAAAA,aAAa,GAAGC,YAAY,GAA5BD,YAAAA;AAEA,YAAMS,QAAQ,GAAGD,gBAAgB,GAAjC,YAAA;AACAT,QAAAA,YAAY,CAAZA,CAAAA,GAAiB,CAACE,YAAY,GAAGF,YAAY,CAA3BE,CAAAA,GAAgCQ,QAAQ,GAAG3B,UAAU,CAAtD,CAAA,IAAjBiB,gBAAAA;AACAA,QAAAA,YAAY,CAAZA,CAAAA,GAAiB,CAACE,YAAY,GAAGF,YAAY,CAA3BE,CAAAA,GAAgCQ,QAAQ,GAAG3B,UAAU,CAAtD,CAAA,IAAjBiB,gBAAAA;AACAA,QAAAA,YAAY,CAAZA,CAAAA,GAAiB,CAACE,YAAY,GAAGF,YAAY,CAA3BE,CAAAA,GAAgCQ,QAAQ,GAAG3B,UAAU,CAAtD,CAAA,IAAjBiB,gBAAAA;AACD;AACF;AAzIoF,GAAA,CAAA,OAAA,GAAA,EAAA;AAAA,IAAA,kBAAA,GAAA,IAAA;AAAA,IAAA,eAAA,GAAA,GAAA;AAAA,GAAA,SAAA;AAAA,QAAA;AAAA,UAAA,CAAA,0BAAA,IAAA,UAAA,CAAA,QAAA,CAAA,IAAA,IAAA,EAAA;AAAA,QAAA,UAAA,CAAA,QAAA,CAAA;AAAA;AAAA,KAAA,SAAA;AAAA,UAAA,kBAAA,EAAA;AAAA,cAAA,eAAA;AAAA;AAAA;AAAA;;AA2IrF,MAAIE,YAAY,GAAhB,WAAA,EAAgC;AAC9BF,IAAAA,YAAY,CAAZA,EAAAA,CAAgBnB,MAAM,CAAtBmB,MAAAA;AACAnB,IAAAA,MAAM,CAANA,MAAAA,GAAAA,YAAAA;AAFF,GAAA,MAGO;AACLwB,IAAAA,WAAW,CAAXA,EAAAA,CAAexB,MAAM,CAArBwB,MAAAA;AACAxB,IAAAA,MAAM,CAANA,MAAAA,GAAAA,WAAAA;AACD;;AAED,SAAA,MAAA;AACD","sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Vector3} from 'math.gl';\nimport BoundingSphere from '../lib/bounding-sphere';\n\n/* eslint-disable */\nconst fromPointsXMin = new Vector3();\nconst fromPointsYMin = new Vector3();\nconst fromPointsZMin = new Vector3();\nconst fromPointsXMax = new Vector3();\nconst fromPointsYMax = new Vector3();\nconst fromPointsZMax = new Vector3();\nconst fromPointsCurrentPos = new Vector3();\nconst fromPointsScratch = new Vector3();\nconst fromPointsRitterCenter = new Vector3();\nconst fromPointsMinBoxPt = new Vector3();\nconst fromPointsMaxBoxPt = new Vector3();\nconst fromPointsNaiveCenterScratch = new Vector3();\nconst volumeConstant = (4.0 / 3.0) * Math.PI;\n\n/*\nComputes a tight-fitting bounding sphere enclosing a list of 3D Cartesian points.\nThe bounding sphere is computed by running two algorithms, a naive algorithm and\nRitter's algorithm. The smaller of the two spheres is used to ensure a tight fit.\n   *\n@param {Vector3[]} [positions] An array of points that the bounding sphere will enclose.  Each point must have <code>x</code>, <code>y</code>, and <code>z</code> properties.\n@param {BoundingSphere} [result] The object onto which to store the result.\n@returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.\n   *\n@see {@link http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding/|Bounding Sphere computation article}\n*/\n\nexport function makeBoundingSphereFromPoints(positions, result = new BoundingSphere()) {\n  if (!positions || positions.length === 0) {\n    return result.fromCenterRadius([0, 0, 0], 0);\n  }\n\n  const currentPos = fromPointsCurrentPos.copy(positions[0]);\n\n  const xMin = fromPointsXMin.copy(currentPos);\n  const yMin = fromPointsYMin.copy(currentPos);\n  const zMin = fromPointsZMin.copy(currentPos);\n\n  const xMax = fromPointsXMax.copy(currentPos);\n  const yMax = fromPointsYMax.copy(currentPos);\n  const zMax = fromPointsZMax.copy(currentPos);\n\n  for (const position of positions) {\n    currentPos.copy(position);\n\n    const x = currentPos.x;\n    const y = currentPos.y;\n    const z = currentPos.z;\n\n    // Store points containing the the smallest and largest components\n    if (x < xMin.x) {\n      currentPos.copy(xMin);\n    }\n\n    if (x > xMax.x) {\n      currentPos.copy(xMax);\n    }\n\n    if (y < yMin.y) {\n      currentPos.copy(yMin);\n    }\n\n    if (y > yMax.y) {\n      currentPos.copy(yMax);\n    }\n\n    if (z < zMin.z) {\n      currentPos.copy(zMin);\n    }\n\n    if (z > zMax.z) {\n      currentPos.copy(zMax);\n    }\n  }\n\n  // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n  const xSpan = fromPointsScratch\n    .copy(xMax)\n    .subtract(xMin)\n    .magnitudeSquared();\n  const ySpan = fromPointsScratch\n    .copy(yMax)\n    .subtract(yMin)\n    .magnitudeSquared();\n  const zSpan = fromPointsScratch\n    .copy(zMax)\n    .subtract(zMin)\n    .magnitudeSquared();\n\n  // Set the diameter endpoints to the largest span.\n  let diameter1 = xMin;\n  let diameter2 = xMax;\n  let maxSpan = xSpan;\n  if (ySpan > maxSpan) {\n    maxSpan = ySpan;\n    diameter1 = yMin;\n    diameter2 = yMax;\n  }\n  if (zSpan > maxSpan) {\n    maxSpan = zSpan;\n    diameter1 = zMin;\n    diameter2 = zMax;\n  }\n\n  // Calculate the center of the initial sphere found by Ritter's algorithm\n  const ritterCenter = fromPointsRitterCenter;\n  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n\n  // Calculate the radius of the initial sphere found by Ritter's algorithm\n  let radiusSquared = fromPointsScratch\n    .copy(diameter2)\n    .subtract(ritterCenter)\n    .magnitudeSquared();\n  let ritterRadius = Math.sqrt(radiusSquared);\n\n  // Find the center of the sphere found using the Naive method.\n  const minBoxPt = fromPointsMinBoxPt;\n  minBoxPt.x = xMin.x;\n  minBoxPt.y = yMin.y;\n  minBoxPt.z = zMin.z;\n\n  const maxBoxPt = fromPointsMaxBoxPt;\n  maxBoxPt.x = xMax.x;\n  maxBoxPt.y = yMax.y;\n  maxBoxPt.z = zMax.z;\n\n  const naiveCenter = fromPointsNaiveCenterScratch\n    .copy(minBoxPt)\n    .add(maxBoxPt)\n    .multiplyByScalar(0.5);\n\n  // Begin 2nd pass to find naive radius and modify the ritter sphere.\n  let naiveRadius = 0;\n  for (const position of positions) {\n    currentPos.copy(position);\n\n    // Find the furthest point from the naive center to calculate the naive radius.\n    const r = fromPointsScratch\n      .copy(currentPos)\n      .subtract(naiveCenter)\n      .magnitude();\n    if (r > naiveRadius) {\n      naiveRadius = r;\n    }\n\n    // Make adjustments to the Ritter Sphere to include all points.\n    const oldCenterToPointSquared = fromPointsScratch\n      .copy(currentPos)\n      .subtract(ritterCenter)\n      .magnitudeSquared();\n\n    if (oldCenterToPointSquared > radiusSquared) {\n      const oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n      // Calculate new radius to include the point that lies outside\n      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n      radiusSquared = ritterRadius * ritterRadius;\n      // Calculate center of new Ritter sphere\n      const oldToNew = oldCenterToPoint - ritterRadius;\n      ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;\n      ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;\n      ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;\n    }\n  }\n\n  if (ritterRadius < naiveRadius) {\n    ritterCenter.to(result.center);\n    result.radius = ritterRadius;\n  } else {\n    naiveCenter.to(result.center);\n    result.radius = naiveRadius;\n  }\n\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}