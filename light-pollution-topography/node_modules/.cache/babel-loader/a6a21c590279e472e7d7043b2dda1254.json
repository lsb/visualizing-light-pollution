{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { Vector } from './vector';\nimport { BufferType } from './enum';\nimport { Data } from './data';\nimport { createIsValidFunction } from './builder/valid';\nimport { BitmapBufferBuilder, DataBufferBuilder, OffsetsBufferBuilder } from './builder/buffer';\nimport { strideForType } from './type';\n/**\n * An abstract base class for types that construct Arrow Vectors from arbitrary JavaScript values.\n *\n * A `Builder` is responsible for writing arbitrary JavaScript values\n * to ArrayBuffers and/or child Builders according to the Arrow specification\n * for each DataType, creating or resizing the underlying ArrayBuffers as necessary.\n *\n * The `Builder` for each Arrow `DataType` handles converting and appending\n * values for a given `DataType`. The high-level {@link Builder.new `Builder.new()`} convenience\n * method creates the specific `Builder` subclass for the supplied `DataType`.\n *\n * Once created, `Builder` instances support both appending values to the end\n * of the `Builder`, and random-access writes to specific indices\n * (`Builder.prototype.append(value)` is a convenience method for\n * `builder.set(builder.length, value)`). Appending or setting values beyond the\n * Builder's current length may cause the builder to grow its underlying buffers\n * or child Builders (if applicable) to accommodate the new values.\n *\n * After enough values have been written to a `Builder`, `Builder.prototype.flush()`\n * will commit the values to the underlying ArrayBuffers (or child Builders). The\n * internal Builder state will be reset, and an instance of `Data<T>` is returned.\n * Alternatively, `Builder.prototype.toVector()` will flush the `Builder` and return\n * an instance of `Vector<T>` instead.\n *\n * When there are no more values to write, use `Builder.prototype.finish()` to\n * finalize the `Builder`. This does not reset the internal state, so it is\n * necessary to call `Builder.prototype.flush()` or `toVector()` one last time\n * if there are still values queued to be flushed.\n *\n * Note: calling `Builder.prototype.finish()` is required when using a `DictionaryBuilder`,\n * because this is when it flushes the values that have been enqueued in its internal\n * dictionary's `Builder`, and creates the `dictionaryVector` for the `Dictionary` `DataType`.\n *\n * ```ts\n * import { Builder, Utf8 } from 'apache-arrow';\n *\n * const utf8Builder = Builder.new({\n *     type: new Utf8(),\n *     nullValues: [null, 'n/a']\n * });\n *\n * utf8Builder\n *     .append('hello')\n *     .append('n/a')\n *     .append('world')\n *     .append(null);\n *\n * const utf8Vector = utf8Builder.finish().toVector();\n *\n * console.log(utf8Vector.toJSON());\n * // > [\"hello\", null, \"world\", null]\n * ```\n *\n * @typeparam T The `DataType` of this `Builder`.\n * @typeparam TNull The type(s) of values which will be considered null-value sentinels.\n */\n\nexport class Builder {\n  /**\n   * Construct a builder with the given Arrow DataType with optional null values,\n   * which will be interpreted as \"null\" when set or appended to the `Builder`.\n   * @param {{ type: T, nullValues?: any[] }} options A `BuilderOptions` object used to create this `Builder`.\n   */\n  constructor({\n    'type': type,\n    'nullValues': nulls\n  }) {\n    /**\n     * The number of values written to the `Builder` that haven't been flushed yet.\n     * @readonly\n     */\n    this.length = 0;\n    /**\n     * A boolean indicating whether `Builder.prototype.finish()` has been called on this `Builder`.\n     * @readonly\n     */\n\n    this.finished = false;\n    this.type = type;\n    this.children = [];\n    this.nullValues = nulls;\n    this.stride = strideForType(type);\n    this._nulls = new BitmapBufferBuilder();\n\n    if (nulls && nulls.length > 0) {\n      this._isValid = createIsValidFunction(nulls);\n    }\n  }\n  /**\n   * Create a `Builder` instance based on the `type` property of the supplied `options` object.\n   * @param {BuilderOptions<T, TNull>} options An object with a required `DataType` instance\n   * and other optional parameters to be passed to the `Builder` subclass for the given `type`.\n   *\n   * @typeparam T The `DataType` of the `Builder` to create.\n   * @typeparam TNull The type(s) of values which will be considered null-value sentinels.\n   * @nocollapse\n   */\n  // @ts-ignore\n\n\n  static new(options) {}\n  /** @nocollapse */\n  // @ts-ignore\n\n\n  static throughNode(options) {\n    throw new Error(`\"throughNode\" not available in this environment`);\n  }\n  /** @nocollapse */\n  // @ts-ignore\n\n\n  static throughDOM(options) {\n    throw new Error(`\"throughDOM\" not available in this environment`);\n  }\n  /**\n   * Transform a synchronous `Iterable` of arbitrary JavaScript values into a\n   * sequence of Arrow Vector<T> following the chunking semantics defined in\n   * the supplied `options` argument.\n   *\n   * This function returns a function that accepts an `Iterable` of values to\n   * transform. When called, this function returns an Iterator of `Vector<T>`.\n   *\n   * The resulting `Iterator<Vector<T>>` yields Vectors based on the\n   * `queueingStrategy` and `highWaterMark` specified in the `options` argument.\n   *\n   * * If `queueingStrategy` is `\"count\"` (or omitted), The `Iterator<Vector<T>>`\n   *   will flush the underlying `Builder` (and yield a new `Vector<T>`) once the\n   *   Builder's `length` reaches or exceeds the supplied `highWaterMark`.\n   * * If `queueingStrategy` is `\"bytes\"`, the `Iterator<Vector<T>>` will flush\n   *   the underlying `Builder` (and yield a new `Vector<T>`) once its `byteLength`\n   *   reaches or exceeds the supplied `highWaterMark`.\n   *\n   * @param {IterableBuilderOptions<T, TNull>} options An object of properties which determine the `Builder` to create and the chunking semantics to use.\n   * @returns A function which accepts a JavaScript `Iterable` of values to\n   *          write, and returns an `Iterator` that yields Vectors according\n   *          to the chunking semantics defined in the `options` argument.\n   * @nocollapse\n   */\n\n\n  static throughIterable(options) {\n    return throughIterable(options);\n  }\n  /**\n   * Transform an `AsyncIterable` of arbitrary JavaScript values into a\n   * sequence of Arrow Vector<T> following the chunking semantics defined in\n   * the supplied `options` argument.\n   *\n   * This function returns a function that accepts an `AsyncIterable` of values to\n   * transform. When called, this function returns an AsyncIterator of `Vector<T>`.\n   *\n   * The resulting `AsyncIterator<Vector<T>>` yields Vectors based on the\n   * `queueingStrategy` and `highWaterMark` specified in the `options` argument.\n   *\n   * * If `queueingStrategy` is `\"count\"` (or omitted), The `AsyncIterator<Vector<T>>`\n   *   will flush the underlying `Builder` (and yield a new `Vector<T>`) once the\n   *   Builder's `length` reaches or exceeds the supplied `highWaterMark`.\n   * * If `queueingStrategy` is `\"bytes\"`, the `AsyncIterator<Vector<T>>` will flush\n   *   the underlying `Builder` (and yield a new `Vector<T>`) once its `byteLength`\n   *   reaches or exceeds the supplied `highWaterMark`.\n   *\n   * @param {IterableBuilderOptions<T, TNull>} options An object of properties which determine the `Builder` to create and the chunking semantics to use.\n   * @returns A function which accepts a JavaScript `AsyncIterable` of values\n   *          to write, and returns an `AsyncIterator` that yields Vectors\n   *          according to the chunking semantics defined in the `options`\n   *          argument.\n   * @nocollapse\n   */\n\n\n  static throughAsyncIterable(options) {\n    return throughAsyncIterable(options);\n  }\n  /**\n   * Flush the `Builder` and return a `Vector<T>`.\n   * @returns {Vector<T>} A `Vector<T>` of the flushed values.\n   */\n\n\n  toVector() {\n    return Vector.new(this.flush());\n  }\n\n  get ArrayType() {\n    return this.type.ArrayType;\n  }\n\n  get nullCount() {\n    return this._nulls.numInvalid;\n  }\n\n  get numChildren() {\n    return this.children.length;\n  }\n  /**\n   * @returns The aggregate length (in bytes) of the values that have been written.\n   */\n\n\n  get byteLength() {\n    let size = 0;\n    this._offsets && (size += this._offsets.byteLength);\n    this._values && (size += this._values.byteLength);\n    this._nulls && (size += this._nulls.byteLength);\n    this._typeIds && (size += this._typeIds.byteLength);\n    return this.children.reduce((size, child) => size + child.byteLength, size);\n  }\n  /**\n   * @returns The aggregate number of rows that have been reserved to write new values.\n   */\n\n\n  get reservedLength() {\n    return this._nulls.reservedLength;\n  }\n  /**\n   * @returns The aggregate length (in bytes) that has been reserved to write new values.\n   */\n\n\n  get reservedByteLength() {\n    let size = 0;\n    this._offsets && (size += this._offsets.reservedByteLength);\n    this._values && (size += this._values.reservedByteLength);\n    this._nulls && (size += this._nulls.reservedByteLength);\n    this._typeIds && (size += this._typeIds.reservedByteLength);\n    return this.children.reduce((size, child) => size + child.reservedByteLength, size);\n  }\n\n  get valueOffsets() {\n    return this._offsets ? this._offsets.buffer : null;\n  }\n\n  get values() {\n    return this._values ? this._values.buffer : null;\n  }\n\n  get nullBitmap() {\n    return this._nulls ? this._nulls.buffer : null;\n  }\n\n  get typeIds() {\n    return this._typeIds ? this._typeIds.buffer : null;\n  }\n  /**\n   * Appends a value (or null) to this `Builder`.\n   * This is equivalent to `builder.set(builder.length, value)`.\n   * @param {T['TValue'] | TNull } value The value to append.\n   */\n\n\n  append(value) {\n    return this.set(this.length, value);\n  }\n  /**\n   * Validates whether a value is valid (true), or null (false)\n   * @param {T['TValue'] | TNull } value The value to compare against null the value representations\n   */\n  // @ts-ignore\n\n\n  isValid(value) {\n    return this._isValid(value);\n  }\n  /**\n   * Write a value (or null-value sentinel) at the supplied index.\n   * If the value matches one of the null-value representations, a 1-bit is\n   * written to the null `BitmapBufferBuilder`. Otherwise, a 0 is written to\n   * the null `BitmapBufferBuilder`, and the value is passed to\n   * `Builder.prototype.setValue()`.\n   * @param {number} index The index of the value to write.\n   * @param {T['TValue'] | TNull } value The value to write at the supplied index.\n   * @returns {this} The updated `Builder` instance.\n   */\n\n\n  set(index, value) {\n    if (this.setValid(index, this.isValid(value))) {\n      this.setValue(index, value);\n    }\n\n    return this;\n  }\n  /**\n   * Write a value to the underlying buffers at the supplied index, bypassing\n   * the null-value check. This is a low-level method that\n   * @param {number} index\n   * @param {T['TValue'] | TNull } value\n   */\n  // @ts-ignore\n\n\n  setValue(index, value) {\n    this._setValue(this, index, value);\n  }\n\n  setValid(index, valid) {\n    this.length = this._nulls.set(index, +valid).length;\n    return valid;\n  } // @ts-ignore\n\n\n  addChild(child, name = `${this.numChildren}`) {\n    throw new Error(`Cannot append children to non-nested type \"${this.type}\"`);\n  }\n  /**\n   * Retrieve the child `Builder` at the supplied `index`, or null if no child\n   * exists at that index.\n   * @param {number} index The index of the child `Builder` to retrieve.\n   * @returns {Builder | null} The child Builder at the supplied index or null.\n   */\n\n\n  getChildAt(index) {\n    return this.children[index] || null;\n  }\n  /**\n   * Commit all the values that have been written to their underlying\n   * ArrayBuffers, including any child Builders if applicable, and reset\n   * the internal `Builder` state.\n   * @returns A `Data<T>` of the buffers and childData representing the values written.\n   */\n\n\n  flush() {\n    const buffers = [];\n    const values = this._values;\n    const offsets = this._offsets;\n    const typeIds = this._typeIds;\n    const {\n      length,\n      nullCount\n    } = this;\n\n    if (typeIds) {\n      /* Unions */\n      buffers[BufferType.TYPE] = typeIds.flush(length); // DenseUnions\n\n      offsets && (buffers[BufferType.OFFSET] = offsets.flush(length));\n    } else if (offsets) {\n      /* Variable-width primitives (Binary, Utf8) and Lists */\n      // Binary, Utf8\n      values && (buffers[BufferType.DATA] = values.flush(offsets.last()));\n      buffers[BufferType.OFFSET] = offsets.flush(length);\n    } else if (values) {\n      /* Fixed-width primitives (Int, Float, Decimal, Time, Timestamp, and Interval) */\n      buffers[BufferType.DATA] = values.flush(length);\n    }\n\n    nullCount > 0 && (buffers[BufferType.VALIDITY] = this._nulls.flush(length));\n    const data = Data.new(this.type, 0, length, nullCount, buffers, this.children.map(child => child.flush()));\n    this.clear();\n    return data;\n  }\n  /**\n   * Finalize this `Builder`, and child builders if applicable.\n   * @returns {this} The finalized `Builder` instance.\n   */\n\n\n  finish() {\n    this.finished = true;\n    this.children.forEach(child => child.finish());\n    return this;\n  }\n  /**\n   * Clear this Builder's internal state, including child Builders if applicable, and reset the length to 0.\n   * @returns {this} The cleared `Builder` instance.\n   */\n\n\n  clear() {\n    this.length = 0;\n    this._offsets && this._offsets.clear();\n    this._values && this._values.clear();\n    this._nulls && this._nulls.clear();\n    this._typeIds && this._typeIds.clear();\n    this.children.forEach(child => child.clear());\n    return this;\n  }\n\n}\nBuilder.prototype.length = 1;\nBuilder.prototype.stride = 1;\nBuilder.prototype.children = null;\nBuilder.prototype.finished = false;\nBuilder.prototype.nullValues = null;\n\nBuilder.prototype._isValid = () => true;\n/** @ignore */\n\n\nexport class FixedWidthBuilder extends Builder {\n  constructor(opts) {\n    super(opts);\n    this._values = new DataBufferBuilder(new this.ArrayType(0), this.stride);\n  }\n\n  setValue(index, value) {\n    const values = this._values;\n    values.reserve(index - values.length + 1);\n    return super.setValue(index, value);\n  }\n\n}\n/** @ignore */\n\nexport class VariableWidthBuilder extends Builder {\n  constructor(opts) {\n    super(opts);\n    this._pendingLength = 0;\n    this._offsets = new OffsetsBufferBuilder();\n  }\n\n  setValue(index, value) {\n    const pending = this._pending || (this._pending = new Map());\n    const current = pending.get(index);\n    current && (this._pendingLength -= current.length);\n    this._pendingLength += value.length;\n    pending.set(index, value);\n  }\n\n  setValid(index, isValid) {\n    if (!super.setValid(index, isValid)) {\n      (this._pending || (this._pending = new Map())).set(index, undefined);\n      return false;\n    }\n\n    return true;\n  }\n\n  clear() {\n    this._pendingLength = 0;\n    this._pending = undefined;\n    return super.clear();\n  }\n\n  flush() {\n    this._flush();\n\n    return super.flush();\n  }\n\n  finish() {\n    this._flush();\n\n    return super.finish();\n  }\n\n  _flush() {\n    const pending = this._pending;\n    const pendingLength = this._pendingLength;\n    this._pendingLength = 0;\n    this._pending = undefined;\n\n    if (pending && pending.size > 0) {\n      this._flushPending(pending, pendingLength);\n    }\n\n    return this;\n  }\n\n}\n/** @ignore */\n\nfunction throughIterable(options) {\n  const {\n    ['queueingStrategy']: queueingStrategy = 'count'\n  } = options;\n  const {\n    ['highWaterMark']: highWaterMark = queueingStrategy !== 'bytes' ? 1000 : 2 ** 14\n  } = options;\n  const sizeProperty = queueingStrategy !== 'bytes' ? 'length' : 'byteLength';\n  return function* (source) {\n    let numChunks = 0;\n    let builder = Builder.new(options);\n\n    for (const value of source) {\n      if (builder.append(value)[sizeProperty] >= highWaterMark) {\n        ++numChunks && (yield builder.toVector());\n      }\n    }\n\n    if (builder.finish().length > 0 || numChunks === 0) {\n      yield builder.toVector();\n    }\n  };\n}\n/** @ignore */\n\n\nfunction throughAsyncIterable(options) {\n  const {\n    ['queueingStrategy']: queueingStrategy = 'count'\n  } = options;\n  const {\n    ['highWaterMark']: highWaterMark = queueingStrategy !== 'bytes' ? 1000 : 2 ** 14\n  } = options;\n  const sizeProperty = queueingStrategy !== 'bytes' ? 'length' : 'byteLength';\n  return async function* (source) {\n    let numChunks = 0;\n    let builder = Builder.new(options);\n\n    for await (const value of source) {\n      if (builder.append(value)[sizeProperty] >= highWaterMark) {\n        ++numChunks && (yield builder.toVector());\n      }\n    }\n\n    if (builder.finish().length > 0 || numChunks === 0) {\n      yield builder.toVector();\n    }\n  };\n}","map":{"version":3,"sources":["builder.ts"],"names":[],"mappings":"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","sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Vector } from './vector';\nimport { BufferType } from './enum';\nimport { Data, Buffers } from './data';\nimport { createIsValidFunction } from './builder/valid';\nimport { BuilderType as B, VectorType as V} from './interfaces';\nimport { BufferBuilder, BitmapBufferBuilder, DataBufferBuilder, OffsetsBufferBuilder } from './builder/buffer';\nimport {\n    DataType, strideForType,\n    Float, Int, Decimal, FixedSizeBinary,\n    Date_, Time, Timestamp, Interval,\n    Utf8, Binary, List, Map_\n} from './type';\n\n/**\n * A set of options required to create a `Builder` instance for a given `DataType`.\n * @see {@link Builder}\n */\nexport interface BuilderOptions<T extends DataType = any, TNull = any> {\n    type: T;\n    nullValues?: TNull[] | ReadonlyArray<TNull> | null;\n    children?: { [key: string]: BuilderOptions; } | BuilderOptions[];\n}\n\n/**\n * A set of options to create an Iterable or AsyncIterable `Builder` transform function.\n * @see {@link Builder.throughIterable}\n * @see {@link Builder.throughAsyncIterable}\n */\n\nexport interface IterableBuilderOptions<T extends DataType = any, TNull = any> extends BuilderOptions<T, TNull> {\n    highWaterMark?: number;\n    queueingStrategy?: 'bytes' | 'count';\n    dictionaryHashFunction?: (value: any) => string | number;\n    valueToChildTypeId?: (builder: Builder<T, TNull>, value: any, offset: number) => number;\n}\n\n/**\n * An abstract base class for types that construct Arrow Vectors from arbitrary JavaScript values.\n *\n * A `Builder` is responsible for writing arbitrary JavaScript values\n * to ArrayBuffers and/or child Builders according to the Arrow specification\n * for each DataType, creating or resizing the underlying ArrayBuffers as necessary.\n *\n * The `Builder` for each Arrow `DataType` handles converting and appending\n * values for a given `DataType`. The high-level {@link Builder.new `Builder.new()`} convenience\n * method creates the specific `Builder` subclass for the supplied `DataType`.\n *\n * Once created, `Builder` instances support both appending values to the end\n * of the `Builder`, and random-access writes to specific indices\n * (`Builder.prototype.append(value)` is a convenience method for\n * `builder.set(builder.length, value)`). Appending or setting values beyond the\n * Builder's current length may cause the builder to grow its underlying buffers\n * or child Builders (if applicable) to accommodate the new values.\n *\n * After enough values have been written to a `Builder`, `Builder.prototype.flush()`\n * will commit the values to the underlying ArrayBuffers (or child Builders). The\n * internal Builder state will be reset, and an instance of `Data<T>` is returned.\n * Alternatively, `Builder.prototype.toVector()` will flush the `Builder` and return\n * an instance of `Vector<T>` instead.\n *\n * When there are no more values to write, use `Builder.prototype.finish()` to\n * finalize the `Builder`. This does not reset the internal state, so it is\n * necessary to call `Builder.prototype.flush()` or `toVector()` one last time\n * if there are still values queued to be flushed.\n *\n * Note: calling `Builder.prototype.finish()` is required when using a `DictionaryBuilder`,\n * because this is when it flushes the values that have been enqueued in its internal\n * dictionary's `Builder`, and creates the `dictionaryVector` for the `Dictionary` `DataType`.\n *\n * ```ts\n * import { Builder, Utf8 } from 'apache-arrow';\n *\n * const utf8Builder = Builder.new({\n *     type: new Utf8(),\n *     nullValues: [null, 'n/a']\n * });\n *\n * utf8Builder\n *     .append('hello')\n *     .append('n/a')\n *     .append('world')\n *     .append(null);\n *\n * const utf8Vector = utf8Builder.finish().toVector();\n *\n * console.log(utf8Vector.toJSON());\n * // > [\"hello\", null, \"world\", null]\n * ```\n *\n * @typeparam T The `DataType` of this `Builder`.\n * @typeparam TNull The type(s) of values which will be considered null-value sentinels.\n */\nexport abstract class Builder<T extends DataType = any, TNull = any> {\n\n    /**\n     * Create a `Builder` instance based on the `type` property of the supplied `options` object.\n     * @param {BuilderOptions<T, TNull>} options An object with a required `DataType` instance\n     * and other optional parameters to be passed to the `Builder` subclass for the given `type`.\n     *\n     * @typeparam T The `DataType` of the `Builder` to create.\n     * @typeparam TNull The type(s) of values which will be considered null-value sentinels.\n     * @nocollapse\n     */\n    // @ts-ignore\n    public static new<T extends DataType = any, TNull = any>(options: BuilderOptions<T, TNull>): B<T, TNull> {}\n\n    /** @nocollapse */\n    // @ts-ignore\n    public static throughNode<T extends DataType = any, TNull = any>(options: import('./io/node/builder').BuilderDuplexOptions<T, TNull>): import('stream').Duplex {\n        throw new Error(`\"throughNode\" not available in this environment`);\n    }\n    /** @nocollapse */\n    // @ts-ignore\n    public static throughDOM<T extends DataType = any, TNull = any>(options: import('./io/whatwg/builder').BuilderTransformOptions<T, TNull>): import('./io/whatwg/builder').BuilderTransform<T, TNull> {\n        throw new Error(`\"throughDOM\" not available in this environment`);\n    }\n\n    /**\n     * Transform a synchronous `Iterable` of arbitrary JavaScript values into a\n     * sequence of Arrow Vector<T> following the chunking semantics defined in\n     * the supplied `options` argument.\n     *\n     * This function returns a function that accepts an `Iterable` of values to\n     * transform. When called, this function returns an Iterator of `Vector<T>`.\n     *\n     * The resulting `Iterator<Vector<T>>` yields Vectors based on the\n     * `queueingStrategy` and `highWaterMark` specified in the `options` argument.\n     *\n     * * If `queueingStrategy` is `\"count\"` (or omitted), The `Iterator<Vector<T>>`\n     *   will flush the underlying `Builder` (and yield a new `Vector<T>`) once the\n     *   Builder's `length` reaches or exceeds the supplied `highWaterMark`.\n     * * If `queueingStrategy` is `\"bytes\"`, the `Iterator<Vector<T>>` will flush\n     *   the underlying `Builder` (and yield a new `Vector<T>`) once its `byteLength`\n     *   reaches or exceeds the supplied `highWaterMark`.\n     *\n     * @param {IterableBuilderOptions<T, TNull>} options An object of properties which determine the `Builder` to create and the chunking semantics to use.\n     * @returns A function which accepts a JavaScript `Iterable` of values to\n     *          write, and returns an `Iterator` that yields Vectors according\n     *          to the chunking semantics defined in the `options` argument.\n     * @nocollapse\n     */\n    public static throughIterable<T extends DataType = any, TNull = any>(options: IterableBuilderOptions<T, TNull>) {\n        return throughIterable(options);\n    }\n\n    /**\n     * Transform an `AsyncIterable` of arbitrary JavaScript values into a\n     * sequence of Arrow Vector<T> following the chunking semantics defined in\n     * the supplied `options` argument.\n     *\n     * This function returns a function that accepts an `AsyncIterable` of values to\n     * transform. When called, this function returns an AsyncIterator of `Vector<T>`.\n     *\n     * The resulting `AsyncIterator<Vector<T>>` yields Vectors based on the\n     * `queueingStrategy` and `highWaterMark` specified in the `options` argument.\n     *\n     * * If `queueingStrategy` is `\"count\"` (or omitted), The `AsyncIterator<Vector<T>>`\n     *   will flush the underlying `Builder` (and yield a new `Vector<T>`) once the\n     *   Builder's `length` reaches or exceeds the supplied `highWaterMark`.\n     * * If `queueingStrategy` is `\"bytes\"`, the `AsyncIterator<Vector<T>>` will flush\n     *   the underlying `Builder` (and yield a new `Vector<T>`) once its `byteLength`\n     *   reaches or exceeds the supplied `highWaterMark`.\n     *\n     * @param {IterableBuilderOptions<T, TNull>} options An object of properties which determine the `Builder` to create and the chunking semantics to use.\n     * @returns A function which accepts a JavaScript `AsyncIterable` of values\n     *          to write, and returns an `AsyncIterator` that yields Vectors\n     *          according to the chunking semantics defined in the `options`\n     *          argument.\n     * @nocollapse\n     */\n    public static throughAsyncIterable<T extends DataType = any, TNull = any>(options: IterableBuilderOptions<T, TNull>) {\n        return throughAsyncIterable(options);\n    }\n\n    /**\n     * Construct a builder with the given Arrow DataType with optional null values,\n     * which will be interpreted as \"null\" when set or appended to the `Builder`.\n     * @param {{ type: T, nullValues?: any[] }} options A `BuilderOptions` object used to create this `Builder`.\n     */\n    constructor({ 'type': type, 'nullValues': nulls }: BuilderOptions<T, TNull>) {\n        this.type = type;\n        this.children = [];\n        this.nullValues = nulls;\n        this.stride = strideForType(type);\n        this._nulls = new BitmapBufferBuilder();\n        if (nulls && nulls.length > 0) {\n            this._isValid = createIsValidFunction(nulls);\n        }\n    }\n\n    /**\n     * The Builder's `DataType` instance.\n     * @readonly\n     */\n    public type: T;\n    /**\n     * The number of values written to the `Builder` that haven't been flushed yet.\n     * @readonly\n     */\n    public length = 0;\n    /**\n     * A boolean indicating whether `Builder.prototype.finish()` has been called on this `Builder`.\n     * @readonly\n     */\n    public finished = false;\n    /**\n     * The number of elements in the underlying values TypedArray that\n     * represent a single logical element, determined by this Builder's\n     * `DataType`. This is 1 for most types, but is larger when the `DataType`\n     * is `Int64`, `Uint64`, `Decimal`, `DateMillisecond`, certain variants of\n     * `Interval`, `Time`, or `Timestamp`, `FixedSizeBinary`, and `FixedSizeList`.\n     * @readonly\n     */\n    public readonly stride: number;\n    public readonly children: Builder[];\n    /**\n     * The list of null-value sentinels for this `Builder`. When one of these values\n     * is written to the `Builder` (either via `Builder.prototype.set()` or `Builder.prototype.append()`),\n     * a 1-bit is written to this Builder's underlying null BitmapBufferBuilder.\n     * @readonly\n     */\n    public readonly nullValues?: TNull[] | ReadonlyArray<TNull> | null;\n\n    /**\n     * Flush the `Builder` and return a `Vector<T>`.\n     * @returns {Vector<T>} A `Vector<T>` of the flushed values.\n     */\n    public toVector() { return Vector.new(this.flush()); }\n\n    public get ArrayType() { return this.type.ArrayType; }\n    public get nullCount() { return this._nulls.numInvalid; }\n    public get numChildren() { return this.children.length; }\n\n    /**\n     * @returns The aggregate length (in bytes) of the values that have been written.\n     */\n    public get byteLength(): number {\n        let size = 0;\n        this._offsets && (size += this._offsets.byteLength);\n        this._values && (size += this._values.byteLength);\n        this._nulls && (size += this._nulls.byteLength);\n        this._typeIds && (size += this._typeIds.byteLength);\n        return this.children.reduce((size, child) => size + child.byteLength, size);\n    }\n\n    /**\n     * @returns The aggregate number of rows that have been reserved to write new values.\n     */\n    public get reservedLength(): number {\n        return this._nulls.reservedLength;\n    }\n\n    /**\n     * @returns The aggregate length (in bytes) that has been reserved to write new values.\n     */\n    public get reservedByteLength(): number {\n        let size = 0;\n        this._offsets && (size += this._offsets.reservedByteLength);\n        this._values && (size += this._values.reservedByteLength);\n        this._nulls && (size += this._nulls.reservedByteLength);\n        this._typeIds && (size += this._typeIds.reservedByteLength);\n        return this.children.reduce((size, child) => size + child.reservedByteLength, size);\n    }\n\n    // @ts-ignore\n    protected _offsets: DataBufferBuilder<Int32Array>;\n    public get valueOffsets() { return this._offsets ? this._offsets.buffer : null; }\n\n    // @ts-ignore\n    protected _values: BufferBuilder<T['TArray'], any>;\n    public get values() { return this._values ? this._values.buffer : null; }\n\n    protected _nulls: BitmapBufferBuilder;\n    public get nullBitmap() { return this._nulls ? this._nulls.buffer : null; }\n\n    // @ts-ignore\n    protected _typeIds: DataBufferBuilder<Int8Array>;\n    public get typeIds() { return this._typeIds ? this._typeIds.buffer : null; }\n\n    // @ts-ignore\n    protected _isValid: (value: T['TValue'] | TNull) => boolean;\n    // @ts-ignore\n    protected _setValue: (inst: Builder<T>, index: number, value: T['TValue']) => void;\n\n    /**\n     * Appends a value (or null) to this `Builder`.\n     * This is equivalent to `builder.set(builder.length, value)`.\n     * @param {T['TValue'] | TNull } value The value to append.\n     */\n    public append(value: T['TValue'] | TNull) { return this.set(this.length, value); }\n\n    /**\n     * Validates whether a value is valid (true), or null (false)\n     * @param {T['TValue'] | TNull } value The value to compare against null the value representations\n     */\n    // @ts-ignore\n    public isValid(value: T['TValue'] | TNull): boolean { return this._isValid(value); }\n\n    /**\n     * Write a value (or null-value sentinel) at the supplied index.\n     * If the value matches one of the null-value representations, a 1-bit is\n     * written to the null `BitmapBufferBuilder`. Otherwise, a 0 is written to\n     * the null `BitmapBufferBuilder`, and the value is passed to\n     * `Builder.prototype.setValue()`.\n     * @param {number} index The index of the value to write.\n     * @param {T['TValue'] | TNull } value The value to write at the supplied index.\n     * @returns {this} The updated `Builder` instance.\n     */\n    public set(index: number, value: T['TValue'] | TNull) {\n        if (this.setValid(index, this.isValid(value))) {\n            this.setValue(index, value);\n        }\n        return this;\n    }\n\n    /**\n     * Write a value to the underlying buffers at the supplied index, bypassing\n     * the null-value check. This is a low-level method that\n     * @param {number} index\n     * @param {T['TValue'] | TNull } value\n     */\n    // @ts-ignore\n    public setValue(index: number, value: T['TValue']) { this._setValue(this, index, value); }\n    public setValid(index: number, valid: boolean) {\n        this.length = this._nulls.set(index, +valid).length;\n        return valid;\n    }\n\n    // @ts-ignore\n    public addChild(child: Builder, name = `${this.numChildren}`) {\n        throw new Error(`Cannot append children to non-nested type \"${this.type}\"`);\n    }\n\n    /**\n     * Retrieve the child `Builder` at the supplied `index`, or null if no child\n     * exists at that index.\n     * @param {number} index The index of the child `Builder` to retrieve.\n     * @returns {Builder | null} The child Builder at the supplied index or null.\n     */\n    public getChildAt<R extends DataType = any>(index: number): Builder<R> | null {\n        return this.children[index] || null;\n    }\n\n    /**\n     * Commit all the values that have been written to their underlying\n     * ArrayBuffers, including any child Builders if applicable, and reset\n     * the internal `Builder` state.\n     * @returns A `Data<T>` of the buffers and childData representing the values written.\n     */\n    public flush() {\n\n        const buffers: any = [];\n        const values =  this._values;\n        const offsets =  this._offsets;\n        const typeIds =  this._typeIds;\n        const { length, nullCount } = this;\n\n        if (typeIds) { /* Unions */\n            buffers[BufferType.TYPE] = typeIds.flush(length);\n            // DenseUnions\n            offsets && (buffers[BufferType.OFFSET] = offsets.flush(length));\n        } else if (offsets) { /* Variable-width primitives (Binary, Utf8) and Lists */\n            // Binary, Utf8\n            values && (buffers[BufferType.DATA] = values.flush(offsets.last()));\n            buffers[BufferType.OFFSET] = offsets.flush(length);\n        } else if (values) { /* Fixed-width primitives (Int, Float, Decimal, Time, Timestamp, and Interval) */\n            buffers[BufferType.DATA] = values.flush(length);\n        }\n\n        nullCount > 0 && (buffers[BufferType.VALIDITY] = this._nulls.flush(length));\n\n        const data = Data.new<T>(\n            this.type, 0, length, nullCount, buffers as Buffers<T>,\n            this.children.map((child) => child.flush())) as Data<T>;\n\n        this.clear();\n\n        return data;\n    }\n\n    /**\n     * Finalize this `Builder`, and child builders if applicable.\n     * @returns {this} The finalized `Builder` instance.\n     */\n    public finish() {\n        this.finished = true;\n        this.children.forEach((child) => child.finish());\n        return this;\n    }\n\n    /**\n     * Clear this Builder's internal state, including child Builders if applicable, and reset the length to 0.\n     * @returns {this} The cleared `Builder` instance.\n     */\n    public clear() {\n        this.length = 0;\n        this._offsets && (this._offsets.clear());\n        this._values && (this._values.clear());\n        this._nulls && (this._nulls.clear());\n        this._typeIds && (this._typeIds.clear());\n        this.children.forEach((child) => child.clear());\n        return this;\n    }\n}\n\n(Builder.prototype as any).length = 1;\n(Builder.prototype as any).stride = 1;\n(Builder.prototype as any).children = null;\n(Builder.prototype as any).finished = false;\n(Builder.prototype as any).nullValues = null;\n(Builder.prototype as any)._isValid = () => true;\n\n/** @ignore */\nexport abstract class FixedWidthBuilder<T extends Int | Float | FixedSizeBinary | Date_ | Timestamp | Time | Decimal | Interval = any, TNull = any> extends Builder<T, TNull> {\n    constructor(opts: BuilderOptions<T, TNull>) {\n        super(opts);\n        this._values = new DataBufferBuilder(new this.ArrayType(0), this.stride);\n    }\n    public setValue(index: number, value: T['TValue']) {\n        const values = this._values;\n        values.reserve(index - values.length + 1);\n        return super.setValue(index, value);\n    }\n}\n\n/** @ignore */\nexport abstract class VariableWidthBuilder<T extends Binary | Utf8 | List | Map_, TNull = any> extends Builder<T, TNull> {\n    protected _pendingLength: number = 0;\n    protected _offsets: OffsetsBufferBuilder;\n    protected _pending: Map<number, any> | undefined;\n    constructor(opts: BuilderOptions<T, TNull>) {\n        super(opts);\n        this._offsets = new OffsetsBufferBuilder();\n    }\n    public setValue(index: number, value: T['TValue']) {\n        const pending = this._pending || (this._pending = new Map());\n        const current = pending.get(index);\n        current && (this._pendingLength -= current.length);\n        this._pendingLength += value.length;\n        pending.set(index, value);\n    }\n    public setValid(index: number, isValid: boolean) {\n        if (!super.setValid(index, isValid)) {\n            (this._pending || (this._pending = new Map())).set(index, undefined);\n            return false;\n        }\n        return true;\n    }\n    public clear() {\n        this._pendingLength = 0;\n        this._pending = undefined;\n        return super.clear();\n    }\n    public flush() {\n        this._flush();\n        return super.flush();\n    }\n    public finish() {\n        this._flush();\n        return super.finish();\n    }\n    protected _flush() {\n        const pending = this._pending;\n        const pendingLength = this._pendingLength;\n        this._pendingLength = 0;\n        this._pending = undefined;\n        if (pending && pending.size > 0) {\n            this._flushPending(pending, pendingLength);\n        }\n        return this;\n    }\n    protected abstract _flushPending(pending: Map<number, any>, pendingLength: number): void;\n}\n\n/** @ignore */\ntype ThroughIterable<T extends DataType = any, TNull = any> = (source: Iterable<T['TValue'] | TNull>) => IterableIterator<V<T>>;\n\n/** @ignore */\nfunction throughIterable<T extends DataType = any, TNull = any>(options: IterableBuilderOptions<T, TNull>): ThroughIterable<T, TNull> {\n    const { ['queueingStrategy']: queueingStrategy = 'count' } = options;\n    const { ['highWaterMark']: highWaterMark = queueingStrategy !== 'bytes' ? 1000 : 2 ** 14 } = options;\n    const sizeProperty: 'length' | 'byteLength' = queueingStrategy !== 'bytes' ? 'length' : 'byteLength';\n    return function*(source: Iterable<T['TValue'] | TNull>) {\n        let numChunks = 0;\n        let builder = Builder.new(options);\n        for (const value of source) {\n            if (builder.append(value)[sizeProperty] >= highWaterMark) {\n                ++numChunks && (yield builder.toVector());\n            }\n        }\n        if (builder.finish().length > 0 || numChunks === 0) {\n            yield builder.toVector();\n        }\n    };\n}\n\n/** @ignore */\ntype ThroughAsyncIterable<T extends DataType = any, TNull = any> = (source: Iterable<T['TValue'] | TNull> | AsyncIterable<T['TValue'] | TNull>) => AsyncIterableIterator<V<T>>;\n\n/** @ignore */\nfunction throughAsyncIterable<T extends DataType = any, TNull = any>(options: IterableBuilderOptions<T, TNull>): ThroughAsyncIterable<T, TNull> {\n    const { ['queueingStrategy']: queueingStrategy = 'count' } = options;\n    const { ['highWaterMark']: highWaterMark = queueingStrategy !== 'bytes' ? 1000 : 2 ** 14 } = options;\n    const sizeProperty: 'length' | 'byteLength' = queueingStrategy !== 'bytes' ? 'length' : 'byteLength';\n    return async function* (source: Iterable<T['TValue'] | TNull> | AsyncIterable<T['TValue'] | TNull>) {\n        let numChunks = 0;\n        let builder = Builder.new(options);\n        for await (const value of source) {\n            if (builder.append(value)[sizeProperty] >= highWaterMark) {\n                ++numChunks && (yield builder.toVector());\n            }\n        }\n        if (builder.finish().length > 0 || numChunks === 0) {\n            yield builder.toVector();\n        }\n    };\n}\n"]},"metadata":{},"sourceType":"module"}