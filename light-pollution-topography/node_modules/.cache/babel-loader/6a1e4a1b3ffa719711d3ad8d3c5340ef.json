{"ast":null,"code":"import _slicedToArray from \"/home/lsb/wikidatageo/dark-sky-vacations/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/home/lsb/wikidatageo/dark-sky-vacations/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/lsb/wikidatageo/dark-sky-vacations/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _getPrototypeOf from \"/home/lsb/wikidatageo/dark-sky-vacations/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"/home/lsb/wikidatageo/dark-sky-vacations/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _createSuper from \"/home/lsb/wikidatageo/dark-sky-vacations/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _inherits from \"/home/lsb/wikidatageo/dark-sky-vacations/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { Visitor } from '../visitor';\nimport { UnionMode } from '../enum';\nimport { RecordBatch } from '../recordbatch';\nimport { rebaseValueOffsets } from '../util/buffer';\nimport { packBools, truncateBitmap } from '../util/bit';\nimport { selectVectorChildrenArgs } from '../util/args';\nimport { BufferRegion, FieldNode } from '../ipc/metadata/message';\nimport { DataType } from '../type';\n/** @ignore */\n\nexport var VectorAssembler = /*#__PURE__*/function (_Visitor) {\n  _inherits(VectorAssembler, _Visitor);\n\n  var _super = _createSuper(VectorAssembler);\n\n  function VectorAssembler() {\n    var _this;\n\n    _classCallCheck(this, VectorAssembler);\n\n    _this = _super.call(this);\n    _this._byteLength = 0;\n    _this._nodes = [];\n    _this._buffers = [];\n    _this._bufferRegions = [];\n    return _this;\n  }\n  /** @nocollapse */\n\n\n  _createClass(VectorAssembler, [{\n    key: \"visit\",\n    value: function visit(vector) {\n      if (!DataType.isDictionary(vector.type)) {\n        var data = vector.data,\n            length = vector.length,\n            nullCount = vector.nullCount;\n\n        if (length > 2147483647) {\n          /* istanbul ignore next */\n          throw new RangeError('Cannot write arrays larger than 2^31 - 1 in length');\n        }\n\n        if (!DataType.isNull(vector.type)) {\n          addBuffer.call(this, nullCount <= 0 ? new Uint8Array(0) // placeholder validity buffer\n          : truncateBitmap(data.offset, length, data.nullBitmap));\n        }\n\n        this.nodes.push(new FieldNode(length, nullCount));\n      }\n\n      return _get(_getPrototypeOf(VectorAssembler.prototype), \"visit\", this).call(this, vector);\n    }\n  }, {\n    key: \"visitNull\",\n    value: function visitNull(_nullV) {\n      return this;\n    }\n  }, {\n    key: \"visitDictionary\",\n    value: function visitDictionary(vector) {\n      // Assemble the indices here, Dictionary assembled separately.\n      return this.visit(vector.indices);\n    }\n  }, {\n    key: \"nodes\",\n    get: function get() {\n      return this._nodes;\n    }\n  }, {\n    key: \"buffers\",\n    get: function get() {\n      return this._buffers;\n    }\n  }, {\n    key: \"byteLength\",\n    get: function get() {\n      return this._byteLength;\n    }\n  }, {\n    key: \"bufferRegions\",\n    get: function get() {\n      return this._bufferRegions;\n    }\n  }], [{\n    key: \"assemble\",\n    value: function assemble() {\n      var assembler = new VectorAssembler();\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var vectorChildren = selectVectorChildrenArgs(RecordBatch, args);\n\n      var _assembler$visitMany = assembler.visitMany(vectorChildren),\n          _assembler$visitMany2 = _slicedToArray(_assembler$visitMany, 1),\n          _assembler$visitMany3 = _assembler$visitMany2[0],\n          assembleResult = _assembler$visitMany3 === void 0 ? assembler : _assembler$visitMany3;\n\n      return assembleResult;\n    }\n  }]);\n\n  return VectorAssembler;\n}(Visitor);\n/** @ignore */\n\nfunction addBuffer(values) {\n  var byteLength = values.byteLength + 7 & ~7; // Round up to a multiple of 8\n\n  this.buffers.push(values);\n  this.bufferRegions.push(new BufferRegion(this._byteLength, byteLength));\n  this._byteLength += byteLength;\n  return this;\n}\n/** @ignore */\n\n\nfunction assembleUnion(vector) {\n  var type = vector.type,\n      length = vector.length,\n      typeIds = vector.typeIds,\n      valueOffsets = vector.valueOffsets; // All Union Vectors have a typeIds buffer\n\n  addBuffer.call(this, typeIds); // If this is a Sparse Union, treat it like all other Nested types\n\n  if (type.mode === UnionMode.Sparse) {\n    return assembleNestedVector.call(this, vector);\n  } else if (type.mode === UnionMode.Dense) {\n    // If this is a Dense Union, add the valueOffsets buffer and potentially slice the children\n    if (vector.offset <= 0) {\n      // If the Vector hasn't been sliced, write the existing valueOffsets\n      addBuffer.call(this, valueOffsets); // We can treat this like all other Nested types\n\n      return assembleNestedVector.call(this, vector);\n    } else {\n      // A sliced Dense Union is an unpleasant case. Because the offsets are different for\n      // each child vector, we need to \"rebase\" the valueOffsets for each child\n      // Union typeIds are not necessary 0-indexed\n      var maxChildTypeId = typeIds.reduce(function (x, y) {\n        return Math.max(x, y);\n      }, typeIds[0]);\n      var childLengths = new Int32Array(maxChildTypeId + 1); // Set all to -1 to indicate that we haven't observed a first occurrence of a particular child yet\n\n      var childOffsets = new Int32Array(maxChildTypeId + 1).fill(-1);\n      var shiftedOffsets = new Int32Array(length); // If we have a non-zero offset, then the value offsets do not start at\n      // zero. We must a) create a new offsets array with shifted offsets and\n      // b) slice the values array accordingly\n\n      var unshiftedOffsets = rebaseValueOffsets(-valueOffsets[0], length, valueOffsets);\n\n      for (var typeId, shift, index = -1; ++index < length;) {\n        if ((shift = childOffsets[typeId = typeIds[index]]) === -1) {\n          shift = childOffsets[typeId] = unshiftedOffsets[typeId];\n        }\n\n        shiftedOffsets[index] = unshiftedOffsets[index] - shift;\n        ++childLengths[typeId];\n      }\n\n      addBuffer.call(this, shiftedOffsets); // Slice and visit children accordingly\n\n      for (var child, childIndex = -1, numChildren = type.children.length; ++childIndex < numChildren;) {\n        if (child = vector.getChildAt(childIndex)) {\n          var _typeId = type.typeIds[childIndex];\n          var childLength = Math.min(length, childLengths[_typeId]);\n          this.visit(child.slice(childOffsets[_typeId], childLength));\n        }\n      }\n    }\n  }\n\n  return this;\n}\n/** @ignore */\n\n\nfunction assembleBoolVector(vector) {\n  // Bool vector is a special case of FlatVector, as its data buffer needs to stay packed\n  var values;\n\n  if (vector.nullCount >= vector.length) {\n    // If all values are null, just insert a placeholder empty data buffer (fastest path)\n    return addBuffer.call(this, new Uint8Array(0));\n  } else if ((values = vector.values) instanceof Uint8Array) {\n    // If values is already a Uint8Array, slice the bitmap (fast path)\n    return addBuffer.call(this, truncateBitmap(vector.offset, vector.length, values));\n  } // Otherwise if the underlying data *isn't* a Uint8Array, enumerate the\n  // values as bools and re-pack them into a Uint8Array. This code isn't\n  // reachable unless you're trying to manipulate the Data internals,\n  // we we're only doing this for safety.\n\n  /* istanbul ignore next */\n\n\n  return addBuffer.call(this, packBools(vector));\n}\n/** @ignore */\n\n\nfunction assembleFlatVector(vector) {\n  return addBuffer.call(this, vector.values.subarray(0, vector.length * vector.stride));\n}\n/** @ignore */\n\n\nfunction assembleFlatListVector(vector) {\n  var length = vector.length,\n      values = vector.values,\n      valueOffsets = vector.valueOffsets;\n  var firstOffset = valueOffsets[0];\n  var lastOffset = valueOffsets[length];\n  var byteLength = Math.min(lastOffset - firstOffset, values.byteLength - firstOffset); // Push in the order FlatList types read their buffers\n\n  addBuffer.call(this, rebaseValueOffsets(-valueOffsets[0], length, valueOffsets)); // valueOffsets buffer first\n\n  addBuffer.call(this, values.subarray(firstOffset, firstOffset + byteLength)); // sliced values buffer second\n\n  return this;\n}\n/** @ignore */\n\n\nfunction assembleListVector(vector) {\n  var length = vector.length,\n      valueOffsets = vector.valueOffsets; // If we have valueOffsets (MapVector, ListVector), push that buffer first\n\n  if (valueOffsets) {\n    addBuffer.call(this, rebaseValueOffsets(valueOffsets[0], length, valueOffsets));\n  } // Then insert the List's values child\n\n\n  return this.visit(vector.getChildAt(0));\n}\n/** @ignore */\n\n\nfunction assembleNestedVector(vector) {\n  return this.visitMany(vector.type.children.map(function (_, i) {\n    return vector.getChildAt(i);\n  }).filter(Boolean))[0];\n}\n\nVectorAssembler.prototype.visitBool = assembleBoolVector;\nVectorAssembler.prototype.visitInt = assembleFlatVector;\nVectorAssembler.prototype.visitFloat = assembleFlatVector;\nVectorAssembler.prototype.visitUtf8 = assembleFlatListVector;\nVectorAssembler.prototype.visitBinary = assembleFlatListVector;\nVectorAssembler.prototype.visitFixedSizeBinary = assembleFlatVector;\nVectorAssembler.prototype.visitDate = assembleFlatVector;\nVectorAssembler.prototype.visitTimestamp = assembleFlatVector;\nVectorAssembler.prototype.visitTime = assembleFlatVector;\nVectorAssembler.prototype.visitDecimal = assembleFlatVector;\nVectorAssembler.prototype.visitList = assembleListVector;\nVectorAssembler.prototype.visitStruct = assembleNestedVector;\nVectorAssembler.prototype.visitUnion = assembleUnion;\nVectorAssembler.prototype.visitInterval = assembleFlatVector;\nVectorAssembler.prototype.visitFixedSizeList = assembleListVector;\nVectorAssembler.prototype.visitMap = assembleListVector;","map":{"version":3,"sources":["visitor/vectorassembler.ts"],"names":[],"mappings":"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","sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Data } from '../data';\nimport { Vector } from '../vector';\nimport { Visitor } from '../visitor';\nimport { Type, UnionMode } from '../enum';\nimport { RecordBatch } from '../recordbatch';\nimport { VectorType as V } from '../interfaces';\nimport { rebaseValueOffsets } from '../util/buffer';\nimport { packBools, truncateBitmap } from '../util/bit';\nimport { selectVectorChildrenArgs } from '../util/args';\nimport { BufferRegion, FieldNode } from '../ipc/metadata/message';\nimport {\n    DataType, Dictionary,\n    Float, Int, Date_, Interval, Time, Timestamp, Union,\n    Bool, Null, Utf8, Binary, Decimal, FixedSizeBinary, List, FixedSizeList, Map_, Struct,\n} from '../type';\n\n/** @ignore */\nexport interface VectorAssembler extends Visitor {\n    visit<T extends Vector>(node: T): this;\n    visitMany<T extends Vector>(nodes: T[]): this[];\n    getVisitFn<T extends Type>(node: T): (vector: V<T>) => this;\n    getVisitFn<T extends DataType>(node: V<T> | Data<T> | T): (vector: V<T>) => this;\n\n    visitBool                 <T extends Bool>            (vector: V<T>): this;\n    visitInt                  <T extends Int>             (vector: V<T>): this;\n    visitFloat                <T extends Float>           (vector: V<T>): this;\n    visitUtf8                 <T extends Utf8>            (vector: V<T>): this;\n    visitBinary               <T extends Binary>          (vector: V<T>): this;\n    visitFixedSizeBinary      <T extends FixedSizeBinary> (vector: V<T>): this;\n    visitDate                 <T extends Date_>           (vector: V<T>): this;\n    visitTimestamp            <T extends Timestamp>       (vector: V<T>): this;\n    visitTime                 <T extends Time>            (vector: V<T>): this;\n    visitDecimal              <T extends Decimal>         (vector: V<T>): this;\n    visitList                 <T extends List>            (vector: V<T>): this;\n    visitStruct               <T extends Struct>          (vector: V<T>): this;\n    visitUnion                <T extends Union>           (vector: V<T>): this;\n    visitInterval             <T extends Interval>        (vector: V<T>): this;\n    visitFixedSizeList        <T extends FixedSizeList>   (vector: V<T>): this;\n    visitMap                  <T extends Map_>            (vector: V<T>): this;\n}\n\n/** @ignore */\nexport class VectorAssembler extends Visitor {\n\n    /** @nocollapse */\n    public static assemble<T extends Vector | RecordBatch>(...args: (T | T[])[]) {\n        const assembler = new VectorAssembler();\n        const vectorChildren = selectVectorChildrenArgs(RecordBatch, args);\n        const [assembleResult = assembler] = assembler.visitMany(vectorChildren);\n        return assembleResult;\n    }\n\n    private constructor() { super(); }\n\n    public visit<T extends Vector>(vector: T): this {\n        if (!DataType.isDictionary(vector.type)) {\n            const { data, length, nullCount } = vector;\n            if (length > 2147483647) {\n                /* istanbul ignore next */\n                throw new RangeError('Cannot write arrays larger than 2^31 - 1 in length');\n            }\n            if (!DataType.isNull(vector.type)) {\n                addBuffer.call(this, nullCount <= 0\n                    ? new Uint8Array(0) // placeholder validity buffer\n                    : truncateBitmap(data.offset, length, data.nullBitmap)\n                );\n            }\n            this.nodes.push(new FieldNode(length, nullCount));\n        }\n        return super.visit(vector);\n    }\n\n    public visitNull<T extends Null>(_nullV: V<T>) {\n        return this;\n    }\n    public visitDictionary<T extends Dictionary>(vector: V<T>) {\n        // Assemble the indices here, Dictionary assembled separately.\n        return this.visit(vector.indices);\n    }\n\n    public get nodes() { return this._nodes; }\n    public get buffers() { return this._buffers; }\n    public get byteLength() { return this._byteLength; }\n    public get bufferRegions() { return this._bufferRegions; }\n\n    protected _byteLength = 0;\n    protected _nodes: FieldNode[] = [];\n    protected _buffers: ArrayBufferView[] = [];\n    protected _bufferRegions: BufferRegion[] = [];\n}\n\n/** @ignore */\nfunction addBuffer(this: VectorAssembler, values: ArrayBufferView) {\n    const byteLength = (values.byteLength + 7) & ~7; // Round up to a multiple of 8\n    this.buffers.push(values);\n    this.bufferRegions.push(new BufferRegion(this._byteLength, byteLength));\n    this._byteLength += byteLength;\n    return this;\n}\n\n/** @ignore */\nfunction assembleUnion<T extends Union>(this: VectorAssembler, vector: V<T>) {\n    const { type, length, typeIds, valueOffsets } = vector;\n    // All Union Vectors have a typeIds buffer\n    addBuffer.call(this, typeIds);\n    // If this is a Sparse Union, treat it like all other Nested types\n    if (type.mode === UnionMode.Sparse) {\n        return assembleNestedVector.call(this, vector);\n    } else if (type.mode === UnionMode.Dense) {\n        // If this is a Dense Union, add the valueOffsets buffer and potentially slice the children\n        if (vector.offset <= 0) {\n            // If the Vector hasn't been sliced, write the existing valueOffsets\n            addBuffer.call(this, valueOffsets);\n            // We can treat this like all other Nested types\n            return assembleNestedVector.call(this, vector);\n        } else {\n            // A sliced Dense Union is an unpleasant case. Because the offsets are different for\n            // each child vector, we need to \"rebase\" the valueOffsets for each child\n            // Union typeIds are not necessary 0-indexed\n            const maxChildTypeId = typeIds.reduce((x, y) => Math.max(x, y), typeIds[0]);\n            const childLengths = new Int32Array(maxChildTypeId + 1);\n            // Set all to -1 to indicate that we haven't observed a first occurrence of a particular child yet\n            const childOffsets = new Int32Array(maxChildTypeId + 1).fill(-1);\n            const shiftedOffsets = new Int32Array(length);\n            // If we have a non-zero offset, then the value offsets do not start at\n            // zero. We must a) create a new offsets array with shifted offsets and\n            // b) slice the values array accordingly\n            const unshiftedOffsets = rebaseValueOffsets(-valueOffsets[0], length, valueOffsets);\n            for (let typeId, shift, index = -1; ++index < length;) {\n                if ((shift = childOffsets[typeId = typeIds[index]]) === -1) {\n                    shift = childOffsets[typeId] = unshiftedOffsets[typeId];\n                }\n                shiftedOffsets[index] = unshiftedOffsets[index] - shift;\n                ++childLengths[typeId];\n            }\n            addBuffer.call(this, shiftedOffsets);\n            // Slice and visit children accordingly\n            for (let child: Vector | null, childIndex = -1, numChildren = type.children.length; ++childIndex < numChildren;) {\n                if (child = vector.getChildAt(childIndex)) {\n                    const typeId = type.typeIds[childIndex];\n                    const childLength = Math.min(length, childLengths[typeId]);\n                    this.visit(child.slice(childOffsets[typeId], childLength));\n                }\n            }\n        }\n    }\n    return this;\n}\n\n/** @ignore */\nfunction assembleBoolVector<T extends Bool>(this: VectorAssembler, vector: V<T>) {\n    // Bool vector is a special case of FlatVector, as its data buffer needs to stay packed\n    let values: Uint8Array;\n    if (vector.nullCount >= vector.length) {\n        // If all values are null, just insert a placeholder empty data buffer (fastest path)\n        return addBuffer.call(this, new Uint8Array(0));\n    } else if ((values = vector.values) instanceof Uint8Array) {\n        // If values is already a Uint8Array, slice the bitmap (fast path)\n        return addBuffer.call(this, truncateBitmap(vector.offset, vector.length, values));\n    }\n    // Otherwise if the underlying data *isn't* a Uint8Array, enumerate the\n    // values as bools and re-pack them into a Uint8Array. This code isn't\n    // reachable unless you're trying to manipulate the Data internals,\n    // we we're only doing this for safety.\n    /* istanbul ignore next */\n    return addBuffer.call(this, packBools(vector));\n}\n\n/** @ignore */\nfunction assembleFlatVector<T extends Int | Float | FixedSizeBinary | Date_ | Timestamp | Time | Decimal | Interval>(this: VectorAssembler, vector: V<T>) {\n    return addBuffer.call(this, vector.values.subarray(0, vector.length * vector.stride));\n}\n\n/** @ignore */\nfunction assembleFlatListVector<T extends Utf8 | Binary>(this: VectorAssembler, vector: V<T>) {\n    const { length, values, valueOffsets } = vector;\n    const firstOffset = valueOffsets[0];\n    const lastOffset = valueOffsets[length];\n    const byteLength = Math.min(lastOffset - firstOffset, values.byteLength - firstOffset);\n    // Push in the order FlatList types read their buffers\n    addBuffer.call(this, rebaseValueOffsets(-valueOffsets[0], length, valueOffsets)); // valueOffsets buffer first\n    addBuffer.call(this, values.subarray(firstOffset, firstOffset + byteLength)); // sliced values buffer second\n    return this;\n}\n\n/** @ignore */\nfunction assembleListVector<T extends Map_ | List | FixedSizeList>(this: VectorAssembler, vector: V<T>) {\n    const { length, valueOffsets } = vector;\n    // If we have valueOffsets (MapVector, ListVector), push that buffer first\n    if (valueOffsets) {\n        addBuffer.call(this, rebaseValueOffsets(valueOffsets[0], length, valueOffsets));\n    }\n    // Then insert the List's values child\n    return this.visit(vector.getChildAt(0)!);\n}\n\n/** @ignore */\nfunction assembleNestedVector<T extends Struct | Union>(this: VectorAssembler, vector: V<T>) {\n    return this.visitMany(vector.type.children.map((_, i) => vector.getChildAt(i)!).filter(Boolean))[0];\n}\n\nVectorAssembler.prototype.visitBool            =     assembleBoolVector;\nVectorAssembler.prototype.visitInt             =     assembleFlatVector;\nVectorAssembler.prototype.visitFloat           =     assembleFlatVector;\nVectorAssembler.prototype.visitUtf8            = assembleFlatListVector;\nVectorAssembler.prototype.visitBinary          = assembleFlatListVector;\nVectorAssembler.prototype.visitFixedSizeBinary =     assembleFlatVector;\nVectorAssembler.prototype.visitDate            =     assembleFlatVector;\nVectorAssembler.prototype.visitTimestamp       =     assembleFlatVector;\nVectorAssembler.prototype.visitTime            =     assembleFlatVector;\nVectorAssembler.prototype.visitDecimal         =     assembleFlatVector;\nVectorAssembler.prototype.visitList            =     assembleListVector;\nVectorAssembler.prototype.visitStruct          =   assembleNestedVector;\nVectorAssembler.prototype.visitUnion           =          assembleUnion;\nVectorAssembler.prototype.visitInterval        =     assembleFlatVector;\nVectorAssembler.prototype.visitFixedSizeList   =     assembleListVector;\nVectorAssembler.prototype.visitMap             =     assembleListVector;\n"]},"metadata":{},"sourceType":"module"}