{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { mimeTypeMap } from './binary-image-parsers';\nvar ERR_INVALID_MIME_TYPE = \"Invalid MIME type. Supported MIME types are: \".concat(Array.from(mimeTypeMap.keys()).join(', '));\nexport function isBinaryImage(arrayBuffer, mimeType) {\n  if (mimeType) {\n    var _getBinaryImageTypeHa = getBinaryImageTypeHandlers(mimeType),\n        test = _getBinaryImageTypeHa.test;\n\n    var dataView = toDataView(arrayBuffer);\n    return test(dataView);\n  }\n\n  return Boolean(getBinaryImageMIMEType(arrayBuffer));\n}\nexport function getBinaryImageMIMEType(arrayBuffer) {\n  var dataView = toDataView(arrayBuffer);\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = mimeTypeMap.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _step$value = _slicedToArray(_step.value, 2),\n          mimeType = _step$value[0],\n          test = _step$value[1].test;\n\n      if (test(dataView)) {\n        return mimeType;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return null;\n}\nexport function getBinaryImageSize(arrayBuffer) {\n  var mimeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  mimeType = mimeType || getBinaryImageMIMEType(arrayBuffer);\n\n  var _getBinaryImageTypeHa2 = getBinaryImageTypeHandlers(mimeType),\n      getSize = _getBinaryImageTypeHa2.getSize;\n\n  var dataView = toDataView(arrayBuffer);\n  var size = getSize(dataView);\n\n  if (!size) {\n    throw new Error(\"invalid image data for type: \".concat(mimeType));\n  }\n\n  return size;\n}\n\nfunction getBinaryImageTypeHandlers(mimeType) {\n  var handlers = mimeTypeMap.get(mimeType);\n\n  if (!handlers) {\n    throw new Error(ERR_INVALID_MIME_TYPE);\n  }\n\n  return handlers;\n}\n\nfunction toDataView(data) {\n  data = data.buffer || data;\n\n  if (data instanceof ArrayBuffer) {\n    return new DataView(data);\n  }\n\n  if (ArrayBuffer.isView(data)) {\n    return new DataView(data.buffer);\n  }\n\n  throw new Error('toDataView');\n}","map":{"version":3,"sources":["../../../../src/lib/binary-image-api/binary-image-api.js"],"names":["ERR_INVALID_MIME_TYPE","Array","mimeTypeMap","test","getBinaryImageTypeHandlers","dataView","toDataView","Boolean","getBinaryImageMIMEType","mimeType","getSize","size","handlers","data","ArrayBuffer"],"mappings":"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","sourcesContent":["// Attributions\n// * Based on binary-gltf-utils under MIT license: Copyright (c) 2016-17 Karl Cheng\n\n// TODO: make these functions work for Node.js buffers?\n// Quarantine references to Buffer to prevent bundler from adding big polyfills\n// import {bufferToArrayBuffer} from '../node/buffer-to-array-buffer';\n// TODO - this should be handled in @loaders.gl/polyfills\n\nimport {mimeTypeMap} from './binary-image-parsers';\n\nconst ERR_INVALID_MIME_TYPE = `Invalid MIME type. Supported MIME types are: ${Array.from(\n  mimeTypeMap.keys()\n).join(', ')}`;\n\n// Supported image types are PNG, JPEG, GIF and BMP.\nexport function isBinaryImage(arrayBuffer, mimeType) {\n  if (mimeType) {\n    const {test} = getBinaryImageTypeHandlers(mimeType);\n    const dataView = toDataView(arrayBuffer);\n    return test(dataView);\n  }\n  // check if known type\n  return Boolean(getBinaryImageMIMEType(arrayBuffer));\n}\n\n// Sniffs the contents of a file to attempt to deduce the image type\nexport function getBinaryImageMIMEType(arrayBuffer) {\n  const dataView = toDataView(arrayBuffer);\n\n  // Loop through each file type and see if they work.\n  for (const [mimeType, {test}] of mimeTypeMap.entries()) {\n    if (test(dataView)) {\n      return mimeType;\n    }\n  }\n\n  return null;\n}\n\nexport function getBinaryImageSize(arrayBuffer, mimeType = null) {\n  mimeType = mimeType || getBinaryImageMIMEType(arrayBuffer);\n\n  const {getSize} = getBinaryImageTypeHandlers(mimeType);\n\n  const dataView = toDataView(arrayBuffer);\n  const size = getSize(dataView);\n\n  if (!size) {\n    throw new Error(`invalid image data for type: ${mimeType}`);\n  }\n\n  return size;\n}\n\nfunction getBinaryImageTypeHandlers(mimeType) {\n  const handlers = mimeTypeMap.get(mimeType);\n  if (!handlers) {\n    throw new Error(ERR_INVALID_MIME_TYPE);\n  }\n  return handlers;\n}\n\nfunction toDataView(data) {\n  data = data.buffer || data;\n  // TODO: make these functions work for Node.js buffers?\n  // if (bufferToArrayBuffer) {\n  //   data = bufferToArrayBuffer(data);\n  // }\n\n  // Careful - Node Buffers will look like ArrayBuffers (keep after isBuffer)\n  if (data instanceof ArrayBuffer) {\n    return new DataView(data);\n  }\n  if (ArrayBuffer.isView(data)) {\n    return new DataView(data.buffer);\n  }\n  throw new Error('toDataView');\n}\n"]},"metadata":{},"sourceType":"module"}