{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { formatValue, equals as _equals, config } from '../lib/common';\nimport { degrees, radians, clamp } from '../lib/common';\nimport Vector3 from './vector3';\nimport * as vec3 from 'gl-matrix/vec3';\nvar EPSILON = 0.000001;\nvar EARTH_RADIUS_METERS = 6.371e6;\n\nvar SphericalCoordinates = function () {\n  function SphericalCoordinates() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        phi = _ref.phi,\n        theta = _ref.theta,\n        radius = _ref.radius,\n        bearing = _ref.bearing,\n        pitch = _ref.pitch,\n        altitude = _ref.altitude,\n        _ref$radiusScale = _ref.radiusScale,\n        radiusScale = _ref$radiusScale === void 0 ? EARTH_RADIUS_METERS : _ref$radiusScale;\n\n    _classCallCheck(this, SphericalCoordinates);\n\n    if (arguments.length === 0) {\n      this.phi = 0;\n      this.theta = 0;\n      this.radius = 1;\n    } else if (Number.isFinite(phi) || Number.isFinite(theta)) {\n      this.phi = phi || 0;\n      this.theta = theta || 0;\n    } else if (Number.isFinite(bearing) || Number.isFinite(pitch)) {\n      this.bearing = bearing || 0;\n      this.pitch = pitch || 0;\n    }\n\n    this.radius = radius || 1;\n    this.radiusScale = radiusScale || 1;\n    this.check();\n  }\n\n  _createClass(SphericalCoordinates, [{\n    key: \"toString\",\n    value: function toString() {\n      return this.formatString(config);\n    }\n  }, {\n    key: \"formatString\",\n    value: function formatString(_ref2) {\n      var printTypes = _ref2.printTypes,\n          printDegrees = _ref2.printDegrees;\n      var f = formatValue;\n      return \"\".concat(printTypes ? 'Spherical' : '', \"[rho:\").concat(f(this.radius), \",theta:\").concat(f(this.theta), \",phi:\").concat(f(this.phi), \"]\");\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return _equals(this.radius, other.radius) && _equals(this.theta, other.theta) && _equals(this.phi, other.phi);\n    }\n  }, {\n    key: \"exactEquals\",\n    value: function exactEquals(other) {\n      return this.radius === other.radius && this.theta === other.theta && this.phi === other.phi;\n    }\n  }, {\n    key: \"set\",\n    value: function set(radius, phi, theta) {\n      this.radius = radius;\n      this.phi = phi;\n      this.theta = theta;\n      return this.check();\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(other) {\n      this.radius = other.radius;\n      this.phi = other.phi;\n      this.theta = other.theta;\n      return this.check();\n    }\n  }, {\n    key: \"fromLngLatZ\",\n    value: function fromLngLatZ(_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 3),\n          lng = _ref4[0],\n          lat = _ref4[1],\n          z = _ref4[2];\n\n      this.radius = 1 + z / this.radiusScale;\n      this.phi = radians(lat);\n      this.theta = radians(lng);\n    }\n  }, {\n    key: \"fromVector3\",\n    value: function fromVector3(v) {\n      this.radius = vec3.length(v);\n\n      if (this.radius > 0) {\n        this.theta = Math.atan2(v[0], v[1]);\n        this.phi = Math.acos(clamp(v[2] / this.radius, -1, 1));\n      }\n\n      return this.check();\n    }\n  }, {\n    key: \"toVector3\",\n    value: function toVector3() {\n      return new Vector3(0, 0, this.radius).rotateX({\n        radians: this.theta\n      }).rotateZ({\n        radians: this.phi\n      });\n    }\n  }, {\n    key: \"makeSafe\",\n    value: function makeSafe() {\n      this.phi = Math.max(EPSILON, Math.min(Math.PI - EPSILON, this.phi));\n    }\n  }, {\n    key: \"check\",\n    value: function check() {\n      if (!Number.isFinite(this.phi) || !Number.isFinite(this.theta) || !(this.radius > 0)) {\n        throw new Error('SphericalCoordinates: some fields set to invalid numbers');\n      }\n\n      return this;\n    }\n  }, {\n    key: \"bearing\",\n    get: function get() {\n      return 180 - degrees(this.phi);\n    },\n    set: function set(v) {\n      this.phi = Math.PI - radians(v);\n    }\n  }, {\n    key: \"pitch\",\n    get: function get() {\n      return degrees(this.theta);\n    },\n    set: function set(v) {\n      this.theta = radians(v);\n    }\n  }, {\n    key: \"longitude\",\n    get: function get() {\n      return degrees(this.phi);\n    }\n  }, {\n    key: \"latitude\",\n    get: function get() {\n      return degrees(this.theta);\n    }\n  }, {\n    key: \"lng\",\n    get: function get() {\n      return degrees(this.phi);\n    }\n  }, {\n    key: \"lat\",\n    get: function get() {\n      return degrees(this.theta);\n    }\n  }, {\n    key: \"z\",\n    get: function get() {\n      return (this.radius - 1) * this.radiusScale;\n    }\n  }]);\n\n  return SphericalCoordinates;\n}();\n\nexport { SphericalCoordinates as default };","map":{"version":3,"sources":["../../../src/classes/spherical-coordinates.js"],"names":["equals","EPSILON","EARTH_RADIUS_METERS","SphericalCoordinates","phi","theta","radius","bearing","pitch","altitude","radiusScale","arguments","Number","printTypes","printDegrees","f","other","degrees","v","Math","radians","lng","lat","z","vec3","clamp"],"mappings":"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","sourcesContent":["// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Adaptation of THREE.js Spherical class, under MIT license\nimport {formatValue, equals, config} from '../lib/common';\nimport {degrees, radians, clamp} from '../lib/common';\nimport Vector3 from './vector3';\n\nimport * as vec3 from 'gl-matrix/vec3';\n\n// TODO - import epsilon\nconst EPSILON = 0.000001;\n\nconst EARTH_RADIUS_METERS = 6.371e6;\n\n// Todo [rho, theta, phi] ?\nexport default class SphericalCoordinates {\n  /**\n   * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n   * The poles (phi) are at the positive and negative y axis.\n   * The equator starts at positive z.\n   * @class\n   * @param {Number} phi=0 - rotation around X (latitude)\n   * @param {Number} theta=0 - rotation around Y (longitude)\n   * @param {Number} radius=1 - Distance from center\n   */\n  /* eslint-disable complexity */\n  constructor({\n    phi,\n    theta,\n    radius,\n    bearing,\n    pitch,\n    altitude,\n    radiusScale = EARTH_RADIUS_METERS\n  } = {}) {\n    if (arguments.length === 0) {\n      this.phi = 0;\n      this.theta = 0;\n      this.radius = 1;\n    } else if (Number.isFinite(phi) || Number.isFinite(theta)) {\n      this.phi = phi || 0; // up / down towards top and bottom pole\n      this.theta = theta || 0; // around the equator of the sphere\n    } else if (Number.isFinite(bearing) || Number.isFinite(pitch)) {\n      this.bearing = bearing || 0; // up / down towards top and bottom pole\n      this.pitch = pitch || 0; // around the equator of the sphere\n    }\n    this.radius = radius || 1; // radial distance from center\n    this.radiusScale = radiusScale || 1; // Used by lngLatZ\n    this.check();\n  }\n  /* eslint-enable complexity */\n\n  toString() {\n    return this.formatString(config);\n  }\n\n  formatString({printTypes, printDegrees}) {\n    const f = formatValue;\n    return `${printTypes ? 'Spherical' : ''}\\\n[rho:${f(this.radius)},theta:${f(this.theta)},phi:${f(this.phi)}]`;\n  }\n\n  equals(other) {\n    return (\n      equals(this.radius, other.radius) &&\n      equals(this.theta, other.theta) &&\n      equals(this.phi, other.phi)\n    );\n  }\n\n  exactEquals(other) {\n    return this.radius === other.radius && this.theta === other.theta && this.phi === other.phi;\n  }\n\n  /* eslint-disable brace-style */\n  // Cartographic (bearing 0 north, pitch 0 look from above)\n  get bearing() {\n    return 180 - degrees(this.phi);\n  }\n  set bearing(v) {\n    this.phi = Math.PI - radians(v);\n  }\n  get pitch() {\n    return degrees(this.theta);\n  }\n  set pitch(v) {\n    this.theta = radians(v);\n  }\n  // get pitch() { return 90 - degrees(this.phi); }\n  // set pitch(v) { this.phi = radians(v) + Math.PI / 2; }\n  // get altitude() { return this.radius - 1; } // relative altitude\n\n  // lnglatZ coordinates\n  get longitude() {\n    return degrees(this.phi);\n  }\n  get latitude() {\n    return degrees(this.theta);\n  }\n  get lng() {\n    return degrees(this.phi);\n  }\n  get lat() {\n    return degrees(this.theta);\n  }\n  get z() {\n    return (this.radius - 1) * this.radiusScale;\n  }\n  /* eslint-enable brace-style */\n\n  set(radius, phi, theta) {\n    this.radius = radius;\n    this.phi = phi;\n    this.theta = theta;\n    return this.check();\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  copy(other) {\n    this.radius = other.radius;\n    this.phi = other.phi;\n    this.theta = other.theta;\n    return this.check();\n  }\n\n  fromLngLatZ([lng, lat, z]) {\n    this.radius = 1 + z / this.radiusScale;\n    this.phi = radians(lat);\n    this.theta = radians(lng);\n  }\n\n  fromVector3(v) {\n    this.radius = vec3.length(v);\n    if (this.radius > 0) {\n      this.theta = Math.atan2(v[0], v[1]); // equator angle around y-up axis\n      this.phi = Math.acos(clamp(v[2] / this.radius, -1, 1)); // polar angle\n    }\n    return this.check();\n  }\n\n  toVector3() {\n    return new Vector3(0, 0, this.radius)\n      .rotateX({radians: this.theta})\n      .rotateZ({radians: this.phi});\n  }\n\n  // restrict phi to be betwee EPS and PI-EPS\n  makeSafe() {\n    this.phi = Math.max(EPSILON, Math.min(Math.PI - EPSILON, this.phi));\n  }\n\n  check() {\n    // this.makeSafe();\n    if (!Number.isFinite(this.phi) || !Number.isFinite(this.theta) || !(this.radius > 0)) {\n      throw new Error('SphericalCoordinates: some fields set to invalid numbers');\n    }\n    return this;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}