{"ast":null,"code":"import _slicedToArray from \"/home/lsb/wikidatageo/dark-sky-vacations/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { Data } from '../data';\nimport { Field } from '../schema';\nimport { Column } from '../column';\nimport { Vector } from '../vector';\nimport { DataType } from '../type';\nimport { Chunked } from '../vector/chunked';\nvar isArray = Array.isArray;\n/** @ignore */\n\nexport var selectArgs = function selectArgs(Ctor, vals) {\n  return _selectArgs(Ctor, vals, [], 0);\n};\n/** @ignore */\n\nexport var selectColumnArgs = function selectColumnArgs(args) {\n  var _selectFieldArgs2 = _selectFieldArgs(args, [[], []]),\n      _selectFieldArgs3 = _slicedToArray(_selectFieldArgs2, 2),\n      fields = _selectFieldArgs3[0],\n      values = _selectFieldArgs3[1];\n\n  return values.map(function (x, i) {\n    return x instanceof Column ? Column.new(x.field.clone(fields[i]), x) : x instanceof Vector ? Column.new(fields[i], x) : Column.new(fields[i], []);\n  });\n};\n/** @ignore */\n\nexport var selectFieldArgs = function selectFieldArgs(args) {\n  return _selectFieldArgs(args, [[], []]);\n};\n/** @ignore */\n\nexport var selectChunkArgs = function selectChunkArgs(Ctor, vals) {\n  return _selectChunkArgs(Ctor, vals, [], 0);\n};\n/** @ignore */\n\nexport var selectVectorChildrenArgs = function selectVectorChildrenArgs(Ctor, vals) {\n  return _selectVectorChildrenArgs(Ctor, vals, [], 0);\n};\n/** @ignore */\n\nexport var selectColumnChildrenArgs = function selectColumnChildrenArgs(Ctor, vals) {\n  return _selectColumnChildrenArgs(Ctor, vals, [], 0);\n};\n/** @ignore */\n\nfunction _selectArgs(Ctor, vals, res, idx) {\n  var value,\n      j = idx;\n  var i = -1,\n      n = vals.length;\n\n  while (++i < n) {\n    if (isArray(value = vals[i])) {\n      j = _selectArgs(Ctor, value, res, j).length;\n    } else if (value instanceof Ctor) {\n      res[j++] = value;\n    }\n  }\n\n  return res;\n}\n/** @ignore */\n\n\nfunction _selectChunkArgs(Ctor, vals, res, idx) {\n  var value,\n      j = idx;\n  var i = -1,\n      n = vals.length;\n\n  while (++i < n) {\n    if (isArray(value = vals[i])) {\n      j = _selectChunkArgs(Ctor, value, res, j).length;\n    } else if (value instanceof Chunked) {\n      j = _selectChunkArgs(Ctor, value.chunks, res, j).length;\n    } else if (value instanceof Ctor) {\n      res[j++] = value;\n    }\n  }\n\n  return res;\n}\n/** @ignore */\n\n\nfunction _selectVectorChildrenArgs(Ctor, vals, res, idx) {\n  var value,\n      j = idx;\n  var i = -1,\n      n = vals.length;\n\n  while (++i < n) {\n    if (isArray(value = vals[i])) {\n      j = _selectVectorChildrenArgs(Ctor, value, res, j).length;\n    } else if (value instanceof Ctor) {\n      j = _selectArgs(Vector, value.schema.fields.map(function (_, i) {\n        return value.getChildAt(i);\n      }), res, j).length;\n    } else if (value instanceof Vector) {\n      res[j++] = value;\n    }\n  }\n\n  return res;\n}\n/** @ignore */\n\n\nfunction _selectColumnChildrenArgs(Ctor, vals, res, idx) {\n  var value,\n      j = idx;\n  var i = -1,\n      n = vals.length;\n\n  while (++i < n) {\n    if (isArray(value = vals[i])) {\n      j = _selectColumnChildrenArgs(Ctor, value, res, j).length;\n    } else if (value instanceof Ctor) {\n      j = _selectArgs(Column, value.schema.fields.map(function (f, i) {\n        return Column.new(f, value.getChildAt(i));\n      }), res, j).length;\n    } else if (value instanceof Column) {\n      res[j++] = value;\n    }\n  }\n\n  return res;\n}\n/** @ignore */\n\n\nvar toKeysAndValues = function toKeysAndValues(xs, _ref, i) {\n  var _ref2 = _slicedToArray(_ref, 2),\n      k = _ref2[0],\n      v = _ref2[1];\n\n  return xs[0][i] = k, xs[1][i] = v, xs;\n};\n/** @ignore */\n\n\nfunction _selectFieldArgs(vals, ret) {\n  var keys, n;\n\n  switch (n = vals.length) {\n    case 0:\n      return ret;\n\n    case 1:\n      keys = ret[0];\n\n      if (!vals[0]) {\n        return ret;\n      }\n\n      if (isArray(vals[0])) {\n        return _selectFieldArgs(vals[0], ret);\n      }\n\n      if (!(vals[0] instanceof Data || vals[0] instanceof Vector || vals[0] instanceof DataType)) {\n        var _Object$entries$reduc = Object.entries(vals[0]).reduce(toKeysAndValues, ret);\n\n        var _Object$entries$reduc2 = _slicedToArray(_Object$entries$reduc, 2);\n\n        keys = _Object$entries$reduc2[0];\n        vals = _Object$entries$reduc2[1];\n      }\n\n      break;\n\n    default:\n      !isArray(keys = vals[n - 1]) ? (vals = isArray(vals[0]) ? vals[0] : vals, keys = []) : vals = isArray(vals[0]) ? vals[0] : vals.slice(0, n - 1);\n  }\n\n  var fieldIndex = -1;\n  var valueIndex = -1;\n  var idx = -1,\n      len = vals.length;\n  var field;\n  var val;\n\n  var _ret = _slicedToArray(ret, 2),\n      fields = _ret[0],\n      values = _ret[1];\n\n  while (++idx < len) {\n    val = vals[idx];\n\n    if (val instanceof Column && (values[++valueIndex] = val)) {\n      fields[++fieldIndex] = val.field.clone(keys[idx], val.type, true);\n    } else {\n      var _keys = keys;\n      var _keys$idx = _keys[idx];\n      field = _keys$idx === void 0 ? idx : _keys$idx;\n\n      if (val instanceof DataType && (values[++valueIndex] = val)) {\n        fields[++fieldIndex] = Field.new(field, val, true);\n      } else if (val && val.type && (values[++valueIndex] = val)) {\n        val instanceof Data && (values[valueIndex] = val = Vector.new(val));\n        fields[++fieldIndex] = Field.new(field, val.type, true);\n      }\n    }\n  }\n\n  return ret;\n}","map":{"version":3,"sources":["util/args.ts"],"names":[],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAAS,IAAT,QAAqB,SAArB;AACA,SAAS,KAAT,QAAsB,WAAtB;AACA,SAAS,MAAT,QAAuB,WAAvB;AACA,SAAS,MAAT,QAAuB,WAAvB;AACA,SAAS,QAAT,QAAyB,SAAzB;AACA,SAAS,OAAT,QAAwB,mBAAxB;AAIA,IAAM,OAAO,GAAG,KAAK,CAAC,OAAtB;AAEA;;AACA,OAAO,IAAM,UAAU,GAAG,SAAb,UAAa,CAAI,IAAJ,EAAe,IAAf;AAAA,SAA+B,WAAW,CAAC,IAAD,EAAO,IAAP,EAAa,EAAb,EAAiB,CAAjB,CAA1C;AAAA,CAAnB;AACP;;AACA,OAAO,IAAM,gBAAgB,GAAG,SAAnB,gBAAmB,CAAwC,IAAxC,EAAuD;AAAA,0BAC1D,gBAAgB,CAAI,IAAJ,EAAU,CAAC,EAAD,EAAK,EAAL,CAAV,CAD0C;AAAA;AAAA,MAC5E,MAD4E;AAAA,MACpE,MADoE;;AAEnF,SAAO,MAAM,CAAC,GAAP,CAAW,UAAC,CAAD,EAAI,CAAJ;AAAA,WACd,CAAC,YAAY,MAAb,GAAsB,MAAM,CAAC,GAAP,CAAW,CAAC,CAAC,KAAF,CAAQ,KAAR,CAAc,MAAM,CAAC,CAAD,CAApB,CAAX,EAAqC,CAArC,CAAtB,GACA,CAAC,YAAY,MAAb,GAAsB,MAAM,CAAC,GAAP,CAAW,MAAM,CAAC,CAAD,CAAjB,EAAsB,CAAtB,CAAtB,GACsB,MAAM,CAAC,GAAP,CAAW,MAAM,CAAC,CAAD,CAAjB,EAAsB,EAAtB,CAHR;AAAA,GAAX,CAAP;AAIH,CANM;AAQP;;AACA,OAAO,IAAM,eAAe,GAAG,SAAlB,eAAkB,CAAwC,IAAxC;AAAA,SAAwD,gBAAgB,CAAI,IAAJ,EAAU,CAAC,EAAD,EAAK,EAAL,CAAV,CAAxE;AAAA,CAAxB;AACP;;AACA,OAAO,IAAM,eAAe,GAAG,SAAlB,eAAkB,CAAI,IAAJ,EAAe,IAAf;AAAA,SAA+B,gBAAgB,CAAC,IAAD,EAAO,IAAP,EAAa,EAAb,EAAiB,CAAjB,CAA/C;AAAA,CAAxB;AACP;;AACA,OAAO,IAAM,wBAAwB,GAAG,SAA3B,wBAA2B,CAAmB,IAAnB,EAA0C,IAA1C;AAAA,SAA0D,yBAAyB,CAAC,IAAD,EAAO,IAAP,EAAa,EAAb,EAAiB,CAAjB,CAAnF;AAAA,CAAjC;AACP;;AACA,OAAO,IAAM,wBAAwB,GAAG,SAA3B,wBAA2B,CAAmB,IAAnB,EAA0C,IAA1C;AAAA,SAA0D,yBAAyB,CAAC,IAAD,EAAO,IAAP,EAAa,EAAb,EAAiB,CAAjB,CAAnF;AAAA,CAAjC;AAEP;;AACA,SAAS,WAAT,CAAwB,IAAxB,EAAmC,IAAnC,EAAgD,GAAhD,EAA0D,GAA1D,EAAqE;AACjE,MAAI,KAAJ;AAAA,MAAgB,CAAC,GAAG,GAApB;AACA,MAAI,CAAC,GAAG,CAAC,CAAT;AAAA,MAAY,CAAC,GAAG,IAAI,CAAC,MAArB;;AACA,SAAO,EAAE,CAAF,GAAM,CAAb,EAAgB;AACZ,QAAI,OAAO,CAAC,KAAK,GAAG,IAAI,CAAC,CAAD,CAAb,CAAX,EAA8B;AAC1B,MAAA,CAAC,GAAG,WAAW,CAAC,IAAD,EAAO,KAAP,EAAc,GAAd,EAAmB,CAAnB,CAAX,CAAiC,MAArC;AACH,KAFD,MAEO,IAAI,KAAK,YAAY,IAArB,EAA2B;AAAE,MAAA,GAAG,CAAC,CAAC,EAAF,CAAH,GAAW,KAAX;AAAmB;AAC1D;;AACD,SAAO,GAAP;AACH;AAED;;;AACA,SAAS,gBAAT,CAA6B,IAA7B,EAAwC,IAAxC,EAAqD,GAArD,EAA+D,GAA/D,EAA0E;AACtE,MAAI,KAAJ;AAAA,MAAgB,CAAC,GAAG,GAApB;AACA,MAAI,CAAC,GAAG,CAAC,CAAT;AAAA,MAAY,CAAC,GAAG,IAAI,CAAC,MAArB;;AACA,SAAO,EAAE,CAAF,GAAM,CAAb,EAAgB;AACZ,QAAI,OAAO,CAAC,KAAK,GAAG,IAAI,CAAC,CAAD,CAAb,CAAX,EAA8B;AAC1B,MAAA,CAAC,GAAG,gBAAgB,CAAC,IAAD,EAAO,KAAP,EAAc,GAAd,EAAmB,CAAnB,CAAhB,CAAsC,MAA1C;AACH,KAFD,MAEO,IAAI,KAAK,YAAY,OAArB,EAA8B;AACjC,MAAA,CAAC,GAAG,gBAAgB,CAAC,IAAD,EAAO,KAAK,CAAC,MAAb,EAAqB,GAArB,EAA0B,CAA1B,CAAhB,CAA6C,MAAjD;AACH,KAFM,MAEA,IAAI,KAAK,YAAY,IAArB,EAA2B;AAAE,MAAA,GAAG,CAAC,CAAC,EAAF,CAAH,GAAW,KAAX;AAAmB;AAC1D;;AACD,SAAO,GAAP;AACH;AAED;;;AACA,SAAS,yBAAT,CAAqD,IAArD,EAA4E,IAA5E,EAAyF,GAAzF,EAAmG,GAAnG,EAA8G;AAC1G,MAAI,KAAJ;AAAA,MAAgB,CAAC,GAAG,GAApB;AACA,MAAI,CAAC,GAAG,CAAC,CAAT;AAAA,MAAY,CAAC,GAAG,IAAI,CAAC,MAArB;;AACA,SAAO,EAAE,CAAF,GAAM,CAAb,EAAgB;AACZ,QAAI,OAAO,CAAC,KAAK,GAAG,IAAI,CAAC,CAAD,CAAb,CAAX,EAA8B;AAC1B,MAAA,CAAC,GAAG,yBAAyB,CAAC,IAAD,EAAO,KAAP,EAAc,GAAd,EAAmB,CAAnB,CAAzB,CAA+C,MAAnD;AACH,KAFD,MAEO,IAAI,KAAK,YAAY,IAArB,EAA2B;AAC9B,MAAA,CAAC,GAAG,WAAW,CAAC,MAAD,EAAS,KAAK,CAAC,MAAN,CAAa,MAAb,CAAoB,GAApB,CAAwB,UAAC,CAAD,EAAI,CAAJ;AAAA,eAAU,KAAK,CAAC,UAAN,CAAiB,CAAjB,CAAV;AAAA,OAAxB,CAAT,EAAkE,GAAlE,EAAuE,CAAvE,CAAX,CAAqF,MAAzF;AACH,KAFM,MAEA,IAAI,KAAK,YAAY,MAArB,EAA6B;AAAE,MAAA,GAAG,CAAC,CAAC,EAAF,CAAH,GAAW,KAAX;AAAwB;AACjE;;AACD,SAAO,GAAP;AACH;AAED;;;AACA,SAAS,yBAAT,CAAqD,IAArD,EAA4E,IAA5E,EAAyF,GAAzF,EAAmG,GAAnG,EAA8G;AAC1G,MAAI,KAAJ;AAAA,MAAgB,CAAC,GAAG,GAApB;AACA,MAAI,CAAC,GAAG,CAAC,CAAT;AAAA,MAAY,CAAC,GAAG,IAAI,CAAC,MAArB;;AACA,SAAO,EAAE,CAAF,GAAM,CAAb,EAAgB;AACZ,QAAI,OAAO,CAAC,KAAK,GAAG,IAAI,CAAC,CAAD,CAAb,CAAX,EAA8B;AAC1B,MAAA,CAAC,GAAG,yBAAyB,CAAC,IAAD,EAAO,KAAP,EAAc,GAAd,EAAmB,CAAnB,CAAzB,CAA+C,MAAnD;AACH,KAFD,MAEO,IAAI,KAAK,YAAY,IAArB,EAA2B;AAC9B,MAAA,CAAC,GAAG,WAAW,CAAC,MAAD,EAAS,KAAK,CAAC,MAAN,CAAa,MAAb,CAAoB,GAApB,CAAwB,UAAC,CAAD,EAAI,CAAJ;AAAA,eAAU,MAAM,CAAC,GAAP,CAAW,CAAX,EAAc,KAAK,CAAC,UAAN,CAAiB,CAAjB,CAAd,CAAV;AAAA,OAAxB,CAAT,EAAiF,GAAjF,EAAsF,CAAtF,CAAX,CAAoG,MAAxG;AACH,KAFM,MAEA,IAAI,KAAK,YAAY,MAArB,EAA6B;AAAE,MAAA,GAAG,CAAC,CAAC,EAAF,CAAH,GAAW,KAAX;AAAwB;AACjE;;AACD,SAAO,GAAP;AACH;AAED;;;AACA,IAAM,eAAe,GAAG,SAAlB,eAAkB,CAAC,EAAD,QAAyC,CAAzC;AAAA;AAAA,MAAsB,CAAtB;AAAA,MAAyB,CAAzB;;AAAA,SAAwD,EAAE,CAAC,CAAD,CAAF,CAAM,CAAN,IAAW,CAAX,EAAc,EAAE,CAAC,CAAD,CAAF,CAAM,CAAN,IAAW,CAAzB,EAA4B,EAApF;AAAA,CAAxB;AAEA;;;AACA,SAAS,gBAAT,CAAiE,IAAjE,EAA8E,GAA9E,EAA8H;AAC1H,MAAI,IAAJ,EAAiB,CAAjB;;AACA,UAAQ,CAAC,GAAG,IAAI,CAAC,MAAjB;AACI,SAAK,CAAL;AAAQ,aAAO,GAAP;;AACR,SAAK,CAAL;AACI,MAAA,IAAI,GAAG,GAAG,CAAC,CAAD,CAAV;;AACA,UAAI,CAAE,IAAI,CAAC,CAAD,CAAV,EAAgB;AAAE,eAAO,GAAP;AAAa;;AAC/B,UAAI,OAAO,CAAC,IAAI,CAAC,CAAD,CAAL,CAAX,EAAsB;AAAE,eAAO,gBAAgB,CAAC,IAAI,CAAC,CAAD,CAAL,EAAU,GAAV,CAAvB;AAAwC;;AAChE,UAAI,EAAE,IAAI,CAAC,CAAD,CAAJ,YAAmB,IAAnB,IAA2B,IAAI,CAAC,CAAD,CAAJ,YAAmB,MAA9C,IAAwD,IAAI,CAAC,CAAD,CAAJ,YAAmB,QAA7E,CAAJ,EAA4F;AAAA,oCACzE,MAAM,CAAC,OAAP,CAAe,IAAI,CAAC,CAAD,CAAnB,EAAwB,MAAxB,CAA+B,eAA/B,EAAgD,GAAhD,CADyE;;AAAA;;AACvF,QAAA,IADuF;AACjF,QAAA,IADiF;AAE3F;;AACD;;AACJ;AACI,OAAC,OAAO,CAAC,IAAI,GAAG,IAAI,CAAC,CAAC,GAAG,CAAL,CAAZ,CAAR,IACO,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC,CAAD,CAAL,CAAP,GAAmB,IAAI,CAAC,CAAD,CAAvB,GAA6B,IAApC,EAA0C,IAAI,GAAG,EADxD,IAEO,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC,CAAD,CAAL,CAAP,GAAmB,IAAI,CAAC,CAAD,CAAvB,GAA6B,IAAI,CAAC,KAAL,CAAW,CAAX,EAAc,CAAC,GAAG,CAAlB,CAF3C;AAXR;;AAgBA,MAAI,UAAU,GAAG,CAAC,CAAlB;AACA,MAAI,UAAU,GAAG,CAAC,CAAlB;AACA,MAAI,GAAG,GAAG,CAAC,CAAX;AAAA,MAAc,GAAG,GAAG,IAAI,CAAC,MAAzB;AACA,MAAI,KAAJ;AACA,MAAI,GAAJ;;AAtB0H,4BAuBnG,GAvBmG;AAAA,MAuBrH,MAvBqH;AAAA,MAuB7G,MAvB6G;;AAyB1H,SAAO,EAAE,GAAF,GAAQ,GAAf,EAAoB;AAChB,IAAA,GAAG,GAAG,IAAI,CAAC,GAAD,CAAV;;AACA,QAAI,GAAG,YAAY,MAAf,KAA0B,MAAM,CAAC,EAAE,UAAH,CAAN,GAAuB,GAAjD,CAAJ,EAA2D;AACvD,MAAA,MAAM,CAAC,EAAE,UAAH,CAAN,GAAuB,GAAG,CAAC,KAAJ,CAAU,KAAV,CAAgB,IAAI,CAAC,GAAD,CAApB,EAA2B,GAAG,CAAC,IAA/B,EAAqC,IAArC,CAAvB;AACH,KAFD,MAEO;AAAA,kBACuB,IADvB;AAAA,4BACC,GADD;AACO,MAAA,KADP,0BACe,GADf;;AAEH,UAAI,GAAG,YAAY,QAAf,KAA4B,MAAM,CAAC,EAAE,UAAH,CAAN,GAAuB,GAAnD,CAAJ,EAA6D;AACzD,QAAA,MAAM,CAAC,EAAE,UAAH,CAAN,GAAuB,KAAK,CAAC,GAAN,CAAU,KAAV,EAAiB,GAAjB,EAAkC,IAAlC,CAAvB;AACH,OAFD,MAEO,IAAI,GAAG,IAAI,GAAG,CAAC,IAAX,KAAoB,MAAM,CAAC,EAAE,UAAH,CAAN,GAAuB,GAA3C,CAAJ,EAAqD;AACxD,QAAA,GAAG,YAAY,IAAf,KAAwB,MAAM,CAAC,UAAD,CAAN,GAAqB,GAAG,GAAG,MAAM,CAAC,GAAP,CAAW,GAAX,CAAnD;AACA,QAAA,MAAM,CAAC,EAAE,UAAH,CAAN,GAAuB,KAAK,CAAC,GAAN,CAAU,KAAV,EAAiB,GAAG,CAAC,IAArB,EAA2B,IAA3B,CAAvB;AACH;AACJ;AACJ;;AACD,SAAO,GAAP;AACH","sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Data } from '../data';\nimport { Field } from '../schema';\nimport { Column } from '../column';\nimport { Vector } from '../vector';\nimport { DataType } from '../type';\nimport { Chunked } from '../vector/chunked';\n\ntype RecordBatchCtor = typeof import('../recordbatch').RecordBatch;\n\nconst isArray = Array.isArray;\n\n/** @ignore */\nexport const selectArgs = <T>(Ctor: any, vals: any[]) => _selectArgs(Ctor, vals, [], 0) as T[];\n/** @ignore */\nexport const selectColumnArgs = <T extends { [key: string]: DataType }>(args: any[]) => {\n    const [fields, values] = _selectFieldArgs<T>(args, [[], []]);\n    return values.map((x, i) =>\n        x instanceof Column ? Column.new(x.field.clone(fields[i]), x) :\n        x instanceof Vector ? Column.new(fields[i], x) as Column<T[keyof T]> :\n                              Column.new(fields[i], [] as Vector<T[keyof T]>[]));\n};\n\n/** @ignore */\nexport const selectFieldArgs = <T extends { [key: string]: DataType }>(args: any[]) => _selectFieldArgs<T>(args, [[], []]);\n/** @ignore */\nexport const selectChunkArgs = <T>(Ctor: any, vals: any[]) => _selectChunkArgs(Ctor, vals, [], 0) as T[];\n/** @ignore */\nexport const selectVectorChildrenArgs = <T extends Vector>(Ctor: RecordBatchCtor, vals: any[]) => _selectVectorChildrenArgs(Ctor, vals, [], 0) as T[];\n/** @ignore */\nexport const selectColumnChildrenArgs = <T extends Column>(Ctor: RecordBatchCtor, vals: any[]) => _selectColumnChildrenArgs(Ctor, vals, [], 0) as T[];\n\n/** @ignore */\nfunction _selectArgs<T>(Ctor: any, vals: any[], res: T[], idx: number) {\n    let value: any, j = idx;\n    let i = -1, n = vals.length;\n    while (++i < n) {\n        if (isArray(value = vals[i])) {\n            j = _selectArgs(Ctor, value, res, j).length;\n        } else if (value instanceof Ctor) { res[j++] = value; }\n    }\n    return res;\n}\n\n/** @ignore */\nfunction _selectChunkArgs<T>(Ctor: any, vals: any[], res: T[], idx: number) {\n    let value: any, j = idx;\n    let i = -1, n = vals.length;\n    while (++i < n) {\n        if (isArray(value = vals[i])) {\n            j = _selectChunkArgs(Ctor, value, res, j).length;\n        } else if (value instanceof Chunked) {\n            j = _selectChunkArgs(Ctor, value.chunks, res, j).length;\n        } else if (value instanceof Ctor) { res[j++] = value; }\n    }\n    return res;\n}\n\n/** @ignore */\nfunction _selectVectorChildrenArgs<T extends Vector>(Ctor: RecordBatchCtor, vals: any[], res: T[], idx: number) {\n    let value: any, j = idx;\n    let i = -1, n = vals.length;\n    while (++i < n) {\n        if (isArray(value = vals[i])) {\n            j = _selectVectorChildrenArgs(Ctor, value, res, j).length;\n        } else if (value instanceof Ctor) {\n            j = _selectArgs(Vector, value.schema.fields.map((_, i) => value.getChildAt(i)!), res, j).length;\n        } else if (value instanceof Vector) { res[j++] = value as T; }\n    }\n    return res;\n}\n\n/** @ignore */\nfunction _selectColumnChildrenArgs<T extends Column>(Ctor: RecordBatchCtor, vals: any[], res: T[], idx: number) {\n    let value: any, j = idx;\n    let i = -1, n = vals.length;\n    while (++i < n) {\n        if (isArray(value = vals[i])) {\n            j = _selectColumnChildrenArgs(Ctor, value, res, j).length;\n        } else if (value instanceof Ctor) {\n            j = _selectArgs(Column, value.schema.fields.map((f, i) => Column.new(f, value.getChildAt(i)!)), res, j).length;\n        } else if (value instanceof Column) { res[j++] = value as T; }\n    }\n    return res;\n}\n\n/** @ignore */\nconst toKeysAndValues = (xs: [any[], any[]], [k, v]: [any, any], i: number) => (xs[0][i] = k, xs[1][i] = v, xs);\n\n/** @ignore */\nfunction _selectFieldArgs<T extends { [key: string]: DataType }>(vals: any[], ret: [Field<T[keyof T]>[], Vector<T[keyof T]>[]]): [Field<T[keyof T]>[], (T[keyof T] | Vector<T[keyof T]>)[]] {\n    let keys: any[], n: number;\n    switch (n = vals.length) {\n        case 0: return ret;\n        case 1:\n            keys = ret[0];\n            if (!(vals[0])) { return ret; }\n            if (isArray(vals[0])) { return _selectFieldArgs(vals[0], ret); }\n            if (!(vals[0] instanceof Data || vals[0] instanceof Vector || vals[0] instanceof DataType)) {\n                [keys, vals] = Object.entries(vals[0]).reduce(toKeysAndValues, ret);\n            }\n            break;\n        default:\n            !isArray(keys = vals[n - 1])\n                ? (vals = isArray(vals[0]) ? vals[0] : vals, keys = [])\n                : (vals = isArray(vals[0]) ? vals[0] : vals.slice(0, n - 1));\n    }\n\n    let fieldIndex = -1;\n    let valueIndex = -1;\n    let idx = -1, len = vals.length;\n    let field: number | string | Field<T[keyof T]>;\n    let val: Vector<T[keyof T]> | Data<T[keyof T]>;\n    let [fields, values] = ret as [Field<T[keyof T]>[], any[]];\n\n    while (++idx < len) {\n        val = vals[idx];\n        if (val instanceof Column && (values[++valueIndex] = val)) {\n            fields[++fieldIndex] = val.field.clone(keys[idx], val.type, true);\n        } else {\n            ({ [idx]: field = idx } = keys);\n            if (val instanceof DataType && (values[++valueIndex] = val)) {\n                fields[++fieldIndex] = Field.new(field, val as DataType, true) as Field<T[keyof T]>;\n            } else if (val && val.type && (values[++valueIndex] = val)) {\n                val instanceof Data && (values[valueIndex] = val = Vector.new(val) as Vector);\n                fields[++fieldIndex] = Field.new(field, val.type, true) as Field<T[keyof T]>;\n            }\n        }\n    }\n    return ret;\n}\n"]},"metadata":{},"sourceType":"module"}