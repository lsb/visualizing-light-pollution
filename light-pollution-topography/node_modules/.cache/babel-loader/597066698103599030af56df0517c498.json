{"ast":null,"code":"import _readOnlyError from \"@babel/runtime/helpers/esm/readOnlyError\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { Vector3, Matrix3, Matrix4, degrees } from '@math.gl/core';\nimport { BoundingSphere, OrientedBoundingBox } from '@math.gl/culling';\nimport { Ellipsoid } from '@math.gl/geospatial';\nimport { assert } from '@loaders.gl/loader-utils';\n\nfunction defined(x) {\n  return x !== undefined && x !== null;\n}\n\nvar scratchMatrix = new Matrix3();\nvar scratchScale = new Vector3();\nvar scratchNorthWest = new Vector3();\nvar scratchSouthEast = new Vector3();\nvar scratchTransform = new Matrix4();\nexport function createBoundingVolume(boundingVolumeHeader, transform, result) {\n  assert(boundingVolumeHeader, '3D Tile: boundingVolume must be defined');\n\n  if (boundingVolumeHeader.box) {\n    return createBox(boundingVolumeHeader.box, transform, result);\n  }\n\n  if (boundingVolumeHeader.region) {\n    var _boundingVolumeHeader = _slicedToArray(boundingVolumeHeader.region, 6),\n        west = _boundingVolumeHeader[0],\n        south = _boundingVolumeHeader[1],\n        east = _boundingVolumeHeader[2],\n        north = _boundingVolumeHeader[3],\n        minHeight = _boundingVolumeHeader[4],\n        maxHeight = _boundingVolumeHeader[5];\n\n    var northWest = Ellipsoid.WGS84.cartographicToCartesian([degrees(west), degrees(north), minHeight], scratchNorthWest);\n    var southEast = Ellipsoid.WGS84.cartographicToCartesian([degrees(east), degrees(south), maxHeight], scratchSouthEast);\n    var centerInCartesian = new Vector3().addVectors(northWest, southEast).multiplyScalar(0.5);\n    var radius = new Vector3().subVectors(northWest, southEast).len() / 2.0;\n    return createSphere([centerInCartesian[0], centerInCartesian[1], centerInCartesian[2], radius], new Matrix4());\n  }\n\n  if (boundingVolumeHeader.sphere) {\n    return createSphere(boundingVolumeHeader.sphere, transform, result);\n  }\n\n  throw new Error('3D Tile: boundingVolume must contain a sphere, region, or box');\n}\n\nfunction createBox(box, transform, result) {\n  var center = new Vector3(box[0], box[1], box[2]);\n  transform.transform(center, center);\n  var xAxis = transform.transformAsVector(box.slice(3, 6));\n  var yAxis = transform.transformAsVector(box.slice(6, 9));\n  var zAxis = transform.transformAsVector(box.slice(9, 12));\n  var halfAxes = new Matrix3([xAxis[0], xAxis[1], xAxis[2], yAxis[0], yAxis[1], yAxis[2], zAxis[0], zAxis[1], zAxis[2]]);\n\n  if (defined(result)) {\n    result.center = center;\n    result.halfAxes = halfAxes;\n    return result;\n  }\n\n  return new OrientedBoundingBox(center, halfAxes);\n}\n\nfunction createBoxFromTransformedRegion(region, transform, initialTransform, result) {\n  var rectangle = Rectangle.unpack(region, 0, scratchRectangle);\n  var minimumHeight = region[4];\n  var maximumHeight = region[5];\n  var orientedBoundingBox = OrientedBoundingBox.fromRectangle(rectangle, minimumHeight, maximumHeight, Ellipsoid.WGS84, scratchOrientedBoundingBox);\n  var center = orientedBoundingBox.center;\n  var halfAxes = orientedBoundingBox.halfAxes;\n  transform = Matrix4.multiplyTransformation(transform, Matrix4.inverseTransformation(initialTransform, scratchTransform), scratchTransform);\n  center = (_readOnlyError(\"center\"), Matrix4.multiplyByPoint(transform, center, center));\n  var rotationScale = Matrix4.getRotation(transform, scratchMatrix);\n  halfAxes = (_readOnlyError(\"halfAxes\"), Matrix3.multiply(rotationScale, halfAxes, halfAxes));\n\n  if (defined(result) && result instanceof TileOrientedBoundingBox) {\n    result.update(center, halfAxes);\n    return result;\n  }\n\n  return new TileOrientedBoundingBox(center, halfAxes);\n}\n\nfunction createRegion(region, transform, initialTransform, result) {\n  if (!Matrix4.equalsEpsilon(transform, initialTransform, CesiumMath.EPSILON8)) {\n    return createBoxFromTransformedRegion(region, transform, initialTransform, result);\n  }\n\n  if (defined(result)) {\n    return result;\n  }\n\n  var rectangleRegion = Rectangle.unpack(region, 0, scratchRectangle);\n  return new TileBoundingRegion({\n    rectangle: rectangleRegion,\n    minimumHeight: region[4],\n    maximumHeight: region[5]\n  });\n}\n\nfunction createSphere(sphere, transform, result) {\n  var center = new Vector3(sphere[0], sphere[1], sphere[2]);\n  transform.transform(center, center);\n  var scale = transform.getScale(scratchScale);\n  var uniformScale = Math.max(Math.max(scale[0], scale[1]), scale[2]);\n  var radius = sphere[3] * uniformScale;\n\n  if (defined(result)) {\n    result.center = center;\n    result.radius = radius;\n    return result;\n  }\n\n  return new BoundingSphere(center, radius);\n}","map":{"version":3,"sources":["../../../../src/tileset/helpers/bounding-volume.js"],"names":["x","scratchMatrix","scratchScale","scratchNorthWest","scratchSouthEast","scratchTransform","assert","boundingVolumeHeader","createBox","west","south","east","north","minHeight","maxHeight","northWest","Ellipsoid","degrees","southEast","centerInCartesian","radius","createSphere","center","box","transform","xAxis","yAxis","zAxis","halfAxes","defined","result","rectangle","Rectangle","minimumHeight","region","maximumHeight","orientedBoundingBox","OrientedBoundingBox","Matrix4","rotationScale","Matrix3","CesiumMath","createBoxFromTransformedRegion","rectangleRegion","sphere","scale","uniformScale","Math"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/* eslint-disable */\nimport {Vector3, Matrix3, Matrix4, degrees} from '@math.gl/core';\nimport {BoundingSphere, OrientedBoundingBox} from '@math.gl/culling';\nimport {Ellipsoid} from '@math.gl/geospatial';\nimport {assert} from '@loaders.gl/loader-utils';\n\n// const scratchProjectedBoundingSphere = new BoundingSphere();\n\nfunction defined(x) {\n  return x !== undefined && x !== null;\n}\n\nconst scratchMatrix = new Matrix3();\nconst scratchScale = new Vector3();\nconst scratchNorthWest = new Vector3();\nconst scratchSouthEast = new Vector3();\n// const scratchRectangle = new Rectangle();\n// const scratchOrientedBoundingBox = new OrientedBoundingBox();\nconst scratchTransform = new Matrix4();\n\n/**\n * Create a bounding volume from the tile's bounding volume header.\n * @param {Object} boundingVolumeHeader The tile's bounding volume header.\n * @param {Matrix4} transform The transform to apply to the bounding volume.\n * @param {TileBoundingVolume} [result] The object onto which to store the result.\n * @returns {TileBoundingVolume} The modified result parameter or a new TileBoundingVolume instance if none was provided.\n */\nexport function createBoundingVolume(boundingVolumeHeader, transform, result) {\n  assert(boundingVolumeHeader, '3D Tile: boundingVolume must be defined');\n\n  // boundingVolume schema:\n  // https://github.com/AnalyticalGraphicsInc/3d-tiles/blob/master/specification/schema/boundingVolume.schema.json\n  if (boundingVolumeHeader.box) {\n    return createBox(boundingVolumeHeader.box, transform, result);\n  }\n  if (boundingVolumeHeader.region) {\n    // [west, south, east, north, minimum height, maximum height]\n    // Latitudes and longitudes are in the WGS 84 datum as defined in EPSG 4979 and are in radians.\n    // Heights are in meters above (or below) the WGS 84 ellipsoid.\n    const [west, south, east, north, minHeight, maxHeight] = boundingVolumeHeader.region;\n\n    const northWest = Ellipsoid.WGS84.cartographicToCartesian(\n      [degrees(west), degrees(north), minHeight],\n      scratchNorthWest\n    );\n    const southEast = Ellipsoid.WGS84.cartographicToCartesian(\n      [degrees(east), degrees(south), maxHeight],\n      scratchSouthEast\n    );\n    const centerInCartesian = new Vector3().addVectors(northWest, southEast).multiplyScalar(0.5);\n    const radius = new Vector3().subVectors(northWest, southEast).len() / 2.0;\n\n    // TODO improve region boundingVolume\n    // for now, create a sphere as the boundingVolume instead of box\n    return createSphere(\n      [centerInCartesian[0], centerInCartesian[1], centerInCartesian[2], radius],\n      new Matrix4()\n    );\n  }\n\n  if (boundingVolumeHeader.sphere) {\n    return createSphere(boundingVolumeHeader.sphere, transform, result);\n  }\n\n  throw new Error('3D Tile: boundingVolume must contain a sphere, region, or box');\n}\n\nfunction createBox(box, transform, result) {\n  // box: An array of 12 numbers that define an oriented bounding box.\n  // The first three elements define the x, y, and z values for the center of the box.\n  // The next three elements (with indices 3, 4, and 5) define the x axis direction and half-length.\n  // The next three elements (indices 6, 7, and 8) define the y axis direction and half-length.\n  // The last three elements (indices 9, 10, and 11) define the z axis direction and half-length.\n  const center = new Vector3(box[0], box[1], box[2]);\n  transform.transform(center, center);\n\n  const xAxis = transform.transformAsVector(box.slice(3, 6));\n  const yAxis = transform.transformAsVector(box.slice(6, 9));\n  const zAxis = transform.transformAsVector(box.slice(9, 12));\n  const halfAxes = new Matrix3([\n    xAxis[0],\n    xAxis[1],\n    xAxis[2],\n    yAxis[0],\n    yAxis[1],\n    yAxis[2],\n    zAxis[0],\n    zAxis[1],\n    zAxis[2]\n  ]);\n\n  if (defined(result)) {\n    result.center = center;\n    result.halfAxes = halfAxes;\n    return result;\n  }\n\n  return new OrientedBoundingBox(center, halfAxes);\n}\n\nfunction createBoxFromTransformedRegion(region, transform, initialTransform, result) {\n  const rectangle = Rectangle.unpack(region, 0, scratchRectangle);\n  const minimumHeight = region[4];\n  const maximumHeight = region[5];\n\n  const orientedBoundingBox = OrientedBoundingBox.fromRectangle(\n    rectangle,\n    minimumHeight,\n    maximumHeight,\n    Ellipsoid.WGS84,\n    scratchOrientedBoundingBox\n  );\n  const center = orientedBoundingBox.center;\n  const halfAxes = orientedBoundingBox.halfAxes;\n\n  // A region bounding volume is not transformed by the transform in the tileset JSON,\n  // but may be transformed by additional transforms applied in Cesium.\n  // This is why the transform is calculated as the difference between the initial transform and the current transform.\n  transform = Matrix4.multiplyTransformation(\n    transform,\n    Matrix4.inverseTransformation(initialTransform, scratchTransform),\n    scratchTransform\n  );\n  center = Matrix4.multiplyByPoint(transform, center, center);\n  const rotationScale = Matrix4.getRotation(transform, scratchMatrix);\n  halfAxes = Matrix3.multiply(rotationScale, halfAxes, halfAxes);\n\n  if (defined(result) && result instanceof TileOrientedBoundingBox) {\n    result.update(center, halfAxes);\n    return result;\n  }\n\n  return new TileOrientedBoundingBox(center, halfAxes);\n}\n\nfunction createRegion(region, transform, initialTransform, result) {\n  if (!Matrix4.equalsEpsilon(transform, initialTransform, CesiumMath.EPSILON8)) {\n    return createBoxFromTransformedRegion(region, transform, initialTransform, result);\n  }\n\n  if (defined(result)) {\n    return result;\n  }\n\n  const rectangleRegion = Rectangle.unpack(region, 0, scratchRectangle);\n\n  return new TileBoundingRegion({\n    rectangle: rectangleRegion,\n    minimumHeight: region[4],\n    maximumHeight: region[5]\n  });\n}\n\nfunction createSphere(sphere, transform, result) {\n  // Find the transformed center\n  const center = new Vector3(sphere[0], sphere[1], sphere[2]);\n  transform.transform(center, center);\n  const scale = transform.getScale(scratchScale);\n\n  const uniformScale = Math.max(Math.max(scale[0], scale[1]), scale[2]);\n  const radius = sphere[3] * uniformScale;\n\n  if (defined(result)) {\n    result.center = center;\n    result.radius = radius;\n    return result;\n  }\n\n  return new BoundingSphere(center, radius);\n}\n"]},"metadata":{},"sourceType":"module"}