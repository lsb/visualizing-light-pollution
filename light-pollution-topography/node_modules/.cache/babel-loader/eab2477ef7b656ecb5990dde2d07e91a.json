{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { createIterable, getAccessorFromBuffer } from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\nimport { Buffer } from '@luma.gl/core';\n\nvar Tesselator = function () {\n  function Tesselator() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Tesselator);\n\n    var _opts$attributes = opts.attributes,\n        attributes = _opts$attributes === void 0 ? {} : _opts$attributes;\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.indexStarts = null;\n    this.vertexStarts = null;\n    this.vertexCount = 0;\n    this.instanceCount = 0;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n    this.updateGeometry(opts);\n    Object.seal(this);\n  }\n\n  _createClass(Tesselator, [{\n    key: \"updateGeometry\",\n    value: function updateGeometry(opts) {\n      Object.assign(this.opts, opts);\n      var _this$opts = this.opts,\n          data = _this$opts.data,\n          _this$opts$buffers = _this$opts.buffers,\n          buffers = _this$opts$buffers === void 0 ? {} : _this$opts$buffers,\n          getGeometry = _this$opts.getGeometry,\n          geometryBuffer = _this$opts.geometryBuffer,\n          positionFormat = _this$opts.positionFormat,\n          dataChanged = _this$opts.dataChanged,\n          _this$opts$normalize = _this$opts.normalize,\n          normalize = _this$opts$normalize === void 0 ? true : _this$opts$normalize;\n      this.data = data;\n      this.getGeometry = getGeometry;\n      this.positionSize = geometryBuffer && geometryBuffer.size || (positionFormat === 'XY' ? 2 : 3);\n      this.buffers = buffers;\n      this.normalize = normalize;\n\n      if (geometryBuffer) {\n        assert(data.startIndices, 'binary data missing startIndices');\n        this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n\n        if (!normalize) {\n          buffers.positions = geometryBuffer;\n        }\n      }\n\n      this.geometryBuffer = buffers.positions;\n\n      if (Array.isArray(dataChanged)) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = dataChanged[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var dataRange = _step.value;\n\n            this._rebuildGeometry(dataRange);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n              _iterator[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } else {\n        this._rebuildGeometry();\n      }\n    }\n  }, {\n    key: \"updatePartialGeometry\",\n    value: function updatePartialGeometry(_ref) {\n      var startRow = _ref.startRow,\n          endRow = _ref.endRow;\n\n      this._rebuildGeometry({\n        startRow: startRow,\n        endRow: endRow\n      });\n    }\n  }, {\n    key: \"updateGeometryAttributes\",\n    value: function updateGeometryAttributes(geometry, startIndex, size) {\n      throw new Error('Not implemented');\n    }\n  }, {\n    key: \"getGeometrySize\",\n    value: function getGeometrySize(geometry) {\n      throw new Error('Not implemented');\n    }\n  }, {\n    key: \"getGeometryFromBuffer\",\n    value: function getGeometryFromBuffer(geometryBuffer) {\n      var value = geometryBuffer.value || geometryBuffer;\n      assert(ArrayBuffer.isView(value), 'cannot read geometries');\n      return getAccessorFromBuffer(value, {\n        size: this.positionSize,\n        offset: geometryBuffer.offset,\n        stride: geometryBuffer.stride,\n        startIndices: this.data.startIndices\n      });\n    }\n  }, {\n    key: \"_allocate\",\n    value: function _allocate(instanceCount, copy) {\n      var attributes = this.attributes,\n          buffers = this.buffers,\n          _attributeDefs = this._attributeDefs,\n          typedArrayManager = this.typedArrayManager;\n\n      for (var name in _attributeDefs) {\n        if (name in buffers) {\n          typedArrayManager.release(attributes[name]);\n          attributes[name] = null;\n        } else {\n          var def = _attributeDefs[name];\n          def.copy = copy;\n          attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n        }\n      }\n    }\n  }, {\n    key: \"_forEachGeometry\",\n    value: function _forEachGeometry(visitor, startRow, endRow) {\n      var data = this.data,\n          getGeometry = this.getGeometry;\n\n      var _createIterable = createIterable(data, startRow, endRow),\n          iterable = _createIterable.iterable,\n          objectInfo = _createIterable.objectInfo;\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = iterable[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var object = _step2.value;\n          objectInfo.index++;\n          var geometry = getGeometry(object, objectInfo);\n          visitor(geometry, objectInfo.index);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_rebuildGeometry\",\n    value: function _rebuildGeometry(dataRange) {\n      var _this = this;\n\n      if (!this.data || !this.getGeometry) {\n        return;\n      }\n\n      var indexStarts = this.indexStarts,\n          vertexStarts = this.vertexStarts,\n          instanceCount = this.instanceCount;\n      var data = this.data,\n          geometryBuffer = this.geometryBuffer;\n\n      var _ref2 = dataRange || {},\n          _ref2$startRow = _ref2.startRow,\n          startRow = _ref2$startRow === void 0 ? 0 : _ref2$startRow,\n          _ref2$endRow = _ref2.endRow,\n          endRow = _ref2$endRow === void 0 ? Infinity : _ref2$endRow;\n\n      if (!dataRange) {\n        indexStarts = [0];\n        vertexStarts = [0];\n      }\n\n      if (this.normalize || !geometryBuffer) {\n        this._forEachGeometry(function (geometry, dataIndex) {\n          vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + _this.getGeometrySize(geometry);\n        }, startRow, endRow);\n\n        instanceCount = vertexStarts[vertexStarts.length - 1];\n      } else if (geometryBuffer.buffer instanceof Buffer) {\n        var byteStride = geometryBuffer.stride || this.positionSize * 4;\n        vertexStarts = data.startIndices;\n        instanceCount = vertexStarts[data.length] || geometryBuffer.buffer.byteLength / byteStride;\n      } else {\n        var bufferValue = geometryBuffer.value || geometryBuffer;\n        var elementStride = geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n        vertexStarts = data.startIndices;\n        instanceCount = vertexStarts[data.length] || bufferValue.length / elementStride;\n      }\n\n      this._allocate(instanceCount, Boolean(dataRange));\n\n      this.indexStarts = indexStarts;\n      this.vertexStarts = vertexStarts;\n      this.instanceCount = instanceCount;\n      var context = {};\n\n      this._forEachGeometry(function (geometry, dataIndex) {\n        context.vertexStart = vertexStarts[dataIndex];\n        context.indexStart = indexStarts[dataIndex];\n        var vertexEnd = dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n        context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n        context.geometryIndex = dataIndex;\n\n        _this.updateGeometryAttributes(geometry, context);\n      }, startRow, endRow);\n\n      this.vertexCount = indexStarts[indexStarts.length - 1];\n    }\n  }]);\n\n  return Tesselator;\n}();\n\nexport { Tesselator as default };","map":{"version":3,"sources":["../../../src/utils/tesselator.js"],"names":["Tesselator","opts","attributes","Object","data","buffers","getGeometry","geometryBuffer","positionFormat","dataChanged","normalize","assert","Array","dataRange","startRow","endRow","geometry","startIndex","size","value","ArrayBuffer","getAccessorFromBuffer","offset","stride","startIndices","instanceCount","copy","_attributeDefs","typedArrayManager","name","def","visitor","iterable","objectInfo","createIterable","object","indexStarts","vertexStarts","dataIndex","byteStride","bufferValue","elementStride","Boolean","context","vertexEnd"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {createIterable, getAccessorFromBuffer} from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\n\nimport {Buffer} from '@luma.gl/core';\n\nexport default class Tesselator {\n  constructor(opts = {}) {\n    const {attributes = {}} = opts;\n\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.indexStarts = null;\n    this.vertexStarts = null;\n    this.vertexCount = 0;\n    this.instanceCount = 0;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n\n    this.updateGeometry(opts);\n\n    Object.seal(this);\n  }\n\n  /* Public methods */\n  updateGeometry(opts) {\n    Object.assign(this.opts, opts);\n    const {\n      data,\n      buffers = {},\n      getGeometry,\n      geometryBuffer,\n      positionFormat,\n      dataChanged,\n      normalize = true\n    } = this.opts;\n    this.data = data;\n    this.getGeometry = getGeometry;\n    this.positionSize =\n      (geometryBuffer && geometryBuffer.size) || (positionFormat === 'XY' ? 2 : 3);\n    this.buffers = buffers;\n    this.normalize = normalize;\n\n    // Handle external logical value\n    if (geometryBuffer) {\n      assert(data.startIndices, 'binary data missing startIndices');\n      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n\n      if (!normalize) {\n        // skip packing and set attribute value directly\n        // TODO - avoid mutating user-provided object\n        buffers.positions = geometryBuffer;\n      }\n    }\n    this.geometryBuffer = buffers.positions;\n\n    if (Array.isArray(dataChanged)) {\n      // is partial update\n      for (const dataRange of dataChanged) {\n        this._rebuildGeometry(dataRange);\n      }\n    } else {\n      this._rebuildGeometry();\n    }\n  }\n\n  updatePartialGeometry({startRow, endRow}) {\n    this._rebuildGeometry({startRow, endRow});\n  }\n\n  /* Subclass interface */\n\n  // Update the positions of a single geometry\n  updateGeometryAttributes(geometry, startIndex, size) {\n    throw new Error('Not implemented');\n  }\n\n  // Returns the number of vertices in a geometry\n  getGeometrySize(geometry) {\n    throw new Error('Not implemented');\n  }\n\n  getGeometryFromBuffer(geometryBuffer) {\n    const value = geometryBuffer.value || geometryBuffer;\n    assert(ArrayBuffer.isView(value), 'cannot read geometries');\n\n    return getAccessorFromBuffer(value, {\n      size: this.positionSize,\n      offset: geometryBuffer.offset,\n      stride: geometryBuffer.stride,\n      startIndices: this.data.startIndices\n    });\n  }\n\n  /* Private utility methods */\n  _allocate(instanceCount, copy) {\n    // allocate attributes\n    const {attributes, buffers, _attributeDefs, typedArrayManager} = this;\n    for (const name in _attributeDefs) {\n      if (name in buffers) {\n        // Use external buffer\n        typedArrayManager.release(attributes[name]);\n        attributes[name] = null;\n      } else {\n        const def = _attributeDefs[name];\n        // If dataRange is supplied, this is a partial update.\n        // In case we need to reallocate the typed array, it will need the old values copied\n        // before performing partial update.\n        def.copy = copy;\n\n        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n      }\n    }\n  }\n\n  /**\n   * Visit all objects\n   * `data` is expected to be an iterable consistent with the base Layer expectation\n   */\n  _forEachGeometry(visitor, startRow, endRow) {\n    const {data, getGeometry} = this;\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n      const geometry = getGeometry(object, objectInfo);\n      visitor(geometry, objectInfo.index);\n    }\n  }\n\n  /* eslint-disable complexity,max-statements */\n  _rebuildGeometry(dataRange) {\n    if (!this.data || !this.getGeometry) {\n      return;\n    }\n\n    let {indexStarts, vertexStarts, instanceCount} = this;\n    const {data, geometryBuffer} = this;\n    const {startRow = 0, endRow = Infinity} = dataRange || {};\n\n    if (!dataRange) {\n      // Full update - regenerate buffer layout from scratch\n      indexStarts = [0];\n      vertexStarts = [0];\n    }\n    if (this.normalize || !geometryBuffer) {\n      this._forEachGeometry(\n        (geometry, dataIndex) => {\n          vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + this.getGeometrySize(geometry);\n        },\n        startRow,\n        endRow\n      );\n      // count instances\n      instanceCount = vertexStarts[vertexStarts.length - 1];\n    } else if (geometryBuffer.buffer instanceof Buffer) {\n      const byteStride = geometryBuffer.stride || this.positionSize * 4;\n      // assume user provided data is already normalized\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || geometryBuffer.buffer.byteLength / byteStride;\n    } else {\n      const bufferValue = geometryBuffer.value || geometryBuffer;\n      const elementStride =\n        geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n      // assume user provided data is already normalized\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || bufferValue.length / elementStride;\n    }\n\n    // allocate attributes\n    this._allocate(instanceCount, Boolean(dataRange));\n\n    this.indexStarts = indexStarts;\n    this.vertexStarts = vertexStarts;\n    this.instanceCount = instanceCount;\n\n    const context = {};\n\n    this._forEachGeometry(\n      (geometry, dataIndex) => {\n        context.vertexStart = vertexStarts[dataIndex];\n        context.indexStart = indexStarts[dataIndex];\n        const vertexEnd =\n          dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n        context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n        context.geometryIndex = dataIndex;\n        this.updateGeometryAttributes(geometry, context);\n      },\n      startRow,\n      endRow\n    );\n\n    this.vertexCount = indexStarts[indexStarts.length - 1];\n  }\n}\n"]},"metadata":{},"sourceType":"module"}