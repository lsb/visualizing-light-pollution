{"ast":null,"code":"import { Vector3, assert, _MathUtils } from 'math.gl';\nimport * as vec3 from 'gl-matrix/vec3';\nvar scratchVector = new Vector3();\nvar scaleToGeodeticSurfaceIntersection = new Vector3();\nvar scaleToGeodeticSurfaceGradient = new Vector3();\nexport default function scaleToGeodeticSurface(cartesian, ellipsoid) {\n  var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector3();\n  var oneOverRadii = ellipsoid.oneOverRadii,\n      oneOverRadiiSquared = ellipsoid.oneOverRadiiSquared,\n      centerToleranceSquared = ellipsoid.centerToleranceSquared;\n  scratchVector.from(cartesian);\n  var positionX = cartesian.x;\n  var positionY = cartesian.y;\n  var positionZ = cartesian.z;\n  var oneOverRadiiX = oneOverRadii.x;\n  var oneOverRadiiY = oneOverRadii.y;\n  var oneOverRadiiZ = oneOverRadii.z;\n  var x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;\n  var y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;\n  var z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;\n  var squaredNorm = x2 + y2 + z2;\n  var ratio = Math.sqrt(1.0 / squaredNorm);\n\n  if (!Number.isFinite(ratio)) {\n    return undefined;\n  }\n\n  var intersection = scaleToGeodeticSurfaceIntersection;\n  intersection.copy(cartesian).scale(ratio);\n\n  if (squaredNorm < centerToleranceSquared) {\n    return intersection.to(result);\n  }\n\n  var oneOverRadiiSquaredX = oneOverRadiiSquared.x;\n  var oneOverRadiiSquaredY = oneOverRadiiSquared.y;\n  var oneOverRadiiSquaredZ = oneOverRadiiSquared.z;\n  var gradient = scaleToGeodeticSurfaceGradient;\n  gradient.set(intersection.x * oneOverRadiiSquaredX * 2.0, intersection.y * oneOverRadiiSquaredY * 2.0, intersection.z * oneOverRadiiSquaredZ * 2.0);\n  var lambda = (1.0 - ratio) * cartesian.len() / (0.5 * gradient.len());\n  var correction = 0.0;\n  var xMultiplier;\n  var yMultiplier;\n  var zMultiplier;\n  var func;\n\n  do {\n    lambda -= correction;\n    xMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredX);\n    yMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredY);\n    zMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredZ);\n    var xMultiplier2 = xMultiplier * xMultiplier;\n    var yMultiplier2 = yMultiplier * yMultiplier;\n    var zMultiplier2 = zMultiplier * zMultiplier;\n    var xMultiplier3 = xMultiplier2 * xMultiplier;\n    var yMultiplier3 = yMultiplier2 * yMultiplier;\n    var zMultiplier3 = zMultiplier2 * zMultiplier;\n    func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;\n    var denominator = x2 * xMultiplier3 * oneOverRadiiSquaredX + y2 * yMultiplier3 * oneOverRadiiSquaredY + z2 * zMultiplier3 * oneOverRadiiSquaredZ;\n    var derivative = -2.0 * denominator;\n    correction = func / derivative;\n  } while (Math.abs(func) > _MathUtils.EPSILON12);\n\n  return scratchVector.scale([xMultiplier, yMultiplier, zMultiplier]).to(result);\n}","map":{"version":3,"sources":["../../../../src/ellipsoid/helpers/scale-to-geodetic-surface.js"],"names":["scratchVector","scaleToGeodeticSurfaceIntersection","scaleToGeodeticSurfaceGradient","result","oneOverRadii","oneOverRadiiSquared","centerToleranceSquared","ellipsoid","positionX","cartesian","positionY","positionZ","oneOverRadiiX","oneOverRadiiY","oneOverRadiiZ","x2","y2","z2","squaredNorm","ratio","Math","Number","intersection","oneOverRadiiSquaredX","oneOverRadiiSquaredY","oneOverRadiiSquaredZ","gradient","lambda","correction","xMultiplier","yMultiplier","zMultiplier","xMultiplier2","yMultiplier2","zMultiplier2","xMultiplier3","yMultiplier3","zMultiplier3","func","denominator","derivative","_MathUtils"],"mappings":"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","sourcesContent":["/* eslint-disable */\nimport {Vector3, assert, _MathUtils} from 'math.gl';\nimport * as vec3 from 'gl-matrix/vec3';\n\nconst scratchVector = new Vector3();\nconst scaleToGeodeticSurfaceIntersection = new Vector3();\nconst scaleToGeodeticSurfaceGradient = new Vector3();\n\n// Scales the provided Cartesian position along the geodetic surface normal\n// so that it is on the surface of this ellipsoid.  If the position is\n// at the center of the ellipsoid, this function returns undefined.\nexport default function scaleToGeodeticSurface(cartesian, ellipsoid, result = new Vector3()) {\n  const {oneOverRadii, oneOverRadiiSquared, centerToleranceSquared} = ellipsoid;\n\n  scratchVector.from(cartesian);\n\n  const positionX = cartesian.x;\n  const positionY = cartesian.y;\n  const positionZ = cartesian.z;\n\n  const oneOverRadiiX = oneOverRadii.x;\n  const oneOverRadiiY = oneOverRadii.y;\n  const oneOverRadiiZ = oneOverRadii.z;\n\n  const x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;\n  const y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;\n  const z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;\n\n  // Compute the squared ellipsoid norm.\n  const squaredNorm = x2 + y2 + z2;\n  const ratio = Math.sqrt(1.0 / squaredNorm);\n\n  // When very close to center or at center\n  if (!Number.isFinite(ratio)) {\n    return undefined;\n  }\n\n  // As an initial approximation, assume that the radial intersection is the projection point.\n  const intersection = scaleToGeodeticSurfaceIntersection;\n  intersection.copy(cartesian).scale(ratio);\n\n  // If the position is near the center, the iteration will not converge.\n  if (squaredNorm < centerToleranceSquared) {\n    return intersection.to(result);\n  }\n\n  const oneOverRadiiSquaredX = oneOverRadiiSquared.x;\n  const oneOverRadiiSquaredY = oneOverRadiiSquared.y;\n  const oneOverRadiiSquaredZ = oneOverRadiiSquared.z;\n\n  // Use the gradient at the intersection point in place of the true unit normal.\n  // The difference in magnitude will be absorbed in the multiplier.\n  const gradient = scaleToGeodeticSurfaceGradient;\n  gradient.set(\n    intersection.x * oneOverRadiiSquaredX * 2.0,\n    intersection.y * oneOverRadiiSquaredY * 2.0,\n    intersection.z * oneOverRadiiSquaredZ * 2.0\n  );\n\n  // Compute the initial guess at the normal vector multiplier, lambda.\n  let lambda = ((1.0 - ratio) * cartesian.len()) / (0.5 * gradient.len());\n  let correction = 0.0;\n\n  let xMultiplier;\n  let yMultiplier;\n  let zMultiplier;\n  let func;\n\n  do {\n    lambda -= correction;\n\n    xMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredX);\n    yMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredY);\n    zMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredZ);\n\n    const xMultiplier2 = xMultiplier * xMultiplier;\n    const yMultiplier2 = yMultiplier * yMultiplier;\n    const zMultiplier2 = zMultiplier * zMultiplier;\n\n    const xMultiplier3 = xMultiplier2 * xMultiplier;\n    const yMultiplier3 = yMultiplier2 * yMultiplier;\n    const zMultiplier3 = zMultiplier2 * zMultiplier;\n\n    func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;\n\n    // \"denominator\" here refers to the use of this expression in the velocity and acceleration\n    // computations in the sections to follow.\n    const denominator =\n      x2 * xMultiplier3 * oneOverRadiiSquaredX +\n      y2 * yMultiplier3 * oneOverRadiiSquaredY +\n      z2 * zMultiplier3 * oneOverRadiiSquaredZ;\n\n    const derivative = -2.0 * denominator;\n\n    correction = func / derivative;\n  } while (Math.abs(func) > _MathUtils.EPSILON12);\n\n  return scratchVector.scale([xMultiplier, yMultiplier, zMultiplier]).to(result);\n}\n"]},"metadata":{},"sourceType":"module"}