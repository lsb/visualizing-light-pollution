{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport ManagedArray from '../../utils/managed-array';\nimport { TILE_REFINEMENT } from '../../constants';\nimport { assert } from '@loaders.gl/loader-utils';\nexport var DEFAULT_OPTIONS = {\n  loadSiblings: false,\n  skipLevelOfDetail: false,\n  maximumScreenSpaceError: 2\n};\n\nvar TilesetTraverser = function () {\n  function TilesetTraverser(options) {\n    _classCallCheck(this, TilesetTraverser);\n\n    this.options = _objectSpread({}, DEFAULT_OPTIONS, {}, options);\n    this._traversalStack = new ManagedArray();\n    this._emptyTraversalStack = new ManagedArray();\n    this._frameNumber = null;\n    this.root = null;\n    this.selectedTiles = {};\n    this.requestedTiles = {};\n    this.emptyTiles = {};\n  }\n\n  _createClass(TilesetTraverser, [{\n    key: \"traverse\",\n    value: function traverse(root, frameState, options) {\n      this.root = root;\n      this.options = _objectSpread({}, this.options, {}, options);\n      this.reset();\n      this.updateTile(root, frameState);\n      this._frameNumber = frameState.frameNumber;\n      this.executeTraversal(root, frameState);\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.requestedTiles = {};\n      this.selectedTiles = {};\n      this.emptyTiles = {};\n\n      this._traversalStack.reset();\n\n      this._emptyTraversalStack.reset();\n    }\n  }, {\n    key: \"executeTraversal\",\n    value: function executeTraversal(root, frameState) {\n      var stack = this._traversalStack;\n      stack.push(root);\n\n      while (stack.length > 0) {\n        var tile = stack.pop();\n        var shouldRefine = false;\n\n        if (this.canTraverse(tile, frameState)) {\n          this.updateChildTiles(tile, frameState);\n          shouldRefine = this.updateAndPushChildren(tile, frameState, stack);\n        }\n\n        var parent = tile.parent;\n        var parentRefines = Boolean(!parent || parent._shouldRefine);\n        var stoppedRefining = !shouldRefine;\n\n        if (!tile.hasRenderContent) {\n          this.emptyTiles[tile.id] = tile;\n          this.loadTile(tile, frameState);\n\n          if (stoppedRefining) {\n            this.selectTile(tile, frameState);\n          }\n        } else if (tile.refine === TILE_REFINEMENT.ADD) {\n          this.loadTile(tile, frameState);\n          this.selectTile(tile, frameState);\n        } else if (tile.refine === TILE_REFINEMENT.REPLACE) {\n          this.loadTile(tile, frameState);\n\n          if (stoppedRefining) {\n            this.selectTile(tile, frameState);\n          }\n        }\n\n        this.touchTile(tile, frameState);\n        tile._shouldRefine = shouldRefine && parentRefines;\n      }\n    }\n  }, {\n    key: \"updateChildTiles\",\n    value: function updateChildTiles(tile, frameState) {\n      var children = tile.children;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var child = _step.value;\n          this.updateTile(child, frameState);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"updateAndPushChildren\",\n    value: function updateAndPushChildren(tile, frameState, stack) {\n      var _this$options = this.options,\n          loadSiblings = _this$options.loadSiblings,\n          skipLevelOfDetail = _this$options.skipLevelOfDetail;\n      var children = tile.children;\n      children.sort(this.compareDistanceToCamera);\n      var checkRefines = !skipLevelOfDetail && tile.refine === TILE_REFINEMENT.REPLACE && tile.hasRenderContent;\n      var hasVisibleChild = false;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var child = _step2.value;\n\n          if (child.isVisibleAndInRequestVolume) {\n            if (stack.find(child)) {\n              stack[\"delete\"](child);\n            }\n\n            stack.push(child);\n            hasVisibleChild = true;\n          } else if (checkRefines || loadSiblings) {\n            this.loadTile(child, frameState);\n            this.touchTile(child, frameState);\n          }\n\n          if (checkRefines) {\n            var childRefines = void 0;\n\n            if (!child._inRequestVolume) {\n              childRefines = false;\n            } else if (!child.hasRenderContent) {\n              childRefines = this.executeEmptyTraversal(child, frameState);\n            } else {\n              childRefines = child.contentAvailable;\n            }\n\n            if (!childRefines) {\n              return childRefines;\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return hasVisibleChild;\n    }\n  }, {\n    key: \"updateTile\",\n    value: function updateTile(tile, frameState) {\n      this.updateTileVisibility(tile, frameState);\n    }\n  }, {\n    key: \"selectTile\",\n    value: function selectTile(tile, frameState) {\n      if (this.shouldSelectTile(tile, frameState)) {\n        tile._selectedFrame = frameState.frameNumber;\n        this.selectedTiles[tile.id] = tile;\n      }\n    }\n  }, {\n    key: \"loadTile\",\n    value: function loadTile(tile, frameState) {\n      if (this.shouldLoadTile(tile, frameState)) {\n        tile._requestedFrame = frameState.frameNumber;\n        tile._priority = this.getPriority(tile);\n        this.requestedTiles[tile.id] = tile;\n      }\n    }\n  }, {\n    key: \"touchTile\",\n    value: function touchTile(tile, frameState) {\n      tile.tileset._cache.touch(tile);\n\n      tile._touchedFrame = frameState.frameNumber;\n    }\n  }, {\n    key: \"canTraverse\",\n    value: function canTraverse(tile, frameState) {\n      var useParentMetric = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var ignoreVisibility = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n      if (!ignoreVisibility && !tile.isVisibleAndInRequestVolume) {\n        return false;\n      }\n\n      if (!tile.hasChildren) {\n        return false;\n      }\n\n      if (tile.hasTilesetContent) {\n        return !tile.contentExpired;\n      }\n\n      return this.shouldRefine(tile, frameState, useParentMetric);\n    }\n  }, {\n    key: \"shouldLoadTile\",\n    value: function shouldLoadTile(tile, frameState) {\n      return tile.hasUnloadedContent || tile.contentExpired;\n    }\n  }, {\n    key: \"shouldSelectTile\",\n    value: function shouldSelectTile(tile, frameState) {\n      return tile.contentAvailable && !this.options.skipLevelOfDetail;\n    }\n  }, {\n    key: \"shouldRefine\",\n    value: function shouldRefine(tile, frameState, useParentMetric) {\n      var screenSpaceError = tile._screenSpaceError;\n\n      if (useParentMetric) {\n        screenSpaceError = tile.getScreenSpaceError(frameState, true);\n      }\n\n      return screenSpaceError > this.options.maximumScreenSpaceError;\n    }\n  }, {\n    key: \"updateTileVisibility\",\n    value: function updateTileVisibility(tile, frameState) {\n      tile.updateVisibility(frameState);\n    }\n  }, {\n    key: \"compareDistanceToCamera\",\n    value: function compareDistanceToCamera(b, a) {\n      return b._distanceToCamera - a._distanceToCamera;\n    }\n  }, {\n    key: \"getPriority\",\n    value: function getPriority(tile) {\n      var options = this.options;\n\n      switch (tile.refine) {\n        case TILE_REFINEMENT.ADD:\n          return tile._distanceToCamera;\n\n        case TILE_REFINEMENT.REPLACE:\n          var parent = tile.parent;\n          var useParentScreenSpaceError = parent && (!options.skipLevelOfDetail || tile._screenSpaceError === 0.0 || parent.hasTilesetContent);\n          var screenSpaceError = useParentScreenSpaceError ? parent._screenSpaceError : tile._screenSpaceError;\n          var rootScreenSpaceError = this.root._screenSpaceError;\n          return rootScreenSpaceError - screenSpaceError;\n\n        default:\n          return assert(false);\n      }\n    }\n  }, {\n    key: \"anyChildrenVisible\",\n    value: function anyChildrenVisible(tile, frameState) {\n      var anyVisible = false;\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = tile.children[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var child = _step3.value;\n          child.updateVisibility(frameState);\n          anyVisible = anyVisible || child.isVisibleAndInRequestVolume;\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n            _iterator3[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return anyVisible;\n    }\n  }, {\n    key: \"executeEmptyTraversal\",\n    value: function executeEmptyTraversal(root, frameState) {\n      var allDescendantsLoaded = true;\n      var stack = this._emptyTraversalStack;\n\n      while (stack.length > 0) {\n        var tile = stack.pop();\n        this.updateTile(tile, frameState);\n\n        if (!tile.isVisibleAndInRequestVolume) {\n          this.loadTile(tile, frameState);\n          this.touchTile(tile, frameState);\n        }\n\n        var traverse = !tile.hasRenderContent && this.canTraverse(tile, frameState, false, true);\n\n        if (!traverse && !tile.contentAvailable) {\n          allDescendantsLoaded = false;\n        }\n\n        if (traverse) {\n          var children = tile.children.filter(function (c) {\n            return c;\n          });\n          var _iteratorNormalCompletion4 = true;\n          var _didIteratorError4 = false;\n          var _iteratorError4 = undefined;\n\n          try {\n            for (var _iterator4 = children[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n              var child = _step4.value;\n\n              if (stack.find(child)) {\n                stack[\"delete\"](child);\n              }\n\n              stack.push(child);\n            }\n          } catch (err) {\n            _didIteratorError4 = true;\n            _iteratorError4 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion4 && _iterator4[\"return\"] != null) {\n                _iterator4[\"return\"]();\n              }\n            } finally {\n              if (_didIteratorError4) {\n                throw _iteratorError4;\n              }\n            }\n          }\n        }\n      }\n\n      return allDescendantsLoaded;\n    }\n  }]);\n\n  return TilesetTraverser;\n}();\n\nexport { TilesetTraverser as default };","map":{"version":3,"sources":["../../../../src/tileset/traversers/tileset-traverser.js"],"names":["DEFAULT_OPTIONS","loadSiblings","skipLevelOfDetail","maximumScreenSpaceError","TilesetTraverser","root","frameState","options","stack","tile","shouldRefine","parent","parentRefines","Boolean","stoppedRefining","TILE_REFINEMENT","children","child","checkRefines","hasVisibleChild","childRefines","useParentMetric","ignoreVisibility","screenSpaceError","b","a","useParentScreenSpaceError","rootScreenSpaceError","assert","anyVisible","allDescendantsLoaded","traverse"],"mappings":"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","sourcesContent":["import ManagedArray from '../../utils/managed-array';\nimport {TILE_REFINEMENT} from '../../constants';\nimport {assert} from '@loaders.gl/loader-utils';\n\nexport const DEFAULT_OPTIONS = {\n  loadSiblings: false,\n  skipLevelOfDetail: false,\n  maximumScreenSpaceError: 2\n};\n\nexport default class TilesetTraverser {\n  // TODO nested props\n  constructor(options) {\n    this.options = {...DEFAULT_OPTIONS, ...options};\n    // TRAVERSAL\n    // temporary storage to hold the traversed tiles during a traversal\n    this._traversalStack = new ManagedArray();\n    this._emptyTraversalStack = new ManagedArray();\n\n    // set in every traverse cycle\n    this._frameNumber = null;\n\n    // fulfill in traverse call\n    this.root = null;\n\n    // RESULT\n    // tiles should be rendered\n    this.selectedTiles = {};\n    // tiles should be loaded from server\n    this.requestedTiles = {};\n    // tiles does not have render content\n    this.emptyTiles = {};\n  }\n\n  // tiles should be visible\n  traverse(root, frameState, options) {\n    this.root = root; // for root screen space error\n    this.options = {...this.options, ...options};\n\n    // reset result\n    this.reset();\n\n    // update tile (visibility and expiration)\n    this.updateTile(root, frameState);\n\n    this._frameNumber = frameState.frameNumber;\n    this.executeTraversal(root, frameState);\n  }\n\n  reset() {\n    this.requestedTiles = {};\n    this.selectedTiles = {};\n    this.emptyTiles = {};\n    this._traversalStack.reset();\n    this._emptyTraversalStack.reset();\n  }\n\n  // execute traverse\n  // Depth-first traversal that traverses all visible tiles and marks tiles for selection.\n  // If skipLevelOfDetail is off then a tile does not refine until all children are loaded.\n  // This is the traditional replacement refinement approach and is called the base traversal.\n  // Tiles that have a greater screen space error than the base screen space error are part of the base traversal,\n  // all other tiles are part of the skip traversal. The skip traversal allows for skipping levels of the tree\n  // and rendering children and parent tiles simultaneously.\n  /* eslint-disable-next-line complexity, max-statements */\n  executeTraversal(root, frameState) {\n    // stack to store traversed tiles, only visible tiles should be added to stack\n    // visible: visible in the current view frustum\n    const stack = this._traversalStack;\n\n    stack.push(root);\n    while (stack.length > 0) {\n      // 1. pop tile\n      const tile = stack.pop();\n\n      // 2. check if tile needs to be refine, needs refine if a tile's LoD is not sufficient and tile has available children (available content)\n      let shouldRefine = false;\n      if (this.canTraverse(tile, frameState)) {\n        this.updateChildTiles(tile, frameState);\n        shouldRefine = this.updateAndPushChildren(tile, frameState, stack);\n      }\n\n      // 3. decide if should render (select) this tile\n      //   - tile does not have render content\n      //   - tile has render content and tile is `add` type (pointcloud)\n      //   - tile has render content and tile is `replace` type (photogrammetry) and can't refine any further\n      const parent = tile.parent;\n      const parentRefines = Boolean(!parent || parent._shouldRefine);\n      const stoppedRefining = !shouldRefine;\n\n      if (!tile.hasRenderContent) {\n        this.emptyTiles[tile.id] = tile;\n        this.loadTile(tile, frameState);\n        if (stoppedRefining) {\n          this.selectTile(tile, frameState);\n        }\n        // additive tiles\n      } else if (tile.refine === TILE_REFINEMENT.ADD) {\n        // Additive tiles are always loaded and selected\n        this.loadTile(tile, frameState);\n        this.selectTile(tile, frameState);\n\n        // replace tiles\n      } else if (tile.refine === TILE_REFINEMENT.REPLACE) {\n        // Always load tiles in the base traversal\n        // Select tiles that can't refine further\n        this.loadTile(tile, frameState);\n        if (stoppedRefining) {\n          this.selectTile(tile, frameState);\n        }\n      }\n\n      // 3. update cache, most recent touched tiles have higher priority to be fetched from server\n      this.touchTile(tile, frameState);\n\n      // 4. update tile refine prop and parent refinement status to trickle down to the descendants\n      tile._shouldRefine = shouldRefine && parentRefines;\n    }\n  }\n\n  updateChildTiles(tile, frameState) {\n    const children = tile.children;\n    for (const child of children) {\n      this.updateTile(child, frameState);\n    }\n    return true;\n  }\n\n  /* eslint-disable complexity, max-statements */\n  updateAndPushChildren(tile, frameState, stack) {\n    const {loadSiblings, skipLevelOfDetail} = this.options;\n\n    const children = tile.children;\n\n    // sort children tiles\n    children.sort(this.compareDistanceToCamera);\n\n    // For traditional replacement refinement only refine if all children are loaded.\n    // Empty tiles are exempt since it looks better if children stream in as they are loaded to fill the empty space.\n    const checkRefines =\n      !skipLevelOfDetail && tile.refine === TILE_REFINEMENT.REPLACE && tile.hasRenderContent;\n\n    let hasVisibleChild = false;\n    for (const child of children) {\n      if (child.isVisibleAndInRequestVolume) {\n        if (stack.find(child)) {\n          stack.delete(child);\n        }\n        stack.push(child);\n        hasVisibleChild = true;\n      } else if (checkRefines || loadSiblings) {\n        // Keep non-visible children loaded since they are still needed before the parent can refine.\n        // Or loadSiblings is true so always load tiles regardless of visibility.\n        this.loadTile(child, frameState);\n        this.touchTile(child, frameState);\n      }\n\n      if (checkRefines) {\n        let childRefines;\n        if (!child._inRequestVolume) {\n          childRefines = false;\n        } else if (!child.hasRenderContent) {\n          childRefines = this.executeEmptyTraversal(child, frameState);\n        } else {\n          childRefines = child.contentAvailable;\n        }\n\n        if (!childRefines) {\n          return childRefines;\n        }\n      }\n    }\n\n    return hasVisibleChild;\n  }\n  /* eslint-enable complexity, max-statements */\n\n  updateTile(tile, frameState) {\n    this.updateTileVisibility(tile, frameState);\n  }\n\n  // tile to render in the browser\n  selectTile(tile, frameState) {\n    if (this.shouldSelectTile(tile, frameState)) {\n      // The tile can be selected right away and does not require traverseAndSelect\n      tile._selectedFrame = frameState.frameNumber;\n      this.selectedTiles[tile.id] = tile;\n    }\n  }\n\n  // tile to load from server\n  loadTile(tile, frameState) {\n    if (this.shouldLoadTile(tile, frameState)) {\n      tile._requestedFrame = frameState.frameNumber;\n      tile._priority = this.getPriority(tile);\n      this.requestedTiles[tile.id] = tile;\n    }\n  }\n\n  // cache tile\n  touchTile(tile, frameState) {\n    tile.tileset._cache.touch(tile);\n    tile._touchedFrame = frameState.frameNumber;\n  }\n\n  // tile should be visible\n  // tile should have children\n  // tile LoD (level of detail) is not sufficient under current viewport\n  canTraverse(tile, frameState, useParentMetric = false, ignoreVisibility = false) {\n    if (!ignoreVisibility && !tile.isVisibleAndInRequestVolume) {\n      return false;\n    }\n\n    if (!tile.hasChildren) {\n      return false;\n    }\n\n    // cesium specific\n    if (tile.hasTilesetContent) {\n      // Traverse external this to visit its root tile\n      // Don't traverse if the subtree is expired because it will be destroyed\n      return !tile.contentExpired;\n    }\n\n    return this.shouldRefine(tile, frameState, useParentMetric);\n  }\n\n  shouldLoadTile(tile, frameState) {\n    // if request tile is in current frame\n    // and has unexpired render content\n    return tile.hasUnloadedContent || tile.contentExpired;\n  }\n\n  shouldSelectTile(tile, frameState) {\n    // if select tile is in current frame\n    // and content available\n    return tile.contentAvailable && !this.options.skipLevelOfDetail;\n  }\n\n  // Decide if tile LoD (level of detail) is not sufficient under current viewport\n  shouldRefine(tile, frameState, useParentMetric) {\n    let screenSpaceError = tile._screenSpaceError;\n    if (useParentMetric) {\n      screenSpaceError = tile.getScreenSpaceError(frameState, true);\n    }\n\n    return screenSpaceError > this.options.maximumScreenSpaceError;\n  }\n\n  updateTileVisibility(tile, frameState) {\n    tile.updateVisibility(frameState);\n  }\n\n  // UTILITIES\n\n  compareDistanceToCamera(b, a) {\n    return b._distanceToCamera - a._distanceToCamera;\n  }\n\n  // If skipLevelOfDetail is off try to load child tiles as soon as possible so that their parent can refine sooner.\n  // Additive tiles are prioritized by distance because it subjectively looks better.\n  // Replacement tiles are prioritized by screen space error.\n  // A tileset that has both additive and replacement tiles may not prioritize tiles as effectively since SSE and distance\n  // are different types of values. Maybe all priorities need to be normalized to 0-1 range.\n  // TODO move to tile-3d-header\n  getPriority(tile) {\n    const {options} = this;\n    switch (tile.refine) {\n      case TILE_REFINEMENT.ADD:\n        return tile._distanceToCamera;\n\n      case TILE_REFINEMENT.REPLACE:\n        const {parent} = tile;\n        const useParentScreenSpaceError =\n          parent &&\n          (!options.skipLevelOfDetail ||\n            tile._screenSpaceError === 0.0 ||\n            parent.hasTilesetContent);\n        const screenSpaceError = useParentScreenSpaceError\n          ? parent._screenSpaceError\n          : tile._screenSpaceError;\n        const rootScreenSpaceError = this.root._screenSpaceError;\n        return rootScreenSpaceError - screenSpaceError; // Map higher SSE to lower values (e.g. root tile is highest priority)\n\n      default:\n        return assert(false);\n    }\n  }\n\n  anyChildrenVisible(tile, frameState) {\n    let anyVisible = false;\n    for (const child of tile.children) {\n      child.updateVisibility(frameState);\n      anyVisible = anyVisible || child.isVisibleAndInRequestVolume;\n    }\n    return anyVisible;\n  }\n\n  // TODO revisit this empty traversal logic\n  // Depth-first traversal that checks if all nearest descendants with content are loaded.\n  // Ignores visibility.\n  executeEmptyTraversal(root, frameState) {\n    let allDescendantsLoaded = true;\n    const stack = this._emptyTraversalStack;\n\n    while (stack.length > 0) {\n      const tile = stack.pop();\n\n      this.updateTile(tile, frameState);\n\n      if (!tile.isVisibleAndInRequestVolume) {\n        // Load tiles that aren't visible since they are still needed for the parent to refine\n        this.loadTile(tile, frameState);\n        this.touchTile(tile, frameState);\n      }\n\n      // Only traverse if the tile is empty - traversal stop at descendants with content\n      const traverse = !tile.hasRenderContent && this.canTraverse(tile, frameState, false, true);\n\n      // Traversal stops but the tile does not have content yet.\n      // There will be holes if the parent tries to refine to its children, so don't refine.\n      if (!traverse && !tile.contentAvailable) {\n        allDescendantsLoaded = false;\n      }\n\n      if (traverse) {\n        const children = tile.children.filter(c => c);\n        for (const child of children) {\n          // eslint-disable-next-line max-depth\n          if (stack.find(child)) {\n            stack.delete(child);\n          }\n          stack.push(child);\n        }\n      }\n    }\n\n    return allDescendantsLoaded;\n  }\n}\n\n// TODO\n// enable expiration\n// enable optimization hint\n"]},"metadata":{},"sourceType":"module"}