{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { Vector3, equals as _equals, assert, MathUtils } from 'math.gl';\nvar scratchPosition = new Vector3();\nvar scratchNormal = new Vector3();\n\nvar Plane = function () {\n  function Plane() {\n    var normal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 1];\n    var distance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _classCallCheck(this, Plane);\n\n    this.normal = new Vector3();\n    this.distance = -0;\n    this.fromNormalDistance(normal, distance);\n  }\n\n  _createClass(Plane, [{\n    key: \"fromNormalDistance\",\n    value: function fromNormalDistance(normal, distance) {\n      assert(Number.isFinite(distance));\n      this.normal.from(normal).normalize();\n      this.distance = distance;\n      return this;\n    }\n  }, {\n    key: \"fromPointNormal\",\n    value: function fromPointNormal(point, normal) {\n      point = scratchPosition.from(point);\n      this.normal.from(normal).normalize();\n      var distance = -this.normal.dot(point);\n      this.distance = distance;\n      return this;\n    }\n  }, {\n    key: \"fromCoefficients\",\n    value: function fromCoefficients(a, b, c, d) {\n      this.normal.set(a, b, c);\n      assert(_equals(this.normal.len(), 1));\n      this.distance = d;\n      return this;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone(plane) {\n      return new Plane(this.normal, this.distance);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(right) {\n      return _equals(this.distance, right.distance) && _equals(this.normal, right.normal);\n    }\n  }, {\n    key: \"getPointDistance\",\n    value: function getPointDistance(point) {\n      return this.normal.dot(point) + this.distance;\n    }\n  }, {\n    key: \"transform\",\n    value: function transform(matrix4) {\n      var normal = scratchNormal.copy(this.normal).transformAsVector(matrix4).normalize();\n      var point = this.normal.scale(-this.distance).transform(matrix4);\n      return this.fromPointNormal(point, normal);\n    }\n  }, {\n    key: \"projectPointOntoPlane\",\n    value: function projectPointOntoPlane(point) {\n      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n      point = scratchPosition.from(point);\n      var pointDistance = this.getPointDistance(point);\n      var scaledNormal = scratchNormal.copy(this.normal).scale(pointDistance);\n      return point.subtract(scaledNormal).to(result);\n    }\n  }]);\n\n  return Plane;\n}();\n\nexport { Plane as default };","map":{"version":3,"sources":["../../../src/lib/plane.js"],"names":["equals","scratchPosition","scratchNormal","Plane","normal","distance","assert","Number","point","a","b","c","d","plane","right","matrix4","result","pointDistance","scaledNormal"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/* eslint-disable */\nimport {Vector3, equals, assert, MathUtils} from 'math.gl';\n\nconst scratchPosition = new Vector3();\nconst scratchNormal = new Vector3();\n\n// A plane in Hessian Normal Form\nexport default class Plane {\n  constructor(normal = [0, 0, 1], distance = 0) {\n    this.normal = new Vector3();\n    this.distance = -0;\n    this.fromNormalDistance(normal, distance);\n  }\n\n  fromNormalDistance(normal, distance) {\n    assert(Number.isFinite(distance));\n    this.normal.from(normal).normalize();\n    this.distance = distance;\n    return this;\n  }\n\n  // Creates a plane from a normal and a point on the plane.\n  fromPointNormal(point, normal) {\n    point = scratchPosition.from(point);\n    this.normal.from(normal).normalize();\n    const distance = -this.normal.dot(point);\n    this.distance = distance;\n\n    return this;\n  }\n\n  // Creates a plane from the general equation\n  fromCoefficients(a, b, c, d) {\n    this.normal.set(a, b, c);\n    assert(equals(this.normal.len(), 1));\n    this.distance = d;\n    return this;\n  }\n\n  // Duplicates a Plane instance.\n  clone(plane) {\n    return new Plane(this.normal, this.distance);\n  }\n\n  // Compares the provided Planes by normal and distance\n  equals(right) {\n    return equals(this.distance, right.distance) && equals(this.normal, right.normal);\n  }\n\n  // Computes the signed shortest distance of a point to a plane.\n  // The sign of the distance determines which side of the plane the point is on.\n  getPointDistance(point) {\n    return this.normal.dot(point) + this.distance;\n  }\n\n  // Transforms the plane by the given transformation matrix.\n  transform(matrix4) {\n    const normal = scratchNormal\n      .copy(this.normal)\n      .transformAsVector(matrix4)\n      .normalize();\n    const point = this.normal.scale(-this.distance).transform(matrix4);\n    return this.fromPointNormal(point, normal);\n  }\n\n  // Projects a point onto the plane.\n  projectPointOntoPlane(point, result = [0, 0, 0]) {\n    point = scratchPosition.from(point);\n    // projectedPoint = point - (normal.point + scale) * normal\n    const pointDistance = this.getPointDistance(point);\n    const scaledNormal = scratchNormal.copy(this.normal).scale(pointDistance);\n\n    return point.subtract(scaledNormal).to(result);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}