{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nvar _DEFAULT_TEXTURE_PARA;\n\nimport { Texture2D, copyToTexture, cloneTextureFrom } from '@luma.gl/core';\nimport { ImageLoader } from '@loaders.gl/images';\nimport { load } from '@loaders.gl/core';\nimport { createIterable, log } from '@deck.gl/core';\nvar DEFAULT_CANVAS_WIDTH = 1024;\nvar DEFAULT_BUFFER = 4;\n\nvar noop = function noop() {};\n\nvar DEFAULT_TEXTURE_PARAMETERS = (_DEFAULT_TEXTURE_PARA = {}, _defineProperty(_DEFAULT_TEXTURE_PARA, 10241, 9987), _defineProperty(_DEFAULT_TEXTURE_PARA, 10240, 9729), _defineProperty(_DEFAULT_TEXTURE_PARA, 10242, 33071), _defineProperty(_DEFAULT_TEXTURE_PARA, 10243, 33071), _DEFAULT_TEXTURE_PARA);\n\nfunction nextPowOfTwo(number) {\n  return Math.pow(2, Math.ceil(Math.log2(number)));\n}\n\nfunction resizeImage(ctx, imageData, width, height) {\n  var naturalWidth = imageData.naturalWidth,\n      naturalHeight = imageData.naturalHeight;\n\n  if (width === naturalWidth && height === naturalHeight) {\n    return imageData;\n  }\n\n  ctx.canvas.height = height;\n  ctx.canvas.width = width;\n  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n  ctx.drawImage(imageData, 0, 0, naturalWidth, naturalHeight, 0, 0, width, height);\n  return ctx.canvas;\n}\n\nfunction getIconId(icon) {\n  return icon && (icon.id || icon.url);\n}\n\nfunction resizeTexture(gl, texture, width, height) {\n  var oldWidth = texture.width;\n  var oldHeight = texture.height;\n  var newTexture = cloneTextureFrom(texture, {\n    width: width,\n    height: height\n  });\n  copyToTexture(texture, newTexture, {\n    targetY: 0,\n    width: oldWidth,\n    height: oldHeight\n  });\n  texture[\"delete\"]();\n  return newTexture;\n}\n\nfunction buildRowMapping(mapping, columns, yOffset) {\n  for (var i = 0; i < columns.length; i++) {\n    var _columns$i = columns[i],\n        icon = _columns$i.icon,\n        xOffset = _columns$i.xOffset;\n    var id = getIconId(icon);\n    mapping[id] = Object.assign({}, icon, {\n      x: xOffset,\n      y: yOffset\n    });\n  }\n}\n\nexport function buildMapping(_ref) {\n  var icons = _ref.icons,\n      buffer = _ref.buffer,\n      _ref$mapping = _ref.mapping,\n      mapping = _ref$mapping === void 0 ? {} : _ref$mapping,\n      _ref$xOffset = _ref.xOffset,\n      xOffset = _ref$xOffset === void 0 ? 0 : _ref$xOffset,\n      _ref$yOffset = _ref.yOffset,\n      yOffset = _ref$yOffset === void 0 ? 0 : _ref$yOffset,\n      _ref$rowHeight = _ref.rowHeight,\n      rowHeight = _ref$rowHeight === void 0 ? 0 : _ref$rowHeight,\n      canvasWidth = _ref.canvasWidth;\n  var columns = [];\n\n  for (var i = 0; i < icons.length; i++) {\n    var icon = icons[i];\n    var id = getIconId(icon);\n\n    if (!mapping[id]) {\n      var height = icon.height,\n          width = icon.width;\n\n      if (xOffset + width + buffer > canvasWidth) {\n        buildRowMapping(mapping, columns, yOffset);\n        xOffset = 0;\n        yOffset = rowHeight + yOffset + buffer;\n        rowHeight = 0;\n        columns = [];\n      }\n\n      columns.push({\n        icon: icon,\n        xOffset: xOffset\n      });\n      xOffset = xOffset + width + buffer;\n      rowHeight = Math.max(rowHeight, height);\n    }\n  }\n\n  if (columns.length > 0) {\n    buildRowMapping(mapping, columns, yOffset);\n  }\n\n  return {\n    mapping: mapping,\n    rowHeight: rowHeight,\n    xOffset: xOffset,\n    yOffset: yOffset,\n    canvasWidth: canvasWidth,\n    canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer)\n  };\n}\nexport function getDiffIcons(data, getIcon, cachedIcons) {\n  if (!data || !getIcon) {\n    return null;\n  }\n\n  cachedIcons = cachedIcons || {};\n  var icons = {};\n\n  var _createIterable = createIterable(data),\n      iterable = _createIterable.iterable,\n      objectInfo = _createIterable.objectInfo;\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var object = _step.value;\n      objectInfo.index++;\n      var icon = getIcon(object, objectInfo);\n      var id = getIconId(icon);\n\n      if (!icon) {\n        throw new Error('Icon is missing.');\n      }\n\n      if (!icon.url) {\n        throw new Error('Icon url is missing.');\n      }\n\n      if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {\n        icons[id] = icon;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return icons;\n}\n\nvar IconManager = function () {\n  function IconManager(gl, _ref2) {\n    var _ref2$onUpdate = _ref2.onUpdate,\n        onUpdate = _ref2$onUpdate === void 0 ? noop : _ref2$onUpdate;\n\n    _classCallCheck(this, IconManager);\n\n    this.gl = gl;\n    this.onUpdate = onUpdate;\n    this._loadOptions = null;\n    this._getIcon = null;\n    this._texture = null;\n    this._externalTexture = null;\n    this._mapping = {};\n    this._pendingCount = 0;\n    this._autoPacking = false;\n    this._xOffset = 0;\n    this._yOffset = 0;\n    this._rowHeight = 0;\n    this._buffer = DEFAULT_BUFFER;\n    this._canvasWidth = DEFAULT_CANVAS_WIDTH;\n    this._canvasHeight = 0;\n    this._canvas = null;\n  }\n\n  _createClass(IconManager, [{\n    key: \"finalize\",\n    value: function finalize() {\n      if (this._texture) {\n        this._texture[\"delete\"]();\n      }\n    }\n  }, {\n    key: \"getTexture\",\n    value: function getTexture() {\n      return this._texture || this._externalTexture;\n    }\n  }, {\n    key: \"getIconMapping\",\n    value: function getIconMapping(icon) {\n      var id = this._autoPacking ? getIconId(icon) : icon;\n      return this._mapping[id] || {};\n    }\n  }, {\n    key: \"setProps\",\n    value: function setProps(_ref3) {\n      var loadOptions = _ref3.loadOptions,\n          autoPacking = _ref3.autoPacking,\n          iconAtlas = _ref3.iconAtlas,\n          iconMapping = _ref3.iconMapping,\n          data = _ref3.data,\n          getIcon = _ref3.getIcon;\n\n      if (loadOptions) {\n        this._loadOptions = loadOptions;\n      }\n\n      if (autoPacking !== undefined) {\n        this._autoPacking = autoPacking;\n      }\n\n      if (getIcon) {\n        this._getIcon = getIcon;\n      }\n\n      if (iconMapping) {\n        this._mapping = iconMapping;\n      }\n\n      if (iconAtlas) {\n        this._updateIconAtlas(iconAtlas);\n      }\n\n      if (this._autoPacking && (data || getIcon) && typeof document !== 'undefined') {\n        this._canvas = this._canvas || document.createElement('canvas');\n\n        this._updateAutoPacking(data);\n      }\n    }\n  }, {\n    key: \"_updateIconAtlas\",\n    value: function _updateIconAtlas(iconAtlas) {\n      if (this._texture) {\n        this._texture[\"delete\"]();\n\n        this._texture = null;\n      }\n\n      if (iconAtlas instanceof Texture2D) {\n        iconAtlas.setParameters(DEFAULT_TEXTURE_PARAMETERS);\n        this._externalTexture = iconAtlas;\n        this.onUpdate();\n      } else if (iconAtlas) {\n        this._texture = new Texture2D(this.gl, {\n          data: iconAtlas,\n          parameters: DEFAULT_TEXTURE_PARAMETERS\n        });\n        this.onUpdate();\n      }\n    }\n  }, {\n    key: \"_updateAutoPacking\",\n    value: function _updateAutoPacking(data) {\n      var icons = Object.values(getDiffIcons(data, this._getIcon, this._mapping) || {});\n\n      if (icons.length > 0) {\n        var _buildMapping = buildMapping({\n          icons: icons,\n          buffer: this._buffer,\n          canvasWidth: this._canvasWidth,\n          mapping: this._mapping,\n          rowHeight: this._rowHeight,\n          xOffset: this._xOffset,\n          yOffset: this._yOffset\n        }),\n            mapping = _buildMapping.mapping,\n            xOffset = _buildMapping.xOffset,\n            yOffset = _buildMapping.yOffset,\n            rowHeight = _buildMapping.rowHeight,\n            canvasHeight = _buildMapping.canvasHeight;\n\n        this._rowHeight = rowHeight;\n        this._mapping = mapping;\n        this._xOffset = xOffset;\n        this._yOffset = yOffset;\n        this._canvasHeight = canvasHeight;\n\n        if (!this._texture) {\n          this._texture = new Texture2D(this.gl, {\n            width: this._canvasWidth,\n            height: this._canvasHeight,\n            parameters: DEFAULT_TEXTURE_PARAMETERS\n          });\n        }\n\n        if (this._texture.height !== this._canvasHeight) {\n          this._texture = resizeTexture(this.gl, this._texture, this._canvasWidth, this._canvasHeight);\n        }\n\n        this.onUpdate();\n\n        this._loadIcons(icons);\n      }\n    }\n  }, {\n    key: \"_loadIcons\",\n    value: function _loadIcons(icons) {\n      var _this = this;\n\n      var ctx = this._canvas.getContext('2d');\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        var _loop = function _loop() {\n          var icon = _step2.value;\n          _this._pendingCount++;\n          load(icon.url, ImageLoader, _this._loadOptions).then(function (imageData) {\n            var id = getIconId(icon);\n            var _this$_mapping$id = _this._mapping[id],\n                x = _this$_mapping$id.x,\n                y = _this$_mapping$id.y,\n                width = _this$_mapping$id.width,\n                height = _this$_mapping$id.height;\n            var data = resizeImage(ctx, imageData, width, height);\n\n            _this._texture.setSubImageData({\n              data: data,\n              x: x,\n              y: y,\n              width: width,\n              height: height\n            });\n\n            _this._texture.generateMipmap();\n\n            _this.onUpdate();\n          })[\"catch\"](function (error) {\n            log.error(error)();\n          })[\"finally\"](function () {\n            _this._pendingCount--;\n          });\n        };\n\n        for (var _iterator2 = icons[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          _loop();\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"isLoaded\",\n    get: function get() {\n      return this._pendingCount === 0;\n    }\n  }]);\n\n  return IconManager;\n}();\n\nexport { IconManager as default };","map":{"version":3,"sources":["../../../src/icon-layer/icon-manager.js"],"names":["DEFAULT_CANVAS_WIDTH","DEFAULT_BUFFER","noop","DEFAULT_TEXTURE_PARAMETERS","Math","naturalWidth","naturalHeight","imageData","width","height","ctx","icon","oldWidth","texture","oldHeight","newTexture","cloneTextureFrom","copyToTexture","targetY","i","columns","xOffset","id","getIconId","mapping","x","y","yOffset","icons","buffer","rowHeight","canvasWidth","buildRowMapping","canvasHeight","nextPowOfTwo","cachedIcons","iterable","objectInfo","createIterable","object","getIcon","IconManager","onUpdate","loadOptions","autoPacking","iconAtlas","iconMapping","data","document","parameters","Object","getDiffIcons","buildMapping","_yOffset","resizeTexture","load","resizeImage","log"],"mappings":"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","sourcesContent":["/* global document */\nimport GL from '@luma.gl/constants';\nimport {Texture2D, copyToTexture, cloneTextureFrom} from '@luma.gl/core';\nimport {ImageLoader} from '@loaders.gl/images';\nimport {load} from '@loaders.gl/core';\nimport {createIterable, log} from '@deck.gl/core';\n\nconst DEFAULT_CANVAS_WIDTH = 1024;\nconst DEFAULT_BUFFER = 4;\n\nconst noop = () => {};\n\nconst DEFAULT_TEXTURE_PARAMETERS = {\n  [GL.TEXTURE_MIN_FILTER]: GL.LINEAR_MIPMAP_LINEAR,\n  // GL.LINEAR is the default value but explicitly set it here\n  [GL.TEXTURE_MAG_FILTER]: GL.LINEAR,\n  // for texture boundary artifact\n  [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n  [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n};\n\nfunction nextPowOfTwo(number) {\n  return Math.pow(2, Math.ceil(Math.log2(number)));\n}\n\n// update comment to create a new texture and copy original data.\nfunction resizeImage(ctx, imageData, width, height) {\n  const {naturalWidth, naturalHeight} = imageData;\n  if (width === naturalWidth && height === naturalHeight) {\n    return imageData;\n  }\n\n  ctx.canvas.height = height;\n  ctx.canvas.width = width;\n\n  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n  // image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight\n  ctx.drawImage(imageData, 0, 0, naturalWidth, naturalHeight, 0, 0, width, height);\n\n  return ctx.canvas;\n}\n\nfunction getIconId(icon) {\n  return icon && (icon.id || icon.url);\n}\n\n// resize texture without losing original data\nfunction resizeTexture(gl, texture, width, height) {\n  const oldWidth = texture.width;\n  const oldHeight = texture.height;\n\n  const newTexture = cloneTextureFrom(texture, {width, height});\n  copyToTexture(texture, newTexture, {\n    targetY: 0,\n    width: oldWidth,\n    height: oldHeight\n  });\n\n  texture.delete();\n  return newTexture;\n}\n\n// traverse icons in a row of icon atlas\n// extend each icon with left-top coordinates\nfunction buildRowMapping(mapping, columns, yOffset) {\n  for (let i = 0; i < columns.length; i++) {\n    const {icon, xOffset} = columns[i];\n    const id = getIconId(icon);\n    mapping[id] = Object.assign({}, icon, {\n      x: xOffset,\n      y: yOffset\n    });\n  }\n}\n\n/**\n * Generate coordinate mapping to retrieve icon left-top position from an icon atlas\n * @param icons {Array<Object>} list of icons, each icon requires url, width, height\n * @param buffer {Number} add buffer to the right and bottom side of the image\n * @param xOffset {Number} right position of last icon in old mapping\n * @param yOffset {Number} top position in last icon in old mapping\n * @param rowHeight {Number} rowHeight of the last icon's row\n * @param canvasWidth {Number} max width of canvas\n * @param mapping {object} old mapping\n * @returns {{mapping: {'/icon/1': {url, width, height, ...}},, canvasHeight: {Number}}}\n */\nexport function buildMapping({\n  icons,\n  buffer,\n  mapping = {},\n  xOffset = 0,\n  yOffset = 0,\n  rowHeight = 0,\n  canvasWidth\n}) {\n  let columns = [];\n  // Strategy to layout all the icons into a texture:\n  // traverse the icons sequentially, layout the icons from left to right, top to bottom\n  // when the sum of the icons width is equal or larger than canvasWidth,\n  // move to next row starting from total height so far plus max height of the icons in previous row\n  // row width is equal to canvasWidth\n  // row height is decided by the max height of the icons in that row\n  // mapping coordinates of each icon is its left-top position in the texture\n  for (let i = 0; i < icons.length; i++) {\n    const icon = icons[i];\n    const id = getIconId(icon);\n\n    if (!mapping[id]) {\n      const {height, width} = icon;\n\n      // fill one row\n      if (xOffset + width + buffer > canvasWidth) {\n        buildRowMapping(mapping, columns, yOffset);\n\n        xOffset = 0;\n        yOffset = rowHeight + yOffset + buffer;\n        rowHeight = 0;\n        columns = [];\n      }\n\n      columns.push({\n        icon,\n        xOffset\n      });\n\n      xOffset = xOffset + width + buffer;\n      rowHeight = Math.max(rowHeight, height);\n    }\n  }\n\n  if (columns.length > 0) {\n    buildRowMapping(mapping, columns, yOffset);\n  }\n\n  return {\n    mapping,\n    rowHeight,\n    xOffset,\n    yOffset,\n    canvasWidth,\n    canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer)\n  };\n}\n\n// extract icons from data\n// return icons should be unique, and not cached or cached but url changed\nexport function getDiffIcons(data, getIcon, cachedIcons) {\n  if (!data || !getIcon) {\n    return null;\n  }\n\n  cachedIcons = cachedIcons || {};\n  const icons = {};\n  const {iterable, objectInfo} = createIterable(data);\n  for (const object of iterable) {\n    objectInfo.index++;\n    const icon = getIcon(object, objectInfo);\n    const id = getIconId(icon);\n\n    if (!icon) {\n      throw new Error('Icon is missing.');\n    }\n\n    if (!icon.url) {\n      throw new Error('Icon url is missing.');\n    }\n\n    if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {\n      icons[id] = icon;\n    }\n  }\n  return icons;\n}\n\nexport default class IconManager {\n  constructor(\n    gl,\n    {\n      onUpdate = noop // notify IconLayer when icon texture update\n    }\n  ) {\n    this.gl = gl;\n    this.onUpdate = onUpdate;\n\n    // load options used for loading images\n    this._loadOptions = null;\n    this._getIcon = null;\n\n    this._texture = null;\n    this._externalTexture = null;\n    this._mapping = {};\n    // count of pending requests to fetch icons\n    this._pendingCount = 0;\n\n    this._autoPacking = false;\n\n    // internal props used when autoPacking applied\n    // right position of last icon\n    this._xOffset = 0;\n    // top position of last icon\n    this._yOffset = 0;\n    this._rowHeight = 0;\n    this._buffer = DEFAULT_BUFFER;\n    this._canvasWidth = DEFAULT_CANVAS_WIDTH;\n    this._canvasHeight = 0;\n    this._canvas = null;\n  }\n\n  finalize() {\n    if (this._texture) {\n      this._texture.delete();\n    }\n  }\n\n  getTexture() {\n    return this._texture || this._externalTexture;\n  }\n\n  getIconMapping(icon) {\n    const id = this._autoPacking ? getIconId(icon) : icon;\n    return this._mapping[id] || {};\n  }\n\n  setProps({loadOptions, autoPacking, iconAtlas, iconMapping, data, getIcon}) {\n    if (loadOptions) {\n      this._loadOptions = loadOptions;\n    }\n\n    if (autoPacking !== undefined) {\n      this._autoPacking = autoPacking;\n    }\n\n    if (getIcon) {\n      this._getIcon = getIcon;\n    }\n\n    if (iconMapping) {\n      this._mapping = iconMapping;\n    }\n\n    if (iconAtlas) {\n      this._updateIconAtlas(iconAtlas);\n    }\n\n    if (this._autoPacking && (data || getIcon) && typeof document !== 'undefined') {\n      this._canvas = this._canvas || document.createElement('canvas');\n\n      this._updateAutoPacking(data);\n    }\n  }\n\n  get isLoaded() {\n    return this._pendingCount === 0;\n  }\n\n  _updateIconAtlas(iconAtlas) {\n    if (this._texture) {\n      this._texture.delete();\n      this._texture = null;\n    }\n    if (iconAtlas instanceof Texture2D) {\n      iconAtlas.setParameters(DEFAULT_TEXTURE_PARAMETERS);\n\n      this._externalTexture = iconAtlas;\n      this.onUpdate();\n    } else if (iconAtlas) {\n      // Browser object: Image, ImageData, HTMLCanvasElement, ImageBitmap\n      this._texture = new Texture2D(this.gl, {\n        data: iconAtlas,\n        parameters: DEFAULT_TEXTURE_PARAMETERS\n      });\n      this.onUpdate();\n    }\n  }\n\n  _updateAutoPacking(data) {\n    const icons = Object.values(getDiffIcons(data, this._getIcon, this._mapping) || {});\n\n    if (icons.length > 0) {\n      // generate icon mapping\n      const {mapping, xOffset, yOffset, rowHeight, canvasHeight} = buildMapping({\n        icons,\n        buffer: this._buffer,\n        canvasWidth: this._canvasWidth,\n        mapping: this._mapping,\n        rowHeight: this._rowHeight,\n        xOffset: this._xOffset,\n        yOffset: this._yOffset\n      });\n\n      this._rowHeight = rowHeight;\n      this._mapping = mapping;\n      this._xOffset = xOffset;\n      this._yOffset = yOffset;\n      this._canvasHeight = canvasHeight;\n\n      // create new texture\n      if (!this._texture) {\n        this._texture = new Texture2D(this.gl, {\n          width: this._canvasWidth,\n          height: this._canvasHeight,\n          parameters: DEFAULT_TEXTURE_PARAMETERS\n        });\n      }\n\n      if (this._texture.height !== this._canvasHeight) {\n        this._texture = resizeTexture(\n          this.gl,\n          this._texture,\n          this._canvasWidth,\n          this._canvasHeight\n        );\n      }\n\n      this.onUpdate();\n\n      // load images\n      this._loadIcons(icons);\n    }\n  }\n\n  _loadIcons(icons) {\n    const ctx = this._canvas.getContext('2d');\n\n    for (const icon of icons) {\n      this._pendingCount++;\n      load(icon.url, ImageLoader, this._loadOptions)\n        .then(imageData => {\n          const id = getIconId(icon);\n          const {x, y, width, height} = this._mapping[id];\n\n          const data = resizeImage(ctx, imageData, width, height);\n\n          this._texture.setSubImageData({\n            data,\n            x,\n            y,\n            width,\n            height\n          });\n\n          // Call to regenerate mipmaps after modifying texture(s)\n          this._texture.generateMipmap();\n\n          this.onUpdate();\n        })\n        .catch(error => {\n          log.error(error)();\n        })\n        .finally(() => {\n          this._pendingCount--;\n        });\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}