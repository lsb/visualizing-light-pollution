{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nvar _MODULE_INJECTORS;\n\nimport { MODULE_INJECTORS_VS, MODULE_INJECTORS_FS } from '../modules/module-injectors';\nimport { VERTEX_SHADER, FRAGMENT_SHADER } from './constants';\nimport { assert } from '../utils';\nvar MODULE_INJECTORS = (_MODULE_INJECTORS = {}, _defineProperty(_MODULE_INJECTORS, VERTEX_SHADER, MODULE_INJECTORS_VS), _defineProperty(_MODULE_INJECTORS, FRAGMENT_SHADER, MODULE_INJECTORS_FS), _MODULE_INJECTORS);\nexport var DECLARATION_INJECT_MARKER = '__LUMA_INJECT_DECLARATIONS__';\nvar REGEX_START_OF_MAIN = /void\\s+main\\s*\\([^)]*\\)\\s*\\{\\n?/;\nvar REGEX_END_OF_MAIN = /}\\n?[^{}]*$/;\nvar fragments = [];\nexport default function injectShader(source, type, inject, injectStandardStubs) {\n  var isVertex = type === VERTEX_SHADER;\n\n  var _loop = function _loop(key) {\n    var fragmentData = inject[key];\n    fragmentData.sort(function (a, b) {\n      return a.order - b.order;\n    });\n    fragments.length = fragmentData.length;\n\n    for (var i = 0, len = fragmentData.length; i < len; ++i) {\n      fragments[i] = fragmentData[i].injection;\n    }\n\n    var fragmentString = \"\".concat(fragments.join('\\n'), \"\\n\");\n\n    switch (key) {\n      case 'vs:#decl':\n        if (isVertex) {\n          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n        }\n\n        break;\n\n      case 'vs:#main-start':\n        if (isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, function (match) {\n            return match + fragmentString;\n          });\n        }\n\n        break;\n\n      case 'vs:#main-end':\n        if (isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, function (match) {\n            return fragmentString + match;\n          });\n        }\n\n        break;\n\n      case 'fs:#decl':\n        if (!isVertex) {\n          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n        }\n\n        break;\n\n      case 'fs:#main-start':\n        if (!isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, function (match) {\n            return match + fragmentString;\n          });\n        }\n\n        break;\n\n      case 'fs:#main-end':\n        if (!isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, function (match) {\n            return fragmentString + match;\n          });\n        }\n\n        break;\n\n      default:\n        source = source.replace(key, function (match) {\n          return match + fragmentString;\n        });\n    }\n  };\n\n  for (var key in inject) {\n    _loop(key);\n  }\n\n  source = source.replace(DECLARATION_INJECT_MARKER, '');\n\n  if (injectStandardStubs) {\n    source = source.replace(/\\}\\s*$/, function (match) {\n      return match + MODULE_INJECTORS[type];\n    });\n  }\n\n  return source;\n}\nexport function combineInjects(injects) {\n  var result = {};\n  assert(Array.isArray(injects) && injects.length > 1);\n  injects.forEach(function (inject) {\n    for (var key in inject) {\n      result[key] = result[key] ? \"\".concat(result[key], \"\\n\").concat(inject[key]) : inject[key];\n    }\n  });\n  return result;\n}","map":{"version":3,"sources":["../../../src/lib/inject-shader.js"],"names":["MODULE_INJECTORS","DECLARATION_INJECT_MARKER","REGEX_START_OF_MAIN","REGEX_END_OF_MAIN","fragments","isVertex","type","key","fragmentData","inject","a","b","i","len","fragmentString","source","match","result","assert","Array","injects"],"mappings":"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","sourcesContent":["import {MODULE_INJECTORS_VS, MODULE_INJECTORS_FS} from '../modules/module-injectors';\nimport {VERTEX_SHADER, FRAGMENT_SHADER} from './constants';\nimport {assert} from '../utils';\n\n// TODO - experimental\nconst MODULE_INJECTORS = {\n  [VERTEX_SHADER]: MODULE_INJECTORS_VS,\n  [FRAGMENT_SHADER]: MODULE_INJECTORS_FS\n};\n\nexport const DECLARATION_INJECT_MARKER = '__LUMA_INJECT_DECLARATIONS__'; // Uniform/attribute declarations\n\nconst REGEX_START_OF_MAIN = /void\\s+main\\s*\\([^)]*\\)\\s*\\{\\n?/; // Beginning of main\nconst REGEX_END_OF_MAIN = /}\\n?[^{}]*$/; // End of main, assumes main is last function\nconst fragments = [];\n\n// A minimal shader injection/templating system.\n// RFC: https://github.com/uber/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/shader-injection-rfc.md\n/* eslint-disable complexity */\nexport default function injectShader(source, type, inject, injectStandardStubs) {\n  const isVertex = type === VERTEX_SHADER;\n\n  for (const key in inject) {\n    const fragmentData = inject[key];\n    fragmentData.sort((a, b) => a.order - b.order);\n    fragments.length = fragmentData.length;\n    for (let i = 0, len = fragmentData.length; i < len; ++i) {\n      fragments[i] = fragmentData[i].injection;\n    }\n    const fragmentString = `${fragments.join('\\n')}\\n`;\n    switch (key) {\n      // declarations are injected before the main function\n      case 'vs:#decl':\n        if (isVertex) {\n          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n        }\n        break;\n      // main code is injected at the end of main function\n      case 'vs:#main-start':\n        if (isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);\n        }\n        break;\n      case 'vs:#main-end':\n        if (isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);\n        }\n        break;\n      case 'fs:#decl':\n        if (!isVertex) {\n          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n        }\n        break;\n      case 'fs:#main-start':\n        if (!isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);\n        }\n        break;\n      case 'fs:#main-end':\n        if (!isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);\n        }\n        break;\n\n      default:\n        // TODO(Tarek): I think this usage should be deprecated.\n\n        // inject code after key, leaving key in place\n        source = source.replace(key, match => match + fragmentString);\n    }\n  }\n\n  // Remove if it hasn't already been replaced\n  source = source.replace(DECLARATION_INJECT_MARKER, '');\n\n  // Finally, if requested, insert an automatic module injector chunk\n  if (injectStandardStubs) {\n    source = source.replace(/\\}\\s*$/, match => match + MODULE_INJECTORS[type]);\n  }\n\n  return source;\n}\n\n/* eslint-enable complexity */\n\n// Takes an array of inject objects and combines them into one\nexport function combineInjects(injects) {\n  const result = {};\n  assert(Array.isArray(injects) && injects.length > 1);\n  injects.forEach(inject => {\n    for (const key in inject) {\n      result[key] = result[key] ? `${result[key]}\\n${inject[key]}` : inject[key];\n    }\n  });\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}