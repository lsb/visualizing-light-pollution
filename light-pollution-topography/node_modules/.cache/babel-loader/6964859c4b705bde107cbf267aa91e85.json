{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { Vector3, Matrix4, assert } from 'math.gl';\nimport CullingVolume from './culling-volume';\nimport Plane from './plane';\nvar scratchPlaneUpVector = new Vector3();\nvar scratchPlaneRightVector = new Vector3();\nvar scratchPlaneNearCenter = new Vector3();\nvar scratchPlaneFarCenter = new Vector3();\nvar scratchPlaneNormal = new Vector3();\n\nvar PerspectiveOffCenterFrustum = function () {\n  function PerspectiveOffCenterFrustum() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, PerspectiveOffCenterFrustum);\n\n    options = _objectSpread({\n      near: 1.0,\n      far: 500000000.0\n    }, options);\n    this.left = options.left;\n    this._left = undefined;\n    this.right = options.right;\n    this._right = undefined;\n    this.top = options.top;\n    this._top = undefined;\n    this.bottom = options.bottom;\n    this._bottom = undefined;\n    this.near = options.near;\n    this._near = this.near;\n    this.far = options.far;\n    this._far = this.far;\n    this._cullingVolume = new CullingVolume([new Plane(), new Plane(), new Plane(), new Plane(), new Plane(), new Plane()]);\n    this._perspectiveMatrix = new Matrix4();\n    this._infinitePerspective = new Matrix4();\n  }\n\n  _createClass(PerspectiveOffCenterFrustum, [{\n    key: \"clone\",\n    value: function clone() {\n      return new PerspectiveOffCenterFrustum({\n        right: this.right,\n        left: this.left,\n        top: this.top,\n        bottom: this.bottom,\n        near: this.near,\n        far: this.far\n      });\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return other && other instanceof PerspectiveOffCenterFrustum && this.right === other.right && this.left === other.left && this.top === other.top && this.bottom === other.bottom && this.near === other.near && this.far === other.far;\n    }\n  }, {\n    key: \"computeCullingVolume\",\n    value: function computeCullingVolume(position, direction, up) {\n      assert(position, 'position is required.');\n      assert(direction, 'direction is required.');\n      assert(up, 'up is required.');\n      var planes = this._cullingVolume.planes;\n      up = scratchPlaneUpVector.copy(up).normalize();\n      var right = scratchPlaneRightVector.copy(direction).cross(up).normalize();\n      var nearCenter = scratchPlaneNearCenter.copy(direction).multiplyByScalar(this.near).add(position);\n      var farCenter = scratchPlaneFarCenter.copy(direction).multiplyByScalar(this.far).add(position);\n      var normal = scratchPlaneNormal;\n      normal.copy(right).multiplyByScalar(this.left).add(nearCenter).subtract(position).cross(up);\n      planes[0].fromPointNormal(position, normal);\n      normal.copy(right).multiplyByScalar(this.right).add(nearCenter).subtract(position).cross(up).negate();\n      planes[1].fromPointNormal(position, normal);\n      normal.copy(up).multiplyByScalar(this.bottom).add(nearCenter).subtract(position).cross(right).negate();\n      planes[2].fromPointNormal(position, normal);\n      normal.copy(up).multiplyByScalar(this.top).add(nearCenter).subtract(position).cross(right);\n      planes[3].fromPointNormal(position, normal);\n      normal = new Vector3().copy(direction);\n      planes[4].fromPointNormal(nearCenter, normal);\n      normal.negate();\n      planes[5].fromPointNormal(farCenter, normal);\n      return this._cullingVolume;\n    }\n  }, {\n    key: \"getPixelDimensions\",\n    value: function getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, result) {\n      update(this);\n      assert(Number.isFinite(drawingBufferWidth) && Number.isFinite(drawingBufferHeight));\n      assert(drawingBufferWidth > 0);\n      assert(drawingBufferHeight > 0);\n      assert(distance > 0);\n      assert(result);\n      var inverseNear = 1.0 / this.near;\n      var tanTheta = this.top * inverseNear;\n      var pixelHeight = 2.0 * distance * tanTheta / drawingBufferHeight;\n      tanTheta = this.right * inverseNear;\n      var pixelWidth = 2.0 * distance * tanTheta / drawingBufferWidth;\n      result.x = pixelWidth;\n      result.y = pixelHeight;\n      return result;\n    }\n  }, {\n    key: \"projectionMatrix\",\n    get: function get() {\n      update(this);\n      return this._perspectiveMatrix;\n    }\n  }, {\n    key: \"infiniteProjectionMatrix\",\n    get: function get() {\n      update(this);\n      return this._infinitePerspective;\n    }\n  }]);\n\n  return PerspectiveOffCenterFrustum;\n}();\n\nexport { PerspectiveOffCenterFrustum as default };\n\nfunction update(frustum) {\n  assert(Number.isFinite(frustum.right) && Number.isFinite(frustum.left) && Number.isFinite(frustum.top) && Number.isFinite(frustum.bottom) && Number.isFinite(frustum.near) && Number.isFinite(frustum.far));\n  var top = frustum.top,\n      bottom = frustum.bottom,\n      right = frustum.right,\n      left = frustum.left,\n      near = frustum.near,\n      far = frustum.far;\n\n  if (top !== frustum._top || bottom !== frustum._bottom || left !== frustum._left || right !== frustum._right || near !== frustum._near || far !== frustum._far) {\n    assert(frustum.near > 0 && frustum.near < frustum.far, 'near must be greater than zero and less than far.');\n    frustum._left = left;\n    frustum._right = right;\n    frustum._top = top;\n    frustum._bottom = bottom;\n    frustum._near = near;\n    frustum._far = far;\n    frustum._perspectiveMatrix = new Matrix4().frustum({\n      left: left,\n      right: right,\n      bottom: bottom,\n      top: top,\n      near: near,\n      far: far\n    });\n    frustum._infinitePerspective = new Matrix4().frustum({\n      left: left,\n      right: right,\n      bottom: bottom,\n      top: top,\n      near: near,\n      far: Infinity\n    });\n  }\n}","map":{"version":3,"sources":["../../../src/lib/perspective-off-center-frustum.js"],"names":["scratchPlaneUpVector","scratchPlaneRightVector","scratchPlaneNearCenter","scratchPlaneFarCenter","scratchPlaneNormal","PerspectiveOffCenterFrustum","options","near","far","right","left","top","bottom","other","update","position","direction","up","assert","planes","nearCenter","farCenter","normal","drawingBufferWidth","drawingBufferHeight","distance","result","Number","inverseNear","tanTheta","pixelHeight","pixelWidth","frustum","Infinity"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n// Note: This class is still an experimental export, mainly used by other test cases\n// - It has not been fully adapted to math.gl conventions\n// - Documentation has not been ported\n\nimport {Vector3, Matrix4, assert} from 'math.gl';\nimport CullingVolume from './culling-volume';\nimport Plane from './plane';\n\nconst scratchPlaneUpVector = new Vector3();\nconst scratchPlaneRightVector = new Vector3();\nconst scratchPlaneNearCenter = new Vector3();\nconst scratchPlaneFarCenter = new Vector3();\nconst scratchPlaneNormal = new Vector3();\n\nexport default class PerspectiveOffCenterFrustum {\n  /**\n   * The viewing frustum is defined by 6 planes.\n   * Each plane is represented by a {@link Vector4} object, where the x, y, and z components\n   * define the unit vector normal to the plane, and the w component is the distance of the\n   * plane from the origin/camera position.\n   *\n   * @alias PerspectiveOffCenterFrustum\n   * @constructor\n   *\n   * @param {Object} [options] An object with the following properties:\n   * @param {Number} [options.left] The left clipping plane distance.\n   * @param {Number} [options.right] The right clipping plane distance.\n   * @param {Number} [options.top] The top clipping plane distance.\n   * @param {Number} [options.bottom] The bottom clipping plane distance.\n   * @param {Number} [options.near=1.0] The near clipping plane distance.\n   * @param {Number} [options.far=500000000.0] The far clipping plane distance.\n   *\n   * @example\n   * const frustum = new PerspectiveOffCenterFrustum({\n   *     left : -1.0,\n   *     right : 1.0,\n   *     top : 1.0,\n   *     bottom : -1.0,\n   *     near : 1.0,\n   *     far : 100.0\n   * });\n   *\n   * @see PerspectiveFrustum\n   */\n  constructor(options = {}) {\n    options = {near: 1.0, far: 500000000.0, ...options};\n\n    /**\n     * Defines the left clipping plane.\n     * @type {Number}\n     * @default undefined\n     */\n    this.left = options.left;\n    this._left = undefined;\n\n    /**\n     * Defines the right clipping plane.\n     * @type {Number}\n     * @default undefined\n     */\n    this.right = options.right;\n    this._right = undefined;\n\n    /**\n     * Defines the top clipping plane.\n     * @type {Number}\n     * @default undefined\n     */\n    this.top = options.top;\n    this._top = undefined;\n\n    /**\n     * Defines the bottom clipping plane.\n     * @type {Number}\n     * @default undefined\n     */\n    this.bottom = options.bottom;\n    this._bottom = undefined;\n\n    /**\n     * The distance of the near plane.\n     * @type {Number}\n     * @default 1.0\n     */\n    this.near = options.near;\n    this._near = this.near;\n\n    /**\n     * The distance of the far plane.\n     * @type {Number}\n     * @default 500000000.0\n     */\n    this.far = options.far;\n    this._far = this.far;\n\n    this._cullingVolume = new CullingVolume([\n      new Plane(),\n      new Plane(),\n      new Plane(),\n      new Plane(),\n      new Plane(),\n      new Plane()\n    ]);\n    this._perspectiveMatrix = new Matrix4();\n    this._infinitePerspective = new Matrix4();\n  }\n\n  /**\n   * Returns a duplicate of a PerspectiveOffCenterFrustum instance.\n   * @returns {PerspectiveOffCenterFrustum} A new PerspectiveFrustum instance.\n   * */\n  clone() {\n    return new PerspectiveOffCenterFrustum({\n      right: this.right,\n      left: this.left,\n      top: this.top,\n      bottom: this.bottom,\n      near: this.near,\n      far: this.far\n    });\n  }\n\n  /**\n   * Compares the provided PerspectiveOffCenterFrustum componentwise and returns\n   * <code>true</code> if they are equal, <code>false</code> otherwise.\n   *\n   * @param {PerspectiveOffCenterFrustum} [other] The right hand side PerspectiveOffCenterFrustum.\n   * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n   */\n  equals(other) {\n    return (\n      other &&\n      other instanceof PerspectiveOffCenterFrustum &&\n      this.right === other.right &&\n      this.left === other.left &&\n      this.top === other.top &&\n      this.bottom === other.bottom &&\n      this.near === other.near &&\n      this.far === other.far\n    );\n  }\n\n  /**\n   * Gets the perspective projection matrix computed from the view frustum.\n   * @memberof PerspectiveOffCenterFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see PerspectiveOffCenterFrustum#infiniteProjectionMatrix\n   */\n  get projectionMatrix() {\n    update(this);\n    return this._perspectiveMatrix;\n  }\n\n  /**\n   * Gets the perspective projection matrix computed from the view frustum with an infinite far plane.\n   * @memberof PerspectiveOffCenterFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see PerspectiveOffCenterFrustum#projectionMatrix\n   */\n  get infiniteProjectionMatrix() {\n    update(this);\n    return this._infinitePerspective;\n  }\n\n  /**\n   * Creates a culling volume for this frustum.\n   *\n   * @param {Vector3} position The eye position.\n   * @param {Vector3} direction The view direction.\n   * @param {Vector3} up The up direction.\n   * @returns {CullingVolume} A culling volume at the given position and orientation.\n   *\n   * @example\n   * // Check if a bounding volume intersects the frustum.\n   * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n   * const intersect = cullingVolume.computeVisibility(boundingVolume);\n   */\n  // eslint-disable-next-line complexity, max-statements\n  computeCullingVolume(position, direction, up) {\n    assert(position, 'position is required.');\n    assert(direction, 'direction is required.');\n    assert(up, 'up is required.');\n\n    const planes = this._cullingVolume.planes;\n\n    up = scratchPlaneUpVector.copy(up).normalize();\n    const right = scratchPlaneRightVector\n      .copy(direction)\n      .cross(up)\n      .normalize();\n\n    const nearCenter = scratchPlaneNearCenter\n      .copy(direction)\n      .multiplyByScalar(this.near)\n      .add(position);\n\n    const farCenter = scratchPlaneFarCenter\n      .copy(direction)\n      .multiplyByScalar(this.far)\n      .add(position);\n\n    let normal = scratchPlaneNormal;\n\n    // Left plane computation\n    normal\n      .copy(right)\n      .multiplyByScalar(this.left)\n      .add(nearCenter)\n      .subtract(position)\n      .cross(up);\n\n    planes[0].fromPointNormal(position, normal);\n\n    // Right plane computation\n    normal\n      .copy(right)\n      .multiplyByScalar(this.right)\n      .add(nearCenter)\n      .subtract(position)\n      .cross(up)\n      .negate();\n\n    planes[1].fromPointNormal(position, normal);\n\n    // Bottom plane computation\n    normal\n      .copy(up)\n      .multiplyByScalar(this.bottom)\n      .add(nearCenter)\n      .subtract(position)\n      .cross(right)\n      .negate();\n\n    planes[2].fromPointNormal(position, normal);\n\n    // Top plane computation\n    normal\n      .copy(up)\n      .multiplyByScalar(this.top)\n      .add(nearCenter)\n      .subtract(position)\n      .cross(right);\n\n    planes[3].fromPointNormal(position, normal);\n\n    normal = new Vector3().copy(direction);\n\n    // Near plane computation\n    planes[4].fromPointNormal(nearCenter, normal);\n\n    // Far plane computation\n    normal.negate();\n\n    planes[5].fromPointNormal(farCenter, normal);\n\n    return this._cullingVolume;\n  }\n\n  /**\n   * Returns the pixel's width and height in meters.\n   *\n   * @param {Number} drawingBufferWidth The width of the drawing buffer.\n   * @param {Number} drawingBufferHeight The height of the drawing buffer.\n   * @param {Number} distance The distance to the near plane in meters.\n   * @param {Vector2} result The object onto which to store the result.\n   * @returns {Vector2} The modified result parameter or a new instance of {@link Vector2} with the pixel's width and height in the x and y properties, respectively.\n   *\n   * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\n   * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\n   *\n   * @example\n   * // Example 1\n   * // Get the width and height of a pixel.\n   * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, new Vector2());\n   *\n   * @example\n   * // Example 2\n   * // Get the width and height of a pixel if the near plane was set to 'distance'.\n   * // For example, get the size of a pixel of an image on a billboard.\n   * const position = camera.position;\n   * const direction = camera.direction;\n   * const toCenter = Vector3.subtract(primitive.boundingVolume.center, position, new Vector3());      // vector from camera to a primitive\n   * const toCenterProj = Vector3.multiplyByScalar(direction, Vector3.dot(direction, toCenter), new Vector3()); // project vector onto camera direction vector\n   * const distance = Vector3.magnitude(toCenterProj);\n   * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, new Vector2());\n   */\n  getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, result) {\n    update(this);\n\n    assert(Number.isFinite(drawingBufferWidth) && Number.isFinite(drawingBufferHeight));\n    // 'Both drawingBufferWidth and drawingBufferHeight are required.'\n    assert(drawingBufferWidth > 0);\n    // 'drawingBufferWidth must be greater than zero.'\n    assert(drawingBufferHeight > 0);\n    // 'drawingBufferHeight must be greater than zero.'\n    assert(distance > 0);\n    // 'distance is required.');\n    assert(result);\n    // 'A result object is required.');\n\n    const inverseNear = 1.0 / this.near;\n    let tanTheta = this.top * inverseNear;\n    const pixelHeight = (2.0 * distance * tanTheta) / drawingBufferHeight;\n    tanTheta = this.right * inverseNear;\n    const pixelWidth = (2.0 * distance * tanTheta) / drawingBufferWidth;\n\n    result.x = pixelWidth;\n    result.y = pixelHeight;\n    return result;\n  }\n}\n\n// eslint-disable-next-line complexity, max-statements\nfunction update(frustum) {\n  assert(\n    Number.isFinite(frustum.right) &&\n      Number.isFinite(frustum.left) &&\n      Number.isFinite(frustum.top) &&\n      Number.isFinite(frustum.bottom) &&\n      Number.isFinite(frustum.near) &&\n      Number.isFinite(frustum.far)\n  );\n  // throw new DeveloperError('right, left, top, bottom, near, or far parameters are not set.');\n\n  const {top, bottom, right, left, near, far} = frustum;\n\n  if (\n    top !== frustum._top ||\n    bottom !== frustum._bottom ||\n    left !== frustum._left ||\n    right !== frustum._right ||\n    near !== frustum._near ||\n    far !== frustum._far\n  ) {\n    assert(\n      frustum.near > 0 && frustum.near < frustum.far,\n      'near must be greater than zero and less than far.'\n    );\n\n    frustum._left = left;\n    frustum._right = right;\n    frustum._top = top;\n    frustum._bottom = bottom;\n    frustum._near = near;\n    frustum._far = far;\n    frustum._perspectiveMatrix = new Matrix4().frustum({\n      left,\n      right,\n      bottom,\n      top,\n      near,\n      far\n    });\n    frustum._infinitePerspective = new Matrix4().frustum({\n      left,\n      right,\n      bottom,\n      top,\n      near,\n      far: Infinity\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}