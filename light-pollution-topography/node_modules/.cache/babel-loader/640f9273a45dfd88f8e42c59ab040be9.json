{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { Transform } from '@luma.gl/core';\nimport GPUInterpolationTransition from '../../transitions/gpu-interpolation-transition';\nimport GPUSpringTransition from '../../transitions/gpu-spring-transition';\nimport log from '../../utils/log';\nvar TRANSITION_TYPES = {\n  interpolation: GPUInterpolationTransition,\n  spring: GPUSpringTransition\n};\n\nvar AttributeTransitionManager = function () {\n  function AttributeTransitionManager(gl, _ref) {\n    var id = _ref.id,\n        timeline = _ref.timeline;\n\n    _classCallCheck(this, AttributeTransitionManager);\n\n    this.id = id;\n    this.gl = gl;\n    this.timeline = timeline;\n    this.transitions = {};\n    this.needsRedraw = false;\n    this.numInstances = 1;\n\n    if (Transform.isSupported(gl)) {\n      this.isSupported = true;\n    } else if (gl) {\n      log.warn('WebGL2 not supported by this browser. Transition animation is disabled.')();\n    }\n  }\n\n  _createClass(AttributeTransitionManager, [{\n    key: \"finalize\",\n    value: function finalize() {\n      for (var attributeName in this.transitions) {\n        this._removeTransition(attributeName);\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(_ref2) {\n      var attributes = _ref2.attributes,\n          _ref2$transitions = _ref2.transitions,\n          transitions = _ref2$transitions === void 0 ? {} : _ref2$transitions,\n          numInstances = _ref2.numInstances;\n      this.numInstances = numInstances || 1;\n\n      if (!this.isSupported) {\n        return;\n      }\n\n      for (var attributeName in attributes) {\n        var attribute = attributes[attributeName];\n        var settings = attribute.getTransitionSetting(transitions);\n        if (!settings) continue;\n\n        this._updateAttribute(attributeName, attribute, settings);\n      }\n\n      for (var _attributeName in this.transitions) {\n        var _attribute = attributes[_attributeName];\n\n        if (!_attribute || !_attribute.getTransitionSetting(transitions)) {\n          this._removeTransition(_attributeName);\n        }\n      }\n    }\n  }, {\n    key: \"hasAttribute\",\n    value: function hasAttribute(attributeName) {\n      var transition = this.transitions[attributeName];\n      return transition && transition.inProgress;\n    }\n  }, {\n    key: \"getAttributes\",\n    value: function getAttributes() {\n      var animatedAttributes = {};\n\n      for (var attributeName in this.transitions) {\n        var transition = this.transitions[attributeName];\n\n        if (transition.inProgress) {\n          animatedAttributes[attributeName] = transition.attributeInTransition;\n        }\n      }\n\n      return animatedAttributes;\n    }\n  }, {\n    key: \"run\",\n    value: function run() {\n      if (!this.isSupported || this.numInstances === 0) {\n        return false;\n      }\n\n      for (var attributeName in this.transitions) {\n        var updated = this.transitions[attributeName].update();\n\n        if (updated) {\n          this.needsRedraw = true;\n        }\n      }\n\n      var needsRedraw = this.needsRedraw;\n      this.needsRedraw = false;\n      return needsRedraw;\n    }\n  }, {\n    key: \"_removeTransition\",\n    value: function _removeTransition(attributeName) {\n      this.transitions[attributeName].cancel();\n      delete this.transitions[attributeName];\n    }\n  }, {\n    key: \"_updateAttribute\",\n    value: function _updateAttribute(attributeName, attribute, settings) {\n      var transition = this.transitions[attributeName];\n      var isNew = !transition || transition.type !== settings.type;\n\n      if (isNew) {\n        if (transition) {\n          this._removeTransition(attributeName);\n        }\n\n        var TransitionType = TRANSITION_TYPES[settings.type];\n\n        if (TransitionType) {\n          this.transitions[attributeName] = new TransitionType({\n            attribute: attribute,\n            timeline: this.timeline,\n            gl: this.gl\n          });\n        } else {\n          log.error(\"unsupported transition type '\".concat(settings.type, \"'\"))();\n          isNew = false;\n        }\n      }\n\n      if (isNew || attribute.needsRedraw()) {\n        this.needsRedraw = true;\n        this.transitions[attributeName].start(settings, this.numInstances);\n      }\n    }\n  }]);\n\n  return AttributeTransitionManager;\n}();\n\nexport { AttributeTransitionManager as default };","map":{"version":3,"sources":["../../../../src/lib/attribute/attribute-transition-manager.js"],"names":["TRANSITION_TYPES","interpolation","spring","GPUSpringTransition","AttributeTransitionManager","id","timeline","Transform","log","attributes","transitions","numInstances","attribute","settings","attributeName","transition","animatedAttributes","updated","needsRedraw","isNew","TransitionType","gl"],"mappings":"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","sourcesContent":["import {Transform} from '@luma.gl/core';\nimport GPUInterpolationTransition from '../../transitions/gpu-interpolation-transition';\nimport GPUSpringTransition from '../../transitions/gpu-spring-transition';\nimport log from '../../utils/log';\n\nconst TRANSITION_TYPES = {\n  interpolation: GPUInterpolationTransition,\n  spring: GPUSpringTransition\n};\n\nexport default class AttributeTransitionManager {\n  constructor(gl, {id, timeline}) {\n    this.id = id;\n    this.gl = gl;\n    this.timeline = timeline;\n\n    this.transitions = {};\n    this.needsRedraw = false;\n    this.numInstances = 1;\n\n    if (Transform.isSupported(gl)) {\n      this.isSupported = true;\n    } else if (gl) {\n      // This class may be instantiated without a WebGL context (e.g. web worker)\n      log.warn('WebGL2 not supported by this browser. Transition animation is disabled.')();\n    }\n  }\n\n  finalize() {\n    for (const attributeName in this.transitions) {\n      this._removeTransition(attributeName);\n    }\n  }\n\n  /* Public methods */\n\n  // Called when attribute manager updates\n  // Check the latest attributes for updates.\n  update({attributes, transitions = {}, numInstances}) {\n    // Transform class will crash if elementCount is 0\n    this.numInstances = numInstances || 1;\n\n    if (!this.isSupported) {\n      return;\n    }\n\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      const settings = attribute.getTransitionSetting(transitions);\n\n      // this attribute might not support transitions?\n      if (!settings) continue; // eslint-disable-line no-continue\n      this._updateAttribute(attributeName, attribute, settings);\n    }\n\n    for (const attributeName in this.transitions) {\n      const attribute = attributes[attributeName];\n      if (!attribute || !attribute.getTransitionSetting(transitions)) {\n        // Animated attribute has been removed\n        this._removeTransition(attributeName);\n      }\n    }\n  }\n\n  // Returns `true` if attribute is transition-enabled\n  hasAttribute(attributeName) {\n    const transition = this.transitions[attributeName];\n    return transition && transition.inProgress;\n  }\n\n  // Get all the animated attributes\n  getAttributes() {\n    const animatedAttributes = {};\n\n    for (const attributeName in this.transitions) {\n      const transition = this.transitions[attributeName];\n      if (transition.inProgress) {\n        animatedAttributes[attributeName] = transition.attributeInTransition;\n      }\n    }\n\n    return animatedAttributes;\n  }\n\n  /* eslint-disable max-statements */\n  // Called every render cycle, run transform feedback\n  // Returns `true` if anything changes\n  run() {\n    if (!this.isSupported || this.numInstances === 0) {\n      return false;\n    }\n\n    for (const attributeName in this.transitions) {\n      const updated = this.transitions[attributeName].update();\n      if (updated) {\n        this.needsRedraw = true;\n      }\n    }\n\n    const needsRedraw = this.needsRedraw;\n    this.needsRedraw = false;\n    return needsRedraw;\n  }\n  /* eslint-enable max-statements */\n\n  /* Private methods */\n  _removeTransition(attributeName) {\n    this.transitions[attributeName].cancel();\n    delete this.transitions[attributeName];\n  }\n\n  // Check an attributes for updates\n  // Returns a transition object if a new transition is triggered.\n  _updateAttribute(attributeName, attribute, settings) {\n    const transition = this.transitions[attributeName];\n    // an attribute can change transition type when it updates\n    // let's remove the transition when that happens so we can create the new transition type\n    // TODO: when switching transition types, make sure to carry over the attribute's\n    // previous buffers, currentLength, startIndices, etc, to be used as the starting point\n    // for the next transition\n    let isNew = !transition || transition.type !== settings.type;\n    if (isNew) {\n      if (transition) {\n        this._removeTransition(attributeName);\n      }\n\n      const TransitionType = TRANSITION_TYPES[settings.type];\n      if (TransitionType) {\n        this.transitions[attributeName] = new TransitionType({\n          attribute,\n          timeline: this.timeline,\n          gl: this.gl\n        });\n      } else {\n        log.error(`unsupported transition type '${settings.type}'`)();\n        isNew = false;\n      }\n    }\n\n    if (isNew || attribute.needsRedraw()) {\n      this.needsRedraw = true;\n      this.transitions[attributeName].start(settings, this.numInstances);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}