{"ast":null,"code":"import { padTo4Bytes, assert } from '@loaders.gl/loader-utils';\nvar MAGIC_glTF = 0x676c5446;\nvar GLB_FILE_HEADER_SIZE = 12;\nvar GLB_CHUNK_HEADER_SIZE = 8;\nvar GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\nvar GLB_CHUNK_TYPE_BIN = 0x004e4942;\nvar GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED = 0;\nvar GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED = 1;\nvar LE = true;\n\nfunction getMagicString(dataView) {\n  var byteOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  return \"\".concat(String.fromCharCode(dataView.getUint8(byteOffset + 0))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 1))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 2))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 3)));\n}\n\nexport function isGLB(arrayBuffer) {\n  var byteOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var dataView = new DataView(arrayBuffer);\n  var _options$magic = options.magic,\n      magic = _options$magic === void 0 ? MAGIC_glTF : _options$magic;\n  var magic1 = dataView.getUint32(byteOffset, false);\n  return magic1 === magic || magic1 === MAGIC_glTF;\n}\nexport default function parseGLBSync(glb, arrayBuffer) {\n  var byteOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var dataView = new DataView(arrayBuffer);\n  glb.type = getMagicString(dataView, byteOffset + 0);\n  glb.version = dataView.getUint32(byteOffset + 4, LE);\n  var byteLength = dataView.getUint32(byteOffset + 8, LE);\n  glb.header = {\n    byteOffset: byteOffset,\n    byteLength: byteLength\n  };\n  assert(glb.version === 2, \"Invalid GLB version \".concat(glb.version, \". Only supports v2.\"));\n  assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n  glb.json = {};\n  glb.binChunks = [];\n  parseGLBChunksSync(glb, dataView, byteOffset + GLB_FILE_HEADER_SIZE, options);\n  return byteOffset + glb.header.byteLength;\n}\n\nfunction parseGLBChunksSync(glb, dataView, byteOffset, options) {\n  while (byteOffset + 8 <= glb.header.byteLength) {\n    var chunkLength = dataView.getUint32(byteOffset + 0, LE);\n    var chunkFormat = dataView.getUint32(byteOffset + 4, LE);\n    byteOffset += GLB_CHUNK_HEADER_SIZE;\n\n    switch (chunkFormat) {\n      case GLB_CHUNK_TYPE_JSON:\n        parseJSONChunk(glb, dataView, byteOffset, chunkLength, options);\n        break;\n\n      case GLB_CHUNK_TYPE_BIN:\n        parseBINChunk(glb, dataView, byteOffset, chunkLength, options);\n        break;\n\n      case GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED:\n        if (!options.glb.strict) {\n          parseJSONChunk(glb, dataView, byteOffset, chunkLength, options);\n        }\n\n        break;\n\n      case GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED:\n        if (!options.glb.strict) {\n          parseBINChunk(glb, dataView, byteOffset, chunkLength, options);\n        }\n\n        break;\n\n      default:\n        break;\n    }\n\n    byteOffset += padTo4Bytes(chunkLength);\n  }\n\n  return byteOffset;\n}\n\nfunction parseJSONChunk(glb, dataView, byteOffset, chunkLength, options) {\n  var jsonChunk = new Uint8Array(dataView.buffer, byteOffset, chunkLength);\n  var textDecoder = new TextDecoder('utf8');\n  var jsonText = textDecoder.decode(jsonChunk);\n  glb.json = JSON.parse(jsonText);\n}\n\nfunction parseBINChunk(glb, dataView, byteOffset, chunkLength, options) {\n  glb.header.hasBinChunk = true;\n  glb.binChunks.push({\n    byteOffset: byteOffset,\n    byteLength: chunkLength,\n    arrayBuffer: dataView.buffer\n  });\n}","map":{"version":3,"sources":["../../../src/lib/parse-glb.js"],"names":["MAGIC_glTF","GLB_FILE_HEADER_SIZE","GLB_CHUNK_HEADER_SIZE","GLB_CHUNK_TYPE_JSON","GLB_CHUNK_TYPE_BIN","GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED","GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED","LE","byteOffset","String","dataView","options","magic","magic1","glb","getMagicString","byteLength","assert","parseGLBChunksSync","chunkLength","chunkFormat","parseJSONChunk","parseBINChunk","padTo4Bytes","jsonChunk","textDecoder","jsonText","JSON","arrayBuffer","buffer"],"mappings":"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","sourcesContent":["/* eslint-disable camelcase, max-statements */\n/* global TextDecoder */\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#glb-file-format-specification\n\nimport {padTo4Bytes, assert} from '@loaders.gl/loader-utils';\n\nconst MAGIC_glTF = 0x676c5446; // glTF in Big-Endian ASCII\n\nconst GLB_FILE_HEADER_SIZE = 12;\nconst GLB_CHUNK_HEADER_SIZE = 8;\n\nconst GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\nconst GLB_CHUNK_TYPE_BIN = 0x004e4942;\nconst GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED = 0; // DEPRECATED - Backward compatibility for old xviz files\nconst GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED = 1; // DEPRECATED - Backward compatibility for old xviz files\n\nconst LE = true; // Binary GLTF is little endian.\n\nfunction getMagicString(dataView, byteOffset = 0) {\n  return `\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 0))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 1))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 2))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 3))}`;\n}\n\n// Check if a data view is a GLB\nexport function isGLB(arrayBuffer, byteOffset = 0, options = {}) {\n  const dataView = new DataView(arrayBuffer);\n  // Check that GLB Header starts with the magic number\n  const {magic = MAGIC_glTF} = options;\n  const magic1 = dataView.getUint32(byteOffset, false);\n  return magic1 === magic || magic1 === MAGIC_glTF;\n}\n\nexport default function parseGLBSync(glb, arrayBuffer, byteOffset = 0, options = {}) {\n  // Check that GLB Header starts with the magic number\n  const dataView = new DataView(arrayBuffer);\n\n  // Compare format with GLBLoader documentation\n  glb.type = getMagicString(dataView, byteOffset + 0);\n  glb.version = dataView.getUint32(byteOffset + 4, LE); // Version 2 of binary glTF container format\n  const byteLength = dataView.getUint32(byteOffset + 8, LE); // Total byte length of generated file\n\n  // Put less important stuff in a header, to avoid clutter\n  glb.header = {\n    byteOffset, // Byte offset into the initial arrayBuffer\n    byteLength\n  };\n\n  assert(glb.version === 2, `Invalid GLB version ${glb.version}. Only supports v2.`);\n  assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n\n  // Per spec we must iterate over chunks, ignoring all except JSON and BIN\n  glb.json = {};\n  glb.binChunks = [];\n\n  parseGLBChunksSync(glb, dataView, byteOffset + GLB_FILE_HEADER_SIZE, options);\n\n  return byteOffset + glb.header.byteLength;\n}\n\nfunction parseGLBChunksSync(glb, dataView, byteOffset, options) {\n  // Iterate as long as there is space left for another chunk header\n  while (byteOffset + 8 <= glb.header.byteLength) {\n    const chunkLength = dataView.getUint32(byteOffset + 0, LE); // Byte length of chunk\n    const chunkFormat = dataView.getUint32(byteOffset + 4, LE); // Chunk format as uint32\n    byteOffset += GLB_CHUNK_HEADER_SIZE;\n\n    // Per spec we must iterate over chunks, ignoring all except JSON and BIN\n    switch (chunkFormat) {\n      case GLB_CHUNK_TYPE_JSON:\n        parseJSONChunk(glb, dataView, byteOffset, chunkLength, options);\n        break;\n      case GLB_CHUNK_TYPE_BIN:\n        parseBINChunk(glb, dataView, byteOffset, chunkLength, options);\n        break;\n\n      // Backward compatibility for very old xviz files\n      case GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED:\n        if (!options.glb.strict) {\n          parseJSONChunk(glb, dataView, byteOffset, chunkLength, options);\n        }\n        break;\n      case GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED:\n        if (!options.glb.strict) {\n          parseBINChunk(glb, dataView, byteOffset, chunkLength, options);\n        }\n        break;\n\n      default:\n        // Ignore, per spec\n        // console.warn(`Unknown GLB chunk type`); // eslint-disable-line\n        break;\n    }\n\n    byteOffset += padTo4Bytes(chunkLength);\n  }\n\n  return byteOffset;\n}\n\n// Parse a GLB JSON chunk\nfunction parseJSONChunk(glb, dataView, byteOffset, chunkLength, options) {\n  // 1. Create a \"view\" of the binary encoded JSON data inside the GLB\n  const jsonChunk = new Uint8Array(dataView.buffer, byteOffset, chunkLength);\n\n  // 2. Decode the JSON binary array into clear text\n  const textDecoder = new TextDecoder('utf8');\n  const jsonText = textDecoder.decode(jsonChunk);\n\n  // 3. Parse the JSON text into a JavaScript data structure\n  glb.json = JSON.parse(jsonText);\n}\n\n// Parse a GLB BIN chunk\nfunction parseBINChunk(glb, dataView, byteOffset, chunkLength, options) {\n  // Note: BIN chunk can be optional\n  glb.header.hasBinChunk = true;\n  glb.binChunks.push({\n    byteOffset,\n    byteLength: chunkLength,\n    arrayBuffer: dataView.buffer\n    // TODO - copy, or create typed array view?\n  });\n}\n"]},"metadata":{},"sourceType":"module"}