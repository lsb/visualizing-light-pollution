{"ast":null,"code":"import * as mat4 from 'gl-matrix/mat4';\nimport * as vec4 from 'gl-matrix/vec4';\nimport { COORDINATE_SYSTEM, PROJECTION_MODE } from '../../lib/constants';\nimport memoize from '../../utils/memoize';\nimport assert from '../../utils/assert';\nvar ZERO_VECTOR = [0, 0, 0, 0];\nvar VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];\nvar IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\nvar DEFAULT_PIXELS_PER_UNIT2 = [0, 0, 0];\nvar DEFAULT_COORDINATE_ORIGIN = [0, 0, 0];\nvar getMemoizedViewportUniforms = memoize(calculateViewportUniforms);\nexport function getOffsetOrigin(viewport, coordinateSystem) {\n  var coordinateOrigin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_COORDINATE_ORIGIN;\n  var shaderCoordinateOrigin = coordinateOrigin;\n  var geospatialOrigin;\n  var offsetMode = true;\n\n  if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS) {\n    geospatialOrigin = coordinateOrigin;\n  } else {\n    geospatialOrigin = viewport.isGeospatial ? [Math.fround(viewport.longitude), Math.fround(viewport.latitude), 0] : null;\n  }\n\n  switch (viewport.projectionMode) {\n    case PROJECTION_MODE.WEB_MERCATOR:\n      if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {\n        offsetMode = false;\n      }\n\n      break;\n\n    case PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET:\n      if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {\n        shaderCoordinateOrigin = geospatialOrigin;\n      } else if (coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {\n        shaderCoordinateOrigin = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1]), 0];\n        geospatialOrigin = viewport.unprojectPosition(shaderCoordinateOrigin);\n      }\n\n      break;\n\n    case PROJECTION_MODE.IDENTITY:\n      shaderCoordinateOrigin = viewport.position.map(Math.fround);\n      break;\n\n    default:\n      offsetMode = false;\n  }\n\n  shaderCoordinateOrigin[2] = shaderCoordinateOrigin[2] || 0;\n  return {\n    geospatialOrigin: geospatialOrigin,\n    shaderCoordinateOrigin: shaderCoordinateOrigin,\n    offsetMode: offsetMode\n  };\n}\n\nfunction calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin) {\n  var viewMatrixUncentered = viewport.viewMatrixUncentered,\n      projectionMatrix = viewport.projectionMatrix;\n  var viewMatrix = viewport.viewMatrix,\n      viewProjectionMatrix = viewport.viewProjectionMatrix;\n  var projectionCenter = ZERO_VECTOR;\n  var cameraPosCommon = viewport.cameraPosition;\n\n  var _getOffsetOrigin = getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin),\n      geospatialOrigin = _getOffsetOrigin.geospatialOrigin,\n      shaderCoordinateOrigin = _getOffsetOrigin.shaderCoordinateOrigin,\n      offsetMode = _getOffsetOrigin.offsetMode;\n\n  if (offsetMode) {\n    var positionCommonSpace = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);\n    cameraPosCommon = [cameraPosCommon[0] - positionCommonSpace[0], cameraPosCommon[1] - positionCommonSpace[1], cameraPosCommon[2] - positionCommonSpace[2]];\n    positionCommonSpace[3] = 1;\n    projectionCenter = vec4.transformMat4([], positionCommonSpace, viewProjectionMatrix);\n    viewMatrix = viewMatrixUncentered || viewMatrix;\n    viewProjectionMatrix = mat4.multiply([], projectionMatrix, viewMatrix);\n    viewProjectionMatrix = mat4.multiply([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);\n  }\n\n  return {\n    viewMatrix: viewMatrix,\n    viewProjectionMatrix: viewProjectionMatrix,\n    projectionCenter: projectionCenter,\n    cameraPosCommon: cameraPosCommon,\n    shaderCoordinateOrigin: shaderCoordinateOrigin,\n    geospatialOrigin: geospatialOrigin\n  };\n}\n\nexport function getUniformsFromViewport() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      viewport = _ref.viewport,\n      _ref$devicePixelRatio = _ref.devicePixelRatio,\n      devicePixelRatio = _ref$devicePixelRatio === void 0 ? 1 : _ref$devicePixelRatio,\n      _ref$modelMatrix = _ref.modelMatrix,\n      modelMatrix = _ref$modelMatrix === void 0 ? null : _ref$modelMatrix,\n      _ref$coordinateSystem = _ref.coordinateSystem,\n      coordinateSystem = _ref$coordinateSystem === void 0 ? COORDINATE_SYSTEM.DEFAULT : _ref$coordinateSystem,\n      coordinateOrigin = _ref.coordinateOrigin,\n      _ref$wrapLongitude = _ref.wrapLongitude,\n      wrapLongitude = _ref$wrapLongitude === void 0 ? false : _ref$wrapLongitude,\n      projectionMode = _ref.projectionMode,\n      positionOrigin = _ref.positionOrigin;\n\n  assert(viewport);\n\n  if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n    coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;\n  }\n\n  var uniforms = getMemoizedViewportUniforms({\n    viewport: viewport,\n    devicePixelRatio: devicePixelRatio,\n    coordinateSystem: coordinateSystem,\n    coordinateOrigin: coordinateOrigin\n  });\n  uniforms.project_uWrapLongitude = wrapLongitude;\n  uniforms.project_uModelMatrix = modelMatrix || IDENTITY_MATRIX;\n  return uniforms;\n}\n\nfunction calculateViewportUniforms(_ref2) {\n  var viewport = _ref2.viewport,\n      devicePixelRatio = _ref2.devicePixelRatio,\n      coordinateSystem = _ref2.coordinateSystem,\n      coordinateOrigin = _ref2.coordinateOrigin;\n\n  var _calculateMatrixAndOf = calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin),\n      projectionCenter = _calculateMatrixAndOf.projectionCenter,\n      viewProjectionMatrix = _calculateMatrixAndOf.viewProjectionMatrix,\n      cameraPosCommon = _calculateMatrixAndOf.cameraPosCommon,\n      shaderCoordinateOrigin = _calculateMatrixAndOf.shaderCoordinateOrigin,\n      geospatialOrigin = _calculateMatrixAndOf.geospatialOrigin;\n\n  var distanceScales = viewport.getDistanceScales();\n  var viewportSize = [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio];\n  var uniforms = {\n    project_uCoordinateSystem: coordinateSystem,\n    project_uProjectionMode: viewport.projectionMode,\n    project_uCoordinateOrigin: shaderCoordinateOrigin,\n    project_uCenter: projectionCenter,\n    project_uAntimeridian: (viewport.longitude || 0) - 180,\n    project_uViewportSize: viewportSize,\n    project_uDevicePixelRatio: devicePixelRatio,\n    project_uFocalDistance: viewport.focalDistance || 1,\n    project_uCommonUnitsPerMeter: distanceScales.unitsPerMeter,\n    project_uCommonUnitsPerWorldUnit: distanceScales.unitsPerMeter,\n    project_uCommonUnitsPerWorldUnit2: DEFAULT_PIXELS_PER_UNIT2,\n    project_uScale: viewport.scale,\n    project_uViewProjectionMatrix: viewProjectionMatrix,\n    project_uCameraPosition: cameraPosCommon\n  };\n\n  if (geospatialOrigin) {\n    var distanceScalesAtOrigin = viewport.getDistanceScales(geospatialOrigin);\n\n    switch (coordinateSystem) {\n      case COORDINATE_SYSTEM.METER_OFFSETS:\n        uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerMeter;\n        uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerMeter2;\n        break;\n\n      case COORDINATE_SYSTEM.LNGLAT:\n      case COORDINATE_SYSTEM.LNGLAT_OFFSETS:\n        uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerDegree;\n        uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerDegree2;\n        break;\n\n      case COORDINATE_SYSTEM.CARTESIAN:\n        uniforms.project_uCommonUnitsPerWorldUnit = [1, 1, distanceScalesAtOrigin.unitsPerMeter[2]];\n        uniforms.project_uCommonUnitsPerWorldUnit2 = [0, 0, distanceScalesAtOrigin.unitsPerMeter2[2]];\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  return uniforms;\n}","map":{"version":3,"sources":["../../../../src/shaderlib/project/viewport-uniforms.js"],"names":["ZERO_VECTOR","VECTOR_TO_POINT_MATRIX","IDENTITY_MATRIX","DEFAULT_PIXELS_PER_UNIT2","DEFAULT_COORDINATE_ORIGIN","getMemoizedViewportUniforms","memoize","coordinateOrigin","shaderCoordinateOrigin","offsetMode","coordinateSystem","COORDINATE_SYSTEM","geospatialOrigin","viewport","Math","PROJECTION_MODE","viewMatrixUncentered","projectionMatrix","viewMatrix","viewProjectionMatrix","projectionCenter","cameraPosCommon","getOffsetOrigin","positionCommonSpace","vec4","mat4","devicePixelRatio","modelMatrix","DEFAULT","wrapLongitude","projectionMode","positionOrigin","assert","uniforms","calculateMatrixAndOffset","distanceScales","viewportSize","project_uCoordinateSystem","project_uProjectionMode","project_uCoordinateOrigin","project_uCenter","project_uAntimeridian","project_uViewportSize","project_uDevicePixelRatio","project_uFocalDistance","project_uCommonUnitsPerMeter","project_uCommonUnitsPerWorldUnit","project_uCommonUnitsPerWorldUnit2","project_uScale","project_uViewProjectionMatrix","project_uCameraPosition","distanceScalesAtOrigin"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n/* eslint-disable complexity */\n\nimport * as mat4 from 'gl-matrix/mat4';\nimport * as vec4 from 'gl-matrix/vec4';\n\nimport {COORDINATE_SYSTEM, PROJECTION_MODE} from '../../lib/constants';\n\nimport memoize from '../../utils/memoize';\nimport assert from '../../utils/assert';\n\n// To quickly set a vector to zero\nconst ZERO_VECTOR = [0, 0, 0, 0];\n// 4x4 matrix that drops 4th component of vector\nconst VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];\nconst IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\nconst DEFAULT_PIXELS_PER_UNIT2 = [0, 0, 0];\nconst DEFAULT_COORDINATE_ORIGIN = [0, 0, 0];\n\nconst getMemoizedViewportUniforms = memoize(calculateViewportUniforms);\n\nexport function getOffsetOrigin(\n  viewport,\n  coordinateSystem,\n  coordinateOrigin = DEFAULT_COORDINATE_ORIGIN\n) {\n  let shaderCoordinateOrigin = coordinateOrigin;\n  let geospatialOrigin;\n  let offsetMode = true;\n\n  if (\n    coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS ||\n    coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS\n  ) {\n    geospatialOrigin = coordinateOrigin;\n  } else {\n    geospatialOrigin = viewport.isGeospatial\n      ? [Math.fround(viewport.longitude), Math.fround(viewport.latitude), 0]\n      : null;\n  }\n\n  switch (viewport.projectionMode) {\n    case PROJECTION_MODE.WEB_MERCATOR:\n      if (\n        coordinateSystem === COORDINATE_SYSTEM.LNGLAT ||\n        coordinateSystem === COORDINATE_SYSTEM.CARTESIAN\n      ) {\n        offsetMode = false;\n      }\n      break;\n\n    case PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET:\n      if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {\n        // viewport center in world space\n        shaderCoordinateOrigin = geospatialOrigin;\n      } else if (coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {\n        // viewport center in common space\n        shaderCoordinateOrigin = [\n          Math.fround(viewport.center[0]),\n          Math.fround(viewport.center[1]),\n          0\n        ];\n        // Geospatial origin (wgs84) must match shaderCoordinateOrigin (common)\n        geospatialOrigin = viewport.unprojectPosition(shaderCoordinateOrigin);\n      }\n      break;\n\n    case PROJECTION_MODE.IDENTITY:\n      shaderCoordinateOrigin = viewport.position.map(Math.fround);\n      break;\n\n    default:\n      // Unknown projection mode\n      offsetMode = false;\n  }\n\n  shaderCoordinateOrigin[2] = shaderCoordinateOrigin[2] || 0;\n\n  return {geospatialOrigin, shaderCoordinateOrigin, offsetMode};\n}\n\n// The code that utilizes Matrix4 does the same calculation as their mat4 counterparts,\n// has lower performance but provides error checking.\nfunction calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin) {\n  const {viewMatrixUncentered, projectionMatrix} = viewport;\n  let {viewMatrix, viewProjectionMatrix} = viewport;\n\n  let projectionCenter = ZERO_VECTOR;\n  let cameraPosCommon = viewport.cameraPosition;\n  const {geospatialOrigin, shaderCoordinateOrigin, offsetMode} = getOffsetOrigin(\n    viewport,\n    coordinateSystem,\n    coordinateOrigin\n  );\n\n  if (offsetMode) {\n    // Calculate transformed projectionCenter (using 64 bit precision JS)\n    // This is the key to offset mode precision\n    // (avoids doing this addition in 32 bit precision in GLSL)\n    const positionCommonSpace = viewport.projectPosition(\n      geospatialOrigin || shaderCoordinateOrigin\n    );\n\n    cameraPosCommon = [\n      cameraPosCommon[0] - positionCommonSpace[0],\n      cameraPosCommon[1] - positionCommonSpace[1],\n      cameraPosCommon[2] - positionCommonSpace[2]\n    ];\n\n    positionCommonSpace[3] = 1;\n\n    // projectionCenter = new Matrix4(viewProjectionMatrix)\n    //   .transformVector([positionPixels[0], positionPixels[1], 0.0, 1.0]);\n    projectionCenter = vec4.transformMat4([], positionCommonSpace, viewProjectionMatrix);\n\n    // Always apply uncentered projection matrix if available (shader adds center)\n    viewMatrix = viewMatrixUncentered || viewMatrix;\n\n    // Zero out 4th coordinate (\"after\" model matrix) - avoids further translations\n    // viewMatrix = new Matrix4(viewMatrixUncentered || viewMatrix)\n    //   .multiplyRight(VECTOR_TO_POINT_MATRIX);\n    viewProjectionMatrix = mat4.multiply([], projectionMatrix, viewMatrix);\n    viewProjectionMatrix = mat4.multiply([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);\n  }\n\n  return {\n    viewMatrix,\n    viewProjectionMatrix,\n    projectionCenter,\n    cameraPosCommon,\n    shaderCoordinateOrigin,\n    geospatialOrigin\n  };\n}\n\n/**\n * Returns uniforms for shaders based on current projection\n * includes: projection matrix suitable for shaders\n *\n * TODO - Ensure this works with any viewport, not just WebMercatorViewports\n *\n * @param {WebMercatorViewport} viewport -\n * @return {Float32Array} - 4x4 projection matrix that can be used in shaders\n */\nexport function getUniformsFromViewport({\n  viewport,\n  devicePixelRatio = 1,\n  modelMatrix = null,\n  // Match Layer.defaultProps\n  coordinateSystem = COORDINATE_SYSTEM.DEFAULT,\n  coordinateOrigin,\n  wrapLongitude = false,\n  // Deprecated\n  projectionMode,\n  positionOrigin\n} = {}) {\n  assert(viewport);\n\n  if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n    coordinateSystem = viewport.isGeospatial\n      ? COORDINATE_SYSTEM.LNGLAT\n      : COORDINATE_SYSTEM.CARTESIAN;\n  }\n\n  const uniforms = getMemoizedViewportUniforms({\n    viewport,\n    devicePixelRatio,\n    coordinateSystem,\n    coordinateOrigin\n  });\n\n  uniforms.project_uWrapLongitude = wrapLongitude;\n  uniforms.project_uModelMatrix = modelMatrix || IDENTITY_MATRIX;\n\n  return uniforms;\n}\n\nfunction calculateViewportUniforms({\n  viewport,\n  devicePixelRatio,\n  coordinateSystem,\n  coordinateOrigin\n}) {\n  const {\n    projectionCenter,\n    viewProjectionMatrix,\n    cameraPosCommon,\n    shaderCoordinateOrigin,\n    geospatialOrigin\n  } = calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin);\n\n  // Calculate projection pixels per unit\n  const distanceScales = viewport.getDistanceScales();\n\n  const viewportSize = [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio];\n\n  const uniforms = {\n    // Projection mode values\n    project_uCoordinateSystem: coordinateSystem,\n    project_uProjectionMode: viewport.projectionMode,\n    project_uCoordinateOrigin: shaderCoordinateOrigin,\n    project_uCenter: projectionCenter,\n    project_uAntimeridian: (viewport.longitude || 0) - 180,\n\n    // Screen size\n    project_uViewportSize: viewportSize,\n    project_uDevicePixelRatio: devicePixelRatio,\n\n    // Distance at which screen pixels are projected\n    project_uFocalDistance: viewport.focalDistance || 1,\n    project_uCommonUnitsPerMeter: distanceScales.unitsPerMeter,\n    project_uCommonUnitsPerWorldUnit: distanceScales.unitsPerMeter,\n    project_uCommonUnitsPerWorldUnit2: DEFAULT_PIXELS_PER_UNIT2,\n    project_uScale: viewport.scale, // This is the mercator scale (2 ** zoom)\n\n    project_uViewProjectionMatrix: viewProjectionMatrix,\n\n    // This is for lighting calculations\n    project_uCameraPosition: cameraPosCommon\n  };\n\n  if (geospatialOrigin) {\n    const distanceScalesAtOrigin = viewport.getDistanceScales(geospatialOrigin);\n    switch (coordinateSystem) {\n      case COORDINATE_SYSTEM.METER_OFFSETS:\n        uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerMeter;\n        uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerMeter2;\n        break;\n\n      case COORDINATE_SYSTEM.LNGLAT:\n      case COORDINATE_SYSTEM.LNGLAT_OFFSETS:\n        uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerDegree;\n        uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerDegree2;\n        break;\n\n      // a.k.a \"preprojected\" positions\n      case COORDINATE_SYSTEM.CARTESIAN:\n        uniforms.project_uCommonUnitsPerWorldUnit = [1, 1, distanceScalesAtOrigin.unitsPerMeter[2]];\n        uniforms.project_uCommonUnitsPerWorldUnit2 = [\n          0,\n          0,\n          distanceScalesAtOrigin.unitsPerMeter2[2]\n        ];\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  return uniforms;\n}\n"]},"metadata":{},"sourceType":"module"}