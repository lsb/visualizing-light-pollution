{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport MathArray from './base/math-array';\nimport { checkNumber, checkVector } from '../lib/validators';\nimport assert from '../lib/assert';\nimport * as quat from 'gl-matrix/quat';\nimport * as vec4 from 'gl-matrix/vec4';\nvar IDENTITY_QUATERNION = [0, 0, 0, 1];\n\nvar Quaternion = function (_MathArray) {\n  _inherits(Quaternion, _MathArray);\n\n  function Quaternion() {\n    var _this;\n\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\n    _classCallCheck(this, Quaternion);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Quaternion).call(this, -0, -0, -0, -0));\n\n    if (Array.isArray(x) && arguments.length === 1) {\n      _this.copy(x);\n    } else {\n      _this.set(x, y, z, w);\n    }\n\n    return _this;\n  }\n\n  _createClass(Quaternion, [{\n    key: \"copy\",\n    value: function copy(array) {\n      this[0] = array[0];\n      this[1] = array[1];\n      this[2] = array[2];\n      this[3] = array[3];\n      return this.check();\n    }\n  }, {\n    key: \"set\",\n    value: function set(x, y, z, w) {\n      this[0] = x;\n      this[1] = y;\n      this[2] = z;\n      this[3] = w;\n      return this.check();\n    }\n  }, {\n    key: \"fromMatrix3\",\n    value: function fromMatrix3(m) {\n      quat.fromMat3(this, m);\n      return this.check();\n    }\n  }, {\n    key: \"identity\",\n    value: function identity() {\n      quat.identity(this);\n      return this.check();\n    }\n  }, {\n    key: \"fromAxisRotation\",\n    value: function fromAxisRotation(axis, rad) {\n      quat.setAxisAngle(this, axis, rad);\n      return this.check();\n    }\n  }, {\n    key: \"setAxisAngle\",\n    value: function setAxisAngle(axis, rad) {\n      return this.fromAxisRotation(axis, rad);\n    }\n  }, {\n    key: \"len\",\n    value: function len() {\n      return quat.length(this);\n    }\n  }, {\n    key: \"lengthSquared\",\n    value: function lengthSquared(a) {\n      return quat.squaredLength(this);\n    }\n  }, {\n    key: \"dot\",\n    value: function dot(a, b) {\n      if (b !== undefined) {\n        throw new Error('Quaternion.dot only takes one argument');\n      }\n\n      return quat.dot(this, a);\n    }\n  }, {\n    key: \"rotationTo\",\n    value: function rotationTo(vectorA, vectorB) {\n      quat.rotationTo(this, vectorA, vectorB);\n      return this.check();\n    }\n  }, {\n    key: \"add\",\n    value: function add(a, b) {\n      if (b !== undefined) {\n        throw new Error('Quaternion.add only takes one argument');\n      }\n\n      quat.add(this, this, a);\n      return this.check();\n    }\n  }, {\n    key: \"calculateW\",\n    value: function calculateW() {\n      quat.calculateW(this, this);\n      return this.check();\n    }\n  }, {\n    key: \"conjugate\",\n    value: function conjugate() {\n      quat.conjugate(this, this);\n      return this.check();\n    }\n  }, {\n    key: \"invert\",\n    value: function invert() {\n      quat.invert(this, this);\n      return this.check();\n    }\n  }, {\n    key: \"lerp\",\n    value: function lerp(a, b, t) {\n      quat.lerp(this, a, b, t);\n      return this.check();\n    }\n  }, {\n    key: \"multiplyRight\",\n    value: function multiplyRight(a, b) {\n      assert(!b);\n      quat.multiply(this, this, a);\n      return this.check();\n    }\n  }, {\n    key: \"multiplyLeft\",\n    value: function multiplyLeft(a, b) {\n      assert(!b);\n      quat.multiply(this, a, this);\n      return this.check();\n    }\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      var length = this.len();\n      var l = length > 0 ? 1 / length : 0;\n      this[0] = this[0] * l;\n      this[1] = this[1] * l;\n      this[2] = this[2] * l;\n      this[3] = this[3] * l;\n\n      if (length === 0) {\n        this[3] = 1;\n      }\n\n      return this.check();\n    }\n  }, {\n    key: \"rotateX\",\n    value: function rotateX(rad) {\n      quat.rotateX(this, this, rad);\n      return this.check();\n    }\n  }, {\n    key: \"rotateY\",\n    value: function rotateY(rad) {\n      quat.rotateY(this, this, rad);\n      return this.check();\n    }\n  }, {\n    key: \"rotateZ\",\n    value: function rotateZ(rad) {\n      quat.rotateZ(this, this, rad);\n      return this.check();\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(b) {\n      quat.scale(this, this, b);\n      return this.check();\n    }\n  }, {\n    key: \"slerp\",\n    value: function slerp(start, target, ratio) {\n      switch (arguments.length) {\n        case 1:\n          var _arguments$ = arguments[0];\n          var _arguments$$start = _arguments$.start;\n          start = _arguments$$start === void 0 ? IDENTITY_QUATERNION : _arguments$$start;\n          target = _arguments$.target;\n          ratio = _arguments$.ratio;\n          break;\n\n        case 2:\n          var _arguments = Array.prototype.slice.call(arguments);\n\n          target = _arguments[0];\n          ratio = _arguments[1];\n          start = this;\n          break;\n\n        default:\n      }\n\n      quat.slerp(this, start, target, ratio);\n      return this.check();\n    }\n  }, {\n    key: \"transformVector4\",\n    value: function transformVector4(vector) {\n      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : vector;\n      vec4.transformQuat(result, vector, this);\n      return checkVector(result, 4);\n    }\n  }, {\n    key: \"lengthSq\",\n    value: function lengthSq() {\n      return this.lengthSquared();\n    }\n  }, {\n    key: \"setFromAxisAngle\",\n    value: function setFromAxisAngle(axis, rad) {\n      return this.setAxisAngle(axis, rad);\n    }\n  }, {\n    key: \"premultiply\",\n    value: function premultiply(a, b) {\n      return this.multiplyLeft(a, b);\n    }\n  }, {\n    key: \"multiply\",\n    value: function multiply(a, b) {\n      return this.multiplyRight(a, b);\n    }\n  }, {\n    key: \"ELEMENTS\",\n    get: function get() {\n      return 4;\n    }\n  }, {\n    key: \"x\",\n    get: function get() {\n      return this[0];\n    },\n    set: function set(value) {\n      return this[0] = checkNumber(value);\n    }\n  }, {\n    key: \"y\",\n    get: function get() {\n      return this[1];\n    },\n    set: function set(value) {\n      return this[1] = checkNumber(value);\n    }\n  }, {\n    key: \"z\",\n    get: function get() {\n      return this[2];\n    },\n    set: function set(value) {\n      return this[2] = checkNumber(value);\n    }\n  }, {\n    key: \"w\",\n    get: function get() {\n      return this[3];\n    },\n    set: function set(value) {\n      return this[3] = checkNumber(value);\n    }\n  }]);\n\n  return Quaternion;\n}(MathArray);\n\nexport { Quaternion as default };","map":{"version":3,"sources":["../../../src/classes/quaternion.js"],"names":["IDENTITY_QUATERNION","Quaternion","MathArray","x","y","z","w","Array","arguments","array","m","quat","axis","rad","value","checkNumber","a","b","vectorA","vectorB","t","assert","length","l","start","target","ratio","vector","result","vec4","checkVector"],"mappings":"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","sourcesContent":["// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport MathArray from './base/math-array';\nimport {checkNumber, checkVector} from '../lib/validators';\nimport assert from '../lib/assert';\n\nimport * as quat from 'gl-matrix/quat';\nimport * as vec4 from 'gl-matrix/vec4';\n\nconst IDENTITY_QUATERNION = [0, 0, 0, 1];\n\nexport default class Quaternion extends MathArray {\n  // Creates a new identity quaternion\n  // w^2 + x^2 + y^2 + z^2 = 1\n  constructor(x = 0, y = 0, z = 0, w = 1) {\n    // PERF NOTE: initialize elements as double precision numbers\n    super(-0, -0, -0, -0);\n    if (Array.isArray(x) && arguments.length === 1) {\n      this.copy(x);\n    } else {\n      this.set(x, y, z, w);\n    }\n  }\n\n  copy(array) {\n    this[0] = array[0];\n    this[1] = array[1];\n    this[2] = array[2];\n    this[3] = array[3];\n    return this.check();\n  }\n\n  set(x, y, z, w) {\n    this[0] = x;\n    this[1] = y;\n    this[2] = z;\n    this[3] = w;\n    return this.check();\n  }\n\n  // Creates a quaternion from the given 3x3 rotation matrix.\n  // NOTE: The resultant quaternion is not normalized, so you should\n  // be sure to renormalize the quaternion yourself where necessary.\n  fromMatrix3(m) {\n    quat.fromMat3(this, m);\n    return this.check();\n  }\n\n  // Set a quat to the identity quaternion\n  identity() {\n    quat.identity(this);\n    return this.check();\n  }\n\n  fromAxisRotation(axis, rad) {\n    quat.setAxisAngle(this, axis, rad);\n    return this.check();\n  }\n\n  // Set the components of a quat to the given values\n  // set(i, j, k, l) {\n  //   quat.set(this, i, j, k, l);\n  //   return this.check();\n  // }\n\n  // Sets a quat from the given angle and rotation axis, then returns it.\n  setAxisAngle(axis, rad) {\n    return this.fromAxisRotation(axis, rad);\n  }\n\n  // Getters/setters\n  /* eslint-disable no-multi-spaces, brace-style, no-return-assign */\n  get ELEMENTS() {\n    return 4;\n  }\n\n  get x() {\n    return this[0];\n  }\n\n  set x(value) {\n    return (this[0] = checkNumber(value));\n  }\n\n  get y() {\n    return this[1];\n  }\n\n  set y(value) {\n    return (this[1] = checkNumber(value));\n  }\n\n  get z() {\n    return this[2];\n  }\n\n  set z(value) {\n    return (this[2] = checkNumber(value));\n  }\n\n  get w() {\n    return this[3];\n  }\n\n  set w(value) {\n    return (this[3] = checkNumber(value));\n  }\n\n  /* eslint-enable no-multi-spaces, brace-style, no-return-assign */\n\n  // Calculates the length of a quat\n  len() {\n    return quat.length(this);\n  }\n\n  // Calculates the squared length of a quat\n  lengthSquared(a) {\n    return quat.squaredLength(this);\n  }\n\n  // Calculates the dot product of two quat's\n  // @return {Number}\n  dot(a, b) {\n    if (b !== undefined) {\n      throw new Error('Quaternion.dot only takes one argument');\n    }\n    return quat.dot(this, a);\n  }\n\n  // Gets the rotation axis and angle for a given quaternion.\n  // If a quaternion is created with setAxisAngle, this method will\n  // return the same values as providied in the original parameter\n  // list OR functionally equivalent values.\n  // Example: The quaternion formed by axis [0, 0, 1] and angle -90\n  // is the same as the quaternion formed by [0, 0, 1] and 270.\n  // This method favors the latter.\n  // @return {{[x,y,z], Number}}\n  // getAxisAngle() {\n  //   const axis = [];\n  //   const angle = quat.getAxisAngle(axis, this);\n  //   return {axis, angle};\n  // }\n\n  // MODIFIERS\n\n  // Sets a quaternion to represent the shortest rotation from one vector\n  // to another. Both vectors are assumed to be unit length.\n  rotationTo(vectorA, vectorB) {\n    quat.rotationTo(this, vectorA, vectorB);\n    return this.check();\n  }\n\n  // Sets the specified quaternion with values corresponding to the given axes.\n  // Each axis is a vec3 and is expected to be unit length and perpendicular\n  // to all other specified axes.\n  // setAxes() {\n  //   Number\n  // }\n\n  // Performs a spherical linear interpolation with two control points\n  // sqlerp() {\n  //   Number;\n  // }\n\n  // Adds two quat's\n  add(a, b) {\n    if (b !== undefined) {\n      throw new Error('Quaternion.add only takes one argument');\n    }\n    quat.add(this, this, a);\n    return this.check();\n  }\n\n  // Calculates the W component of a quat from the X, Y, and Z components.\n  // Any existing W component will be ignored.\n  calculateW() {\n    quat.calculateW(this, this);\n    return this.check();\n  }\n\n  // Calculates the conjugate of a quat If the quaternion is normalized,\n  // this function is faster than quat.inverse and produces the same result.\n  conjugate() {\n    quat.conjugate(this, this);\n    return this.check();\n  }\n\n  // Calculates the inverse of a quat\n  invert() {\n    quat.invert(this, this);\n    return this.check();\n  }\n\n  // Performs a linear interpolation between two quat's\n  lerp(a, b, t) {\n    quat.lerp(this, a, b, t);\n    return this.check();\n  }\n\n  // Multiplies two quat's\n  multiplyRight(a, b) {\n    assert(!b); // Quaternion.multiply only takes one argument\n    quat.multiply(this, this, a);\n    return this.check();\n  }\n\n  multiplyLeft(a, b) {\n    assert(!b); // Quaternion.multiply only takes one argument\n    quat.multiply(this, a, this);\n    return this.check();\n  }\n\n  // Normalize a quat\n  normalize() {\n    // Handle 0 case\n    const length = this.len();\n    const l = length > 0 ? 1 / length : 0;\n    this[0] = this[0] * l;\n    this[1] = this[1] * l;\n    this[2] = this[2] * l;\n    this[3] = this[3] * l;\n    // Set to [0, 0, 0, 1] if length is 0\n    if (length === 0) {\n      this[3] = 1;\n    }\n    return this.check();\n  }\n\n  // Rotates a quaternion by the given angle about the X axis\n  rotateX(rad) {\n    quat.rotateX(this, this, rad);\n    return this.check();\n  }\n\n  // Rotates a quaternion by the given angle about the Y axis\n  rotateY(rad) {\n    quat.rotateY(this, this, rad);\n    return this.check();\n  }\n\n  // Rotates a quaternion by the given angle about the Z axis\n  rotateZ(rad) {\n    quat.rotateZ(this, this, rad);\n    return this.check();\n  }\n\n  // Scales a quat by a scalar number\n  scale(b) {\n    quat.scale(this, this, b);\n    return this.check();\n  }\n\n  // Performs a spherical linear interpolation between two quat\n  slerp(start, target, ratio) {\n    switch (arguments.length) {\n      case 1: // Deprecated signature ({start, target, ratio})\n        ({start = IDENTITY_QUATERNION, target, ratio} = arguments[0]);\n        break;\n      case 2: // THREE.js compatibility signature (target, ration)\n        [target, ratio] = arguments;\n        start = this; // eslint-disable-line\n        break;\n      default: // Default signature: (start, target, ratio)\n    }\n    quat.slerp(this, start, target, ratio);\n    return this.check();\n  }\n\n  transformVector4(vector, result = vector) {\n    vec4.transformQuat(result, vector, this);\n    return checkVector(result, 4);\n  }\n\n  // THREE.js Math API compatibility\n  lengthSq() {\n    return this.lengthSquared();\n  }\n\n  setFromAxisAngle(axis, rad) {\n    return this.setAxisAngle(axis, rad);\n  }\n\n  premultiply(a, b) {\n    return this.multiplyLeft(a, b);\n  }\n\n  multiply(a, b) {\n    return this.multiplyRight(a, b);\n  }\n\n  // DEPRECATED\n\n  // fromValues(x, y, z, w) {\n  //   return this.set(x, y, z, w);\n  // }\n\n  // squaredLength() {\n  //   return this.lengthSquared();\n  // }\n}\n"]},"metadata":{},"sourceType":"module"}