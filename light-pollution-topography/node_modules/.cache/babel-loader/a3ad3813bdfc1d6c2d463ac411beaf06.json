{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { GL_PARAMETER_DEFAULTS, GL_HOOKED_SETTERS } from './webgl-parameter-tables';\nimport { setParameters, getParameters } from './unified-parameter-api';\nimport { assert, deepArrayEqual } from '../utils';\n\nfunction installGetterOverride(gl, functionName) {\n  var originalGetterFunc = gl[functionName].bind(gl);\n\n  gl[functionName] = function get() {\n    var pname = arguments.length <= 0 ? undefined : arguments[0];\n\n    if (!(pname in gl.state.cache)) {\n      gl.state.cache[pname] = originalGetterFunc.apply(void 0, arguments);\n    }\n\n    return gl.state.enable ? gl.state.cache[pname] : originalGetterFunc.apply(void 0, arguments);\n  };\n\n  Object.defineProperty(gl[functionName], 'name', {\n    value: \"\".concat(functionName, \"-from-cache\"),\n    configurable: false\n  });\n}\n\nfunction installSetterSpy(gl, functionName, setter) {\n  var originalSetterFunc = gl[functionName].bind(gl);\n\n  gl[functionName] = function set() {\n    for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {\n      params[_key] = arguments[_key];\n    }\n\n    var _setter = setter.apply(void 0, [gl.state._updateCache].concat(params)),\n        valueChanged = _setter.valueChanged,\n        oldValue = _setter.oldValue;\n\n    if (valueChanged) {\n      originalSetterFunc.apply(void 0, params);\n    }\n\n    return oldValue;\n  };\n\n  Object.defineProperty(gl[functionName], 'name', {\n    value: \"\".concat(functionName, \"-to-cache\"),\n    configurable: false\n  });\n}\n\nfunction installProgramSpy(gl) {\n  var originalUseProgram = gl.useProgram.bind(gl);\n\n  gl.useProgram = function useProgramLuma(handle) {\n    if (gl.state.program !== handle) {\n      originalUseProgram(handle);\n      gl.state.program = handle;\n    }\n  };\n}\n\nvar GLState = function () {\n  function GLState(gl) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$copyState = _ref.copyState,\n        copyState = _ref$copyState === void 0 ? false : _ref$copyState,\n        _ref$log = _ref.log,\n        log = _ref$log === void 0 ? function () {} : _ref$log;\n\n    _classCallCheck(this, GLState);\n\n    this.gl = gl;\n    this.program = null;\n    this.stateStack = [];\n    this.enable = true;\n    this.cache = copyState ? getParameters(gl) : Object.assign({}, GL_PARAMETER_DEFAULTS);\n    this.log = log;\n    this._updateCache = this._updateCache.bind(this);\n    Object.seal(this);\n  }\n\n  _createClass(GLState, [{\n    key: \"push\",\n    value: function push() {\n      var values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.stateStack.push({});\n    }\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      assert(this.stateStack.length > 0);\n      var oldValues = this.stateStack[this.stateStack.length - 1];\n      setParameters(this.gl, oldValues, this.cache);\n      this.stateStack.pop();\n    }\n  }, {\n    key: \"_updateCache\",\n    value: function _updateCache(values) {\n      var valueChanged = false;\n      var oldValue;\n      var oldValues = this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1];\n\n      for (var key in values) {\n        assert(key !== undefined);\n        var value = values[key];\n        var cached = this.cache[key];\n\n        if (!deepArrayEqual(value, cached)) {\n          valueChanged = true;\n          oldValue = cached;\n\n          if (oldValues && !(key in oldValues)) {\n            oldValues[key] = cached;\n          }\n\n          this.cache[key] = value;\n        }\n      }\n\n      return {\n        valueChanged: valueChanged,\n        oldValue: oldValue\n      };\n    }\n  }]);\n\n  return GLState;\n}();\n\nexport default function trackContextState(gl) {\n  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref2$enable = _ref2.enable,\n      enable = _ref2$enable === void 0 ? true : _ref2$enable,\n      copyState = _ref2.copyState;\n\n  assert(copyState !== undefined);\n\n  if (!gl.state) {\n    var global_ = typeof global !== 'undefined' ? global : window;\n\n    if (global_.polyfillContext) {\n      global_.polyfillContext(gl);\n    }\n\n    gl.state = new GLState(gl, {\n      copyState: copyState,\n      enable: enable\n    });\n    installProgramSpy(gl);\n\n    for (var key in GL_HOOKED_SETTERS) {\n      var setter = GL_HOOKED_SETTERS[key];\n      installSetterSpy(gl, key, setter);\n    }\n\n    installGetterOverride(gl, 'getParameter');\n    installGetterOverride(gl, 'isEnabled');\n  }\n\n  gl.state.enable = enable;\n  return gl;\n}\nexport function pushContextState(gl) {\n  if (!gl.state) {\n    trackContextState(gl, {\n      copyState: false\n    });\n  }\n\n  gl.state.push();\n}\nexport function popContextState(gl) {\n  assert(gl.state);\n  gl.state.pop();\n}","map":{"version":3,"sources":["../../../src/state-tracker/track-context-state.js"],"names":["originalGetterFunc","gl","pname","Object","value","configurable","originalSetterFunc","params","valueChanged","oldValue","setter","originalUseProgram","GLState","copyState","log","getParameters","values","assert","oldValues","setParameters","key","cached","deepArrayEqual","enable","global_","installProgramSpy","GL_HOOKED_SETTERS","installSetterSpy","installGetterOverride","trackContextState"],"mappings":"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","sourcesContent":["// Support for listening to context state changes and intercepting state queries\n//\n// NOTE: this system does not handle buffer bindings\nimport {GL_PARAMETER_DEFAULTS, GL_HOOKED_SETTERS} from './webgl-parameter-tables';\nimport {setParameters, getParameters} from './unified-parameter-api';\nimport {assert, deepArrayEqual} from '../utils';\n\n// HELPER FUNCTIONS - INSTALL GET/SET INTERCEPTORS (SPYS) ON THE CONTEXT\n\n// Overrides a WebGLRenderingContext state \"getter\" function\n// to return values directly from cache\nfunction installGetterOverride(gl, functionName) {\n  // Get the original function from the WebGLRenderingContext\n  const originalGetterFunc = gl[functionName].bind(gl);\n\n  // Wrap it with a spy so that we can update our state cache when it gets called\n  gl[functionName] = function get(...params) {\n    const pname = params[0];\n\n    // WebGL limits are not prepopulated in the cache, we must\n    // query first time. They are all primitive (single value)\n    if (!(pname in gl.state.cache)) {\n      gl.state.cache[pname] = originalGetterFunc(...params);\n    }\n\n    // Optionally call the original function to do a \"hard\" query from the WebGLRenderingContext\n    return gl.state.enable\n      ? // Call the getter the params so that it can e.g. serve from a cache\n        gl.state.cache[pname]\n      : // Optionally call the original function to do a \"hard\" query from the WebGLRenderingContext\n        originalGetterFunc(...params);\n  };\n\n  // Set the name of this anonymous function to help in debugging and profiling\n  Object.defineProperty(gl[functionName], 'name', {\n    value: `${functionName}-from-cache`,\n    configurable: false\n  });\n}\n\n// Overrides a WebGLRenderingContext state \"setter\" function\n// to call a setter spy before the actual setter. Allows us to keep a cache\n// updated with a copy of the WebGL context state.\nfunction installSetterSpy(gl, functionName, setter) {\n  // Get the original function from the WebGLRenderingContext\n  const originalSetterFunc = gl[functionName].bind(gl);\n\n  // Wrap it with a spy so that we can update our state cache when it gets called\n  gl[functionName] = function set(...params) {\n    // Update the value\n    // Call the setter with the state cache and the params so that it can store the parameters\n    const {valueChanged, oldValue} = setter(gl.state._updateCache, ...params);\n\n    // Call the original WebGLRenderingContext func to make sure the context actually gets updated\n    if (valueChanged) {\n      originalSetterFunc(...params);\n    }\n\n    // Note: if the original function fails to set the value, our state cache will be bad\n    // No solution for this at the moment, but assuming that this is unlikely to be a real problem\n    // We could call the setter after the originalSetterFunc. Concern is that this would\n    // cause different behavior in debug mode, where originalSetterFunc can throw exceptions\n\n    return oldValue;\n  };\n\n  // Set the name of this anonymous function to help in debugging and profiling\n  Object.defineProperty(gl[functionName], 'name', {\n    value: `${functionName}-to-cache`,\n    configurable: false\n  });\n}\n\nfunction installProgramSpy(gl) {\n  const originalUseProgram = gl.useProgram.bind(gl);\n\n  gl.useProgram = function useProgramLuma(handle) {\n    if (gl.state.program !== handle) {\n      originalUseProgram(handle);\n      gl.state.program = handle;\n    }\n  };\n}\n\n// HELPER CLASS - GLState\n\n/* eslint-disable no-shadow */\nclass GLState {\n  constructor(\n    gl,\n    {\n      copyState = false, // Copy cache from params (slow) or initialize from WebGL defaults (fast)\n      log = () => {} // Logging function, called when gl parameter change calls are actually issued\n    } = {}\n  ) {\n    this.gl = gl;\n    this.program = null;\n    this.stateStack = [];\n    this.enable = true;\n    this.cache = copyState ? getParameters(gl) : Object.assign({}, GL_PARAMETER_DEFAULTS);\n    this.log = log;\n\n    this._updateCache = this._updateCache.bind(this);\n    Object.seal(this);\n  }\n\n  push(values = {}) {\n    this.stateStack.push({});\n  }\n\n  pop() {\n    assert(this.stateStack.length > 0);\n    // Use the saved values in the state stack to restore parameters\n    const oldValues = this.stateStack[this.stateStack.length - 1];\n    setParameters(this.gl, oldValues, this.cache);\n    // Don't pop until we have reset parameters (to make sure other \"stack frames\" are not affected)\n    this.stateStack.pop();\n  }\n\n  // interceptor for context set functions - update our cache and our stack\n  // values (Object) - the key values for this setter\n  _updateCache(values) {\n    let valueChanged = false;\n    let oldValue; // = undefined\n\n    const oldValues = this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1];\n\n    for (const key in values) {\n      assert(key !== undefined);\n      const value = values[key];\n      const cached = this.cache[key];\n      // Check that value hasn't already been shadowed\n      if (!deepArrayEqual(value, cached)) {\n        valueChanged = true;\n        oldValue = cached;\n\n        // First, save current value being shadowed\n        // If a state stack frame is active, save the current parameter values for pop\n        // but first check that value hasn't already been shadowed and saved\n        if (oldValues && !(key in oldValues)) {\n          oldValues[key] = cached;\n        }\n\n        // Save current value being shadowed\n        this.cache[key] = value;\n      }\n    }\n\n    return {valueChanged, oldValue};\n  }\n}\n\n// PUBLIC API\n\n/**\n * Initialize WebGL state caching on a context\n * can be called multiple times to enable/disable\n * @param {WebGLRenderingContext} - context\n */\n// After calling this function, context state will be cached\n// gl.state.push() and gl.state.pop() will be available for saving,\n// temporarily modifying, and then restoring state.\nexport default function trackContextState(gl, {enable = true, copyState} = {}) {\n  assert(copyState !== undefined);\n  if (!gl.state) {\n    /* global window, global */\n    const global_ = typeof global !== 'undefined' ? global : window;\n    if (global_.polyfillContext) {\n      global_.polyfillContext(gl);\n    }\n\n    // Create a state cache\n    gl.state = new GLState(gl, {copyState, enable});\n\n    installProgramSpy(gl);\n\n    // intercept all setter functions in the table\n    for (const key in GL_HOOKED_SETTERS) {\n      const setter = GL_HOOKED_SETTERS[key];\n      installSetterSpy(gl, key, setter);\n    }\n\n    // intercept all getter functions in the table\n    installGetterOverride(gl, 'getParameter');\n    installGetterOverride(gl, 'isEnabled');\n  }\n\n  gl.state.enable = enable;\n\n  return gl;\n}\n\nexport function pushContextState(gl) {\n  if (!gl.state) {\n    trackContextState(gl, {copyState: false});\n  }\n  gl.state.push();\n}\n\nexport function popContextState(gl) {\n  assert(gl.state);\n  gl.state.pop();\n}\n"]},"metadata":{},"sourceType":"module"}