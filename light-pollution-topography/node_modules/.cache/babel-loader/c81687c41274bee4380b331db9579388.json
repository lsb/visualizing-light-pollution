{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { Matrix4 } from 'math.gl';\nimport { Buffer, Accessor, log } from '@luma.gl/webgl';\nimport { GroupNode } from '../scenegraph/';\nimport GLTFAnimator from './gltf-animator';\nimport createGLTFModel from './create-gltf-model';\nvar ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nvar DEFAULT_OPTIONS = {\n  modelOptions: {},\n  pbrDebug: false,\n  imageBasedLightingEnvironment: null,\n  lights: true,\n  useTangents: false\n};\n\nvar GLTFInstantiator = function () {\n  function GLTFInstantiator(gl) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, GLTFInstantiator);\n\n    this.gl = gl;\n    this.options = Object.assign({}, DEFAULT_OPTIONS, options);\n  }\n\n  _createClass(GLTFInstantiator, [{\n    key: \"instantiate\",\n    value: function instantiate(gltf) {\n      var _this = this;\n\n      this.gltf = gltf;\n      var scenes = (gltf.scenes || []).map(function (scene) {\n        return _this.createScene(scene);\n      });\n      return scenes;\n    }\n  }, {\n    key: \"createAnimator\",\n    value: function createAnimator() {\n      if (Array.isArray(this.gltf.animations)) {\n        return new GLTFAnimator(this.gltf);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"createScene\",\n    value: function createScene(gltfScene) {\n      var _this2 = this;\n\n      var gltfNodes = gltfScene.nodes || [];\n      var nodes = gltfNodes.map(function (node) {\n        return _this2.createNode(node);\n      });\n      var scene = new GroupNode({\n        id: gltfScene.name || gltfScene.id,\n        children: nodes\n      });\n      return scene;\n    }\n  }, {\n    key: \"createNode\",\n    value: function createNode(gltfNode) {\n      var _this3 = this;\n\n      if (!gltfNode._node) {\n        var gltfChildren = gltfNode.children || [];\n        var children = gltfChildren.map(function (child) {\n          return _this3.createNode(child);\n        });\n\n        if (gltfNode.mesh) {\n          children.push(this.createMesh(gltfNode.mesh));\n        }\n\n        var node = new GroupNode({\n          id: gltfNode.name || gltfNode.id,\n          children: children\n        });\n\n        if (gltfNode.matrix) {\n          node.setMatrix(gltfNode.matrix);\n        } else {\n          node.matrix.identity();\n\n          if (gltfNode.translation) {\n            node.matrix.translate(gltfNode.translation);\n          }\n\n          if (gltfNode.rotation) {\n            var rotationMatrix = new Matrix4().fromQuaternion(gltfNode.rotation);\n            node.matrix.multiplyRight(rotationMatrix);\n          }\n\n          if (gltfNode.scale) {\n            node.matrix.scale(gltfNode.scale);\n          }\n        }\n\n        gltfNode._node = node;\n      }\n\n      return gltfNode._node;\n    }\n  }, {\n    key: \"createMesh\",\n    value: function createMesh(gltfMesh) {\n      var _this4 = this;\n\n      if (!gltfMesh._mesh) {\n        var gltfPrimitives = gltfMesh.primitives || [];\n        var primitives = gltfPrimitives.map(function (gltfPrimitive, i) {\n          return _this4.createPrimitive(gltfPrimitive, i, gltfMesh);\n        });\n        var mesh = new GroupNode({\n          id: gltfMesh.name || gltfMesh.id,\n          children: primitives\n        });\n        gltfMesh._mesh = mesh;\n      }\n\n      return gltfMesh._mesh;\n    }\n  }, {\n    key: \"getVertexCount\",\n    value: function getVertexCount(attributes) {\n      log.warn('getVertexCount() not found')();\n    }\n  }, {\n    key: \"createPrimitive\",\n    value: function createPrimitive(gltfPrimitive, i, gltfMesh) {\n      return createGLTFModel(this.gl, Object.assign({\n        id: gltfPrimitive.name || \"\".concat(gltfMesh.name || gltfMesh.id, \"-primitive-\").concat(i),\n        drawMode: gltfPrimitive.mode || 4,\n        vertexCount: gltfPrimitive.indices ? gltfPrimitive.indices.count : this.getVertexCount(gltfPrimitive.attributes),\n        attributes: this.createAttributes(gltfPrimitive.attributes, gltfPrimitive.indices),\n        material: gltfPrimitive.material\n      }, this.options));\n    }\n  }, {\n    key: \"createAttributes\",\n    value: function createAttributes(attributes, indices) {\n      var _this5 = this;\n\n      var loadedAttributes = {};\n      Object.keys(attributes).forEach(function (attrName) {\n        loadedAttributes[attrName] = _this5.createAccessor(attributes[attrName], _this5.createBuffer(attributes[attrName], _this5.gl.ARRAY_BUFFER));\n      });\n\n      if (indices) {\n        loadedAttributes.indices = this.createAccessor(indices, this.createBuffer(indices, this.gl.ELEMENT_ARRAY_BUFFER));\n      }\n\n      log.info(4, 'glTF Attributes', {\n        attributes: attributes,\n        indices: indices,\n        generated: loadedAttributes\n      })();\n      return loadedAttributes;\n    }\n  }, {\n    key: \"createBuffer\",\n    value: function createBuffer(attribute, target) {\n      if (!attribute.bufferView) {\n        attribute.bufferView = {};\n      }\n\n      var bufferView = attribute.bufferView;\n\n      if (!bufferView.lumaBuffers) {\n        bufferView.lumaBuffers = {};\n      }\n\n      if (!bufferView.lumaBuffers[target]) {\n        bufferView.lumaBuffers[target] = new Buffer(this.gl, {\n          id: \"from-\".concat(bufferView.id),\n          data: bufferView.data || attribute.value,\n          target: target\n        });\n      }\n\n      return bufferView.lumaBuffers[target];\n    }\n  }, {\n    key: \"createAccessor\",\n    value: function createAccessor(accessor, buffer) {\n      return new Accessor({\n        buffer: buffer,\n        offset: accessor.byteOffset || 0,\n        stride: accessor.bufferView.byteStride || 0,\n        type: accessor.componentType,\n        size: ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type]\n      });\n    }\n  }, {\n    key: \"createSampler\",\n    value: function createSampler(gltfSampler) {\n      return gltfSampler;\n    }\n  }, {\n    key: \"needsPOT\",\n    value: function needsPOT() {\n      return false;\n    }\n  }]);\n\n  return GLTFInstantiator;\n}();\n\nexport { GLTFInstantiator as default };","map":{"version":3,"sources":["../../../src/gltf/gltf-instantiator.js"],"names":["ATTRIBUTE_TYPE_TO_COMPONENTS","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","DEFAULT_OPTIONS","modelOptions","pbrDebug","imageBasedLightingEnvironment","lights","useTangents","GLTFInstantiator","options","Object","gltf","scenes","Array","gltfScene","gltfNodes","nodes","scene","id","children","gltfNode","gltfChildren","node","rotationMatrix","gltfMesh","gltfPrimitives","primitives","mesh","attributes","log","gltfPrimitive","i","createGLTFModel","drawMode","vertexCount","material","indices","loadedAttributes","generated","attribute","target","bufferView","data","accessor","buffer","offset","stride","type","size","gltfSampler"],"mappings":"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","sourcesContent":["import {Matrix4} from 'math.gl';\nimport {Buffer, Accessor, log} from '@luma.gl/webgl';\nimport {GroupNode} from '../scenegraph/';\n\nimport GLTFAnimator from './gltf-animator';\nimport createGLTFModel from './create-gltf-model';\n\n// TODO: import {ATTRIBUTE_TYPE_TO_COMPONENTS} from '@loaders.gl/gltf';\nconst ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nconst DEFAULT_OPTIONS = {\n  modelOptions: {},\n  pbrDebug: false,\n  imageBasedLightingEnvironment: null,\n  lights: true,\n  useTangents: false\n};\n\n// GLTF instantiator for luma.gl\n// Walks the parsed and resolved glTF structure and builds a luma.gl scenegraph\nexport default class GLTFInstantiator {\n  constructor(gl, options = {}) {\n    this.gl = gl;\n    this.options = Object.assign({}, DEFAULT_OPTIONS, options);\n  }\n\n  instantiate(gltf) {\n    this.gltf = gltf;\n    const scenes = (gltf.scenes || []).map(scene => this.createScene(scene));\n    return scenes;\n  }\n\n  createAnimator() {\n    if (Array.isArray(this.gltf.animations)) {\n      return new GLTFAnimator(this.gltf);\n    }\n\n    return null;\n  }\n\n  createScene(gltfScene) {\n    const gltfNodes = gltfScene.nodes || [];\n    const nodes = gltfNodes.map(node => this.createNode(node));\n    const scene = new GroupNode({\n      id: gltfScene.name || gltfScene.id,\n      children: nodes\n    });\n    return scene;\n  }\n\n  createNode(gltfNode) {\n    if (!gltfNode._node) {\n      const gltfChildren = gltfNode.children || [];\n      const children = gltfChildren.map(child => this.createNode(child));\n\n      // Node can have children nodes and meshes at the same time\n      if (gltfNode.mesh) {\n        children.push(this.createMesh(gltfNode.mesh));\n      }\n\n      const node = new GroupNode({\n        id: gltfNode.name || gltfNode.id,\n        children\n      });\n\n      if (gltfNode.matrix) {\n        node.setMatrix(gltfNode.matrix);\n      } else {\n        node.matrix.identity();\n\n        if (gltfNode.translation) {\n          node.matrix.translate(gltfNode.translation);\n        }\n\n        if (gltfNode.rotation) {\n          const rotationMatrix = new Matrix4().fromQuaternion(gltfNode.rotation);\n          node.matrix.multiplyRight(rotationMatrix);\n        }\n\n        if (gltfNode.scale) {\n          node.matrix.scale(gltfNode.scale);\n        }\n      }\n      gltfNode._node = node;\n    }\n\n    return gltfNode._node;\n  }\n\n  createMesh(gltfMesh) {\n    // TODO: avoid changing the gltf\n    if (!gltfMesh._mesh) {\n      const gltfPrimitives = gltfMesh.primitives || [];\n      const primitives = gltfPrimitives.map((gltfPrimitive, i) =>\n        this.createPrimitive(gltfPrimitive, i, gltfMesh)\n      );\n      const mesh = new GroupNode({\n        id: gltfMesh.name || gltfMesh.id,\n        children: primitives\n      });\n      gltfMesh._mesh = mesh;\n    }\n\n    return gltfMesh._mesh;\n  }\n\n  getVertexCount(attributes) {\n    // TODO: implement this\n    log.warn('getVertexCount() not found')();\n  }\n\n  createPrimitive(gltfPrimitive, i, gltfMesh) {\n    return createGLTFModel(\n      this.gl,\n      Object.assign(\n        {\n          id: gltfPrimitive.name || `${gltfMesh.name || gltfMesh.id}-primitive-${i}`,\n          drawMode: gltfPrimitive.mode || 4,\n          vertexCount: gltfPrimitive.indices\n            ? gltfPrimitive.indices.count\n            : this.getVertexCount(gltfPrimitive.attributes),\n          attributes: this.createAttributes(gltfPrimitive.attributes, gltfPrimitive.indices),\n          material: gltfPrimitive.material\n        },\n        this.options\n      )\n    );\n  }\n\n  createAttributes(attributes, indices) {\n    const loadedAttributes = {};\n\n    Object.keys(attributes).forEach(attrName => {\n      loadedAttributes[attrName] = this.createAccessor(\n        attributes[attrName],\n        this.createBuffer(attributes[attrName], this.gl.ARRAY_BUFFER)\n      );\n    });\n\n    if (indices) {\n      loadedAttributes.indices = this.createAccessor(\n        indices,\n        this.createBuffer(indices, this.gl.ELEMENT_ARRAY_BUFFER)\n      );\n    }\n\n    log.info(4, 'glTF Attributes', {attributes, indices, generated: loadedAttributes})();\n\n    return loadedAttributes;\n  }\n\n  createBuffer(attribute, target) {\n    if (!attribute.bufferView) {\n      // Draco decoded files do not have a bufferView\n      attribute.bufferView = {};\n    }\n\n    const {bufferView} = attribute;\n    if (!bufferView.lumaBuffers) {\n      bufferView.lumaBuffers = {};\n    }\n\n    if (!bufferView.lumaBuffers[target]) {\n      bufferView.lumaBuffers[target] = new Buffer(this.gl, {\n        id: `from-${bufferView.id}`,\n        // Draco decoded files have attribute.value\n        data: bufferView.data || attribute.value,\n        target\n      });\n    }\n\n    return bufferView.lumaBuffers[target];\n  }\n\n  createAccessor(accessor, buffer) {\n    return new Accessor({\n      buffer,\n      offset: accessor.byteOffset || 0,\n      stride: accessor.bufferView.byteStride || 0,\n      type: accessor.componentType,\n      size: ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type]\n    });\n  }\n\n  // TODO - create sampler in WebGL2\n  createSampler(gltfSampler) {\n    return gltfSampler;\n  }\n\n  // Helper methods (move to GLTFLoader.resolve...?)\n\n  needsPOT() {\n    // Has a wrapping mode (either wrapS or wrapT) equal to REPEAT or MIRRORED_REPEAT, or\n    // Has a minification filter (minFilter) that uses mipmapping\n    // (NEAREST_MIPMAP_NEAREST, NEAREST_MIPMAP_LINEAR,\n    // LINEAR_MIPMAP_NEAREST, or LINEAR_MIPMAP_LINEAR).\n    return false;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}