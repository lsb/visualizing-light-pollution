{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport Resource from './resource';\nimport Buffer from './buffer';\nimport { TEXTURE_FORMATS, DATA_FORMAT_CHANNELS, TYPE_SIZES, isFormatSupported, isLinearFilteringSupported } from './texture-formats';\nimport { isWebGL2, withParameters, log } from '@luma.gl/gltools';\nimport { global } from 'probe.gl/env';\nimport { assertWebGL2Context } from '../webgl-utils';\nimport { uid, isPowerOfTwo, assert } from '../utils';\nvar NPOT_MIN_FILTERS = [9729, 9728];\n\nvar WebGLBuffer = global.WebGLBuffer || function WebGLBuffer() {};\n\nvar Texture = function (_Resource) {\n  _inherits(Texture, _Resource);\n\n  _createClass(Texture, null, [{\n    key: \"isSupported\",\n    value: function isSupported(gl) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          format = _ref.format,\n          linearFiltering = _ref.linearFiltering;\n\n      var supported = true;\n\n      if (format) {\n        supported = supported && isFormatSupported(gl, format);\n        supported = supported && (!linearFiltering || isLinearFilteringSupported(gl, format));\n      }\n\n      return supported;\n    }\n  }]);\n\n  function Texture(gl, props) {\n    var _this;\n\n    _classCallCheck(this, Texture);\n\n    var _props$id = props.id,\n        id = _props$id === void 0 ? uid('texture') : _props$id,\n        handle = props.handle,\n        target = props.target;\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Texture).call(this, gl, {\n      id: id,\n      handle: handle\n    }));\n    _this.target = target;\n    _this.textureUnit = undefined;\n    _this.loaded = false;\n    _this.width = undefined;\n    _this.height = undefined;\n    _this.depth = undefined;\n    _this.format = undefined;\n    _this.type = undefined;\n    _this.dataFormat = undefined;\n    _this.border = undefined;\n    _this.textureUnit = undefined;\n    _this.mipmaps = undefined;\n    return _this;\n  }\n\n  _createClass(Texture, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"Texture(\".concat(this.id, \",\").concat(this.width, \"x\").concat(this.height, \")\");\n    }\n  }, {\n    key: \"initialize\",\n    value: function initialize() {\n      var _this2 = this;\n\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var data = props.data;\n\n      if (data instanceof Promise) {\n        data.then(function (resolvedImageData) {\n          return _this2.initialize(Object.assign({}, props, {\n            pixels: resolvedImageData,\n            data: resolvedImageData\n          }));\n        });\n        return this;\n      }\n\n      var _props$pixels = props.pixels,\n          pixels = _props$pixels === void 0 ? null : _props$pixels,\n          _props$format = props.format,\n          format = _props$format === void 0 ? 6408 : _props$format,\n          _props$border = props.border,\n          border = _props$border === void 0 ? 0 : _props$border,\n          _props$recreate = props.recreate,\n          recreate = _props$recreate === void 0 ? false : _props$recreate,\n          _props$parameters = props.parameters,\n          parameters = _props$parameters === void 0 ? {} : _props$parameters,\n          _props$pixelStore = props.pixelStore,\n          pixelStore = _props$pixelStore === void 0 ? {} : _props$pixelStore,\n          _props$textureUnit = props.textureUnit,\n          textureUnit = _props$textureUnit === void 0 ? undefined : _props$textureUnit;\n      var _props$mipmaps = props.mipmaps,\n          mipmaps = _props$mipmaps === void 0 ? true : _props$mipmaps;\n\n      if (!data) {\n        data = pixels;\n      }\n\n      var width = props.width,\n          height = props.height,\n          dataFormat = props.dataFormat,\n          type = props.type;\n      var _props$depth = props.depth,\n          depth = _props$depth === void 0 ? 0 : _props$depth;\n\n      var _this$_deduceParamete = this._deduceParameters({\n        format: format,\n        type: type,\n        dataFormat: dataFormat,\n        compressed: false,\n        data: data,\n        width: width,\n        height: height\n      });\n\n      width = _this$_deduceParamete.width;\n      height = _this$_deduceParamete.height;\n      dataFormat = _this$_deduceParamete.dataFormat;\n      type = _this$_deduceParamete.type;\n      this.width = width;\n      this.height = height;\n      this.depth = depth;\n      this.format = format;\n      this.type = type;\n      this.dataFormat = dataFormat;\n      this.border = border;\n      this.textureUnit = textureUnit;\n\n      if (Number.isFinite(this.textureUnit)) {\n        this.gl.activeTexture(33984 + this.textureUnit);\n        this.gl.bindTexture(this.target, this.handle);\n      }\n\n      if (mipmaps && this._isNPOT()) {\n        log.warn(\"texture: \".concat(this, \" is Non-Power-Of-Two, disabling mipmaping\"))();\n        mipmaps = false;\n\n        this._updateForNPOT(parameters);\n      }\n\n      this.mipmaps = mipmaps;\n      this.setImageData({\n        data: data,\n        width: width,\n        height: height,\n        depth: depth,\n        format: format,\n        type: type,\n        dataFormat: dataFormat,\n        border: border,\n        mipmaps: mipmaps,\n        parameters: pixelStore\n      });\n\n      if (mipmaps) {\n        this.generateMipmap();\n      }\n\n      this.setParameters(parameters);\n\n      if (recreate) {\n        this.data = data;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"resize\",\n    value: function resize(_ref2) {\n      var height = _ref2.height,\n          width = _ref2.width,\n          _ref2$mipmaps = _ref2.mipmaps,\n          mipmaps = _ref2$mipmaps === void 0 ? false : _ref2$mipmaps;\n\n      if (width !== this.width || height !== this.height) {\n        return this.initialize({\n          width: width,\n          height: height,\n          format: this.format,\n          type: this.type,\n          dataFormat: this.dataFormat,\n          border: this.border,\n          mipmaps: mipmaps\n        });\n      }\n\n      return this;\n    }\n  }, {\n    key: \"generateMipmap\",\n    value: function generateMipmap() {\n      var _this3 = this;\n\n      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (this._isNPOT()) {\n        log.warn(\"texture: \".concat(this, \" is Non-Power-Of-Two, disabling mipmaping\"))();\n        return this;\n      }\n\n      this.mipmaps = true;\n      this.gl.bindTexture(this.target, this.handle);\n      withParameters(this.gl, params, function () {\n        _this3.gl.generateMipmap(_this3.target);\n      });\n      this.gl.bindTexture(this.target, null);\n      return this;\n    }\n  }, {\n    key: \"setImageData\",\n    value: function setImageData(options) {\n      this._trackDeallocatedMemory('Texture');\n\n      var _options$target = options.target,\n          target = _options$target === void 0 ? this.target : _options$target,\n          _options$pixels = options.pixels,\n          pixels = _options$pixels === void 0 ? null : _options$pixels,\n          _options$level = options.level,\n          level = _options$level === void 0 ? 0 : _options$level,\n          _options$format = options.format,\n          format = _options$format === void 0 ? this.format : _options$format,\n          _options$border = options.border,\n          border = _options$border === void 0 ? this.border : _options$border,\n          _options$offset = options.offset,\n          offset = _options$offset === void 0 ? 0 : _options$offset,\n          _options$parameters = options.parameters,\n          parameters = _options$parameters === void 0 ? {} : _options$parameters;\n      var _options$data = options.data,\n          data = _options$data === void 0 ? null : _options$data,\n          _options$type = options.type,\n          type = _options$type === void 0 ? this.type : _options$type,\n          _options$width = options.width,\n          width = _options$width === void 0 ? this.width : _options$width,\n          _options$height = options.height,\n          height = _options$height === void 0 ? this.height : _options$height,\n          _options$dataFormat = options.dataFormat,\n          dataFormat = _options$dataFormat === void 0 ? this.dataFormat : _options$dataFormat,\n          _options$compressed = options.compressed,\n          compressed = _options$compressed === void 0 ? false : _options$compressed;\n\n      if (!data) {\n        data = pixels;\n      }\n\n      var _this$_deduceParamete2 = this._deduceParameters({\n        format: format,\n        type: type,\n        dataFormat: dataFormat,\n        compressed: compressed,\n        data: data,\n        width: width,\n        height: height\n      });\n\n      type = _this$_deduceParamete2.type;\n      dataFormat = _this$_deduceParamete2.dataFormat;\n      compressed = _this$_deduceParamete2.compressed;\n      width = _this$_deduceParamete2.width;\n      height = _this$_deduceParamete2.height;\n      var gl = this.gl;\n      gl.bindTexture(this.target, this.handle);\n      var dataType = null;\n\n      var _this$_getDataType = this._getDataType({\n        data: data,\n        compressed: compressed\n      });\n\n      data = _this$_getDataType.data;\n      dataType = _this$_getDataType.dataType;\n      withParameters(this.gl, parameters, function () {\n        switch (dataType) {\n          case 'null':\n            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);\n            break;\n\n          case 'typed-array':\n            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data, offset);\n            break;\n\n          case 'buffer':\n            assertWebGL2Context(gl);\n            gl.bindBuffer(35052, data.handle || data);\n            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, offset);\n            gl.bindBuffer(35052, null);\n            break;\n\n          case 'browser-object':\n            if (isWebGL2(gl)) {\n              gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);\n            } else {\n              gl.texImage2D(target, level, format, dataFormat, type, data);\n            }\n\n            break;\n\n          case 'compressed':\n            gl.compressedTexImage2D(target, level, format, width, height, border, data);\n            break;\n\n          default:\n            assert(false, 'Unknown image data type');\n        }\n      });\n\n      if (data && data.byteLength) {\n        this._trackAllocatedMemory(data.byteLength, 'Texture');\n      } else {\n        var channels = DATA_FORMAT_CHANNELS[this.dataFormat] || 4;\n        var channelSize = TYPE_SIZES[this.type] || 1;\n\n        this._trackAllocatedMemory(this.width * this.height * channels * channelSize, 'Texture');\n      }\n\n      this.loaded = true;\n      return this;\n    }\n  }, {\n    key: \"setSubImageData\",\n    value: function setSubImageData(_ref3) {\n      var _this4 = this;\n\n      var _ref3$target = _ref3.target,\n          target = _ref3$target === void 0 ? this.target : _ref3$target,\n          _ref3$pixels = _ref3.pixels,\n          pixels = _ref3$pixels === void 0 ? null : _ref3$pixels,\n          _ref3$data = _ref3.data,\n          data = _ref3$data === void 0 ? null : _ref3$data,\n          _ref3$x = _ref3.x,\n          x = _ref3$x === void 0 ? 0 : _ref3$x,\n          _ref3$y = _ref3.y,\n          y = _ref3$y === void 0 ? 0 : _ref3$y,\n          _ref3$width = _ref3.width,\n          width = _ref3$width === void 0 ? this.width : _ref3$width,\n          _ref3$height = _ref3.height,\n          height = _ref3$height === void 0 ? this.height : _ref3$height,\n          _ref3$level = _ref3.level,\n          level = _ref3$level === void 0 ? 0 : _ref3$level,\n          _ref3$format = _ref3.format,\n          format = _ref3$format === void 0 ? this.format : _ref3$format,\n          _ref3$type = _ref3.type,\n          type = _ref3$type === void 0 ? this.type : _ref3$type,\n          _ref3$dataFormat = _ref3.dataFormat,\n          dataFormat = _ref3$dataFormat === void 0 ? this.dataFormat : _ref3$dataFormat,\n          _ref3$compressed = _ref3.compressed,\n          compressed = _ref3$compressed === void 0 ? false : _ref3$compressed,\n          _ref3$offset = _ref3.offset,\n          offset = _ref3$offset === void 0 ? 0 : _ref3$offset,\n          _ref3$border = _ref3.border,\n          border = _ref3$border === void 0 ? this.border : _ref3$border,\n          _ref3$parameters = _ref3.parameters,\n          parameters = _ref3$parameters === void 0 ? {} : _ref3$parameters;\n\n      var _this$_deduceParamete3 = this._deduceParameters({\n        format: format,\n        type: type,\n        dataFormat: dataFormat,\n        compressed: compressed,\n        data: data,\n        width: width,\n        height: height\n      });\n\n      type = _this$_deduceParamete3.type;\n      dataFormat = _this$_deduceParamete3.dataFormat;\n      compressed = _this$_deduceParamete3.compressed;\n      width = _this$_deduceParamete3.width;\n      height = _this$_deduceParamete3.height;\n      assert(this.depth === 0, 'texSubImage not supported for 3D textures');\n\n      if (!data) {\n        data = pixels;\n      }\n\n      if (data && data.data) {\n        var ndarray = data;\n        data = ndarray.data;\n        width = ndarray.shape[0];\n        height = ndarray.shape[1];\n      }\n\n      if (data instanceof Buffer) {\n        data = data.handle;\n      }\n\n      this.gl.bindTexture(this.target, this.handle);\n      withParameters(this.gl, parameters, function () {\n        if (compressed) {\n          _this4.gl.compressedTexSubImage2D(target, level, x, y, width, height, format, data);\n        } else if (data === null) {\n          _this4.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, null);\n        } else if (ArrayBuffer.isView(data)) {\n          _this4.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data, offset);\n        } else if (data instanceof WebGLBuffer) {\n          assertWebGL2Context(_this4.gl);\n\n          _this4.gl.bindBuffer(35052, data);\n\n          _this4.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, offset);\n\n          _this4.gl.bindBuffer(35052, null);\n        } else if (isWebGL2(_this4.gl)) {\n          _this4.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data);\n        } else {\n          _this4.gl.texSubImage2D(target, level, x, y, dataFormat, type, data);\n        }\n      });\n      this.gl.bindTexture(this.target, null);\n    }\n  }, {\n    key: \"copyFramebuffer\",\n    value: function copyFramebuffer() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      log.error('Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})')();\n      return null;\n    }\n  }, {\n    key: \"getActiveUnit\",\n    value: function getActiveUnit() {\n      return this.gl.getParameter(34016) - 33984;\n    }\n  }, {\n    key: \"bind\",\n    value: function bind() {\n      var textureUnit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.textureUnit;\n      var gl = this.gl;\n\n      if (textureUnit !== undefined) {\n        this.textureUnit = textureUnit;\n        gl.activeTexture(33984 + textureUnit);\n      }\n\n      gl.bindTexture(this.target, this.handle);\n      return textureUnit;\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind() {\n      var textureUnit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.textureUnit;\n      var gl = this.gl;\n\n      if (textureUnit !== undefined) {\n        this.textureUnit = textureUnit;\n        gl.activeTexture(33984 + textureUnit);\n      }\n\n      gl.bindTexture(this.target, null);\n      return textureUnit;\n    }\n  }, {\n    key: \"_getDataType\",\n    value: function _getDataType(_ref4) {\n      var data = _ref4.data,\n          _ref4$compressed = _ref4.compressed,\n          compressed = _ref4$compressed === void 0 ? false : _ref4$compressed;\n\n      if (compressed) {\n        return {\n          data: data,\n          dataType: 'compressed'\n        };\n      }\n\n      if (data === null) {\n        return {\n          data: data,\n          dataType: 'null'\n        };\n      }\n\n      if (ArrayBuffer.isView(data)) {\n        return {\n          data: data,\n          dataType: 'typed-array'\n        };\n      }\n\n      if (data instanceof Buffer) {\n        return {\n          data: data.handle,\n          dataType: 'buffer'\n        };\n      }\n\n      if (data instanceof WebGLBuffer) {\n        return {\n          data: data,\n          dataType: 'buffer'\n        };\n      }\n\n      return {\n        data: data,\n        dataType: 'browser-object'\n      };\n    }\n  }, {\n    key: \"_deduceParameters\",\n    value: function _deduceParameters(opts) {\n      var format = opts.format,\n          data = opts.data;\n      var width = opts.width,\n          height = opts.height,\n          dataFormat = opts.dataFormat,\n          type = opts.type,\n          compressed = opts.compressed;\n      var textureFormat = TEXTURE_FORMATS[format];\n      dataFormat = dataFormat || textureFormat && textureFormat.dataFormat;\n      type = type || textureFormat && textureFormat.types[0];\n      compressed = compressed || textureFormat && textureFormat.compressed;\n\n      var _this$_deduceImageSiz = this._deduceImageSize(data, width, height);\n\n      width = _this$_deduceImageSiz.width;\n      height = _this$_deduceImageSiz.height;\n      return {\n        dataFormat: dataFormat,\n        type: type,\n        compressed: compressed,\n        width: width,\n        height: height,\n        format: format,\n        data: data\n      };\n    }\n  }, {\n    key: \"_deduceImageSize\",\n    value: function _deduceImageSize(data, width, height) {\n      var size;\n\n      if (typeof ImageData !== 'undefined' && data instanceof ImageData) {\n        size = {\n          width: data.width,\n          height: data.height\n        };\n      } else if (typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement) {\n        size = {\n          width: data.naturalWidth,\n          height: data.naturalHeight\n        };\n      } else if (typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement) {\n        size = {\n          width: data.width,\n          height: data.height\n        };\n      } else if (typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap) {\n        size = {\n          width: data.width,\n          height: data.height\n        };\n      } else if (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement) {\n        size = {\n          width: data.videoWidth,\n          height: data.videoHeight\n        };\n      } else if (!data) {\n        size = {\n          width: width >= 0 ? width : 1,\n          height: height >= 0 ? height : 1\n        };\n      } else {\n        size = {\n          width: width,\n          height: height\n        };\n      }\n\n      assert(size, 'Could not deduced texture size');\n      assert(width === undefined || size.width === width, 'Deduced texture width does not match supplied width');\n      assert(height === undefined || size.height === height, 'Deduced texture height does not match supplied height');\n      return size;\n    }\n  }, {\n    key: \"_createHandle\",\n    value: function _createHandle() {\n      return this.gl.createTexture();\n    }\n  }, {\n    key: \"_deleteHandle\",\n    value: function _deleteHandle() {\n      this.gl.deleteTexture(this.handle);\n\n      this._trackDeallocatedMemory('Texture');\n    }\n  }, {\n    key: \"_getParameter\",\n    value: function _getParameter(pname) {\n      switch (pname) {\n        case 4096:\n          return this.width;\n\n        case 4097:\n          return this.height;\n\n        default:\n          this.gl.bindTexture(this.target, this.handle);\n          var value = this.gl.getTexParameter(this.target, pname);\n          this.gl.bindTexture(this.target, null);\n          return value;\n      }\n    }\n  }, {\n    key: \"_setParameter\",\n    value: function _setParameter(pname, param) {\n      this.gl.bindTexture(this.target, this.handle);\n      param = this._getNPOTParam(pname, param);\n\n      switch (pname) {\n        case 33082:\n        case 33083:\n          this.gl.texParameterf(this.handle, pname, param);\n          break;\n\n        case 4096:\n        case 4097:\n          assert(false);\n          break;\n\n        default:\n          this.gl.texParameteri(this.target, pname, param);\n          break;\n      }\n\n      this.gl.bindTexture(this.target, null);\n      return this;\n    }\n  }, {\n    key: \"_isNPOT\",\n    value: function _isNPOT() {\n      if (isWebGL2(this.gl)) {\n        return false;\n      }\n\n      if (!this.width || !this.height) {\n        return false;\n      }\n\n      return !isPowerOfTwo(this.width) || !isPowerOfTwo(this.height);\n    }\n  }, {\n    key: \"_updateForNPOT\",\n    value: function _updateForNPOT(parameters) {\n      if (parameters[this.gl.TEXTURE_MIN_FILTER] === undefined) {\n        parameters[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR;\n      }\n\n      if (parameters[this.gl.TEXTURE_WRAP_S] === undefined) {\n        parameters[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE;\n      }\n\n      if (parameters[this.gl.TEXTURE_WRAP_T] === undefined) {\n        parameters[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE;\n      }\n    }\n  }, {\n    key: \"_getNPOTParam\",\n    value: function _getNPOTParam(pname, param) {\n      if (this._isNPOT()) {\n        switch (pname) {\n          case 10241:\n            if (NPOT_MIN_FILTERS.indexOf(param) === -1) {\n              param = 9729;\n            }\n\n            break;\n\n          case 10242:\n          case 10243:\n            if (param !== 33071) {\n              param = 33071;\n            }\n\n            break;\n\n          default:\n            break;\n        }\n      }\n\n      return param;\n    }\n  }]);\n\n  return Texture;\n}(Resource);\n\nexport { Texture as default };","map":{"version":3,"sources":["../../../src/classes/texture.js"],"names":["NPOT_MIN_FILTERS","WebGLBuffer","global","Texture","Resource","gl","format","linearFiltering","supported","isFormatSupported","isLinearFilteringSupported","id","uid","handle","target","props","data","pixels","resolvedImageData","border","recreate","parameters","pixelStore","textureUnit","mipmaps","width","height","dataFormat","type","depth","compressed","Number","log","params","withParameters","options","level","offset","dataType","assertWebGL2Context","isWebGL2","assert","channels","DATA_FORMAT_CHANNELS","channelSize","TYPE_SIZES","x","y","ndarray","ArrayBuffer","opts","textureFormat","TEXTURE_FORMATS","size","naturalHeight","videoHeight","pname","value","param","isPowerOfTwo"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\n\nimport Resource from './resource';\nimport Buffer from './buffer';\nimport {\n  TEXTURE_FORMATS,\n  DATA_FORMAT_CHANNELS,\n  TYPE_SIZES,\n  isFormatSupported,\n  isLinearFilteringSupported\n} from './texture-formats';\n\nimport {isWebGL2, withParameters, log} from '@luma.gl/gltools';\nimport {global} from 'probe.gl/env';\nimport {assertWebGL2Context} from '../webgl-utils';\nimport {uid, isPowerOfTwo, assert} from '../utils';\n\n// Supported min filters for NPOT texture.\nconst NPOT_MIN_FILTERS = [GL.LINEAR, GL.NEAREST];\n\n// Polyfill\n// Note (Tarek): Do we really need to support this API?\nconst WebGLBuffer = global.WebGLBuffer || function WebGLBuffer() {};\n\nexport default class Texture extends Resource {\n  static isSupported(gl, {format, linearFiltering} = {}) {\n    let supported = true;\n    if (format) {\n      supported = supported && isFormatSupported(gl, format);\n      supported = supported && (!linearFiltering || isLinearFilteringSupported(gl, format));\n    }\n    return supported;\n  }\n\n  // target cannot be modified by bind:\n  // textures are special because when you first bind them to a target,\n  // they get special information. When you first bind a texture as a\n  // GL_TEXTURE_2D, you are actually setting special state in the texture.\n  // You are saying that this texture is a 2D texture.\n  // And it will always be a 2D texture; this state cannot be changed ever.\n  // If you have a texture that was first bound as a GL_TEXTURE_2D,\n  // you must always bind it as a GL_TEXTURE_2D;\n  // attempting to bind it as GL_TEXTURE_1D will give rise to an error\n  // (while run-time).\n  constructor(gl, props) {\n    const {\n      id = uid('texture'),\n      handle,\n      target\n      // , magFilter, minFilter, wrapS, wrapT\n    } = props;\n\n    super(gl, {id, handle});\n\n    this.target = target;\n    this.textureUnit = undefined;\n\n    // Program.draw() checks the loaded flag of all textures to avoid\n    // Textures that are still loading from promises\n    // Set to true as soon as texture has been initialized with valid data\n    this.loaded = false;\n\n    this.width = undefined;\n    this.height = undefined;\n    this.depth = undefined;\n    this.format = undefined;\n    this.type = undefined;\n    this.dataFormat = undefined;\n    this.border = undefined;\n    this.textureUnit = undefined;\n    this.mipmaps = undefined;\n  }\n\n  toString() {\n    return `Texture(${this.id},${this.width}x${this.height})`;\n  }\n\n  /* eslint-disable max-len, max-statements */\n  initialize(props = {}) {\n    let data = props.data;\n\n    if (data instanceof Promise) {\n      data.then(resolvedImageData =>\n        this.initialize(\n          Object.assign({}, props, {\n            pixels: resolvedImageData,\n            data: resolvedImageData\n          })\n        )\n      );\n      return this;\n    }\n\n    const {\n      pixels = null,\n      format = GL.RGBA,\n      border = 0,\n      recreate = false,\n      parameters = {},\n      pixelStore = {},\n      textureUnit = undefined\n    } = props;\n\n    let {mipmaps = true} = props;\n\n    // pixels variable is for API compatibility purpose\n    if (!data) {\n      // TODO - This looks backwards? Commenting out for now until we decide\n      // which prop to use\n      // log.deprecated('data', 'pixels')();\n      data = pixels;\n    }\n\n    let {width, height, dataFormat, type} = props;\n    const {depth = 0} = props;\n\n    // Deduce width and height\n    ({width, height, dataFormat, type} = this._deduceParameters({\n      format,\n      type,\n      dataFormat,\n      compressed: false,\n      data,\n      width,\n      height\n    }));\n\n    // Store opts for accessors\n    this.width = width;\n    this.height = height;\n    this.depth = depth;\n    this.format = format;\n    this.type = type;\n    this.dataFormat = dataFormat;\n    this.border = border;\n    this.textureUnit = textureUnit;\n\n    if (Number.isFinite(this.textureUnit)) {\n      this.gl.activeTexture(GL.TEXTURE0 + this.textureUnit);\n      this.gl.bindTexture(this.target, this.handle);\n    }\n\n    if (mipmaps && this._isNPOT()) {\n      log.warn(`texture: ${this} is Non-Power-Of-Two, disabling mipmaping`)();\n      mipmaps = false;\n\n      this._updateForNPOT(parameters);\n    }\n\n    this.mipmaps = mipmaps;\n\n    this.setImageData({\n      data,\n      width,\n      height,\n      depth,\n      format,\n      type,\n      dataFormat,\n      border,\n      mipmaps,\n      parameters: pixelStore\n    });\n\n    if (mipmaps) {\n      this.generateMipmap();\n    }\n\n    // Set texture sampler parameters\n    this.setParameters(parameters);\n\n    // TODO - Store data to enable auto recreate on context loss\n    if (recreate) {\n      this.data = data;\n    }\n\n    return this;\n  }\n\n  // If size has changed, reinitializes with current format\n  // note clears image and mipmaps\n  resize({height, width, mipmaps = false}) {\n    if (width !== this.width || height !== this.height) {\n      return this.initialize({\n        width,\n        height,\n        format: this.format,\n        type: this.type,\n        dataFormat: this.dataFormat,\n        border: this.border,\n        mipmaps\n      });\n    }\n    return this;\n  }\n\n  // Call to regenerate mipmaps after modifying texture(s)\n  generateMipmap(params = {}) {\n    if (this._isNPOT()) {\n      log.warn(`texture: ${this} is Non-Power-Of-Two, disabling mipmaping`)();\n      return this;\n    }\n\n    this.mipmaps = true;\n\n    this.gl.bindTexture(this.target, this.handle);\n    withParameters(this.gl, params, () => {\n      this.gl.generateMipmap(this.target);\n    });\n    this.gl.bindTexture(this.target, null);\n    return this;\n  }\n\n  /*\n   * Allocates storage\n   * @param {*} pixels -\n   *  null - create empty texture of specified format\n   *  Typed array - init from image data in typed array\n   *  Buffer|WebGLBuffer - (WEBGL2) init from image data in WebGLBuffer\n   *  HTMLImageElement|Image - Inits with content of image. Auto width/height\n   *  HTMLCanvasElement - Inits with contents of canvas. Auto width/height\n   *  HTMLVideoElement - Creates video texture. Auto width/height\n   *\n   * @param {GLint} width -\n   * @param {GLint} height -\n   * @param {GLint} mipMapLevel -\n   * @param {GLenum} format - format of image data.\n   * @param {GLenum} type\n   *  - format of array (autodetect from type) or\n   *  - (WEBGL2) format of buffer\n   * @param {Number} offset - (WEBGL2) offset from start of buffer\n   * @param {GLint} border - must be 0.\n   * @parameters - temporary settings to be applied, can be used to supply pixel store settings.\n   */\n  /* eslint-disable max-len, max-statements, complexity */\n  setImageData(options) {\n    this._trackDeallocatedMemory('Texture');\n\n    const {\n      target = this.target,\n      pixels = null,\n      level = 0,\n      format = this.format,\n      border = this.border,\n      offset = 0,\n      parameters = {}\n    } = options;\n\n    let {\n      data = null,\n      type = this.type,\n      width = this.width,\n      height = this.height,\n      dataFormat = this.dataFormat,\n      compressed = false\n    } = options;\n\n    // pixels variable is  for API compatibility purpose\n    if (!data) {\n      data = pixels;\n    }\n\n    ({type, dataFormat, compressed, width, height} = this._deduceParameters({\n      format,\n      type,\n      dataFormat,\n      compressed,\n      data,\n      width,\n      height\n    }));\n\n    const {gl} = this;\n    gl.bindTexture(this.target, this.handle);\n\n    let dataType = null;\n    ({data, dataType} = this._getDataType({data, compressed}));\n\n    withParameters(this.gl, parameters, () => {\n      switch (dataType) {\n        case 'null':\n          gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);\n          break;\n        case 'typed-array':\n          // Looks like this assert is not necessary, as offset is ignored under WebGL1\n          // assert((offset === 0 || isWebGL2(gl)), 'offset supported in WebGL2 only');\n          gl.texImage2D(\n            target,\n            level,\n            format,\n            width,\n            height,\n            border,\n            dataFormat,\n            type,\n            data,\n            offset\n          );\n          break;\n        case 'buffer':\n          // WebGL2 enables creating textures directly from a WebGL buffer\n          assertWebGL2Context(gl);\n          gl.bindBuffer(GL.PIXEL_UNPACK_BUFFER, data.handle || data);\n          gl.texImage2D(target, level, format, width, height, border, dataFormat, type, offset);\n          gl.bindBuffer(GL.PIXEL_UNPACK_BUFFER, null);\n          break;\n        case 'browser-object':\n          if (isWebGL2(gl)) {\n            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);\n          } else {\n            gl.texImage2D(target, level, format, dataFormat, type, data);\n          }\n          break;\n        case 'compressed':\n          gl.compressedTexImage2D(target, level, format, width, height, border, data);\n          break;\n        default:\n          assert(false, 'Unknown image data type');\n      }\n    });\n\n    if (data && data.byteLength) {\n      this._trackAllocatedMemory(data.byteLength, 'Texture');\n    } else {\n      // NOTE(Tarek): Default to RGBA bytes\n      const channels = DATA_FORMAT_CHANNELS[this.dataFormat] || 4;\n      const channelSize = TYPE_SIZES[this.type] || 1;\n\n      this._trackAllocatedMemory(this.width * this.height * channels * channelSize, 'Texture');\n    }\n\n    this.loaded = true;\n\n    return this;\n  }\n  /* eslint-enable max-len, max-statements, complexity */\n\n  /**\n   * Redefines an area of an existing texture\n   * Note: does not allocate storage\n   */\n  /*\n   * Redefines an area of an existing texture\n   * @param {*} pixels, data -\n   *  null - create empty texture of specified format\n   *  Typed array - init from image data in typed array\n   *  Buffer|WebGLBuffer - (WEBGL2) init from image data in WebGLBuffer\n   *  HTMLImageElement|Image - Inits with content of image. Auto width/height\n   *  HTMLCanvasElement - Inits with contents of canvas. Auto width/height\n   *  HTMLVideoElement - Creates video texture. Auto width/height\n   *\n   * @param {GLint} x - xOffset from where texture to be updated\n   * @param {GLint} y - yOffset from where texture to be updated\n   * @param {GLint} width - width of the sub image to be updated\n   * @param {GLint} height - height of the sub image to be updated\n   * @param {GLint} level - mip level to be updated\n   * @param {GLenum} format - internal format of image data.\n   * @param {GLenum} type\n   *  - format of array (autodetect from type) or\n   *  - (WEBGL2) format of buffer or ArrayBufferView\n   * @param {GLenum} dataFormat - format of image data.\n   * @param {Number} offset - (WEBGL2) offset from start of buffer\n   * @param {GLint} border - must be 0.\n   * @parameters - temporary settings to be applied, can be used to supply pixel store settings.\n   */\n  setSubImageData({\n    target = this.target,\n    pixels = null,\n    data = null,\n    x = 0,\n    y = 0,\n    width = this.width,\n    height = this.height,\n    level = 0,\n    format = this.format,\n    type = this.type,\n    dataFormat = this.dataFormat,\n    compressed = false,\n    offset = 0,\n    border = this.border,\n    parameters = {}\n  }) {\n    ({type, dataFormat, compressed, width, height} = this._deduceParameters({\n      format,\n      type,\n      dataFormat,\n      compressed,\n      data,\n      width,\n      height\n    }));\n\n    assert(this.depth === 0, 'texSubImage not supported for 3D textures');\n\n    // pixels variable is  for API compatibility purpose\n    if (!data) {\n      data = pixels;\n    }\n\n    // Support ndarrays\n    if (data && data.data) {\n      const ndarray = data;\n      data = ndarray.data;\n      width = ndarray.shape[0];\n      height = ndarray.shape[1];\n    }\n\n    // Support buffers\n    if (data instanceof Buffer) {\n      data = data.handle;\n    }\n\n    this.gl.bindTexture(this.target, this.handle);\n\n    withParameters(this.gl, parameters, () => {\n      // TODO - x,y parameters\n      if (compressed) {\n        this.gl.compressedTexSubImage2D(target, level, x, y, width, height, format, data);\n      } else if (data === null) {\n        this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, null);\n      } else if (ArrayBuffer.isView(data)) {\n        this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data, offset);\n      } else if (data instanceof WebGLBuffer) {\n        // WebGL2 allows us to create texture directly from a WebGL buffer\n        assertWebGL2Context(this.gl);\n        // This texImage2D signature uses currently bound GL.PIXEL_UNPACK_BUFFER\n        this.gl.bindBuffer(GL.PIXEL_UNPACK_BUFFER, data);\n        this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, offset);\n        this.gl.bindBuffer(GL.PIXEL_UNPACK_BUFFER, null);\n      } else if (isWebGL2(this.gl)) {\n        // Assume data is a browser supported object (ImageData, Canvas, ...)\n        this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data);\n      } else {\n        this.gl.texSubImage2D(target, level, x, y, dataFormat, type, data);\n      }\n    });\n\n    this.gl.bindTexture(this.target, null);\n  }\n  /* eslint-enable max-len, max-statements, complexity */\n\n  /**\n   * Defines a two-dimensional texture image or cube-map texture image with\n   * pixels from the current framebuffer (rather than from client memory).\n   * (gl.copyTexImage2D wrapper)\n   *\n   * Note that binding a texture into a Framebuffer's color buffer and\n   * rendering can be faster.\n   */\n  copyFramebuffer(opts = {}) {\n    log.error(\n      'Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})'\n    )();\n    return null;\n  }\n\n  getActiveUnit() {\n    return this.gl.getParameter(GL.ACTIVE_TEXTURE) - GL.TEXTURE0;\n  }\n\n  // target cannot be modified by bind:\n  // textures are special because when you first bind them to a target,\n  // they get special information. When you first bind a texture as a\n  // GL_TEXTURE_2D, you are actually setting special state in the texture.\n  // You are saying that this texture is a 2D texture.\n  // And it will always be a 2D texture; this state cannot be changed ever.\n  // If you have a texture that was first bound as a GL_TEXTURE_2D,\n  // you must always bind it as a GL_TEXTURE_2D;\n  // attempting to bind it as GL_TEXTURE_1D will give rise to an error\n  // (while run-time).\n\n  bind(textureUnit = this.textureUnit) {\n    const {gl} = this;\n\n    if (textureUnit !== undefined) {\n      this.textureUnit = textureUnit;\n      gl.activeTexture(gl.TEXTURE0 + textureUnit);\n    }\n\n    gl.bindTexture(this.target, this.handle);\n    return textureUnit;\n  }\n\n  unbind(textureUnit = this.textureUnit) {\n    const {gl} = this;\n\n    if (textureUnit !== undefined) {\n      this.textureUnit = textureUnit;\n      gl.activeTexture(gl.TEXTURE0 + textureUnit);\n    }\n\n    gl.bindTexture(this.target, null);\n    return textureUnit;\n  }\n\n  // PRIVATE METHODS\n\n  _getDataType({data, compressed = false}) {\n    if (compressed) {\n      return {data, dataType: 'compressed'};\n    }\n    if (data === null) {\n      return {data, dataType: 'null'};\n    }\n    if (ArrayBuffer.isView(data)) {\n      return {data, dataType: 'typed-array'};\n    }\n    if (data instanceof Buffer) {\n      return {data: data.handle, dataType: 'buffer'};\n    }\n    if (data instanceof WebGLBuffer) {\n      return {data, dataType: 'buffer'};\n    }\n    // Assume data is a browser supported object (ImageData, Canvas, ...)\n    return {data, dataType: 'browser-object'};\n  }\n\n  /* Copied from texture-2d.js\n  // WebGL2\n  setPixels(opts = {}) {\n    const {\n      buffer,\n      width = null,\n      height = null,\n      mipmapLevel = 0,\n      format = GL.RGBA,\n      type = GL.UNSIGNED_BYTE,\n      border = 0\n    } = opts;\n\n    const {gl} = this;\n\n    // This signature of texImage2D uses currently bound GL.PIXEL_UNPACK_BUFFER\n    gl.bindBuffer(GL.PIXEL_UNPACK_BUFFER, buffer.target);\n    // And as always, we must also bind the texture itself\n    this.bind();\n\n    gl.texImage2D(gl.TEXTURE_2D,\n      mipmapLevel, format, width, height, border, format, type, buffer.target);\n\n    this.unbind();\n    gl.bindBuffer(GL.GL.PIXEL_UNPACK_BUFFER, null);\n    return this;\n  }\n\n  setImageDataFromCompressedBuffer(opts) {\n    const {\n      buffer,\n      // offset = 0,\n      width = null,\n      height = null,\n      mipmapLevel = 0,\n      internalFormat = GL.RGBA,\n      // format = GL.RGBA,\n      // type = GL.UNSIGNED_BYTE,\n      border = 0\n    } = opts;\n\n    const {gl} = this;\n    gl.compressedTexImage2D(this.target,\n      mipmapLevel, internalFormat, width, height, border, buffer);\n    // gl.compressedTexSubImage2D(target,\n    //   level, xoffset, yoffset, width, height, format, ArrayBufferView? pixels);\n    return this;\n  }\n\n  copySubImage(opts) {\n    const {\n      // pixels,\n      // offset = 0,\n      // x,\n      // y,\n      // width,\n      // height,\n      // mipmapLevel = 0,\n      // internalFormat = GL.RGBA,\n      // type = GL.UNSIGNED_BYTE,\n      // border = 0\n    } = opts;\n\n    // if (pixels instanceof ArrayBufferView) {\n    //   gl.texSubImage2D(target, level, x, y, width, height, format, type, pixels);\n    // }\n    // gl.texSubImage2D(target, level, x, y, format, type, ? pixels);\n    // gl.texSubImage2D(target, level, x, y, format, type, HTMLImageElement pixels);\n    // gl.texSubImage2D(target, level, x, y, format, type, HTMLCanvasElement pixels);\n    // gl.texSubImage2D(target, level, x, y, format, type, HTMLVideoElement pixels);\n    // // Additional signature in a WebGL 2 context:\n    // gl.texSubImage2D(target, level, x, y, format, type, GLintptr offset);\n  }\n  */\n\n  // HELPER METHODS\n\n  _deduceParameters(opts) {\n    const {format, data} = opts;\n    let {width, height, dataFormat, type, compressed} = opts;\n\n    // Deduce format and type from format\n    const textureFormat = TEXTURE_FORMATS[format];\n    dataFormat = dataFormat || (textureFormat && textureFormat.dataFormat);\n    type = type || (textureFormat && textureFormat.types[0]);\n\n    // Deduce compression from format\n    compressed = compressed || (textureFormat && textureFormat.compressed);\n\n    ({width, height} = this._deduceImageSize(data, width, height));\n\n    return {dataFormat, type, compressed, width, height, format, data};\n  }\n\n  /* global ImageData, HTMLImageElement, HTMLCanvasElement, HTMLVideoElement, ImageBitmap */\n  // eslint-disable-next-line complexity\n  _deduceImageSize(data, width, height) {\n    let size;\n\n    if (typeof ImageData !== 'undefined' && data instanceof ImageData) {\n      size = {width: data.width, height: data.height};\n    } else if (typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement) {\n      size = {width: data.naturalWidth, height: data.naturalHeight};\n    } else if (typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement) {\n      size = {width: data.width, height: data.height};\n    } else if (typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap) {\n      size = {width: data.width, height: data.height};\n    } else if (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement) {\n      size = {width: data.videoWidth, height: data.videoHeight};\n    } else if (!data) {\n      size = {width: width >= 0 ? width : 1, height: height >= 0 ? height : 1};\n    } else {\n      size = {width, height};\n    }\n\n    assert(size, 'Could not deduced texture size');\n    assert(\n      width === undefined || size.width === width,\n      'Deduced texture width does not match supplied width'\n    );\n    assert(\n      height === undefined || size.height === height,\n      'Deduced texture height does not match supplied height'\n    );\n\n    return size;\n  }\n\n  // RESOURCE METHODS\n\n  _createHandle() {\n    return this.gl.createTexture();\n  }\n\n  _deleteHandle() {\n    this.gl.deleteTexture(this.handle);\n    this._trackDeallocatedMemory('Texture');\n  }\n\n  _getParameter(pname) {\n    switch (pname) {\n      case GL.TEXTURE_WIDTH:\n        return this.width;\n      case GL.TEXTURE_HEIGHT:\n        return this.height;\n      default:\n        this.gl.bindTexture(this.target, this.handle);\n        const value = this.gl.getTexParameter(this.target, pname);\n        this.gl.bindTexture(this.target, null);\n        return value;\n    }\n  }\n\n  _setParameter(pname, param) {\n    this.gl.bindTexture(this.target, this.handle);\n\n    // NOTE: Apply NPOT workaround\n    param = this._getNPOTParam(pname, param);\n\n    // Apparently there are some integer/float conversion rules that made\n    // the WebGL committe expose two parameter setting functions in JavaScript.\n    // For now, pick the float version for parameters specified as GLfloat.\n    switch (pname) {\n      case GL.TEXTURE_MIN_LOD:\n      case GL.TEXTURE_MAX_LOD:\n        this.gl.texParameterf(this.handle, pname, param);\n        break;\n\n      case GL.TEXTURE_WIDTH:\n      case GL.TEXTURE_HEIGHT:\n        assert(false);\n        break;\n\n      default:\n        this.gl.texParameteri(this.target, pname, param);\n        break;\n    }\n\n    this.gl.bindTexture(this.target, null);\n    return this;\n  }\n\n  _isNPOT() {\n    if (isWebGL2(this.gl)) {\n      // NPOT restriction is only for WebGL1\n      return false;\n    }\n    // Width and height not available, consider it is not NPOT texture\n    if (!this.width || !this.height) {\n      return false;\n    }\n    return !isPowerOfTwo(this.width) || !isPowerOfTwo(this.height);\n  }\n\n  // Update default settings which are not supported by NPOT textures.\n  _updateForNPOT(parameters) {\n    if (parameters[this.gl.TEXTURE_MIN_FILTER] === undefined) {\n      // log.warn(`texture: ${this} is Non-Power-Of-Two, forcing TEXTURE_MIN_FILTER to LINEAR`)();\n      parameters[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR;\n    }\n    if (parameters[this.gl.TEXTURE_WRAP_S] === undefined) {\n      // log.warn(`texture: ${this} is Non-Power-Of-Two, forcing TEXTURE_WRAP_S to CLAMP_TO_EDGE`)();\n      parameters[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE;\n    }\n    if (parameters[this.gl.TEXTURE_WRAP_T] === undefined) {\n      // log.warn(`texture: ${this} is Non-Power-Of-Two, forcing TEXTURE_WRAP_T to CLAMP_TO_EDGE`)();\n      parameters[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE;\n    }\n  }\n\n  _getNPOTParam(pname, param) {\n    if (this._isNPOT()) {\n      switch (pname) {\n        case GL.TEXTURE_MIN_FILTER:\n          if (NPOT_MIN_FILTERS.indexOf(param) === -1) {\n            // log.warn(`texture: ${this} is Non-Power-Of-Two, forcing TEXTURE_MIN_FILTER to LINEAR`)();\n            param = GL.LINEAR;\n          }\n          break;\n        case GL.TEXTURE_WRAP_S:\n        case GL.TEXTURE_WRAP_T:\n          if (param !== GL.CLAMP_TO_EDGE) {\n            // log.warn(`texture: ${this} is Non-Power-Of-Two, ${getKey(this.gl, pname)} to CLAMP_TO_EDGE`)();\n            param = GL.CLAMP_TO_EDGE;\n          }\n          break;\n        default:\n          break;\n      }\n    }\n    return param;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}