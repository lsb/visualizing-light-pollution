{"ast":null,"code":"import _objectSpread from \"/home/lsb/wikidatageo/dark-sky-vacations/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _regeneratorRuntime from \"/home/lsb/wikidatageo/dark-sky-vacations/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/lsb/wikidatageo/dark-sky-vacations/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { AsyncByteQueue } from '../../io/stream';\nimport { RecordBatchReader } from '../../ipc/reader';\n/** @ignore */\n\nexport function recordBatchReaderThroughDOMStream(writableStrategy, readableStrategy) {\n  var queue = new AsyncByteQueue();\n  var reader = null;\n  var readable = new ReadableStream({\n    cancel: function cancel() {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return queue.close();\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }))();\n    },\n    start: function start(controller) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.t0 = next;\n                _context2.t1 = controller;\n                _context2.t2 = reader;\n\n                if (_context2.t2) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                _context2.next = 6;\n                return open();\n\n              case 6:\n                _context2.t2 = reader = _context2.sent;\n\n              case 7:\n                _context2.t3 = _context2.t2;\n                _context2.next = 10;\n                return (0, _context2.t0)(_context2.t1, _context2.t3);\n\n              case 10:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }))();\n    },\n    pull: function pull(controller) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!reader) {\n                  _context3.next = 5;\n                  break;\n                }\n\n                _context3.next = 3;\n                return next(controller, reader);\n\n              case 3:\n                _context3.next = 6;\n                break;\n\n              case 5:\n                controller.close();\n\n              case 6:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }))();\n    }\n  });\n  return {\n    writable: new WritableStream(queue, _objectSpread({\n      'highWaterMark': Math.pow(2, 14)\n    }, writableStrategy)),\n    readable: readable\n  };\n\n  function open() {\n    return _open.apply(this, arguments);\n  }\n\n  function _open() {\n    _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return RecordBatchReader.from(queue);\n\n            case 2:\n              _context4.next = 4;\n              return _context4.sent.open(readableStrategy);\n\n            case 4:\n              return _context4.abrupt(\"return\", _context4.sent);\n\n            case 5:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n    return _open.apply(this, arguments);\n  }\n\n  function next(_x, _x2) {\n    return _next.apply(this, arguments);\n  }\n\n  function _next() {\n    _next = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(controller, reader) {\n      var size, r;\n      return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              size = controller.desiredSize;\n              r = null;\n\n            case 2:\n              _context5.next = 4;\n              return reader.next();\n\n            case 4:\n              if ((r = _context5.sent).done) {\n                _context5.next = 10;\n                break;\n              }\n\n              controller.enqueue(r.value);\n\n              if (!(size != null && --size <= 0)) {\n                _context5.next = 8;\n                break;\n              }\n\n              return _context5.abrupt(\"return\");\n\n            case 8:\n              _context5.next = 2;\n              break;\n\n            case 10:\n              controller.close();\n\n            case 11:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5);\n    }));\n    return _next.apply(this, arguments);\n  }\n}","map":{"version":3,"sources":["io/whatwg/reader.ts"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA,SAAS,cAAT,QAA+B,iBAA/B;AACA,SAAS,iBAAT,QAAkC,kBAAlC;AAEA;;AACA,OAAM,SAAU,iCAAV,CAAyF,gBAAzF,EAAuI,gBAAvI,EAAkL;AAEpL,MAAM,KAAK,GAAG,IAAI,cAAJ,EAAd;AACA,MAAI,MAAM,GAAgC,IAA1C;AAEA,MAAM,QAAQ,GAAG,IAAI,cAAJ,CAAmC;AAC1C,IAAA,MAD0C,oBACpC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAW,KAAK,CAAC,KAAN,EAAX;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA2B,KADS;AAE1C,IAAA,KAF0C,iBAEpC,UAFoC,EAE1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BAAU,IAAV;AAAA,+BAAe,UAAf;AAAA,+BAA2B,MAA3B;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA,uBAAqD,IAAI,EAAzD;;AAAA;AAAA,+BAAsC,MAAtC;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAgE,KAFtC;AAG1C,IAAA,IAH0C,gBAGrC,UAHqC,EAG3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBAAI,MAAJ;AAAA;AAAA;AAAA;;AAAA;AAAA,uBAAmB,IAAI,CAAC,UAAD,EAAa,MAAb,CAAvB;;AAAA;AAAA;AAAA;;AAAA;AAA8C,gBAAA,UAAU,CAAC,KAAX,EAA9C;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAmE;AAHxC,GAAnC,CAAjB;AAMA,SAAO;AAAE,IAAA,QAAQ,EAAE,IAAI,cAAJ,CAAmB,KAAnB;AAA4B,gCAAiB,CAAjB,EAAsB,EAAtB;AAA5B,OAAyD,gBAAzD,EAAZ;AAA0F,IAAA,QAAQ,EAAR;AAA1F,GAAP;;AAXoL,WAarK,IAbqK;AAAA;AAAA;;AAAA;AAAA,qEAapL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBACwB,iBAAiB,CAAC,IAAlB,CAA0B,KAA1B,CADxB;;AAAA;AAAA;AAAA,oCAC0D,IAD1D,CAC+D,gBAD/D;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAboL;AAAA;AAAA;;AAAA,WAiBrK,IAjBqK;AAAA;AAAA;;AAAA;AAAA,qEAiBpL,kBAAoB,UAApB,EAAiF,MAAjF;AAAA;AAAA;AAAA;AAAA;AAAA;AACQ,cAAA,IADR,GACe,UAAU,CAAC,WAD1B;AAEQ,cAAA,CAFR,GAEmD,IAFnD;;AAAA;AAAA;AAAA,qBAGuB,MAAM,CAAC,IAAP,EAHvB;;AAAA;AAAA,mBAGa,CAHb,mBAGsC,IAHtC;AAAA;AAAA;AAAA;;AAIQ,cAAA,UAAU,CAAC,OAAX,CAAmB,CAAC,CAAC,KAArB;;AAJR,oBAKY,IAAI,IAAI,IAAR,IAAgB,EAAE,IAAF,IAAU,CALtC;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAAA;AASI,cAAA,UAAU,CAAC,KAAX;;AATJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAjBoL;AAAA;AAAA;AA4BvL","sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { DataType } from '../../type';\nimport { RecordBatch } from '../../recordbatch';\nimport { AsyncByteQueue } from '../../io/stream';\nimport { RecordBatchReader } from '../../ipc/reader';\n\n/** @ignore */\nexport function recordBatchReaderThroughDOMStream<T extends { [key: string]: DataType } = any>(writableStrategy?: ByteLengthQueuingStrategy, readableStrategy?: { autoDestroy: boolean }) {\n\n    const queue = new AsyncByteQueue();\n    let reader: RecordBatchReader<T> | null = null;\n\n    const readable = new ReadableStream<RecordBatch<T>>({\n        async cancel() { await queue.close(); },\n        async start(controller) { await next(controller, reader || (reader = await open())); },\n        async pull(controller) { reader ? await next(controller, reader) : controller.close(); }\n    });\n\n    return { writable: new WritableStream(queue, { 'highWaterMark': 2 ** 14, ...writableStrategy }), readable };\n\n    async function open() {\n        return await (await RecordBatchReader.from<T>(queue)).open(readableStrategy);\n    }\n\n    async function next(controller: ReadableStreamDefaultController<RecordBatch<T>>, reader: RecordBatchReader<T>) {\n        let size = controller.desiredSize;\n        let r: IteratorResult<RecordBatch<T>> | null = null;\n        while (!(r = await reader.next()).done) {\n            controller.enqueue(r.value);\n            if (size != null && --size <= 0) {\n                return;\n            }\n        }\n        controller.close();\n    }\n}\n"]},"metadata":{},"sourceType":"module"}