{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport IconLayer from '../../icon-layer/icon-layer';\nimport fs from './multi-icon-layer-fragment.glsl';\nvar DEFAULT_GAMMA = 0.2;\nvar DEFAULT_BUFFER = 192.0 / 256;\nvar EMPTY_ARRAY = [];\nvar defaultProps = {\n  backgroundColor: {\n    type: 'color',\n    value: null,\n    optional: true\n  },\n  getIconOffsets: {\n    type: 'accessor',\n    value: function value(x) {\n      return x.offsets;\n    }\n  }\n};\n\nvar MultiIconLayer = function (_IconLayer) {\n  _inherits(MultiIconLayer, _IconLayer);\n\n  function MultiIconLayer() {\n    _classCallCheck(this, MultiIconLayer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(MultiIconLayer).apply(this, arguments));\n  }\n\n  _createClass(MultiIconLayer, [{\n    key: \"getShaders\",\n    value: function getShaders() {\n      return Object.assign({}, _get(_getPrototypeOf(MultiIconLayer.prototype), \"getShaders\", this).call(this), {\n        inject: {\n          'vs:#decl': \"\\n  uniform float gamma;\\n  varying float vGamma;\\n\",\n          'vs:#main-end': \"\\n  vGamma = gamma / (sizeScale * iconSize.y);\\n\"\n        },\n        fs: fs\n      });\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState() {\n      var _this = this;\n\n      _get(_getPrototypeOf(MultiIconLayer.prototype), \"initializeState\", this).call(this);\n\n      var attributeManager = this.getAttributeManager();\n      attributeManager.addInstanced({\n        instanceOffsets: {\n          size: 2,\n          accessor: 'getIconOffsets'\n        },\n        instancePickingColors: {\n          type: 5121,\n          size: 3,\n          accessor: function accessor(object, _ref) {\n            var index = _ref.index,\n                value = _ref.target;\n            return _this.encodePickingColor(index, value);\n          }\n        }\n      });\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(updateParams) {\n      _get(_getPrototypeOf(MultiIconLayer.prototype), \"updateState\", this).call(this, updateParams);\n\n      var oldProps = updateParams.oldProps,\n          props = updateParams.props;\n\n      if (props.backgroundColor !== oldProps.backgroundColor) {\n        var backgroundColor = Array.isArray(props.backgroundColor) ? props.backgroundColor.map(function (c) {\n          return c / 255.0;\n        }).slice(0, 3) : null;\n        this.setState({\n          backgroundColor: backgroundColor\n        });\n      }\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(_ref2) {\n      var uniforms = _ref2.uniforms;\n      var sdf = this.props.sdf;\n      var backgroundColor = this.state.backgroundColor;\n      var shouldDrawBackground = Array.isArray(backgroundColor);\n\n      _get(_getPrototypeOf(MultiIconLayer.prototype), \"draw\", this).call(this, {\n        uniforms: Object.assign({}, uniforms, {\n          buffer: DEFAULT_BUFFER,\n          gamma: DEFAULT_GAMMA,\n          sdf: Boolean(sdf),\n          backgroundColor: backgroundColor || [0, 0, 0],\n          shouldDrawBackground: shouldDrawBackground\n        })\n      });\n    }\n  }, {\n    key: \"getInstanceOffset\",\n    value: function getInstanceOffset(icons) {\n      var _this2 = this;\n\n      return icons ? Array.from(icons).map(function (icon) {\n        return _get(_getPrototypeOf(MultiIconLayer.prototype), \"getInstanceOffset\", _this2).call(_this2, icon);\n      }) : EMPTY_ARRAY;\n    }\n  }, {\n    key: \"getInstanceColorMode\",\n    value: function getInstanceColorMode(icons) {\n      return 1;\n    }\n  }, {\n    key: \"getInstanceIconFrame\",\n    value: function getInstanceIconFrame(icons) {\n      var _this3 = this;\n\n      return icons ? Array.from(icons).map(function (icon) {\n        return _get(_getPrototypeOf(MultiIconLayer.prototype), \"getInstanceIconFrame\", _this3).call(_this3, icon);\n      }) : EMPTY_ARRAY;\n    }\n  }]);\n\n  return MultiIconLayer;\n}(IconLayer);\n\nexport { MultiIconLayer as default };\nMultiIconLayer.layerName = 'MultiIconLayer';\nMultiIconLayer.defaultProps = defaultProps;","map":{"version":3,"sources":["../../../../src/text-layer/multi-icon-layer/multi-icon-layer.js"],"names":["DEFAULT_GAMMA","DEFAULT_BUFFER","EMPTY_ARRAY","defaultProps","backgroundColor","type","value","optional","getIconOffsets","x","MultiIconLayer","IconLayer","inject","fs","attributeManager","instanceOffsets","size","accessor","instancePickingColors","index","updateParams","oldProps","props","c","uniforms","sdf","shouldDrawBackground","Array","buffer","gamma","Boolean","icons"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport IconLayer from '../../icon-layer/icon-layer';\n\nimport fs from './multi-icon-layer-fragment.glsl';\n\n// TODO expose as layer properties\nconst DEFAULT_GAMMA = 0.2;\nconst DEFAULT_BUFFER = 192.0 / 256;\nconst EMPTY_ARRAY = [];\n\nconst defaultProps = {\n  backgroundColor: {type: 'color', value: null, optional: true},\n  getIconOffsets: {type: 'accessor', value: x => x.offsets}\n};\n\nexport default class MultiIconLayer extends IconLayer {\n  getShaders() {\n    return Object.assign({}, super.getShaders(), {\n      inject: {\n        'vs:#decl': `\n  uniform float gamma;\n  varying float vGamma;\n`,\n        'vs:#main-end': `\n  vGamma = gamma / (sizeScale * iconSize.y);\n`\n      },\n      fs\n    });\n  }\n\n  initializeState() {\n    super.initializeState();\n\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      instanceOffsets: {\n        size: 2,\n        accessor: 'getIconOffsets'\n      },\n      instancePickingColors: {\n        type: GL.UNSIGNED_BYTE,\n        size: 3,\n        accessor: (object, {index, target: value}) => this.encodePickingColor(index, value)\n      }\n    });\n  }\n\n  updateState(updateParams) {\n    super.updateState(updateParams);\n    const {oldProps, props} = updateParams;\n\n    if (props.backgroundColor !== oldProps.backgroundColor) {\n      const backgroundColor = Array.isArray(props.backgroundColor)\n        ? props.backgroundColor.map(c => c / 255.0).slice(0, 3)\n        : null;\n      this.setState({backgroundColor});\n    }\n  }\n\n  draw({uniforms}) {\n    const {sdf} = this.props;\n    const {backgroundColor} = this.state;\n    const shouldDrawBackground = Array.isArray(backgroundColor);\n\n    super.draw({\n      uniforms: Object.assign({}, uniforms, {\n        // Refer the following doc about gamma and buffer\n        // https://blog.mapbox.com/drawing-text-with-signed-distance-fields-in-mapbox-gl-b0933af6f817\n        buffer: DEFAULT_BUFFER,\n        gamma: DEFAULT_GAMMA,\n        sdf: Boolean(sdf),\n        backgroundColor: backgroundColor || [0, 0, 0],\n        shouldDrawBackground\n      })\n    });\n  }\n\n  getInstanceOffset(icons) {\n    return icons ? Array.from(icons).map(icon => super.getInstanceOffset(icon)) : EMPTY_ARRAY;\n  }\n\n  getInstanceColorMode(icons) {\n    return 1; // mask\n  }\n\n  getInstanceIconFrame(icons) {\n    return icons ? Array.from(icons).map(icon => super.getInstanceIconFrame(icon)) : EMPTY_ARRAY;\n  }\n}\n\nMultiIconLayer.layerName = 'MultiIconLayer';\nMultiIconLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}