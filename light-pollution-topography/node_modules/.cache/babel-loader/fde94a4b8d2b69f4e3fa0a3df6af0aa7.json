{"ast":null,"code":"import { Matrix4, Vector3, clamp } from '@math.gl/core';\nvar scratchPositionNormal = new Vector3();\nvar scratchCartographic = new Vector3();\nvar scratchMatrix = new Matrix4();\nvar scratchCenter = new Vector3();\nvar scratchPosition = new Vector3();\nvar scratchDirection = new Vector3();\nexport function calculateDynamicScreenSpaceError(root, _ref) {\n  var camera = _ref.camera,\n      mapProjection = _ref.mapProjection;\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$dynamicScree = options.dynamicScreenSpaceErrorHeightFalloff,\n      dynamicScreenSpaceErrorHeightFalloff = _options$dynamicScree === void 0 ? 0.25 : _options$dynamicScree,\n      _options$dynamicScree2 = options.dynamicScreenSpaceErrorDensity,\n      dynamicScreenSpaceErrorDensity = _options$dynamicScree2 === void 0 ? 0.00278 : _options$dynamicScree2;\n  var up;\n  var direction;\n  var height;\n  var minimumHeight;\n  var maximumHeight;\n  var tileBoundingVolume = root.contentBoundingVolume;\n\n  if (tileBoundingVolume instanceof TileBoundingRegion) {\n    up = Cartesian3.normalize(camera.positionWC, scratchPositionNormal);\n    direction = camera.directionWC;\n    height = camera.positionCartographic.height;\n    minimumHeight = tileBoundingVolume.minimumHeight;\n    maximumHeight = tileBoundingVolume.maximumHeight;\n  } else {\n    var transformLocal = Matrix4.inverseTransformation(root.computedTransform, scratchMatrix);\n    var ellipsoid = mapProjection.ellipsoid;\n    var boundingVolume = tileBoundingVolume.boundingVolume;\n    var centerLocal = Matrix4.multiplyByPoint(transformLocal, boundingVolume.center, scratchCenter);\n\n    if (Cartesian3.magnitude(centerLocal) > ellipsoid.minimumRadius) {\n      var centerCartographic = Cartographic.fromCartesian(centerLocal, ellipsoid, scratchCartographic);\n      up = Cartesian3.normalize(camera.positionWC, scratchPositionNormal);\n      direction = camera.directionWC;\n      height = camera.positionCartographic.height;\n      minimumHeight = 0.0;\n      maximumHeight = centerCartographic.height * 2.0;\n    } else {\n      var positionLocal = Matrix4.multiplyByPoint(transformLocal, camera.positionWC, scratchPosition);\n      up = Cartesian3.UNIT_Z;\n      direction = Matrix4.multiplyByPointAsVector(transformLocal, camera.directionWC, scratchDirection);\n      direction = Cartesian3.normalize(direction, direction);\n      height = positionLocal.z;\n\n      if (tileBoundingVolume instanceof TileOrientedBoundingBox) {\n        var boxHeight = root._header.boundingVolume.box[11];\n        minimumHeight = centerLocal.z - boxHeight;\n        maximumHeight = centerLocal.z + boxHeight;\n      } else if (tileBoundingVolume instanceof TileBoundingSphere) {\n        var radius = boundingVolume.radius;\n        minimumHeight = centerLocal.z - radius;\n        maximumHeight = centerLocal.z + radius;\n      }\n    }\n  }\n\n  var heightFalloff = dynamicScreenSpaceErrorHeightFalloff;\n  var heightClose = minimumHeight + (maximumHeight - minimumHeight) * heightFalloff;\n  var heightFar = maximumHeight;\n  var t = clamp((height - heightClose) / (heightFar - heightClose), 0.0, 1.0);\n  var dot = Math.abs(Cartesian3.dot(direction, up));\n  var horizonFactor = 1.0 - dot;\n  horizonFactor = horizonFactor * (1.0 - t);\n  return dynamicScreenSpaceErrorDensity * horizonFactor;\n}\nexport function fog(distanceToCamera, density) {\n  var scalar = distanceToCamera * density;\n  return 1.0 - Math.exp(-(scalar * scalar));\n}\nexport function getDynamicScreenSpaceError(tileset, distanceToCamera) {\n  if (tileset.dynamicScreenSpaceError && tileset._dynamicScreenSpaceErrorComputedDensity) {\n    var density = tileset._dynamicScreenSpaceErrorComputedDensity;\n    var factor = tileset.dynamicScreenSpaceErrorFactor;\n    var dynamicError = fog(distanceToCamera, density) * factor;\n    return dynamicError;\n  }\n\n  return 0;\n}\nexport function getTiles3DScreenSpaceError(tile, frameState, useParentLodMetric) {\n  var tileset = tile.tileset;\n  var parentLodMetricValue = tile.parent && tile.parent.lodMetricValue || tile.lodMetricValue;\n  var lodMetricValue = useParentLodMetric ? parentLodMetricValue : tile.lodMetricValue;\n\n  if (lodMetricValue === 0.0) {\n    return 0.0;\n  }\n\n  var distance = Math.max(tile._distanceToCamera, 1e-7);\n  var height = frameState.height,\n      sseDenominator = frameState.sseDenominator;\n  var error = lodMetricValue * height / (distance * sseDenominator);\n  error -= getDynamicScreenSpaceError(tileset, distance);\n  return error;\n}","map":{"version":3,"sources":["../../../../src/tileset/helpers/tiles-3d-lod.js"],"names":["scratchPositionNormal","scratchCartographic","scratchMatrix","scratchCenter","scratchPosition","scratchDirection","camera","mapProjection","options","dynamicScreenSpaceErrorHeightFalloff","dynamicScreenSpaceErrorDensity","tileBoundingVolume","root","up","Cartesian3","direction","height","minimumHeight","maximumHeight","transformLocal","Matrix4","ellipsoid","boundingVolume","centerLocal","centerCartographic","Cartographic","positionLocal","boxHeight","radius","heightFalloff","heightClose","heightFar","t","clamp","dot","Math","horizonFactor","scalar","distanceToCamera","tileset","density","factor","dynamicError","fog","tile","parentLodMetricValue","lodMetricValue","useParentLodMetric","distance","sseDenominator","frameState","error","getDynamicScreenSpaceError"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n// TODO - Dynamic screen space error provides an optimization when looking at\n// tilesets from above\n\n/* eslint-disable */\nimport {Matrix4, Vector3, clamp} from '@math.gl/core';\n\nconst scratchPositionNormal = new Vector3();\nconst scratchCartographic = new Vector3();\nconst scratchMatrix = new Matrix4();\nconst scratchCenter = new Vector3();\nconst scratchPosition = new Vector3();\nconst scratchDirection = new Vector3();\n\n// eslint-disable-next-line max-statements, complexity\nexport function calculateDynamicScreenSpaceError(root, {camera, mapProjection}, options = {}) {\n  const {\n    dynamicScreenSpaceErrorHeightFalloff = 0.25,\n    dynamicScreenSpaceErrorDensity = 0.00278\n  } = options;\n\n  let up;\n  let direction;\n  let height;\n  let minimumHeight;\n  let maximumHeight;\n\n  const tileBoundingVolume = root.contentBoundingVolume;\n\n  if (tileBoundingVolume instanceof TileBoundingRegion) {\n    up = Cartesian3.normalize(camera.positionWC, scratchPositionNormal);\n    direction = camera.directionWC;\n    height = camera.positionCartographic.height;\n    minimumHeight = tileBoundingVolume.minimumHeight;\n    maximumHeight = tileBoundingVolume.maximumHeight;\n  } else {\n    // Transform camera position and direction into the local coordinate system of the tileset\n    const transformLocal = Matrix4.inverseTransformation(root.computedTransform, scratchMatrix);\n    const ellipsoid = mapProjection.ellipsoid;\n    const boundingVolume = tileBoundingVolume.boundingVolume;\n    const centerLocal = Matrix4.multiplyByPoint(\n      transformLocal,\n      boundingVolume.center,\n      scratchCenter\n    );\n    if (Cartesian3.magnitude(centerLocal) > ellipsoid.minimumRadius) {\n      // The tileset is defined in WGS84. Approximate the minimum and maximum height.\n      const centerCartographic = Cartographic.fromCartesian(\n        centerLocal,\n        ellipsoid,\n        scratchCartographic\n      );\n      up = Cartesian3.normalize(camera.positionWC, scratchPositionNormal);\n      direction = camera.directionWC;\n      height = camera.positionCartographic.height;\n      minimumHeight = 0.0;\n      maximumHeight = centerCartographic.height * 2.0;\n    } else {\n      // The tileset is defined in local coordinates (z-up)\n      const positionLocal = Matrix4.multiplyByPoint(\n        transformLocal,\n        camera.positionWC,\n        scratchPosition\n      );\n      up = Cartesian3.UNIT_Z;\n      direction = Matrix4.multiplyByPointAsVector(\n        transformLocal,\n        camera.directionWC,\n        scratchDirection\n      );\n      direction = Cartesian3.normalize(direction, direction);\n      height = positionLocal.z;\n      if (tileBoundingVolume instanceof TileOrientedBoundingBox) {\n        // Assuming z-up, the last component stores the half-height of the box\n        const boxHeight = root._header.boundingVolume.box[11];\n        minimumHeight = centerLocal.z - boxHeight;\n        maximumHeight = centerLocal.z + boxHeight;\n      } else if (tileBoundingVolume instanceof TileBoundingSphere) {\n        const radius = boundingVolume.radius;\n        minimumHeight = centerLocal.z - radius;\n        maximumHeight = centerLocal.z + radius;\n      }\n    }\n  }\n\n  // The range where the density starts to lessen. Start at the quarter height of the tileset.\n  const heightFalloff = dynamicScreenSpaceErrorHeightFalloff;\n  const heightClose = minimumHeight + (maximumHeight - minimumHeight) * heightFalloff;\n  const heightFar = maximumHeight;\n\n  const t = clamp((height - heightClose) / (heightFar - heightClose), 0.0, 1.0);\n\n  // Increase density as the camera tilts towards the horizon\n  const dot = Math.abs(Cartesian3.dot(direction, up));\n\n  let horizonFactor = 1.0 - dot;\n\n  // Weaken the horizon factor as the camera height increases, implying the camera is further away from the tileset.\n  // The goal is to increase density for the \"street view\", not when viewing the tileset from a distance.\n  horizonFactor = horizonFactor * (1.0 - t);\n\n  return dynamicScreenSpaceErrorDensity * horizonFactor;\n}\n\nexport function fog(distanceToCamera, density) {\n  const scalar = distanceToCamera * density;\n  return 1.0 - Math.exp(-(scalar * scalar));\n}\n\nexport function getDynamicScreenSpaceError(tileset, distanceToCamera) {\n  if (tileset.dynamicScreenSpaceError && tileset._dynamicScreenSpaceErrorComputedDensity) {\n    const density = tileset._dynamicScreenSpaceErrorComputedDensity;\n    const factor = tileset.dynamicScreenSpaceErrorFactor;\n    // TODO: Refined screen space error that minimizes tiles in non-first-person\n    const dynamicError = fog(distanceToCamera, density) * factor;\n    return dynamicError;\n  }\n\n  return 0;\n}\n\nexport function getTiles3DScreenSpaceError(tile, frameState, useParentLodMetric) {\n  const tileset = tile.tileset;\n  const parentLodMetricValue = (tile.parent && tile.parent.lodMetricValue) || tile.lodMetricValue;\n  const lodMetricValue = useParentLodMetric ? parentLodMetricValue : tile.lodMetricValue;\n\n  // Leaf tiles do not have any error so save the computation\n  if (lodMetricValue === 0.0) {\n    return 0.0;\n  }\n\n  // TODO: Orthographic Frustum needs special treatment?\n  // this._getOrthograhicScreenSpaceError();\n\n  // Avoid divide by zero when viewer is inside the tile\n  const distance = Math.max(tile._distanceToCamera, 1e-7);\n  const {height, sseDenominator} = frameState;\n  let error = (lodMetricValue * height) / (distance * sseDenominator);\n\n  error -= getDynamicScreenSpaceError(tileset, distance);\n\n  return error;\n}\n"]},"metadata":{},"sourceType":"module"}