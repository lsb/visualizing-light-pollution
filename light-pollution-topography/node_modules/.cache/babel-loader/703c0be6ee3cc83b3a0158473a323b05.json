{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { getBlobOrDataUrl } from './get-blob';\nexport default function parseToImage(_x, _x2, _x3) {\n  return _parseToImage.apply(this, arguments);\n}\n\nfunction _parseToImage() {\n  _parseToImage = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(arrayBuffer, options, url) {\n    var blobOrDataUrl, URL, objectUrl;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            blobOrDataUrl = getBlobOrDataUrl(arrayBuffer, url);\n            URL = self.URL || self.webkitURL;\n            objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);\n            _context.prev = 3;\n            _context.next = 6;\n            return loadToImage(objectUrl || blobOrDataUrl, options);\n\n          case 6:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 7:\n            _context.prev = 7;\n\n            if (objectUrl) {\n              URL.revokeObjectURL(objectUrl);\n            }\n\n            return _context.finish(7);\n\n          case 10:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[3,, 7, 10]]);\n  }));\n  return _parseToImage.apply(this, arguments);\n}\n\nexport function loadToImage(_x4, _x5) {\n  return _loadToImage.apply(this, arguments);\n}\n\nfunction _loadToImage() {\n  _loadToImage = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(url, options) {\n    var image;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            image = new Image();\n            image.src = url;\n\n            if (!(options.image && options.image.decode && image.decode)) {\n              _context2.next = 6;\n              break;\n            }\n\n            _context2.next = 5;\n            return image.decode();\n\n          case 5:\n            return _context2.abrupt(\"return\", image);\n\n          case 6:\n            _context2.next = 8;\n            return new Promise(function (resolve, reject) {\n              try {\n                image.onload = function () {\n                  return resolve(image);\n                };\n\n                image.onerror = function (err) {\n                  return reject(new Error(\"Could not load image \".concat(url, \": \").concat(err)));\n                };\n              } catch (error) {\n                reject(error);\n              }\n            });\n\n          case 8:\n            return _context2.abrupt(\"return\", _context2.sent);\n\n          case 9:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _loadToImage.apply(this, arguments);\n}","map":{"version":3,"sources":["../../../../src/lib/parsers/parse-to-image.js"],"names":["blobOrDataUrl","getBlobOrDataUrl","URL","self","objectUrl","loadToImage","image","options","resolve","reject"],"mappings":"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","sourcesContent":["/* global self, Image */\nimport {getBlobOrDataUrl} from './get-blob';\n\n// Parses html image from array buffer\nexport default async function parseToImage(arrayBuffer, options, url) {\n  // Note: image parsing requires conversion to Blob (for createObjectURL).\n  // Potentially inefficient for not using `response.blob()` (and for File / Blob inputs)...\n  // But presumably not worth adding 'blob' flag to loader objects?\n\n  const blobOrDataUrl = getBlobOrDataUrl(arrayBuffer, url);\n  const URL = self.URL || self.webkitURL;\n  const objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);\n  try {\n    return await loadToImage(objectUrl || blobOrDataUrl, options);\n  } finally {\n    if (objectUrl) {\n      URL.revokeObjectURL(objectUrl);\n    }\n  }\n}\n\nexport async function loadToImage(url, options) {\n  const image = new Image();\n  image.src = url;\n\n  // The `image.onload()` callback does not guarantee that the image has been decoded\n  // so a main thread \"freeze\" can be incurred when using the image for the first time.\n  // `Image.decode()` returns a promise that completes when image is decoded.\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode\n  // Note: When calling `img.decode()`, we do not need to wait for `img.onload()`\n  // Note: `HTMLImageElement.decode()` is not available in Edge and IE11\n  if (options.image && options.image.decode && image.decode) {\n    await image.decode();\n    return image;\n  }\n\n  // Create a promise that tracks onload/onerror callbacks\n  return await new Promise((resolve, reject) => {\n    try {\n      image.onload = () => resolve(image);\n      image.onerror = err => reject(new Error(`Could not load image ${url}: ${err}`));\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n"]},"metadata":{},"sourceType":"module"}