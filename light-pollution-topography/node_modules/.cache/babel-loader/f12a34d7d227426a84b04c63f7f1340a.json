{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport Tile2DHeader from './tile-2d-header';\nimport { getTileIndices as _getTileIndices, tileToBoundingBox } from './utils';\nvar TILE_STATE_UNKNOWN = 0;\nvar TILE_STATE_VISIBLE = 1;\nvar TILE_STATE_PLACEHOLDER = 3;\nvar TILE_STATE_HIDDEN = 4;\nvar TILE_STATE_SELECTED = 5;\nexport var STRATEGY_NEVER = 'never';\nexport var STRATEGY_REPLACE = 'no-overlap';\nexport var STRATEGY_DEFAULT = 'best-available';\nvar DEFAULT_CACHE_SCALE = 5;\n\nvar Tileset2D = function () {\n  function Tileset2D(opts) {\n    var _this = this;\n\n    _classCallCheck(this, Tileset2D);\n\n    this.opts = opts;\n    this._getTileData = opts.getTileData;\n    this.onTileError = opts.onTileError;\n\n    this.onTileLoad = function (tile) {\n      opts.onTileLoad(tile);\n\n      if (_this.opts.maxCacheByteSize) {\n        _this._cacheByteSize += tile.byteLength;\n\n        _this._resizeCache();\n      }\n    };\n\n    this._cache = new Map();\n    this._tiles = [];\n    this._dirty = false;\n    this._cacheByteSize = 0;\n    this._viewport = null;\n    this._selectedTiles = null;\n    this._frameNumber = 0;\n    this.setOptions(opts);\n  }\n\n  _createClass(Tileset2D, [{\n    key: \"setOptions\",\n    value: function setOptions(opts) {\n      Object.assign(this.opts, opts);\n\n      if (Number.isFinite(opts.maxZoom)) {\n        this._maxZoom = Math.floor(opts.maxZoom);\n      }\n\n      if (Number.isFinite(opts.minZoom)) {\n        this._minZoom = Math.ceil(opts.minZoom);\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(viewport) {\n      var _this2 = this;\n\n      if (viewport !== this._viewport) {\n        this._viewport = viewport;\n        var tileIndices = this.getTileIndices({\n          viewport: viewport,\n          maxZoom: this._maxZoom,\n          minZoom: this._minZoom\n        });\n        this._selectedTiles = tileIndices.map(function (index) {\n          return _this2._getTile(index, true);\n        });\n\n        if (this._dirty) {\n          this._rebuildTree();\n        }\n      }\n\n      var changed = this.updateTileStates();\n\n      if (this._dirty) {\n        this._resizeCache();\n      }\n\n      if (changed) {\n        this._frameNumber++;\n      }\n\n      return this._frameNumber;\n    }\n  }, {\n    key: \"getTileIndices\",\n    value: function getTileIndices(_ref) {\n      var viewport = _ref.viewport,\n          maxZoom = _ref.maxZoom,\n          minZoom = _ref.minZoom;\n      return _getTileIndices(viewport, maxZoom, minZoom, this.opts.tileSize);\n    }\n  }, {\n    key: \"getTileMetadata\",\n    value: function getTileMetadata(_ref2) {\n      var x = _ref2.x,\n          y = _ref2.y,\n          z = _ref2.z;\n      return {\n        bbox: tileToBoundingBox(this._viewport, x, y, z, this.opts.tileSize)\n      };\n    }\n  }, {\n    key: \"getParentIndex\",\n    value: function getParentIndex(tileIndex) {\n      tileIndex.x = Math.floor(tileIndex.x / 2);\n      tileIndex.y = Math.floor(tileIndex.y / 2);\n      tileIndex.z -= 1;\n      return tileIndex;\n    }\n  }, {\n    key: \"updateTileStates\",\n    value: function updateTileStates() {\n      this._updateTileStates(this.selectedTiles);\n\n      var changed = false;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this._cache.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var tile = _step.value;\n          var isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);\n\n          if (tile.isVisible !== isVisible) {\n            changed = true;\n            tile.isVisible = isVisible;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return changed;\n    }\n  }, {\n    key: \"_rebuildTree\",\n    value: function _rebuildTree() {\n      var _cache = this._cache;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = _cache.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var tile = _step2.value;\n          tile.parent = null;\n          tile.children.length = 0;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = _cache.values()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var _tile = _step3.value;\n\n          var parent = this._getNearestAncestor(_tile.x, _tile.y, _tile.z);\n\n          _tile.parent = parent;\n\n          if (parent) {\n            parent.children.push(_tile);\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n            _iterator3[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_updateTileStates\",\n    value: function _updateTileStates(selectedTiles) {\n      var _cache = this._cache;\n      var refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = _cache.values()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var tile = _step4.value;\n          tile.state = TILE_STATE_UNKNOWN;\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4[\"return\"] != null) {\n            _iterator4[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = selectedTiles[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var _tile2 = _step5.value;\n          _tile2.state = TILE_STATE_SELECTED;\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5[\"return\"] != null) {\n            _iterator5[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      if (refinementStrategy === STRATEGY_NEVER) {\n        return;\n      }\n\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = selectedTiles[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var _tile3 = _step6.value;\n          getPlaceholderInAncestors(_tile3, refinementStrategy);\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6[\"return\"] != null) {\n            _iterator6[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = selectedTiles[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var _tile4 = _step7.value;\n\n          if (needsPlaceholder(_tile4)) {\n            getPlaceholderInChildren(_tile4);\n          }\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7[\"return\"] != null) {\n            _iterator7[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_resizeCache\",\n    value: function _resizeCache() {\n      var _cache = this._cache,\n          opts = this.opts;\n      var maxCacheSize = opts.maxCacheSize || (opts.maxCacheByteSize ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);\n      var maxCacheByteSize = opts.maxCacheByteSize || Infinity;\n      var overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;\n\n      if (overflown) {\n        var _iteratorNormalCompletion8 = true;\n        var _didIteratorError8 = false;\n        var _iteratorError8 = undefined;\n\n        try {\n          for (var _iterator8 = _cache[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n            var _step8$value = _slicedToArray(_step8.value, 2),\n                tileId = _step8$value[0],\n                tile = _step8$value[1];\n\n            if (!tile.isVisible) {\n              this._cacheByteSize -= opts.maxCacheByteSize ? tile.byteLength : 0;\n\n              _cache[\"delete\"](tileId);\n            }\n\n            if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {\n              break;\n            }\n          }\n        } catch (err) {\n          _didIteratorError8 = true;\n          _iteratorError8 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion8 && _iterator8[\"return\"] != null) {\n              _iterator8[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError8) {\n              throw _iteratorError8;\n            }\n          }\n        }\n\n        this._rebuildTree();\n\n        this._dirty = true;\n      }\n\n      if (this._dirty) {\n        this._tiles = Array.from(this._cache.values()).sort(function (t1, t2) {\n          return t1.z - t2.z;\n        });\n        this._dirty = false;\n      }\n    }\n  }, {\n    key: \"_getTile\",\n    value: function _getTile(_ref3, create) {\n      var x = _ref3.x,\n          y = _ref3.y,\n          z = _ref3.z;\n      var tileId = \"\".concat(x, \",\").concat(y, \",\").concat(z);\n\n      var tile = this._cache.get(tileId);\n\n      if (!tile && create) {\n        tile = new Tile2DHeader({\n          x: x,\n          y: y,\n          z: z,\n          onTileLoad: this.onTileLoad,\n          onTileError: this.onTileError\n        });\n        Object.assign(tile, this.getTileMetadata(tile));\n        tile.loadData(this._getTileData);\n\n        this._cache.set(tileId, tile);\n\n        this._dirty = true;\n      }\n\n      return tile;\n    }\n  }, {\n    key: \"_getNearestAncestor\",\n    value: function _getNearestAncestor(x, y, z) {\n      var _this$_minZoom = this._minZoom,\n          _minZoom = _this$_minZoom === void 0 ? 0 : _this$_minZoom;\n\n      var index = {\n        x: x,\n        y: y,\n        z: z\n      };\n\n      while (index.z > _minZoom) {\n        index = this.getParentIndex(index);\n\n        var parent = this._getTile(index);\n\n        if (parent) {\n          return parent;\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"tiles\",\n    get: function get() {\n      return this._tiles;\n    }\n  }, {\n    key: \"selectedTiles\",\n    get: function get() {\n      return this._selectedTiles;\n    }\n  }, {\n    key: \"isLoaded\",\n    get: function get() {\n      return this._selectedTiles.every(function (tile) {\n        return tile.isLoaded;\n      });\n    }\n  }]);\n\n  return Tileset2D;\n}();\n\nexport { Tileset2D as default };\n\nfunction needsPlaceholder(tile) {\n  var t = tile;\n\n  while (t) {\n    if (t.state & TILE_STATE_VISIBLE === 0) {\n      return true;\n    }\n\n    if (t.isLoaded) {\n      return false;\n    }\n\n    t = t.parent;\n  }\n\n  return true;\n}\n\nfunction getPlaceholderInAncestors(tile, refinementStrategy) {\n  var parent;\n  var state = TILE_STATE_PLACEHOLDER;\n\n  while (parent = tile.parent) {\n    if (tile.isLoaded) {\n      state = TILE_STATE_HIDDEN;\n\n      if (refinementStrategy === STRATEGY_DEFAULT) {\n        return;\n      }\n    }\n\n    parent.state = Math.max(parent.state, state);\n    tile = parent;\n  }\n}\n\nfunction getPlaceholderInChildren(tile) {\n  var _iteratorNormalCompletion9 = true;\n  var _didIteratorError9 = false;\n  var _iteratorError9 = undefined;\n\n  try {\n    for (var _iterator9 = tile.children[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n      var child = _step9.value;\n      child.state = Math.max(child.state, TILE_STATE_PLACEHOLDER);\n\n      if (!child.isLoaded) {\n        getPlaceholderInChildren(child);\n      }\n    }\n  } catch (err) {\n    _didIteratorError9 = true;\n    _iteratorError9 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion9 && _iterator9[\"return\"] != null) {\n        _iterator9[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError9) {\n        throw _iteratorError9;\n      }\n    }\n  }\n}","map":{"version":3,"sources":["../../../src/tile-layer/tileset-2d.js"],"names":["getTileIndices","TILE_STATE_UNKNOWN","TILE_STATE_VISIBLE","TILE_STATE_PLACEHOLDER","TILE_STATE_HIDDEN","TILE_STATE_SELECTED","STRATEGY_NEVER","STRATEGY_REPLACE","STRATEGY_DEFAULT","DEFAULT_CACHE_SCALE","Tileset2D","opts","tile","Object","Number","Math","viewport","tileIndices","maxZoom","minZoom","_minZoom","changed","x","y","z","bbox","tileToBoundingBox","tileIndex","isVisible","Boolean","_cache","parent","selectedTiles","refinementStrategy","getPlaceholderInAncestors","needsPlaceholder","getPlaceholderInChildren","maxCacheSize","maxCacheByteSize","overflown","tileId","t1","t2","create","onTileLoad","onTileError","index","t","state","child"],"mappings":"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","sourcesContent":["import Tile2DHeader from './tile-2d-header';\nimport {getTileIndices, tileToBoundingBox} from './utils';\n\nconst TILE_STATE_UNKNOWN = 0;\nconst TILE_STATE_VISIBLE = 1;\n/*\n   show cached parent tile if children are loading\n   +-----------+       +-----+            +-----+-----+\n   |           |       |     |            |     |     |\n   |           |       |     |            |     |     |\n   |           |  -->  +-----+-----+  ->  +-----+-----+\n   |           |             |     |      |     |     |\n   |           |             |     |      |     |     |\n   +-----------+             +-----+      +-----+-----+\n\n   show cached children tiles when parent is loading\n   +-------+----       +------------\n   |       |           |\n   |       |           |\n   |       |           |\n   +-------+----  -->  |\n   |       |           |\n */\nconst TILE_STATE_PLACEHOLDER = 3;\nconst TILE_STATE_HIDDEN = 4;\n// tiles that should be displayed in the current viewport\nconst TILE_STATE_SELECTED = 5;\n\nexport const STRATEGY_NEVER = 'never';\nexport const STRATEGY_REPLACE = 'no-overlap';\nexport const STRATEGY_DEFAULT = 'best-available';\n\nconst DEFAULT_CACHE_SCALE = 5;\n\n/**\n * Manages loading and purging of tiles data. This class caches recently visited tiles\n * and only create new tiles if they are present.\n */\n\nexport default class Tileset2D {\n  /**\n   * Takes in a function that returns tile data, a cache size, and a max and a min zoom level.\n   * Cache size defaults to 5 * number of tiles in the current viewport\n   */\n  constructor(opts) {\n    this.opts = opts;\n    this._getTileData = opts.getTileData;\n\n    this.onTileError = opts.onTileError;\n    this.onTileLoad = tile => {\n      opts.onTileLoad(tile);\n      if (this.opts.maxCacheByteSize) {\n        this._cacheByteSize += tile.byteLength;\n        this._resizeCache();\n      }\n    };\n\n    // Maps tile id in string {z}-{x}-{y} to a Tile object\n    this._cache = new Map();\n    this._tiles = [];\n    this._dirty = false;\n    this._cacheByteSize = 0;\n\n    // Cache the last processed viewport\n    this._viewport = null;\n    this._selectedTiles = null;\n    this._frameNumber = 0;\n\n    this.setOptions(opts);\n  }\n\n  /* Public API */\n  get tiles() {\n    return this._tiles;\n  }\n\n  get selectedTiles() {\n    return this._selectedTiles;\n  }\n\n  get isLoaded() {\n    return this._selectedTiles.every(tile => tile.isLoaded);\n  }\n\n  setOptions(opts) {\n    Object.assign(this.opts, opts);\n    if (Number.isFinite(opts.maxZoom)) {\n      this._maxZoom = Math.floor(opts.maxZoom);\n    }\n    if (Number.isFinite(opts.minZoom)) {\n      this._minZoom = Math.ceil(opts.minZoom);\n    }\n  }\n\n  /**\n   * Update the cache with the given viewport and triggers callback onUpdate.\n   * @param {*} viewport\n   * @param {*} onUpdate\n   */\n  update(viewport) {\n    if (viewport !== this._viewport) {\n      this._viewport = viewport;\n      const tileIndices = this.getTileIndices({\n        viewport,\n        maxZoom: this._maxZoom,\n        minZoom: this._minZoom\n      });\n      this._selectedTiles = tileIndices.map(index => this._getTile(index, true));\n\n      if (this._dirty) {\n        // Some new tiles are added\n        this._rebuildTree();\n      }\n    }\n\n    // Update tile states\n    const changed = this.updateTileStates();\n\n    if (this._dirty) {\n      // cache size is either the user defined maxSize or 5 * number of current tiles in the viewport.\n      this._resizeCache();\n    }\n\n    if (changed) {\n      this._frameNumber++;\n    }\n    return this._frameNumber;\n  }\n\n  /* Public interface for subclassing */\n\n  // Returns array of {x, y, z}\n  getTileIndices({viewport, maxZoom, minZoom}) {\n    return getTileIndices(viewport, maxZoom, minZoom, this.opts.tileSize);\n  }\n\n  // Add custom metadata to tiles\n  getTileMetadata({x, y, z}) {\n    return {\n      bbox: tileToBoundingBox(this._viewport, x, y, z, this.opts.tileSize)\n    };\n  }\n\n  // Returns {x, y, z} of the parent tile\n  getParentIndex(tileIndex) {\n    // Perf: mutate the input object to avoid GC\n    tileIndex.x = Math.floor(tileIndex.x / 2);\n    tileIndex.y = Math.floor(tileIndex.y / 2);\n    tileIndex.z -= 1;\n    return tileIndex;\n  }\n\n  // Returns true if any tile's visibility changed\n  updateTileStates() {\n    this._updateTileStates(this.selectedTiles);\n\n    let changed = false;\n    for (const tile of this._cache.values()) {\n      const isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);\n      if (tile.isVisible !== isVisible) {\n        changed = true;\n        tile.isVisible = isVisible;\n      }\n    }\n\n    return changed;\n  }\n\n  /* Private methods */\n\n  // This needs to be called every time some tiles have been added/removed from cache\n  _rebuildTree() {\n    const {_cache} = this;\n\n    // Reset states\n    for (const tile of _cache.values()) {\n      tile.parent = null;\n      tile.children.length = 0;\n    }\n\n    // Rebuild tree\n    for (const tile of _cache.values()) {\n      const parent = this._getNearestAncestor(tile.x, tile.y, tile.z);\n      tile.parent = parent;\n      if (parent) {\n        parent.children.push(tile);\n      }\n    }\n  }\n\n  // A selected tile is always visible.\n  // Never show two overlapping tiles.\n  // If a selected tile is loading, try showing a cached ancester with the closest z\n  // If a selected tile is loading, and no ancester is shown - try showing cached\n  // descendants with the closest z\n  _updateTileStates(selectedTiles) {\n    const {_cache} = this;\n    const refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;\n\n    // Reset states\n    for (const tile of _cache.values()) {\n      tile.state = TILE_STATE_UNKNOWN;\n    }\n\n    // For all the selected && pending tiles:\n    // - pick the closest ancestor as placeholder\n    // - if no ancestor is visible, pick the closest children as placeholder\n    for (const tile of selectedTiles) {\n      tile.state = TILE_STATE_SELECTED;\n    }\n\n    if (refinementStrategy === STRATEGY_NEVER) {\n      return;\n    }\n    for (const tile of selectedTiles) {\n      getPlaceholderInAncestors(tile, refinementStrategy);\n    }\n    for (const tile of selectedTiles) {\n      if (needsPlaceholder(tile)) {\n        getPlaceholderInChildren(tile);\n      }\n    }\n  }\n\n  /**\n   * Clear tiles that are not visible when the cache is full\n   */\n  /* eslint-disable complexity */\n  _resizeCache() {\n    const {_cache, opts} = this;\n\n    const maxCacheSize =\n      opts.maxCacheSize ||\n      (opts.maxCacheByteSize ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);\n    const maxCacheByteSize = opts.maxCacheByteSize || Infinity;\n\n    const overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;\n\n    if (overflown) {\n      for (const [tileId, tile] of _cache) {\n        if (!tile.isVisible) {\n          // delete tile\n          this._cacheByteSize -= opts.maxCacheByteSize ? tile.byteLength : 0;\n          _cache.delete(tileId);\n        }\n        if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {\n          break;\n        }\n      }\n      this._rebuildTree();\n      this._dirty = true;\n    }\n    if (this._dirty) {\n      this._tiles = Array.from(this._cache.values())\n        // sort by zoom level so that smaller tiles are displayed on top\n        .sort((t1, t2) => t1.z - t2.z);\n\n      this._dirty = false;\n    }\n  }\n  /* eslint-enable complexity */\n\n  _getTile({x, y, z}, create) {\n    const tileId = `${x},${y},${z}`;\n    let tile = this._cache.get(tileId);\n\n    if (!tile && create) {\n      tile = new Tile2DHeader({\n        x,\n        y,\n        z,\n        onTileLoad: this.onTileLoad,\n        onTileError: this.onTileError\n      });\n      Object.assign(tile, this.getTileMetadata(tile));\n      tile.loadData(this._getTileData);\n      this._cache.set(tileId, tile);\n      this._dirty = true;\n    }\n    return tile;\n  }\n\n  _getNearestAncestor(x, y, z) {\n    const {_minZoom = 0} = this;\n    let index = {x, y, z};\n\n    while (index.z > _minZoom) {\n      index = this.getParentIndex(index);\n      const parent = this._getTile(index);\n      if (parent) {\n        return parent;\n      }\n    }\n    return null;\n  }\n}\n\n// A selected tile needs placeholder from its children if\n// - it is not loaded\n// - none of its ancestors is visible and loaded\nfunction needsPlaceholder(tile) {\n  let t = tile;\n  while (t) {\n    if (t.state & (TILE_STATE_VISIBLE === 0)) {\n      return true;\n    }\n    if (t.isLoaded) {\n      return false;\n    }\n    t = t.parent;\n  }\n  return true;\n}\n\nfunction getPlaceholderInAncestors(tile, refinementStrategy) {\n  let parent;\n  let state = TILE_STATE_PLACEHOLDER;\n  while ((parent = tile.parent)) {\n    if (tile.isLoaded) {\n      // If a tile is loaded, mark all its ancestors as hidden\n      state = TILE_STATE_HIDDEN;\n      if (refinementStrategy === STRATEGY_DEFAULT) {\n        return;\n      }\n    }\n    parent.state = Math.max(parent.state, state);\n    tile = parent;\n  }\n}\n\n// Recursively set children as placeholder\nfunction getPlaceholderInChildren(tile) {\n  for (const child of tile.children) {\n    child.state = Math.max(child.state, TILE_STATE_PLACEHOLDER);\n    if (!child.isLoaded) {\n      getPlaceholderInChildren(child);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}