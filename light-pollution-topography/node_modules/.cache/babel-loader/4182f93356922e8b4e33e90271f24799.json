{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { Texture2D, hasFeature, FEATURES, log } from '@luma.gl/webgl';\n\nvar GLTFMaterialParser = function () {\n  function GLTFMaterialParser(gl, _ref) {\n    var attributes = _ref.attributes,\n        material = _ref.material,\n        pbrDebug = _ref.pbrDebug,\n        imageBasedLightingEnvironment = _ref.imageBasedLightingEnvironment,\n        lights = _ref.lights,\n        useTangents = _ref.useTangents;\n\n    _classCallCheck(this, GLTFMaterialParser);\n\n    this.gl = gl;\n    this.defines = {\n      MANUAL_SRGB: 1,\n      SRGB_FAST_APPROXIMATION: 1\n    };\n\n    if (hasFeature(gl, FEATURES.GLSL_TEXTURE_LOD)) {\n      this.defines.USE_TEX_LOD = 1;\n    }\n\n    this.uniforms = {\n      u_Camera: [0, 0, 0],\n      u_MetallicRoughnessValues: [1, 1]\n    };\n    this.parameters = {};\n    this.generatedTextures = [];\n\n    if (imageBasedLightingEnvironment) {\n      this.uniforms.u_DiffuseEnvSampler = imageBasedLightingEnvironment.getDiffuseEnvSampler();\n      this.uniforms.u_SpecularEnvSampler = imageBasedLightingEnvironment.getSpecularEnvSampler();\n      this.uniforms.u_brdfLUT = imageBasedLightingEnvironment.getBrdfTexture();\n      this.uniforms.u_ScaleIBLAmbient = [1, 1];\n    }\n\n    if (pbrDebug) {\n      this.uniforms.u_ScaleDiffBaseMR = [0, 0, 0, 0];\n      this.uniforms.u_ScaleFGDSpec = [0, 0, 0, 0];\n    }\n\n    this.defineIfPresent(attributes.NORMAL, 'HAS_NORMALS');\n    this.defineIfPresent(attributes.TANGENT && useTangents, 'HAS_TANGENTS');\n    this.defineIfPresent(attributes.TEXCOORD_0, 'HAS_UV');\n    this.defineIfPresent(imageBasedLightingEnvironment, 'USE_IBL');\n    this.defineIfPresent(lights, 'USE_LIGHTS');\n    this.defineIfPresent(pbrDebug, 'PBR_DEBUG');\n\n    if (material) {\n      this.parseMaterial(material);\n    }\n  }\n\n  _createClass(GLTFMaterialParser, [{\n    key: \"defineIfPresent\",\n    value: function defineIfPresent(value, name) {\n      if (value) {\n        this.defines[name] = 1;\n      }\n    }\n  }, {\n    key: \"parseTexture\",\n    value: function parseTexture(gltfTexture, name) {\n      var define = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var parameters = gltfTexture.texture && gltfTexture.texture.sampler && gltfTexture.texture.sampler.parameters || {};\n      var texture = new Texture2D(this.gl, {\n        id: gltfTexture.name || gltfTexture.id,\n        parameters: parameters,\n        pixelStore: _defineProperty({}, this.gl.UNPACK_FLIP_Y_WEBGL, false),\n        data: gltfTexture.texture.source.image\n      });\n      this.uniforms[name] = texture;\n      this.defineIfPresent(define, define);\n      this.generatedTextures.push(texture);\n    }\n  }, {\n    key: \"parsePbrMetallicRoughness\",\n    value: function parsePbrMetallicRoughness(pbrMetallicRoughness) {\n      if (pbrMetallicRoughness.baseColorTexture) {\n        this.parseTexture(pbrMetallicRoughness.baseColorTexture, 'u_BaseColorSampler', 'HAS_BASECOLORMAP');\n      }\n\n      this.uniforms.u_BaseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];\n\n      if (pbrMetallicRoughness.metallicRoughnessTexture) {\n        this.parseTexture(pbrMetallicRoughness.metallicRoughnessTexture, 'u_MetallicRoughnessSampler', 'HAS_METALROUGHNESSMAP');\n      }\n\n      var _pbrMetallicRoughness = pbrMetallicRoughness.metallicFactor,\n          metallicFactor = _pbrMetallicRoughness === void 0 ? 1 : _pbrMetallicRoughness,\n          _pbrMetallicRoughness2 = pbrMetallicRoughness.roughnessFactor,\n          roughnessFactor = _pbrMetallicRoughness2 === void 0 ? 1 : _pbrMetallicRoughness2;\n      this.uniforms.u_MetallicRoughnessValues = [metallicFactor, roughnessFactor];\n    }\n  }, {\n    key: \"parseMaterial\",\n    value: function parseMaterial(material) {\n      if (material.pbrMetallicRoughness) {\n        this.parsePbrMetallicRoughness(material.pbrMetallicRoughness);\n      }\n\n      if (material.normalTexture) {\n        this.parseTexture(material.normalTexture, 'u_NormalSampler', 'HAS_NORMALMAP');\n        var _material$normalTextu = material.normalTexture.scale,\n            scale = _material$normalTextu === void 0 ? 1 : _material$normalTextu;\n        this.uniforms.u_NormalScale = scale;\n      }\n\n      if (material.occlusionTexture) {\n        this.parseTexture(material.occlusionTexture, 'u_OcclusionSampler', 'HAS_OCCLUSIONMAP');\n        var _material$occlusionTe = material.occlusionTexture.strength,\n            strength = _material$occlusionTe === void 0 ? 1 : _material$occlusionTe;\n        this.uniforms.u_OcclusionStrength = strength;\n      }\n\n      if (material.emissiveTexture) {\n        this.parseTexture(material.emissiveTexture, 'u_EmissiveSampler', 'HAS_EMISSIVEMAP');\n        this.uniforms.u_EmissiveFactor = material.emissiveFactor || [0, 0, 0];\n      }\n\n      if (material.alphaMode === 'MASK') {\n        var _material$alphaCutoff = material.alphaCutoff,\n            alphaCutoff = _material$alphaCutoff === void 0 ? 0.5 : _material$alphaCutoff;\n        this.defines.ALPHA_CUTOFF = 1;\n        this.uniforms.u_AlphaCutoff = alphaCutoff;\n      } else if (material.alphaMode === 'BLEND') {\n        log.warn('BLEND alphaMode might not work well because it requires mesh sorting')();\n        Object.assign(this.parameters, {\n          blend: true,\n          blendEquation: this.gl.FUNC_ADD,\n          blendFunc: [this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA, this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA]\n        });\n      }\n    }\n  }]);\n\n  return GLTFMaterialParser;\n}();\n\nexport { GLTFMaterialParser as default };","map":{"version":3,"sources":["../../../src/gltf/gltf-material-parser.js"],"names":["GLTFMaterialParser","attributes","material","pbrDebug","imageBasedLightingEnvironment","lights","useTangents","MANUAL_SRGB","SRGB_FAST_APPROXIMATION","hasFeature","FEATURES","u_Camera","u_MetallicRoughnessValues","value","name","gltfTexture","define","parameters","texture","id","pixelStore","data","image","pbrMetallicRoughness","metallicFactor","roughnessFactor","scale","strength","alphaCutoff","log","Object","blend","blendEquation","blendFunc"],"mappings":"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","sourcesContent":["import {Texture2D, hasFeature, FEATURES, log} from '@luma.gl/webgl';\n\nexport default class GLTFMaterialParser {\n  constructor(\n    gl,\n    {attributes, material, pbrDebug, imageBasedLightingEnvironment, lights, useTangents}\n  ) {\n    this.gl = gl;\n\n    this.defines = {\n      // TODO: Use EXT_sRGB if available (Standard in WebGL 2.0)\n      MANUAL_SRGB: 1,\n      SRGB_FAST_APPROXIMATION: 1\n    };\n\n    if (hasFeature(gl, FEATURES.GLSL_TEXTURE_LOD)) {\n      this.defines.USE_TEX_LOD = 1;\n    }\n\n    this.uniforms = {\n      // TODO: find better values?\n      u_Camera: [0, 0, 0], // Model should override\n\n      u_MetallicRoughnessValues: [1, 1] // Default is 1 and 1\n    };\n\n    this.parameters = {};\n    this.generatedTextures = [];\n\n    if (imageBasedLightingEnvironment) {\n      this.uniforms.u_DiffuseEnvSampler = imageBasedLightingEnvironment.getDiffuseEnvSampler();\n      this.uniforms.u_SpecularEnvSampler = imageBasedLightingEnvironment.getSpecularEnvSampler();\n      this.uniforms.u_brdfLUT = imageBasedLightingEnvironment.getBrdfTexture();\n      this.uniforms.u_ScaleIBLAmbient = [1, 1];\n    }\n\n    if (pbrDebug) {\n      // Override final color for reference app visualization\n      // of various parameters in the lighting equation.\n      this.uniforms.u_ScaleDiffBaseMR = [0, 0, 0, 0];\n      this.uniforms.u_ScaleFGDSpec = [0, 0, 0, 0];\n    }\n\n    this.defineIfPresent(attributes.NORMAL, 'HAS_NORMALS');\n    this.defineIfPresent(attributes.TANGENT && useTangents, 'HAS_TANGENTS');\n    this.defineIfPresent(attributes.TEXCOORD_0, 'HAS_UV');\n\n    this.defineIfPresent(imageBasedLightingEnvironment, 'USE_IBL');\n    this.defineIfPresent(lights, 'USE_LIGHTS');\n    this.defineIfPresent(pbrDebug, 'PBR_DEBUG');\n\n    if (material) {\n      this.parseMaterial(material);\n    }\n  }\n\n  defineIfPresent(value, name) {\n    if (value) {\n      this.defines[name] = 1;\n    }\n  }\n\n  parseTexture(gltfTexture, name, define = null) {\n    const parameters =\n      (gltfTexture.texture &&\n        gltfTexture.texture.sampler &&\n        gltfTexture.texture.sampler.parameters) ||\n      {};\n\n    const texture = new Texture2D(this.gl, {\n      id: gltfTexture.name || gltfTexture.id,\n      parameters,\n      pixelStore: {\n        [this.gl.UNPACK_FLIP_Y_WEBGL]: false\n      },\n      // Texture2D accepts a promise that returns an image as data (Async Textures)\n      data: gltfTexture.texture.source.image\n    });\n    this.uniforms[name] = texture;\n    this.defineIfPresent(define, define);\n    this.generatedTextures.push(texture);\n  }\n\n  parsePbrMetallicRoughness(pbrMetallicRoughness) {\n    if (pbrMetallicRoughness.baseColorTexture) {\n      this.parseTexture(\n        pbrMetallicRoughness.baseColorTexture,\n        'u_BaseColorSampler',\n        'HAS_BASECOLORMAP'\n      );\n    }\n    this.uniforms.u_BaseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];\n\n    if (pbrMetallicRoughness.metallicRoughnessTexture) {\n      this.parseTexture(\n        pbrMetallicRoughness.metallicRoughnessTexture,\n        'u_MetallicRoughnessSampler',\n        'HAS_METALROUGHNESSMAP'\n      );\n    }\n    const {metallicFactor = 1, roughnessFactor = 1} = pbrMetallicRoughness;\n    this.uniforms.u_MetallicRoughnessValues = [metallicFactor, roughnessFactor];\n  }\n\n  parseMaterial(material) {\n    if (material.pbrMetallicRoughness) {\n      this.parsePbrMetallicRoughness(material.pbrMetallicRoughness);\n    }\n    if (material.normalTexture) {\n      this.parseTexture(material.normalTexture, 'u_NormalSampler', 'HAS_NORMALMAP');\n\n      const {scale = 1} = material.normalTexture;\n      this.uniforms.u_NormalScale = scale;\n    }\n    if (material.occlusionTexture) {\n      this.parseTexture(material.occlusionTexture, 'u_OcclusionSampler', 'HAS_OCCLUSIONMAP');\n\n      const {strength = 1} = material.occlusionTexture;\n      this.uniforms.u_OcclusionStrength = strength;\n    }\n    if (material.emissiveTexture) {\n      this.parseTexture(material.emissiveTexture, 'u_EmissiveSampler', 'HAS_EMISSIVEMAP');\n      this.uniforms.u_EmissiveFactor = material.emissiveFactor || [0, 0, 0];\n    }\n    if (material.alphaMode === 'MASK') {\n      const {alphaCutoff = 0.5} = material;\n      this.defines.ALPHA_CUTOFF = 1;\n      this.uniforms.u_AlphaCutoff = alphaCutoff;\n    } else if (material.alphaMode === 'BLEND') {\n      log.warn('BLEND alphaMode might not work well because it requires mesh sorting')();\n      Object.assign(this.parameters, {\n        blend: true,\n        blendEquation: this.gl.FUNC_ADD,\n        blendFunc: [\n          this.gl.SRC_ALPHA,\n          this.gl.ONE_MINUS_SRC_ALPHA,\n          this.gl.ONE,\n          this.gl.ONE_MINUS_SRC_ALPHA\n        ]\n      });\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}