{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { log } from '@luma.gl/gltools';\nimport Texture from './texture';\nimport { assertWebGLContext } from '../webgl-utils';\nvar FACES = [34069, 34070, 34071, 34072, 34073, 34074];\n\nvar TextureCube = function (_Texture) {\n  _inherits(TextureCube, _Texture);\n\n  function TextureCube(gl) {\n    var _this;\n\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, TextureCube);\n\n    assertWebGLContext(gl);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TextureCube).call(this, gl, Object.assign({}, props, {\n      target: 34067\n    })));\n\n    _this.initialize(props);\n\n    Object.seal(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(TextureCube, [{\n    key: \"initialize\",\n    value: function initialize() {\n      var _this2 = this;\n\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _props$mipmaps = props.mipmaps,\n          mipmaps = _props$mipmaps === void 0 ? true : _props$mipmaps,\n          _props$parameters = props.parameters,\n          parameters = _props$parameters === void 0 ? {} : _props$parameters;\n      this.opts = props;\n      this.setCubeMapImageData(props).then(function () {\n        _this2.loaded = true;\n\n        if (mipmaps) {\n          _this2.generateMipmap(props);\n        }\n\n        _this2.setParameters(parameters);\n      });\n    }\n  }, {\n    key: \"subImage\",\n    value: function subImage(_ref) {\n      var face = _ref.face,\n          data = _ref.data,\n          _ref$x = _ref.x,\n          x = _ref$x === void 0 ? 0 : _ref$x,\n          _ref$y = _ref.y,\n          y = _ref$y === void 0 ? 0 : _ref$y,\n          _ref$mipmapLevel = _ref.mipmapLevel,\n          mipmapLevel = _ref$mipmapLevel === void 0 ? 0 : _ref$mipmapLevel;\n      return this._subImage({\n        target: face,\n        data: data,\n        x: x,\n        y: y,\n        mipmapLevel: mipmapLevel\n      });\n    }\n  }, {\n    key: \"setCubeMapImageData\",\n    value: function () {\n      var _setCubeMapImageData = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(_ref2) {\n        var _this3 = this;\n\n        var width, height, pixels, data, _ref2$border, border, _ref2$format, format, _ref2$type, type, gl, imageDataMap, resolvedFaces;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                width = _ref2.width, height = _ref2.height, pixels = _ref2.pixels, data = _ref2.data, _ref2$border = _ref2.border, border = _ref2$border === void 0 ? 0 : _ref2$border, _ref2$format = _ref2.format, format = _ref2$format === void 0 ? 6408 : _ref2$format, _ref2$type = _ref2.type, type = _ref2$type === void 0 ? 5121 : _ref2$type;\n                gl = this.gl;\n                imageDataMap = pixels || data;\n                _context.next = 5;\n                return Promise.all(FACES.map(function (face) {\n                  var facePixels = imageDataMap[face];\n                  return Promise.all(Array.isArray(facePixels) ? facePixels : [facePixels]);\n                }));\n\n              case 5:\n                resolvedFaces = _context.sent;\n                this.bind();\n                FACES.forEach(function (face, index) {\n                  if (resolvedFaces[index].length > 1 && _this3.opts.mipmaps !== false) {\n                    log.warn(\"\".concat(_this3.id, \" has mipmap and multiple LODs.\"))();\n                  }\n\n                  resolvedFaces[index].forEach(function (image, lodLevel) {\n                    if (width && height) {\n                      gl.texImage2D(face, lodLevel, format, width, height, border, format, type, image);\n                    } else {\n                      gl.texImage2D(face, lodLevel, format, format, type, image);\n                    }\n                  });\n                });\n                this.unbind();\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function setCubeMapImageData(_x) {\n        return _setCubeMapImageData.apply(this, arguments);\n      }\n\n      return setCubeMapImageData;\n    }()\n  }, {\n    key: \"setImageDataForFace\",\n    value: function setImageDataForFace(options) {\n      var _this4 = this;\n\n      var face = options.face,\n          width = options.width,\n          height = options.height,\n          pixels = options.pixels,\n          data = options.data,\n          _options$border = options.border,\n          border = _options$border === void 0 ? 0 : _options$border,\n          _options$format = options.format,\n          format = _options$format === void 0 ? 6408 : _options$format,\n          _options$type = options.type,\n          type = _options$type === void 0 ? 5121 : _options$type;\n      var gl = this.gl;\n      var imageData = pixels || data;\n      this.bind();\n\n      if (imageData instanceof Promise) {\n        imageData.then(function (resolvedImageData) {\n          return _this4.setImageDataForFace(Object.assign({}, options, {\n            face: face,\n            data: resolvedImageData,\n            pixels: resolvedImageData\n          }));\n        });\n      } else if (this.width || this.height) {\n        gl.texImage2D(face, 0, format, width, height, border, format, type, imageData);\n      } else {\n        gl.texImage2D(face, 0, format, format, type, imageData);\n      }\n\n      return this;\n    }\n  }]);\n\n  return TextureCube;\n}(Texture);\n\nexport { TextureCube as default };\nTextureCube.FACES = FACES;","map":{"version":3,"sources":["../../../src/classes/texture-cube.js"],"names":["FACES","TextureCube","Texture","props","assertWebGLContext","target","Object","mipmaps","parameters","face","data","x","y","mipmapLevel","width","height","pixels","border","format","type","gl","imageDataMap","resolvedFaces","facePixels","Promise","Array","log","options","imageData","resolvedImageData"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport {log} from '@luma.gl/gltools';\nimport Texture from './texture';\nimport {assertWebGLContext} from '../webgl-utils';\n\nconst FACES = [\n  GL.TEXTURE_CUBE_MAP_POSITIVE_X,\n  GL.TEXTURE_CUBE_MAP_NEGATIVE_X,\n  GL.TEXTURE_CUBE_MAP_POSITIVE_Y,\n  GL.TEXTURE_CUBE_MAP_NEGATIVE_Y,\n  GL.TEXTURE_CUBE_MAP_POSITIVE_Z,\n  GL.TEXTURE_CUBE_MAP_NEGATIVE_Z\n];\n\nexport default class TextureCube extends Texture {\n  constructor(gl, props = {}) {\n    assertWebGLContext(gl);\n\n    super(gl, Object.assign({}, props, {target: GL.TEXTURE_CUBE_MAP}));\n\n    this.initialize(props);\n\n    Object.seal(this);\n  }\n\n  /* eslint-disable max-len, max-statements */\n  initialize(props = {}) {\n    const {mipmaps = true, parameters = {}} = props;\n\n    // Store props for accessors\n    this.opts = props;\n\n    this.setCubeMapImageData(props).then(() => {\n      this.loaded = true;\n\n      // TODO - should genMipmap() be called on the cubemap or on the faces?\n      // TODO - without generateMipmap() cube textures do not work at all!!! Why?\n      if (mipmaps) {\n        this.generateMipmap(props);\n      }\n\n      this.setParameters(parameters);\n    });\n  }\n\n  subImage({face, data, x = 0, y = 0, mipmapLevel = 0}) {\n    return this._subImage({target: face, data, x, y, mipmapLevel});\n  }\n\n  /* eslint-disable max-statements, max-len */\n  async setCubeMapImageData({\n    width,\n    height,\n    pixels,\n    data,\n    border = 0,\n    format = GL.RGBA,\n    type = GL.UNSIGNED_BYTE\n  }) {\n    const {gl} = this;\n    const imageDataMap = pixels || data;\n\n    // pixel data (imageDataMap) is an Object from Face to Image or Promise.\n    // For example:\n    // {\n    // GL.TEXTURE_CUBE_MAP_POSITIVE_X : Image-or-Promise,\n    // GL.TEXTURE_CUBE_MAP_NEGATIVE_X : Image-or-Promise,\n    // ... }\n    // To provide multiple level-of-details (LODs) this can be Face to Array\n    // of Image or Promise, like this\n    // {\n    // GL.TEXTURE_CUBE_MAP_POSITIVE_X : [Image-or-Promise-LOD-0, Image-or-Promise-LOD-1],\n    // GL.TEXTURE_CUBE_MAP_NEGATIVE_X : [Image-or-Promise-LOD-0, Image-or-Promise-LOD-1],\n    // ... }\n\n    const resolvedFaces = await Promise.all(\n      FACES.map(face => {\n        const facePixels = imageDataMap[face];\n        return Promise.all(Array.isArray(facePixels) ? facePixels : [facePixels]);\n      })\n    );\n\n    this.bind();\n\n    FACES.forEach((face, index) => {\n      if (resolvedFaces[index].length > 1 && this.opts.mipmaps !== false) {\n        // If the user provides multiple LODs, then automatic mipmap\n        // generation generateMipmap() should be disabled to avoid overwritting them.\n        log.warn(`${this.id} has mipmap and multiple LODs.`)();\n      }\n      resolvedFaces[index].forEach((image, lodLevel) => {\n        // TODO: adjust width & height for LOD!\n        if (width && height) {\n          gl.texImage2D(face, lodLevel, format, width, height, border, format, type, image);\n        } else {\n          gl.texImage2D(face, lodLevel, format, format, type, image);\n        }\n      });\n    });\n\n    this.unbind();\n  }\n\n  // TODO: update this method to accept LODs\n  setImageDataForFace(options) {\n    const {\n      face,\n      width,\n      height,\n      pixels,\n      data,\n      border = 0,\n      format = GL.RGBA,\n      type = GL.UNSIGNED_BYTE\n      // generateMipmap = false // TODO\n    } = options;\n\n    const {gl} = this;\n\n    const imageData = pixels || data;\n\n    this.bind();\n    if (imageData instanceof Promise) {\n      imageData.then(resolvedImageData =>\n        this.setImageDataForFace(\n          Object.assign({}, options, {\n            face,\n            data: resolvedImageData,\n            pixels: resolvedImageData\n          })\n        )\n      );\n    } else if (this.width || this.height) {\n      gl.texImage2D(face, 0, format, width, height, border, format, type, imageData);\n    } else {\n      gl.texImage2D(face, 0, format, format, type, imageData);\n    }\n\n    return this;\n  }\n}\n\nTextureCube.FACES = FACES;\n"]},"metadata":{},"sourceType":"module"}