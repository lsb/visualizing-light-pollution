{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { ImageLoader } from '@loaders.gl/images';\nimport { parseJSON, getZeroOffsetArrayBuffer } from '@loaders.gl/loader-utils';\nimport assert from './utils/assert';\nimport { resolveUrl } from './gltf-utils/resolve-url';\nimport { getTypedArrayForBufferView } from './gltf-utils/get-typed-array';\nimport { decodeExtensions } from './extensions/gltf-extensions';\nimport parseGLBSync, { isGLB } from './parse-glb';\nimport postProcessGLTF from './post-process-gltf';\nexport function isGLTF(arrayBuffer) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var dataView = new DataView(arrayBuffer);\n  var byteOffset = 0;\n  return isGLB(dataView, byteOffset);\n}\nexport function parseGLTF(_x, _x2) {\n  return _parseGLTF.apply(this, arguments);\n}\n\nfunction _parseGLTF() {\n  _parseGLTF = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(gltf, arrayBufferOrString) {\n    var byteOffset,\n        options,\n        context,\n        promises,\n        _promise,\n        promise,\n        _args = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            byteOffset = _args.length > 2 && _args[2] !== undefined ? _args[2] : 0;\n            options = _args.length > 3 ? _args[3] : undefined;\n            context = _args.length > 4 ? _args[4] : undefined;\n            parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);\n            promises = [];\n\n            if (options.gltf.loadImages) {\n              _promise = loadImages(gltf, options, context);\n              promises.push(_promise);\n            }\n\n            if (!options.gltf.loadBuffers) {\n              _context.next = 9;\n              break;\n            }\n\n            _context.next = 9;\n            return loadBuffers(gltf, options, context);\n\n          case 9:\n            promise = decodeExtensions(gltf, options, context);\n            promises.push(promise);\n            _context.next = 13;\n            return Promise.all(promises);\n\n          case 13:\n            return _context.abrupt(\"return\", options.gltf.postProcess ? postProcessGLTF(gltf, options) : gltf);\n\n          case 14:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _parseGLTF.apply(this, arguments);\n}\n\nfunction parseGLTFContainerSync(gltf, data, byteOffset, options) {\n  if (options.uri) {\n    gltf.baseUri = options.uri;\n  }\n\n  if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {\n    var textDecoder = new TextDecoder();\n    data = textDecoder.decode(data);\n  }\n\n  if (typeof data === 'string') {\n    gltf.json = parseJSON(data);\n  } else if (data instanceof ArrayBuffer) {\n    var glb = {};\n    byteOffset = parseGLBSync(glb, data, byteOffset, options);\n    assert(glb.type === 'glTF', \"Invalid GLB magic string \".concat(glb.type));\n    gltf._glb = glb;\n    gltf.json = glb.json;\n  } else {\n    assert(false, \"GLTF: must be ArrayBuffer or string\");\n  }\n\n  var buffers = gltf.json.buffers || [];\n  gltf.buffers = new Array(buffers.length).fill(null);\n\n  if (gltf._glb && gltf._glb.header.hasBinChunk) {\n    var binChunks = gltf._glb.binChunks;\n    gltf.buffers[0] = {\n      arrayBuffer: binChunks[0].arrayBuffer,\n      byteOffset: binChunks[0].byteOffset,\n      byteLength: binChunks[0].byteLength\n    };\n  }\n\n  var images = gltf.json.images || [];\n  gltf.images = new Array(images.length).fill({});\n}\n\nfunction loadBuffers(_x3, _x4, _x5) {\n  return _loadBuffers.apply(this, arguments);\n}\n\nfunction _loadBuffers() {\n  _loadBuffers = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(gltf, options, context) {\n    var i, buffer, fetch, uri, response, arrayBuffer;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            i = 0;\n\n          case 1:\n            if (!(i < gltf.json.buffers.length)) {\n              _context2.next = 18;\n              break;\n            }\n\n            buffer = gltf.json.buffers[i];\n\n            if (!buffer.uri) {\n              _context2.next = 15;\n              break;\n            }\n\n            fetch = context.fetch;\n            assert(fetch);\n            uri = resolveUrl(buffer.uri, options);\n            _context2.next = 9;\n            return fetch(uri);\n\n          case 9:\n            response = _context2.sent;\n            _context2.next = 12;\n            return response.arrayBuffer();\n\n          case 12:\n            arrayBuffer = _context2.sent;\n            gltf.buffers[i] = {\n              arrayBuffer: arrayBuffer,\n              byteOffset: 0,\n              byteLength: arrayBuffer.byteLength\n            };\n            delete buffer.uri;\n\n          case 15:\n            ++i;\n            _context2.next = 1;\n            break;\n\n          case 18:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _loadBuffers.apply(this, arguments);\n}\n\nfunction loadImages(_x6, _x7, _x8) {\n  return _loadImages.apply(this, arguments);\n}\n\nfunction _loadImages() {\n  _loadImages = _asyncToGenerator(_regeneratorRuntime.mark(function _callee3(gltf, options, context) {\n    var images, promises, i;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            images = gltf.json.images || [];\n            promises = [];\n\n            for (i = 0; i < images.length; ++i) {\n              promises.push(loadImage(gltf, images[i], i, options, context));\n            }\n\n            _context3.next = 5;\n            return Promise.all(promises);\n\n          case 5:\n            return _context3.abrupt(\"return\", _context3.sent);\n\n          case 6:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _loadImages.apply(this, arguments);\n}\n\nfunction loadImage(_x9, _x10, _x11, _x12, _x13) {\n  return _loadImage.apply(this, arguments);\n}\n\nfunction _loadImage() {\n  _loadImage = _asyncToGenerator(_regeneratorRuntime.mark(function _callee4(gltf, image, i, options, context) {\n    var fetch, parse, arrayBuffer, uri, response, array, parsedImage;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            fetch = context.fetch, parse = context.parse;\n\n            if (!image.uri) {\n              _context4.next = 9;\n              break;\n            }\n\n            uri = resolveUrl(image.uri, options);\n            _context4.next = 5;\n            return fetch(uri);\n\n          case 5:\n            response = _context4.sent;\n            _context4.next = 8;\n            return response.arrayBuffer();\n\n          case 8:\n            arrayBuffer = _context4.sent;\n\n          case 9:\n            if (Number.isFinite(image.bufferView)) {\n              array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);\n              arrayBuffer = getZeroOffsetArrayBuffer(array.buffer, array.byteOffset, array.byteLength);\n            }\n\n            assert(arrayBuffer, 'glTF image has no data');\n            _context4.next = 13;\n            return parse(arrayBuffer, ImageLoader, {}, context);\n\n          case 13:\n            parsedImage = _context4.sent;\n            gltf.images[i] = parsedImage;\n\n          case 15:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _loadImage.apply(this, arguments);\n}","map":{"version":3,"sources":["../../../src/lib/parse-gltf.js"],"names":["options","dataView","byteOffset","isGLB","context","parseGLTFContainerSync","promises","promise","loadImages","loadBuffers","decodeExtensions","Promise","postProcessGLTF","gltf","data","textDecoder","parseJSON","glb","parseGLBSync","assert","buffers","binChunks","arrayBuffer","byteLength","images","i","buffer","fetch","uri","resolveUrl","response","loadImage","parse","image","Number","array","getTypedArrayForBufferView","getZeroOffsetArrayBuffer","parsedImage"],"mappings":"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","sourcesContent":["/* eslint-disable camelcase, max-statements, no-restricted-globals */\n/* global TextDecoder */\nimport {ImageLoader} from '@loaders.gl/images';\nimport {parseJSON, getZeroOffsetArrayBuffer} from '@loaders.gl/loader-utils';\nimport assert from './utils/assert';\nimport {resolveUrl} from './gltf-utils/resolve-url';\nimport {getTypedArrayForBufferView} from './gltf-utils/get-typed-array';\nimport {decodeExtensions} from './extensions/gltf-extensions';\nimport parseGLBSync, {isGLB} from './parse-glb';\nimport postProcessGLTF from './post-process-gltf';\n\nexport function isGLTF(arrayBuffer, options = {}) {\n  const dataView = new DataView(arrayBuffer);\n  const byteOffset = 0;\n  return isGLB(dataView, byteOffset);\n}\n\nexport async function parseGLTF(gltf, arrayBufferOrString, byteOffset = 0, options, context) {\n  parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);\n\n  const promises = [];\n\n  if (options.gltf.loadImages) {\n    const promise = loadImages(gltf, options, context);\n    promises.push(promise);\n  }\n\n  // Load linked buffers asynchronously and decodes base64 buffers in parallel\n  if (options.gltf.loadBuffers) {\n    await loadBuffers(gltf, options, context);\n  }\n\n  const promise = decodeExtensions(gltf, options, context);\n  promises.push(promise);\n\n  // Parallelize image loading and buffer loading/extension decoding\n  await Promise.all(promises);\n\n  // Post processing resolves indices to objects, buffers\n  return options.gltf.postProcess ? postProcessGLTF(gltf, options) : gltf;\n}\n\n// `data` - can be ArrayBuffer (GLB), ArrayBuffer (Binary JSON), String (JSON), or Object (parsed JSON)\nfunction parseGLTFContainerSync(gltf, data, byteOffset, options) {\n  // Initialize gltf container\n  if (options.uri) {\n    gltf.baseUri = options.uri;\n  }\n\n  // If data is binary and starting with magic bytes, assume binary JSON text, convert to string\n  if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(data);\n  }\n\n  if (typeof data === 'string') {\n    // If string, try to parse as JSON\n    gltf.json = parseJSON(data);\n  } else if (data instanceof ArrayBuffer) {\n    // If still ArrayBuffer, parse as GLB container\n    const glb = {};\n    byteOffset = parseGLBSync(glb, data, byteOffset, options);\n\n    assert(glb.type === 'glTF', `Invalid GLB magic string ${glb.type}`);\n\n    gltf._glb = glb;\n    gltf.json = glb.json;\n  } else {\n    assert(false, `GLTF: must be ArrayBuffer or string`);\n  }\n\n  // Populate buffers\n  // Create an external buffers array to hold binary data\n  const buffers = gltf.json.buffers || [];\n  gltf.buffers = new Array(buffers.length).fill(null);\n\n  // Populates JSON and some bin chunk info\n  if (gltf._glb && gltf._glb.header.hasBinChunk) {\n    const {binChunks} = gltf._glb;\n    gltf.buffers[0] = {\n      arrayBuffer: binChunks[0].arrayBuffer,\n      byteOffset: binChunks[0].byteOffset,\n      byteLength: binChunks[0].byteLength\n    };\n\n    // TODO - this modifies JSON and is a post processing thing\n    // gltf.json.buffers[0].data = gltf.buffers[0].arrayBuffer;\n    // gltf.json.buffers[0].byteOffset = gltf.buffers[0].byteOffset;\n  }\n\n  // Populate images\n  const images = gltf.json.images || [];\n  gltf.images = new Array(images.length).fill({});\n}\n\n// Asynchronously fetch and parse buffers, store in buffers array outside of json\nasync function loadBuffers(gltf, options, context) {\n  for (let i = 0; i < gltf.json.buffers.length; ++i) {\n    const buffer = gltf.json.buffers[i];\n    if (buffer.uri) {\n      const {fetch} = context;\n      assert(fetch);\n\n      const uri = resolveUrl(buffer.uri, options);\n      const response = await fetch(uri);\n      const arrayBuffer = await response.arrayBuffer();\n\n      gltf.buffers[i] = {\n        arrayBuffer,\n        byteOffset: 0,\n        byteLength: arrayBuffer.byteLength\n      };\n\n      delete buffer.uri;\n    }\n  }\n}\n\nasync function loadImages(gltf, options, context) {\n  const images = gltf.json.images || [];\n\n  const promises = [];\n  for (let i = 0; i < images.length; ++i) {\n    promises.push(loadImage(gltf, images[i], i, options, context));\n  }\n\n  return await Promise.all(promises);\n}\n\n// Asynchronously fetches and parses one image, store in images array outside of json\nasync function loadImage(gltf, image, i, options, context) {\n  const {fetch, parse} = context;\n\n  let arrayBuffer;\n\n  if (image.uri) {\n    const uri = resolveUrl(image.uri, options);\n    const response = await fetch(uri);\n    arrayBuffer = await response.arrayBuffer();\n  }\n\n  if (Number.isFinite(image.bufferView)) {\n    const array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);\n    arrayBuffer = getZeroOffsetArrayBuffer(array.buffer, array.byteOffset, array.byteLength);\n  }\n\n  assert(arrayBuffer, 'glTF image has no data');\n\n  // Call `parse`\n  const parsedImage = await parse(arrayBuffer, ImageLoader, {}, context);\n  // TODO making sure ImageLoader is overridable by using array of loaders\n  // const parsedImage = await parse(arrayBuffer, [ImageLoader]);\n\n  gltf.images[i] = parsedImage;\n}\n"]},"metadata":{},"sourceType":"module"}