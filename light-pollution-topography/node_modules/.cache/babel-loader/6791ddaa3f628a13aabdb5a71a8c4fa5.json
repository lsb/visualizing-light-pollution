{"ast":null,"code":"import { assert } from '@loaders.gl/loader-utils';\nexport function encode3DTileHeader(tile, dataView, byteOffset) {\n  var HEADER_SIZE = 12;\n\n  if (!dataView) {\n    return byteOffset + HEADER_SIZE;\n  }\n\n  var magic = tile.magic,\n      _tile$version = tile.version,\n      version = _tile$version === void 0 ? 1 : _tile$version,\n      _tile$byteLength = tile.byteLength,\n      byteLength = _tile$byteLength === void 0 ? 12 : _tile$byteLength;\n  assert(Array.isArray(magic) && Number.isFinite(version) && Number.isFinite(byteLength));\n  dataView.setUint8(byteOffset + 0, magic[0]);\n  dataView.setUint8(byteOffset + 1, magic[1]);\n  dataView.setUint8(byteOffset + 2, magic[2]);\n  dataView.setUint8(byteOffset + 3, magic[3]);\n  dataView.setUint32(byteOffset + 4, version, true);\n  dataView.setUint32(byteOffset + 8, byteLength, true);\n  byteOffset += HEADER_SIZE;\n  return byteOffset;\n}\nexport function encode3DTileByteLength(dataView, byteOffsetTileStart, byteLength) {\n  if (!dataView) {\n    return;\n  }\n\n  dataView.setUint32(byteOffsetTileStart + 8, byteLength, true);\n}","map":{"version":3,"sources":["../../../../../src/lib/encoders/helpers/encode-3d-tile-header.js"],"names":["HEADER_SIZE","byteOffset","magic","version","byteLength","tile","assert","Array","Number","dataView","byteOffsetTileStart"],"mappings":"AACA,SAAA,MAAA,QAAA,0BAAA;AAEA,OAAO,SAAA,kBAAA,CAAA,IAAA,EAAA,QAAA,EAAA,UAAA,EAAwD;AAC7D,MAAMA,WAAW,GAAjB,EAAA;;AAEA,MAAI,CAAJ,QAAA,EAAe;AACb,WAAOC,UAAU,GAAjB,WAAA;AACD;;AAL4D,MAOtDC,KAPsD,GAOfG,IAPe,CAAA,KAAA;AAAA,MAAA,aAAA,GAOfA,IAPe,CAAA,OAAA;AAAA,MAO/CF,OAP+C,GAAA,aAAA,KAAA,KAAA,CAAA,GAAA,CAAA,GAAA,aAAA;AAAA,MAAA,gBAAA,GAOfE,IAPe,CAAA,UAAA;AAAA,MAOlCD,UAPkC,GAAA,gBAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAA,gBAAA;AAS7DE,EAAAA,MAAM,CAACC,KAAK,CAALA,OAAAA,CAAAA,KAAAA,KAAwBC,MAAM,CAANA,QAAAA,CAAxBD,OAAwBC,CAAxBD,IAAoDC,MAAM,CAANA,QAAAA,CAA3DF,UAA2DE,CAArD,CAANF;AAEAG,EAAAA,QAAQ,CAARA,QAAAA,CAAkBR,UAAU,GAA5BQ,CAAAA,EAAkCP,KAAK,CAAvCO,CAAuC,CAAvCA;AACAA,EAAAA,QAAQ,CAARA,QAAAA,CAAkBR,UAAU,GAA5BQ,CAAAA,EAAkCP,KAAK,CAAvCO,CAAuC,CAAvCA;AACAA,EAAAA,QAAQ,CAARA,QAAAA,CAAkBR,UAAU,GAA5BQ,CAAAA,EAAkCP,KAAK,CAAvCO,CAAuC,CAAvCA;AACAA,EAAAA,QAAQ,CAARA,QAAAA,CAAkBR,UAAU,GAA5BQ,CAAAA,EAAkCP,KAAK,CAAvCO,CAAuC,CAAvCA;AACAA,EAAAA,QAAQ,CAARA,SAAAA,CAAmBR,UAAU,GAA7BQ,CAAAA,EAAAA,OAAAA,EAAAA,IAAAA;AACAA,EAAAA,QAAQ,CAARA,SAAAA,CAAmBR,UAAU,GAA7BQ,CAAAA,EAAAA,UAAAA,EAAAA,IAAAA;AAEAR,EAAAA,UAAU,IAAVA,WAAAA;AAEA,SAAA,UAAA;AACD;AAGD,OAAO,SAAA,sBAAA,CAAA,QAAA,EAAA,mBAAA,EAAA,UAAA,EAA2E;AAChF,MAAI,CAAJ,QAAA,EAAe;AACb;AACD;;AAEDQ,EAAAA,QAAQ,CAARA,SAAAA,CAAmBC,mBAAmB,GAAtCD,CAAAA,EAAAA,UAAAA,EAAAA,IAAAA;AACD","sourcesContent":["// HELPER ENCODERS\nimport {assert} from '@loaders.gl/loader-utils';\n\nexport function encode3DTileHeader(tile, dataView, byteOffset) {\n  const HEADER_SIZE = 12;\n\n  if (!dataView) {\n    return byteOffset + HEADER_SIZE;\n  }\n\n  const {magic, version = 1, byteLength = 12} = tile;\n\n  assert(Array.isArray(magic) && Number.isFinite(version) && Number.isFinite(byteLength));\n\n  dataView.setUint8(byteOffset + 0, magic[0]);\n  dataView.setUint8(byteOffset + 1, magic[1]);\n  dataView.setUint8(byteOffset + 2, magic[2]);\n  dataView.setUint8(byteOffset + 3, magic[3]);\n  dataView.setUint32(byteOffset + 4, version, true); // version\n  dataView.setUint32(byteOffset + 8, byteLength, true); // byteLength\n\n  byteOffset += HEADER_SIZE;\n\n  return byteOffset;\n}\n\n// Bytelength is sometimes only known at the end of writing a tile\nexport function encode3DTileByteLength(dataView, byteOffsetTileStart, byteLength) {\n  if (!dataView) {\n    return;\n  }\n\n  dataView.setUint32(byteOffsetTileStart + 8, byteLength, true); // byteLength\n}\n"]},"metadata":{},"sourceType":"module"}