{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nvar _SRC_TEX_PARAMETER_OV;\n\nimport { cloneTextureFrom, readPixelsToArray, getShaderVersion, Buffer, Texture2D, Framebuffer } from '@luma.gl/webgl';\nimport { _transform as transformModule, getPassthroughFS, typeToChannelCount, combineInjects } from '@luma.gl/shadertools';\nimport { updateForTextures, getSizeUniforms } from './transform-shader-utils';\nvar SRC_TEX_PARAMETER_OVERRIDES = (_SRC_TEX_PARAMETER_OV = {}, _defineProperty(_SRC_TEX_PARAMETER_OV, 10241, 9728), _defineProperty(_SRC_TEX_PARAMETER_OV, 10240, 9728), _defineProperty(_SRC_TEX_PARAMETER_OV, 10242, 33071), _defineProperty(_SRC_TEX_PARAMETER_OV, 10243, 33071), _SRC_TEX_PARAMETER_OV);\nvar FS_OUTPUT_VARIABLE = 'transform_output';\n\nvar TextureTransform = function () {\n  function TextureTransform(gl) {\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, TextureTransform);\n\n    this.gl = gl;\n    this.currentIndex = 0;\n    this._swapTexture = null;\n    this.targetTextureVarying = null;\n    this.targetTextureType = null;\n    this.samplerTextureMap = null;\n    this.bindings = [];\n    this.resources = {};\n\n    this._initialize(props);\n\n    Object.seal(this);\n  }\n\n  _createClass(TextureTransform, [{\n    key: \"updateModelProps\",\n    value: function updateModelProps() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var updatedModelProps = this._processVertexShader(props);\n\n      return Object.assign({}, props, updatedModelProps);\n    }\n  }, {\n    key: \"getDrawOptions\",\n    value: function getDrawOptions() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _this$bindings$this$c = this.bindings[this.currentIndex],\n          sourceBuffers = _this$bindings$this$c.sourceBuffers,\n          sourceTextures = _this$bindings$this$c.sourceTextures,\n          framebuffer = _this$bindings$this$c.framebuffer,\n          targetTexture = _this$bindings$this$c.targetTexture;\n      var attributes = Object.assign({}, sourceBuffers, opts.attributes);\n      var uniforms = Object.assign({}, opts.uniforms);\n      var parameters = Object.assign({}, opts.parameters);\n      var discard = opts.discard;\n\n      if (this.hasSourceTextures || this.hasTargetTexture) {\n        attributes.transform_elementID = this.elementIDBuffer;\n\n        for (var sampler in this.samplerTextureMap) {\n          var textureName = this.samplerTextureMap[sampler];\n          uniforms[sampler] = sourceTextures[textureName];\n        }\n\n        this._setSourceTextureParameters();\n\n        var sizeUniforms = getSizeUniforms({\n          sourceTextureMap: sourceTextures,\n          targetTextureVarying: this.targetTextureVarying,\n          targetTexture: targetTexture\n        });\n        Object.assign(uniforms, sizeUniforms);\n      }\n\n      if (this.hasTargetTexture) {\n        discard = false;\n        parameters.viewport = [0, 0, framebuffer.width, framebuffer.height];\n      }\n\n      return {\n        attributes: attributes,\n        framebuffer: framebuffer,\n        uniforms: uniforms,\n        discard: discard,\n        parameters: parameters\n      };\n    }\n  }, {\n    key: \"swap\",\n    value: function swap() {\n      if (this._swapTexture) {\n        this.currentIndex = this._getNextIndex();\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      this._setupTextures(opts);\n    }\n  }, {\n    key: \"getTargetTexture\",\n    value: function getTargetTexture() {\n      var targetTexture = this.bindings[this.currentIndex].targetTexture;\n      return targetTexture;\n    }\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$packed = _ref.packed,\n          packed = _ref$packed === void 0 ? false : _ref$packed;\n\n      var framebuffer = this.bindings[this.currentIndex].framebuffer;\n      var pixels = readPixelsToArray(framebuffer);\n\n      if (!packed) {\n        return pixels;\n      }\n\n      var ArrayType = pixels.constructor;\n      var channelCount = typeToChannelCount(this.targetTextureType);\n      var packedPixels = new ArrayType(pixels.length * channelCount / 4);\n      var packCount = 0;\n\n      for (var i = 0; i < pixels.length; i += 4) {\n        for (var j = 0; j < channelCount; j++) {\n          packedPixels[packCount++] = pixels[i + j];\n        }\n      }\n\n      return packedPixels;\n    }\n  }, {\n    key: \"getFramebuffer\",\n    value: function getFramebuffer() {\n      var currentResources = this.bindings[this.currentIndex];\n      return currentResources.framebuffer;\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      if (this.ownTexture) {\n        this.ownTexture[\"delete\"]();\n      }\n\n      if (this.elementIDBuffer) {\n        this.elementIDBuffer[\"delete\"]();\n      }\n    }\n  }, {\n    key: \"_initialize\",\n    value: function _initialize() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _targetTextureVarying = props._targetTextureVarying,\n          _swapTexture = props._swapTexture;\n      this._swapTexture = _swapTexture;\n      this.targetTextureVarying = _targetTextureVarying;\n      this.hasTargetTexture = _targetTextureVarying;\n\n      this._setupTextures(props);\n    }\n  }, {\n    key: \"_createTargetTexture\",\n    value: function _createTargetTexture(props) {\n      var sourceTextures = props.sourceTextures,\n          textureOrReference = props.textureOrReference;\n\n      if (textureOrReference instanceof Texture2D) {\n        return textureOrReference;\n      }\n\n      var refTexture = sourceTextures[textureOrReference];\n\n      if (!refTexture) {\n        return null;\n      }\n\n      this._targetRefTexName = textureOrReference;\n      return this._createNewTexture(refTexture);\n    }\n  }, {\n    key: \"_setupTextures\",\n    value: function _setupTextures() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var sourceBuffers = props.sourceBuffers,\n          _props$_sourceTexture = props._sourceTextures,\n          _sourceTextures = _props$_sourceTexture === void 0 ? {} : _props$_sourceTexture,\n          _targetTexture = props._targetTexture;\n\n      var targetTexture = this._createTargetTexture({\n        sourceTextures: _sourceTextures,\n        textureOrReference: _targetTexture\n      });\n\n      this.hasSourceTextures = this.hasSourceTextures || _sourceTextures && Object.keys(_sourceTextures).length > 0;\n\n      this._updateBindings({\n        sourceBuffers: sourceBuffers,\n        sourceTextures: _sourceTextures,\n        targetTexture: targetTexture\n      });\n\n      if ('elementCount' in props) {\n        this._updateElementIDBuffer(props.elementCount);\n      }\n    }\n  }, {\n    key: \"_updateElementIDBuffer\",\n    value: function _updateElementIDBuffer(elementCount) {\n      if (typeof elementCount !== 'number' || this.elementCount >= elementCount) {\n        return;\n      }\n\n      var elementIds = new Float32Array(elementCount);\n      elementIds.forEach(function (_, index, array) {\n        array[index] = index;\n      });\n\n      if (!this.elementIDBuffer) {\n        this.elementIDBuffer = new Buffer(this.gl, {\n          data: elementIds,\n          accessor: {\n            size: 1\n          }\n        });\n      } else {\n        this.elementIDBuffer.setData({\n          data: elementIds\n        });\n      }\n\n      this.elementCount = elementCount;\n    }\n  }, {\n    key: \"_updateBindings\",\n    value: function _updateBindings(opts) {\n      this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);\n\n      if (this._swapTexture) {\n        var _this$_swapTextures = this._swapTextures(this.bindings[this.currentIndex]),\n            sourceTextures = _this$_swapTextures.sourceTextures,\n            targetTexture = _this$_swapTextures.targetTexture;\n\n        var nextIndex = this._getNextIndex();\n\n        this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {\n          sourceTextures: sourceTextures,\n          targetTexture: targetTexture\n        });\n      }\n    }\n  }, {\n    key: \"_updateBinding\",\n    value: function _updateBinding(binding, opts) {\n      var sourceBuffers = opts.sourceBuffers,\n          sourceTextures = opts.sourceTextures,\n          targetTexture = opts.targetTexture;\n\n      if (!binding) {\n        binding = {\n          sourceBuffers: {},\n          sourceTextures: {},\n          targetTexture: null\n        };\n      }\n\n      Object.assign(binding.sourceTextures, sourceTextures);\n      Object.assign(binding.sourceBuffers, sourceBuffers);\n\n      if (targetTexture) {\n        binding.targetTexture = targetTexture;\n        var width = targetTexture.width,\n            height = targetTexture.height;\n        var _binding = binding,\n            framebuffer = _binding.framebuffer;\n\n        if (framebuffer) {\n          framebuffer.update({\n            attachments: _defineProperty({}, 36064, targetTexture),\n            resizeAttachments: false\n          });\n          framebuffer.resize({\n            width: width,\n            height: height\n          });\n        } else {\n          binding.framebuffer = new Framebuffer(this.gl, {\n            id: \"\".concat(this.id || 'transform', \"-framebuffer\"),\n            width: width,\n            height: height,\n            attachments: _defineProperty({}, 36064, targetTexture)\n          });\n        }\n      }\n\n      return binding;\n    }\n  }, {\n    key: \"_setSourceTextureParameters\",\n    value: function _setSourceTextureParameters() {\n      var index = this.currentIndex;\n      var sourceTextures = this.bindings[index].sourceTextures;\n\n      for (var name in sourceTextures) {\n        sourceTextures[name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);\n      }\n    }\n  }, {\n    key: \"_swapTextures\",\n    value: function _swapTextures(opts) {\n      if (!this._swapTexture) {\n        return null;\n      }\n\n      var sourceTextures = Object.assign({}, opts.sourceTextures);\n      sourceTextures[this._swapTexture] = opts.targetTexture;\n      var targetTexture = opts.sourceTextures[this._swapTexture];\n      return {\n        sourceTextures: sourceTextures,\n        targetTexture: targetTexture\n      };\n    }\n  }, {\n    key: \"_createNewTexture\",\n    value: function _createNewTexture(refTexture) {\n      var _parameters;\n\n      var texture = cloneTextureFrom(refTexture, {\n        parameters: (_parameters = {}, _defineProperty(_parameters, 10241, 9728), _defineProperty(_parameters, 10240, 9728), _defineProperty(_parameters, 10242, 33071), _defineProperty(_parameters, 10243, 33071), _parameters),\n        pixelStore: _defineProperty({}, 37440, false)\n      });\n\n      if (this.ownTexture) {\n        this.ownTexture[\"delete\"]();\n      }\n\n      this.ownTexture = texture;\n      return texture;\n    }\n  }, {\n    key: \"_getNextIndex\",\n    value: function _getNextIndex() {\n      return (this.currentIndex + 1) % 2;\n    }\n  }, {\n    key: \"_processVertexShader\",\n    value: function _processVertexShader() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _this$bindings$this$c2 = this.bindings[this.currentIndex],\n          sourceTextures = _this$bindings$this$c2.sourceTextures,\n          targetTexture = _this$bindings$this$c2.targetTexture;\n\n      var _updateForTextures = updateForTextures({\n        vs: props.vs,\n        sourceTextureMap: sourceTextures,\n        targetTextureVarying: this.targetTextureVarying,\n        targetTexture: targetTexture\n      }),\n          vs = _updateForTextures.vs,\n          uniforms = _updateForTextures.uniforms,\n          targetTextureType = _updateForTextures.targetTextureType,\n          inject = _updateForTextures.inject,\n          samplerTextureMap = _updateForTextures.samplerTextureMap;\n\n      var combinedInject = combineInjects([props.inject || {}, inject]);\n      this.targetTextureType = targetTextureType;\n      this.samplerTextureMap = samplerTextureMap;\n      var fs = props._fs || getPassthroughFS({\n        version: getShaderVersion(vs),\n        input: this.targetTextureVarying,\n        inputType: targetTextureType,\n        output: FS_OUTPUT_VARIABLE\n      });\n      var modules = this.hasSourceTextures || this.targetTextureVarying ? [transformModule].concat(props.modules || []) : props.modules;\n      return {\n        vs: vs,\n        fs: fs,\n        modules: modules,\n        uniforms: uniforms,\n        inject: combinedInject\n      };\n    }\n  }]);\n\n  return TextureTransform;\n}();\n\nexport { TextureTransform as default };","map":{"version":3,"sources":["../../../src/transform/texture-transform.js"],"names":["_transform","SRC_TEX_PARAMETER_OVERRIDES","FS_OUTPUT_VARIABLE","TextureTransform","props","Object","updatedModelProps","opts","sourceBuffers","sourceTextures","framebuffer","targetTexture","attributes","uniforms","parameters","discard","textureName","sizeUniforms","getSizeUniforms","sourceTextureMap","targetTextureVarying","packed","pixels","readPixelsToArray","ArrayType","channelCount","typeToChannelCount","packedPixels","packCount","i","j","currentResources","_targetTextureVarying","_swapTexture","textureOrReference","refTexture","_sourceTextures","_targetTexture","elementCount","elementIds","array","data","accessor","size","nextIndex","binding","width","height","attachments","resizeAttachments","id","index","texture","cloneTextureFrom","pixelStore","vs","targetTextureType","inject","samplerTextureMap","updateForTextures","combinedInject","combineInjects","fs","getPassthroughFS","version","getShaderVersion","input","inputType","output","modules"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport {\n  cloneTextureFrom,\n  readPixelsToArray,\n  getShaderVersion,\n  Buffer,\n  Texture2D,\n  Framebuffer\n} from '@luma.gl/webgl';\nimport {\n  _transform as transformModule,\n  getPassthroughFS,\n  typeToChannelCount,\n  combineInjects\n} from '@luma.gl/shadertools';\nimport {updateForTextures, getSizeUniforms} from './transform-shader-utils';\n\n// TODO: move these constants to transform-shader-utils\n// Texture parameters needed so sample can precisely pick pixel for given element id.\nconst SRC_TEX_PARAMETER_OVERRIDES = {\n  [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n  [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n  [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n  [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n};\nconst FS_OUTPUT_VARIABLE = 'transform_output';\n\nexport default class TextureTransform {\n  constructor(gl, props = {}) {\n    this.gl = gl;\n    this.currentIndex = 0;\n    this._swapTexture = null;\n    this.targetTextureVarying = null;\n    this.targetTextureType = null;\n    this.samplerTextureMap = null;\n    this.bindings = []; // each element is an object : {sourceTextures, targetTexture, framebuffer}\n\n    this.resources = {}; // resources to be deleted\n\n    this._initialize(props);\n    Object.seal(this);\n  }\n\n  updateModelProps(props = {}) {\n    const updatedModelProps = this._processVertexShader(props);\n    return Object.assign({}, props, updatedModelProps);\n  }\n\n  getDrawOptions(opts = {}) {\n    const {sourceBuffers, sourceTextures, framebuffer, targetTexture} = this.bindings[\n      this.currentIndex\n    ];\n\n    const attributes = Object.assign({}, sourceBuffers, opts.attributes);\n    const uniforms = Object.assign({}, opts.uniforms);\n    const parameters = Object.assign({}, opts.parameters);\n    let discard = opts.discard;\n\n    if (this.hasSourceTextures || this.hasTargetTexture) {\n      attributes.transform_elementID = this.elementIDBuffer;\n\n      for (const sampler in this.samplerTextureMap) {\n        const textureName = this.samplerTextureMap[sampler];\n        uniforms[sampler] = sourceTextures[textureName];\n      }\n      this._setSourceTextureParameters();\n      // get texture size uniforms\n      const sizeUniforms = getSizeUniforms({\n        sourceTextureMap: sourceTextures,\n        targetTextureVarying: this.targetTextureVarying,\n        targetTexture\n      });\n      Object.assign(uniforms, sizeUniforms);\n    }\n\n    if (this.hasTargetTexture) {\n      discard = false;\n      parameters.viewport = [0, 0, framebuffer.width, framebuffer.height];\n    }\n\n    return {attributes, framebuffer, uniforms, discard, parameters};\n  }\n\n  swap() {\n    if (this._swapTexture) {\n      this.currentIndex = this._getNextIndex();\n      return true;\n    }\n    return false;\n  }\n\n  // update source and/or feedbackBuffers\n  update(opts = {}) {\n    this._setupTextures(opts);\n  }\n\n  // returns current target texture\n  getTargetTexture() {\n    const {targetTexture} = this.bindings[this.currentIndex];\n    return targetTexture;\n  }\n\n  getData({packed = false} = {}) {\n    const {framebuffer} = this.bindings[this.currentIndex];\n    const pixels = readPixelsToArray(framebuffer);\n\n    if (!packed) {\n      return pixels;\n    }\n\n    // readPixels returns 4 elements for each pixel, pack the elements when requested\n    const ArrayType = pixels.constructor;\n    const channelCount = typeToChannelCount(this.targetTextureType);\n    const packedPixels = new ArrayType((pixels.length * channelCount) / 4);\n    let packCount = 0;\n    for (let i = 0; i < pixels.length; i += 4) {\n      for (let j = 0; j < channelCount; j++) {\n        packedPixels[packCount++] = pixels[i + j];\n      }\n    }\n    return packedPixels;\n  }\n\n  // returns current framebuffer object that is being used.\n  getFramebuffer() {\n    const currentResources = this.bindings[this.currentIndex];\n    return currentResources.framebuffer;\n  }\n\n  // Delete owned resources.\n  delete() {\n    if (this.ownTexture) {\n      this.ownTexture.delete();\n    }\n    if (this.elementIDBuffer) {\n      this.elementIDBuffer.delete();\n    }\n  }\n\n  // Private\n\n  _initialize(props = {}) {\n    const {_targetTextureVarying, _swapTexture} = props;\n    this._swapTexture = _swapTexture;\n    this.targetTextureVarying = _targetTextureVarying;\n    this.hasTargetTexture = _targetTextureVarying;\n    this._setupTextures(props);\n  }\n\n  // auto create target texture if requested\n  _createTargetTexture(props) {\n    const {sourceTextures, textureOrReference} = props;\n    if (textureOrReference instanceof Texture2D) {\n      return textureOrReference;\n    }\n    // 'targetTexture' is a reference souce texture.\n    const refTexture = sourceTextures[textureOrReference];\n    if (!refTexture) {\n      return null;\n    }\n\n    // save reference texture name, when corresponding source texture is updated\n    // we also update target texture.\n    this._targetRefTexName = textureOrReference;\n\n    return this._createNewTexture(refTexture);\n  }\n\n  _setupTextures(props = {}) {\n    const {sourceBuffers, _sourceTextures = {}, _targetTexture} = props;\n    const targetTexture = this._createTargetTexture({\n      sourceTextures: _sourceTextures,\n      textureOrReference: _targetTexture\n    });\n    this.hasSourceTextures =\n      this.hasSourceTextures || (_sourceTextures && Object.keys(_sourceTextures).length > 0);\n    this._updateBindings({sourceBuffers, sourceTextures: _sourceTextures, targetTexture});\n    if ('elementCount' in props) {\n      this._updateElementIDBuffer(props.elementCount);\n    }\n  }\n\n  _updateElementIDBuffer(elementCount) {\n    if (typeof elementCount !== 'number' || this.elementCount >= elementCount) {\n      return;\n    }\n    // NOTE: using float so this will work with GLSL 1.0 shaders.\n    const elementIds = new Float32Array(elementCount);\n    elementIds.forEach((_, index, array) => {\n      array[index] = index;\n    });\n    if (!this.elementIDBuffer) {\n      this.elementIDBuffer = new Buffer(this.gl, {\n        data: elementIds,\n        accessor: {size: 1}\n      });\n    } else {\n      this.elementIDBuffer.setData({data: elementIds});\n    }\n    this.elementCount = elementCount;\n  }\n\n  _updateBindings(opts) {\n    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);\n    if (this._swapTexture) {\n      const {sourceTextures, targetTexture} = this._swapTextures(this.bindings[this.currentIndex]);\n      const nextIndex = this._getNextIndex();\n      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {\n        sourceTextures,\n        targetTexture\n      });\n    }\n  }\n\n  _updateBinding(binding, opts) {\n    const {sourceBuffers, sourceTextures, targetTexture} = opts;\n    if (!binding) {\n      binding = {\n        sourceBuffers: {},\n        sourceTextures: {},\n        targetTexture: null\n      };\n    }\n    Object.assign(binding.sourceTextures, sourceTextures);\n    Object.assign(binding.sourceBuffers, sourceBuffers);\n    if (targetTexture) {\n      binding.targetTexture = targetTexture;\n\n      const {width, height} = targetTexture;\n      const {framebuffer} = binding;\n      if (framebuffer) {\n        // First update texture without re-sizing attachments\n        framebuffer.update({\n          attachments: {[GL.COLOR_ATTACHMENT0]: targetTexture},\n          resizeAttachments: false\n        });\n        // Resize to new taget texture size\n        framebuffer.resize({width, height});\n      } else {\n        binding.framebuffer = new Framebuffer(this.gl, {\n          id: `${this.id || 'transform'}-framebuffer`,\n          width,\n          height,\n          attachments: {\n            [GL.COLOR_ATTACHMENT0]: targetTexture\n          }\n        });\n      }\n    }\n    return binding;\n  }\n\n  // set texture filtering parameters on source textures.\n  _setSourceTextureParameters() {\n    const index = this.currentIndex;\n    const {sourceTextures} = this.bindings[index];\n    for (const name in sourceTextures) {\n      sourceTextures[name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);\n    }\n  }\n\n  _swapTextures(opts) {\n    if (!this._swapTexture) {\n      return null;\n    }\n    const sourceTextures = Object.assign({}, opts.sourceTextures);\n    sourceTextures[this._swapTexture] = opts.targetTexture;\n\n    const targetTexture = opts.sourceTextures[this._swapTexture];\n\n    return {sourceTextures, targetTexture};\n  }\n\n  // Create a buffer and add to list of buffers to be deleted.\n  _createNewTexture(refTexture) {\n    const texture = cloneTextureFrom(refTexture, {\n      parameters: {\n        [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n        [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n      },\n      pixelStore: {\n        [GL.UNPACK_FLIP_Y_WEBGL]: false\n      }\n    });\n\n    // thre can only be one target texture\n    if (this.ownTexture) {\n      this.ownTexture.delete();\n    }\n    this.ownTexture = texture;\n\n    return texture;\n  }\n\n  _getNextIndex() {\n    return (this.currentIndex + 1) % 2;\n  }\n\n  // build and return shader releated parameters\n  _processVertexShader(props = {}) {\n    const {sourceTextures, targetTexture} = this.bindings[this.currentIndex];\n    const {vs, uniforms, targetTextureType, inject, samplerTextureMap} = updateForTextures({\n      vs: props.vs,\n      sourceTextureMap: sourceTextures,\n      targetTextureVarying: this.targetTextureVarying,\n      targetTexture\n    });\n    const combinedInject = combineInjects([props.inject || {}, inject]);\n    this.targetTextureType = targetTextureType;\n    this.samplerTextureMap = samplerTextureMap;\n    const fs =\n      props._fs ||\n      getPassthroughFS({\n        version: getShaderVersion(vs),\n        input: this.targetTextureVarying,\n        inputType: targetTextureType,\n        output: FS_OUTPUT_VARIABLE\n      });\n    const modules =\n      this.hasSourceTextures || this.targetTextureVarying\n        ? [transformModule].concat(props.modules || [])\n        : props.modules;\n    return {vs, fs, modules, uniforms, inject: combinedInject};\n  }\n}\n"]},"metadata":{},"sourceType":"module"}