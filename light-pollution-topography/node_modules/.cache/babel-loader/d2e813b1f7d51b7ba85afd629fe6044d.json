{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { Buffer, Texture2D, assert } from '@luma.gl/webgl';\nimport { isWebGL2 } from '@luma.gl/gltools';\nimport { Transform } from '@luma.gl/engine';\nimport { default as textureFilterModule } from './texture-filter';\nimport { POLY_TEX_VS, FILTER_VS } from './shaders';\nimport * as Polygon from './polygon';\nvar TEXTURE_SIZE = 512;\n\nvar GPUPointInPolygon = function () {\n  function GPUPointInPolygon(gl) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, GPUPointInPolygon);\n\n    this.gl = gl;\n    assert(isWebGL2(gl));\n    this.textureSize = TEXTURE_SIZE;\n\n    this._setupResources();\n\n    this.update(opts);\n  }\n\n  _createClass(GPUPointInPolygon, [{\n    key: \"update\",\n    value: function update() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          polygons = _ref.polygons,\n          textureSize = _ref.textureSize;\n\n      if (textureSize) {\n        this.textureSize = textureSize;\n      }\n\n      if (!polygons || polygons.length === 0) {\n        return;\n      }\n\n      var _triangulatePolygons = triangulatePolygons(polygons),\n          vertices = _triangulatePolygons.vertices,\n          indices = _triangulatePolygons.indices,\n          vertexCount = _triangulatePolygons.vertexCount,\n          ids = _triangulatePolygons.ids;\n\n      this._updateResources(vertices, indices, ids, vertexCount);\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(_ref2) {\n      var positionBuffer = _ref2.positionBuffer,\n          filterValueIndexBuffer = _ref2.filterValueIndexBuffer,\n          count = _ref2.count;\n      this.filterTransform.update({\n        sourceBuffers: {\n          a_position: positionBuffer\n        },\n        feedbackBuffers: {\n          filterValueIndex: filterValueIndexBuffer\n        },\n        elementCount: count\n      });\n      var polygonTexture = this.polygonTexture,\n          boundingBox = this.boundingBox;\n      this.filterTransform.run({\n        moduleSettings: {\n          boundingBox: boundingBox,\n          texture: polygonTexture\n        }\n      });\n    }\n  }, {\n    key: \"_setupResources\",\n    value: function _setupResources() {\n      var _parameters;\n\n      var gl = this.gl;\n      this.polygonTexture = new Texture2D(gl, {\n        format: 6407,\n        type: 5121,\n        dataFormat: 6407,\n        border: 0,\n        mipmaps: false,\n        parameters: (_parameters = {}, _defineProperty(_parameters, 10240, 9728), _defineProperty(_parameters, 10241, 9728), _defineProperty(_parameters, 10242, 33071), _defineProperty(_parameters, 10243, 33071), _parameters)\n      });\n      this.positionBuffer = new Buffer(gl, {\n        accessor: {\n          type: 5126,\n          size: 2\n        }\n      });\n      this.idBuffer = new Buffer(gl, {\n        accessor: {\n          type: 5126,\n          size: 1\n        }\n      });\n      this.indexBuffer = new Buffer(gl, {\n        target: 34963,\n        accessor: {\n          type: 5123\n        }\n      });\n      this.polyTextureTransform = new Transform(gl, {\n        id: \"polygon-texture-creation-transform\",\n        elementCount: 0,\n        _targetTexture: this.polygonTexture,\n        _targetTextureVarying: 'v_polygonColor',\n        vs: POLY_TEX_VS,\n        drawMode: 4,\n        isIndexed: true,\n        sourceBuffers: {\n          a_position: this.positionBuffer,\n          a_polygonID: this.idBuffer,\n          indices: this.indexBuffer\n        }\n      });\n      this.filterTransform = new Transform(gl, {\n        id: 'filter transform',\n        vs: FILTER_VS,\n        modules: [textureFilterModule],\n        varyings: ['filterValueIndex']\n      });\n    }\n  }, {\n    key: \"_updateResources\",\n    value: function _updateResources(vertices, indices, ids, vertexCount) {\n      var boundingBox = getBoundingBox(vertices, vertexCount);\n\n      var _boundingBox = _slicedToArray(boundingBox, 4),\n          xMin = _boundingBox[0],\n          yMin = _boundingBox[1],\n          xMax = _boundingBox[2],\n          yMax = _boundingBox[3];\n\n      var width = xMax - xMin;\n      var height = yMax - yMin;\n      var whRatio = width / height;\n      var textureSize = this.textureSize;\n      var texWidth = textureSize;\n      var texHeight = textureSize;\n\n      if (whRatio > 1) {\n        texHeight = texWidth / whRatio;\n      } else {\n        texWidth = texHeight * whRatio;\n      }\n\n      this.boundingBox = boundingBox;\n      this.polygonTexture.resize({\n        width: texWidth,\n        height: texHeight,\n        mipmaps: false\n      });\n      this.positionBuffer.setData(new Float32Array(vertices));\n      this.idBuffer.setData(new Float32Array(ids));\n      this.indexBuffer.setData(new Uint16Array(indices));\n      this.polyTextureTransform.update({\n        elementCount: indices.length,\n        _targetTexture: this.polygonTexture\n      });\n      this.polyTextureTransform.run({\n        uniforms: {\n          boundingBoxOriginSize: [xMin, yMin, width, height]\n        }\n      });\n    }\n  }]);\n\n  return GPUPointInPolygon;\n}();\n\nexport { GPUPointInPolygon as default };\n\nfunction getBoundingBox(positions, vertexCount) {\n  var yMin = Infinity;\n  var yMax = -Infinity;\n  var xMin = Infinity;\n  var xMax = -Infinity;\n  var y;\n  var x;\n\n  for (var i = 0; i < vertexCount; i++) {\n    x = positions[i * 2];\n    y = positions[i * 2 + 1];\n    yMin = y < yMin ? y : yMin;\n    yMax = y > yMax ? y : yMax;\n    xMin = x < xMin ? x : xMin;\n    xMax = x > xMax ? x : xMax;\n  }\n\n  return [xMin, yMin, xMax, yMax];\n}\n\nfunction triangulatePolygons(polygons) {\n  var SIZE = 2;\n  var vertices = [];\n  var indices = [];\n  var ids = [];\n  var count = 0;\n  var polygonId = 0;\n\n  for (var i = 0; i < polygons.length; i++) {\n    var normalized = Polygon.normalize(polygons[i], SIZE);\n    var curVertices = normalized.positions || normalized;\n    var curCount = curVertices.length / SIZE;\n    var curIds = new Array(curCount).fill(polygonId);\n    vertices.push.apply(vertices, _toConsumableArray(curVertices));\n    ids.push.apply(ids, _toConsumableArray(curIds));\n    var curIndices = Polygon.getSurfaceIndices(normalized, SIZE);\n    var indexCount = curIndices.length;\n\n    for (var j = 0; j < indexCount; j++) {\n      curIndices[j] += count;\n    }\n\n    count += curCount;\n    indices.push.apply(indices, _toConsumableArray(curIndices));\n    polygonId++;\n  }\n\n  assert(count < 65536);\n  var vertexCount = Polygon.getVertexCount(vertices, SIZE);\n  return {\n    vertices: vertices,\n    indices: indices,\n    ids: ids,\n    vertexCount: vertexCount\n  };\n}","map":{"version":3,"sources":["../../../../src/gpgpu/point-in-polygon/gpu-point-in-polygon.js"],"names":["default","TEXTURE_SIZE","GPUPointInPolygon","opts","assert","isWebGL2","polygons","textureSize","vertices","indices","vertexCount","ids","triangulatePolygons","positionBuffer","filterValueIndexBuffer","count","sourceBuffers","a_position","feedbackBuffers","filterValueIndex","elementCount","polygonTexture","boundingBox","moduleSettings","texture","gl","format","type","dataFormat","border","mipmaps","parameters","accessor","size","target","id","_targetTexture","_targetTextureVarying","vs","drawMode","isIndexed","a_polygonID","indexBuffer","modules","varyings","getBoundingBox","xMin","yMin","xMax","yMax","width","height","whRatio","texWidth","texHeight","uniforms","boundingBoxOriginSize","i","x","positions","y","SIZE","polygonId","normalized","Polygon","curVertices","curCount","curIds","curIndices","indexCount","j"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport {Buffer, Texture2D, assert} from '@luma.gl/webgl';\nimport {isWebGL2} from '@luma.gl/gltools';\nimport {Transform} from '@luma.gl/engine';\nimport {default as textureFilterModule} from './texture-filter';\nimport {POLY_TEX_VS, FILTER_VS} from './shaders';\nimport * as Polygon from './polygon';\nconst TEXTURE_SIZE = 512;\n\nexport default class GPUPointInPolygon {\n  constructor(gl, opts = {}) {\n    this.gl = gl;\n    assert(isWebGL2(gl)); // supports WebGL2 only\n    this.textureSize = TEXTURE_SIZE;\n    this._setupResources();\n    this.update(opts);\n  }\n\n  update({polygons, textureSize} = {}) {\n    if (textureSize) {\n      this.textureSize = textureSize;\n    }\n    if (!polygons || polygons.length === 0) {\n      return;\n    }\n\n    const {vertices, indices, vertexCount, ids} = triangulatePolygons(polygons);\n    this._updateResources(vertices, indices, ids, vertexCount);\n  }\n\n  filter({positionBuffer, filterValueIndexBuffer, count}) {\n    this.filterTransform.update({\n      sourceBuffers: {\n        a_position: positionBuffer\n      },\n      feedbackBuffers: {\n        filterValueIndex: filterValueIndexBuffer\n      },\n      elementCount: count\n    });\n    const {polygonTexture, boundingBox} = this;\n\n    this.filterTransform.run({\n      moduleSettings: {boundingBox, texture: polygonTexture}\n    });\n  }\n\n  // PRIVATE\n\n  _setupResources() {\n    const {gl} = this;\n\n    // texture to render polygons to\n    this.polygonTexture = new Texture2D(gl, {\n      format: GL.RGB,\n      type: GL.UNSIGNED_BYTE,\n      dataFormat: GL.RGB,\n      border: 0,\n      mipmaps: false,\n      parameters: {\n        [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_WRAP_S]: gl.CLAMP_TO_EDGE,\n        [GL.TEXTURE_WRAP_T]: gl.CLAMP_TO_EDGE\n      }\n    });\n    this.positionBuffer = new Buffer(gl, {accessor: {type: GL.FLOAT, size: 2}});\n    this.idBuffer = new Buffer(gl, {accessor: {type: GL.FLOAT, size: 1}});\n    this.indexBuffer = new Buffer(gl, {\n      target: GL.ELEMENT_ARRAY_BUFFER,\n      accessor: {type: GL.UNSIGNED_SHORT}\n    });\n\n    // transform to generate polygon texture\n    this.polyTextureTransform = new Transform(gl, {\n      id: `polygon-texture-creation-transform`,\n      elementCount: 0,\n      _targetTexture: this.polygonTexture,\n      _targetTextureVarying: 'v_polygonColor',\n      vs: POLY_TEX_VS,\n      drawMode: GL.TRIANGLES,\n      isIndexed: true,\n      sourceBuffers: {\n        a_position: this.positionBuffer,\n        a_polygonID: this.idBuffer,\n        indices: this.indexBuffer\n      }\n    });\n\n    // transform to perform filtering\n    this.filterTransform = new Transform(gl, {\n      id: 'filter transform',\n      vs: FILTER_VS,\n      modules: [textureFilterModule],\n      varyings: ['filterValueIndex']\n    });\n  }\n\n  _updateResources(vertices, indices, ids, vertexCount) {\n    const boundingBox = getBoundingBox(vertices, vertexCount);\n    const [xMin, yMin, xMax, yMax] = boundingBox;\n    const width = xMax - xMin;\n    const height = yMax - yMin;\n    const whRatio = width / height;\n    const {textureSize} = this;\n\n    // calculate max texture size with same aspect ratio\n    let texWidth = textureSize;\n    let texHeight = textureSize;\n    if (whRatio > 1) {\n      texHeight = texWidth / whRatio;\n    } else {\n      texWidth = texHeight * whRatio;\n    }\n\n    this.boundingBox = boundingBox;\n    this.polygonTexture.resize({width: texWidth, height: texHeight, mipmaps: false});\n    this.positionBuffer.setData(new Float32Array(vertices));\n    this.idBuffer.setData(new Float32Array(ids));\n    this.indexBuffer.setData(new Uint16Array(indices));\n    this.polyTextureTransform.update({\n      elementCount: indices.length,\n      _targetTexture: this.polygonTexture\n    });\n\n    this.polyTextureTransform.run({\n      uniforms: {\n        boundingBoxOriginSize: [xMin, yMin, width, height]\n      }\n    });\n  }\n}\n\n// Helper methods\n\nfunction getBoundingBox(positions, vertexCount) {\n  let yMin = Infinity;\n  let yMax = -Infinity;\n  let xMin = Infinity;\n  let xMax = -Infinity;\n  let y;\n  let x;\n\n  for (let i = 0; i < vertexCount; i++) {\n    x = positions[i * 2];\n    y = positions[i * 2 + 1];\n    yMin = y < yMin ? y : yMin;\n    yMax = y > yMax ? y : yMax;\n    xMin = x < xMin ? x : xMin;\n    xMax = x > xMax ? x : xMax;\n  }\n\n  return [xMin, yMin, xMax, yMax];\n}\n\nfunction triangulatePolygons(polygons) {\n  const SIZE = 2;\n  const vertices = [];\n  const indices = [];\n  const ids = [];\n  let count = 0;\n  let polygonId = 0;\n  for (let i = 0; i < polygons.length; i++) {\n    const normalized = Polygon.normalize(polygons[i], SIZE);\n    const curVertices = normalized.positions || normalized;\n    const curCount = curVertices.length / SIZE;\n    const curIds = new Array(curCount).fill(polygonId);\n    vertices.push(...curVertices);\n    ids.push(...curIds);\n    const curIndices = Polygon.getSurfaceIndices(normalized, SIZE);\n    const indexCount = curIndices.length;\n    for (let j = 0; j < indexCount; j++) {\n      curIndices[j] += count;\n    }\n    count += curCount;\n    indices.push(...curIndices);\n    polygonId++;\n  }\n\n  // UInt16 (UNSIGNED_SHORT) buffer is used for indices\n  assert(count < 65536); // 0xFFFF\n\n  const vertexCount = Polygon.getVertexCount(vertices, SIZE);\n\n  return {vertices, indices, ids, vertexCount};\n}\n"]},"metadata":{},"sourceType":"module"}