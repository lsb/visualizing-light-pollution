{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport parseImage from '../parsers/parse-image';\nimport { getImageUrls } from './load-image';\nimport { deepLoad } from './deep-load';\nvar GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;\nvar GL_TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;\nvar GL_TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;\nvar GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;\nvar GL_TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;\nvar GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851a;\nvar CUBE_FACES = [{\n  face: GL_TEXTURE_CUBE_MAP_POSITIVE_X,\n  direction: 'right',\n  axis: 'x',\n  sign: 'positive'\n}, {\n  face: GL_TEXTURE_CUBE_MAP_NEGATIVE_X,\n  direction: 'left',\n  axis: 'x',\n  sign: 'negative'\n}, {\n  face: GL_TEXTURE_CUBE_MAP_POSITIVE_Y,\n  direction: 'top',\n  axis: 'y',\n  sign: 'positive'\n}, {\n  face: GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,\n  direction: 'bottom',\n  axis: 'y',\n  sign: 'negative'\n}, {\n  face: GL_TEXTURE_CUBE_MAP_POSITIVE_Z,\n  direction: 'front',\n  axis: 'z',\n  sign: 'positive'\n}, {\n  face: GL_TEXTURE_CUBE_MAP_NEGATIVE_Z,\n  direction: 'back',\n  axis: 'z',\n  sign: 'negative'\n}];\nexport function getImageCubeUrls(_x, _x2) {\n  return _getImageCubeUrls.apply(this, arguments);\n}\n\nfunction _getImageCubeUrls() {\n  _getImageCubeUrls = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(getUrl, options) {\n    var urls, promises, index, _loop, face;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            urls = {};\n            promises = [];\n            index = 0;\n\n            _loop = function _loop(face) {\n              var faceValues = CUBE_FACES[index];\n              var promise = getImageUrls(getUrl, options, _objectSpread({}, faceValues, {\n                index: index++\n              })).then(function (url) {\n                urls[face] = url;\n              });\n              promises.push(promise);\n            };\n\n            for (face in CUBE_FACES) {\n              _loop(face);\n            }\n\n            _context.next = 7;\n            return Promise.all(promises);\n\n          case 7:\n            return _context.abrupt(\"return\", urls);\n\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _getImageCubeUrls.apply(this, arguments);\n}\n\nexport function loadImageCube(_x3) {\n  return _loadImageCube.apply(this, arguments);\n}\n\nfunction _loadImageCube() {\n  _loadImageCube = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(getUrl) {\n    var options,\n        urls,\n        _args2 = arguments;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n            _context2.next = 3;\n            return getImageCubeUrls(getUrl, options);\n\n          case 3:\n            urls = _context2.sent;\n            _context2.next = 6;\n            return deepLoad(urls, parseImage, options);\n\n          case 6:\n            return _context2.abrupt(\"return\", _context2.sent);\n\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _loadImageCube.apply(this, arguments);\n}","map":{"version":3,"sources":["../../../../src/lib/texture-loading-api/load-image-cube.js"],"names":["GL_TEXTURE_CUBE_MAP_POSITIVE_X","GL_TEXTURE_CUBE_MAP_NEGATIVE_X","GL_TEXTURE_CUBE_MAP_POSITIVE_Y","GL_TEXTURE_CUBE_MAP_NEGATIVE_Y","GL_TEXTURE_CUBE_MAP_POSITIVE_Z","GL_TEXTURE_CUBE_MAP_NEGATIVE_Z","CUBE_FACES","face","direction","axis","sign","urls","promises","index","faceValues","promise","Promise","options","getImageCubeUrls","deepLoad"],"mappings":"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","sourcesContent":["import parseImage from '../parsers/parse-image';\nimport {getImageUrls} from './load-image';\nimport {deepLoad} from './deep-load';\n\n// Returned map will be have keys corresponding to GL cubemap constants\nconst GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;\nconst GL_TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;\nconst GL_TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;\nconst GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;\nconst GL_TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;\nconst GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851a;\n\nconst CUBE_FACES = [\n  {face: GL_TEXTURE_CUBE_MAP_POSITIVE_X, direction: 'right', axis: 'x', sign: 'positive'},\n  {face: GL_TEXTURE_CUBE_MAP_NEGATIVE_X, direction: 'left', axis: 'x', sign: 'negative'},\n  {face: GL_TEXTURE_CUBE_MAP_POSITIVE_Y, direction: 'top', axis: 'y', sign: 'positive'},\n  {face: GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, direction: 'bottom', axis: 'y', sign: 'negative'},\n  {face: GL_TEXTURE_CUBE_MAP_POSITIVE_Z, direction: 'front', axis: 'z', sign: 'positive'},\n  {face: GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, direction: 'back', axis: 'z', sign: 'negative'}\n];\n\n// Returns an object with six key-value pairs containing the urls (or url mip arrays)\n// for each cube face\nexport async function getImageCubeUrls(getUrl, options) {\n  // Calculate URLs\n  const urls = {};\n  const promises = [];\n\n  let index = 0;\n  for (const face in CUBE_FACES) {\n    const faceValues = CUBE_FACES[index];\n    const promise = getImageUrls(getUrl, options, {...faceValues, index: index++}).then(url => {\n      urls[face] = url;\n    });\n    promises.push(promise);\n  }\n\n  await Promise.all(promises);\n\n  return urls;\n}\n\n// Returns an object with six key-value pairs containing the images (or image mip arrays)\n// for each cube face\nexport async function loadImageCube(getUrl, options = {}) {\n  const urls = await getImageCubeUrls(getUrl, options);\n  return await deepLoad(urls, parseImage, options);\n}\n"]},"metadata":{},"sourceType":"module"}