{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nvar _SHADER_TYPE;\n\nimport { VERTEX_SHADER, FRAGMENT_SHADER } from './constants';\nimport { resolveModules } from './resolve-modules';\nimport { getPlatformShaderDefines, getVersionDefines } from './platform-defines';\nimport injectShader, { DECLARATION_INJECT_MARKER } from './inject-shader';\nimport transpileShader from './transpile-shader';\nimport { assert } from '../utils';\nvar INJECT_SHADER_DECLARATIONS = \"\\n\\n\".concat(DECLARATION_INJECT_MARKER, \"\\n\\n\");\nvar SHADER_TYPE = (_SHADER_TYPE = {}, _defineProperty(_SHADER_TYPE, VERTEX_SHADER, 'vertex'), _defineProperty(_SHADER_TYPE, FRAGMENT_SHADER, 'fragment'), _SHADER_TYPE);\nvar FRAGMENT_SHADER_PROLOGUE = \"precision highp float;\\n\\n\";\nexport function assembleShaders(gl, opts) {\n  var vs = opts.vs,\n      fs = opts.fs;\n  var modules = resolveModules(opts.modules || []);\n  return {\n    gl: gl,\n    vs: assembleShader(gl, Object.assign({}, opts, {\n      source: vs,\n      type: VERTEX_SHADER,\n      modules: modules\n    })),\n    fs: assembleShader(gl, Object.assign({}, opts, {\n      source: fs,\n      type: FRAGMENT_SHADER,\n      modules: modules\n    })),\n    getUniforms: assembleGetUniforms(modules)\n  };\n}\n\nfunction assembleShader(gl, _ref) {\n  var id = _ref.id,\n      source = _ref.source,\n      type = _ref.type,\n      modules = _ref.modules,\n      _ref$defines = _ref.defines,\n      defines = _ref$defines === void 0 ? {} : _ref$defines,\n      _ref$hookFunctions = _ref.hookFunctions,\n      hookFunctions = _ref$hookFunctions === void 0 ? [] : _ref$hookFunctions,\n      _ref$inject = _ref.inject,\n      inject = _ref$inject === void 0 ? {} : _ref$inject,\n      _ref$transpileToGLSL = _ref.transpileToGLSL100,\n      transpileToGLSL100 = _ref$transpileToGLSL === void 0 ? false : _ref$transpileToGLSL,\n      _ref$prologue = _ref.prologue,\n      prologue = _ref$prologue === void 0 ? true : _ref$prologue,\n      log = _ref.log;\n  assert(typeof source === 'string', 'shader source must be a string');\n  var isVertex = type === VERTEX_SHADER;\n  var sourceLines = source.split('\\n');\n  var glslVersion = 100;\n  var versionLine = '';\n  var coreSource = source;\n\n  if (sourceLines[0].indexOf('#version ') === 0) {\n    glslVersion = 300;\n    versionLine = sourceLines[0];\n    coreSource = sourceLines.slice(1).join('\\n');\n  } else {\n    versionLine = \"#version \".concat(glslVersion);\n  }\n\n  var allDefines = {};\n  modules.forEach(function (module) {\n    Object.assign(allDefines, module.getDefines());\n  });\n  Object.assign(allDefines, defines);\n  var assembledSource = prologue ? \"\".concat(versionLine, \"\\n\").concat(getShaderName({\n    id: id,\n    source: source,\n    type: type\n  }), \"\\n\").concat(getShaderType({\n    type: type\n  }), \"\\n\").concat(getPlatformShaderDefines(gl), \"\\n\").concat(getVersionDefines(gl, glslVersion, !isVertex), \"\\n\").concat(getApplicationDefines(allDefines), \"\\n\").concat(isVertex ? '' : FRAGMENT_SHADER_PROLOGUE, \"\\n\") : \"\".concat(versionLine, \"\\n\");\n  hookFunctions = normalizeHookFunctions(hookFunctions);\n  var hookInjections = {};\n  var declInjections = {};\n  var mainInjections = {};\n\n  for (var key in inject) {\n    var injection = typeof inject[key] === 'string' ? {\n      injection: inject[key],\n      order: 0\n    } : inject[key];\n    var match = key.match(/^(v|f)s:(#)?([\\w-]+)$/);\n\n    if (match) {\n      var hash = match[2];\n      var name = match[3];\n\n      if (hash) {\n        if (name === 'decl') {\n          declInjections[key] = [injection];\n        } else {\n          mainInjections[key] = [injection];\n        }\n      } else {\n        hookInjections[key] = [injection];\n      }\n    } else {\n      mainInjections[key] = [injection];\n    }\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = modules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var module = _step.value;\n\n      if (log) {\n        module.checkDeprecations(coreSource, log);\n      }\n\n      var moduleSource = module.getModuleSource(type, glslVersion);\n      assembledSource += moduleSource;\n      var injections = module.injections[type];\n\n      for (var _key in injections) {\n        var _match = _key.match(/^(v|f)s:#([\\w-]+)$/);\n\n        if (_match) {\n          var _name = _match[2];\n          var injectionType = _name === 'decl' ? declInjections : mainInjections;\n          injectionType[_key] = injectionType[_key] || [];\n\n          injectionType[_key].push(injections[_key]);\n        } else {\n          hookInjections[_key] = hookInjections[_key] || [];\n\n          hookInjections[_key].push(injections[_key]);\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n        _iterator[\"return\"]();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  assembledSource += INJECT_SHADER_DECLARATIONS;\n  assembledSource = injectShader(assembledSource, type, declInjections);\n  assembledSource += getHookFunctions(hookFunctions[type], hookInjections);\n  assembledSource += coreSource;\n  assembledSource = injectShader(assembledSource, type, mainInjections);\n  assembledSource = transpileShader(assembledSource, transpileToGLSL100 ? 100 : glslVersion, isVertex);\n  return assembledSource;\n}\n\nfunction assembleGetUniforms(modules) {\n  return function getUniforms(opts) {\n    var uniforms = {};\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = modules[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var module = _step2.value;\n        var moduleUniforms = module.getUniforms(opts, uniforms);\n        Object.assign(uniforms, moduleUniforms);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n          _iterator2[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    return uniforms;\n  };\n}\n\nfunction getShaderType(_ref2) {\n  var type = _ref2.type;\n  return \"\\n#define SHADER_TYPE_\".concat(SHADER_TYPE[type].toUpperCase(), \"\\n\");\n}\n\nfunction getShaderName(_ref3) {\n  var id = _ref3.id,\n      source = _ref3.source,\n      type = _ref3.type;\n  var injectShaderName = id && typeof id === 'string' && source.indexOf('SHADER_NAME') === -1;\n  return injectShaderName ? \"\\n#define SHADER_NAME \".concat(id, \"_\").concat(SHADER_TYPE[type], \"\\n\\n\") : '';\n}\n\nfunction getApplicationDefines() {\n  var defines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var count = 0;\n  var sourceText = '';\n\n  for (var define in defines) {\n    if (count === 0) {\n      sourceText += '\\n// APPLICATION DEFINES\\n';\n    }\n\n    count++;\n    var value = defines[define];\n\n    if (value || Number.isFinite(value)) {\n      sourceText += \"#define \".concat(define.toUpperCase(), \" \").concat(defines[define], \"\\n\");\n    }\n  }\n\n  if (count === 0) {\n    sourceText += '\\n';\n  }\n\n  return sourceText;\n}\n\nfunction getHookFunctions(hookFunctions, hookInjections) {\n  var result = '';\n\n  for (var hookName in hookFunctions) {\n    var hookFunction = hookFunctions[hookName];\n    result += \"void \".concat(hookFunction.signature, \" {\\n\");\n\n    if (hookFunction.header) {\n      result += \"  \".concat(hookFunction.header);\n    }\n\n    if (hookInjections[hookName]) {\n      var injections = hookInjections[hookName];\n      injections.sort(function (a, b) {\n        return a.order - b.order;\n      });\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = injections[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var injection = _step3.value;\n          result += \"  \".concat(injection.injection, \"\\n\");\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n            _iterator3[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n\n    if (hookFunction.footer) {\n      result += \"  \".concat(hookFunction.footer);\n    }\n\n    result += '}\\n';\n  }\n\n  return result;\n}\n\nfunction normalizeHookFunctions(hookFunctions) {\n  var result = {\n    vs: {},\n    fs: {}\n  };\n  hookFunctions.forEach(function (hook) {\n    var opts;\n\n    if (typeof hook !== 'string') {\n      opts = hook;\n      hook = opts.hook;\n    } else {\n      opts = {};\n    }\n\n    hook = hook.trim();\n\n    var _hook$split = hook.split(':'),\n        _hook$split2 = _slicedToArray(_hook$split, 2),\n        stage = _hook$split2[0],\n        signature = _hook$split2[1];\n\n    var name = hook.replace(/\\(.+/, '');\n    result[stage][name] = Object.assign(opts, {\n      signature: signature\n    });\n  });\n  return result;\n}","map":{"version":3,"sources":["../../../src/lib/assemble-shaders.js"],"names":["INJECT_SHADER_DECLARATIONS","SHADER_TYPE","FRAGMENT_SHADER_PROLOGUE","vs","fs","opts","modules","resolveModules","gl","assembleShader","source","type","getUniforms","assembleGetUniforms","id","defines","hookFunctions","inject","transpileToGLSL100","prologue","log","assert","isVertex","sourceLines","glslVersion","versionLine","coreSource","allDefines","Object","module","assembledSource","getShaderName","getShaderType","getPlatformShaderDefines","getVersionDefines","getApplicationDefines","normalizeHookFunctions","hookInjections","declInjections","mainInjections","injection","order","match","key","hash","name","moduleSource","injections","injectionType","injectShader","getHookFunctions","transpileShader","uniforms","moduleUniforms","injectShaderName","count","sourceText","value","Number","define","result","hookFunction","a","b","hook","stage","signature"],"mappings":"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","sourcesContent":["import {VERTEX_SHADER, FRAGMENT_SHADER} from './constants';\nimport {resolveModules} from './resolve-modules';\nimport {getPlatformShaderDefines, getVersionDefines} from './platform-defines';\nimport injectShader, {DECLARATION_INJECT_MARKER} from './inject-shader';\nimport transpileShader from './transpile-shader';\nimport {assert} from '../utils';\n\nconst INJECT_SHADER_DECLARATIONS = `\\n\\n${DECLARATION_INJECT_MARKER}\\n\\n`;\n\nconst SHADER_TYPE = {\n  [VERTEX_SHADER]: 'vertex',\n  [FRAGMENT_SHADER]: 'fragment'\n};\n\n// Precision prologue to inject before functions are injected in shader\n// TODO - extract any existing prologue in the fragment source and move it up...\nconst FRAGMENT_SHADER_PROLOGUE = `\\\nprecision highp float;\n\n`;\n\n// Inject a list of modules\nexport function assembleShaders(gl, opts) {\n  const {vs, fs} = opts;\n  const modules = resolveModules(opts.modules || []);\n  return {\n    gl,\n    vs: assembleShader(gl, Object.assign({}, opts, {source: vs, type: VERTEX_SHADER, modules})),\n    fs: assembleShader(gl, Object.assign({}, opts, {source: fs, type: FRAGMENT_SHADER, modules})),\n    getUniforms: assembleGetUniforms(modules)\n  };\n}\n\n// Pulls together complete source code for either a vertex or a fragment shader\n// adding prologues, requested module chunks, and any final injections.\nfunction assembleShader(\n  gl,\n  {\n    id,\n    source,\n    type,\n    modules,\n    defines = {},\n    hookFunctions = [],\n    inject = {},\n    transpileToGLSL100 = false,\n    prologue = true,\n    log\n  }\n) {\n  assert(typeof source === 'string', 'shader source must be a string');\n\n  const isVertex = type === VERTEX_SHADER;\n\n  const sourceLines = source.split('\\n');\n  let glslVersion = 100;\n  let versionLine = '';\n  let coreSource = source;\n  // Extract any version directive string from source.\n  // TODO : keep all pre-processor statements at the begining of the shader.\n  if (sourceLines[0].indexOf('#version ') === 0) {\n    glslVersion = 300; // TODO - regexp that matches atual version number\n    versionLine = sourceLines[0];\n    coreSource = sourceLines.slice(1).join('\\n');\n  } else {\n    versionLine = `#version ${glslVersion}`;\n  }\n\n  // Combine Module and Application Defines\n  const allDefines = {};\n  modules.forEach(module => {\n    Object.assign(allDefines, module.getDefines());\n  });\n  Object.assign(allDefines, defines);\n\n  // Add platform defines (use these to work around platform-specific bugs and limitations)\n  // Add common defines (GLSL version compatibility, feature detection)\n  // Add precision declaration for fragment shaders\n  let assembledSource = prologue\n    ? `\\\n${versionLine}\n${getShaderName({id, source, type})}\n${getShaderType({type})}\n${getPlatformShaderDefines(gl)}\n${getVersionDefines(gl, glslVersion, !isVertex)}\n${getApplicationDefines(allDefines)}\n${isVertex ? '' : FRAGMENT_SHADER_PROLOGUE}\n`\n    : `${versionLine}\n`;\n\n  hookFunctions = normalizeHookFunctions(hookFunctions);\n\n  // Add source of dependent modules in resolved order\n  const hookInjections = {};\n  const declInjections = {};\n  const mainInjections = {};\n\n  for (const key in inject) {\n    const injection =\n      typeof inject[key] === 'string' ? {injection: inject[key], order: 0} : inject[key];\n    const match = key.match(/^(v|f)s:(#)?([\\w-]+)$/);\n    if (match) {\n      const hash = match[2];\n      const name = match[3];\n      if (hash) {\n        if (name === 'decl') {\n          declInjections[key] = [injection];\n        } else {\n          mainInjections[key] = [injection];\n        }\n      } else {\n        hookInjections[key] = [injection];\n      }\n    } else {\n      // Regex injection\n      mainInjections[key] = [injection];\n    }\n  }\n\n  for (const module of modules) {\n    if (log) {\n      module.checkDeprecations(coreSource, log);\n    }\n    const moduleSource = module.getModuleSource(type, glslVersion);\n    // Add the module source, and a #define that declares it presence\n    assembledSource += moduleSource;\n\n    const injections = module.injections[type];\n    for (const key in injections) {\n      const match = key.match(/^(v|f)s:#([\\w-]+)$/);\n      if (match) {\n        const name = match[2];\n        const injectionType = name === 'decl' ? declInjections : mainInjections;\n        injectionType[key] = injectionType[key] || [];\n        injectionType[key].push(injections[key]);\n      } else {\n        hookInjections[key] = hookInjections[key] || [];\n        hookInjections[key].push(injections[key]);\n      }\n    }\n  }\n\n  // For injectShader\n  assembledSource += INJECT_SHADER_DECLARATIONS;\n\n  assembledSource = injectShader(assembledSource, type, declInjections);\n\n  assembledSource += getHookFunctions(hookFunctions[type], hookInjections);\n\n  // Add the version directive and actual source of this shader\n  assembledSource += coreSource;\n\n  // Apply any requested shader injections\n  assembledSource = injectShader(assembledSource, type, mainInjections);\n\n  assembledSource = transpileShader(\n    assembledSource,\n    transpileToGLSL100 ? 100 : glslVersion,\n    isVertex\n  );\n\n  return assembledSource;\n}\n\n// Returns a combined `getUniforms` covering the options for all the modules,\n// the created function will pass on options to the inidividual `getUniforms`\n// function of each shader module and combine the results into one object that\n// can be passed to setUniforms.\nfunction assembleGetUniforms(modules) {\n  return function getUniforms(opts) {\n    const uniforms = {};\n    for (const module of modules) {\n      // `modules` is already sorted by dependency level. This guarantees that\n      // modules have access to the uniforms that are generated by their dependencies.\n      const moduleUniforms = module.getUniforms(opts, uniforms);\n      Object.assign(uniforms, moduleUniforms);\n    }\n    return uniforms;\n  };\n}\n\nfunction getShaderType({type}) {\n  return `\n#define SHADER_TYPE_${SHADER_TYPE[type].toUpperCase()}\n`;\n}\n\n// Generate \"glslify-compatible\" SHADER_NAME defines\n// These are understood by the GLSL error parsing function\n// If id is provided and no SHADER_NAME constant is present in source, create one\nfunction getShaderName({id, source, type}) {\n  const injectShaderName = id && typeof id === 'string' && source.indexOf('SHADER_NAME') === -1;\n  return injectShaderName\n    ? `\n#define SHADER_NAME ${id}_${SHADER_TYPE[type]}\n\n`\n    : '';\n}\n\n// Generates application defines from an object\nfunction getApplicationDefines(defines = {}) {\n  let count = 0;\n  let sourceText = '';\n  for (const define in defines) {\n    if (count === 0) {\n      sourceText += '\\n// APPLICATION DEFINES\\n';\n    }\n    count++;\n\n    const value = defines[define];\n    if (value || Number.isFinite(value)) {\n      sourceText += `#define ${define.toUpperCase()} ${defines[define]}\\n`;\n    }\n  }\n  if (count === 0) {\n    sourceText += '\\n';\n  }\n  return sourceText;\n}\n\nfunction getHookFunctions(hookFunctions, hookInjections) {\n  let result = '';\n  for (const hookName in hookFunctions) {\n    const hookFunction = hookFunctions[hookName];\n    result += `void ${hookFunction.signature} {\\n`;\n    if (hookFunction.header) {\n      result += `  ${hookFunction.header}`;\n    }\n    if (hookInjections[hookName]) {\n      const injections = hookInjections[hookName];\n      injections.sort((a, b) => a.order - b.order);\n      for (const injection of injections) {\n        result += `  ${injection.injection}\\n`;\n      }\n    }\n    if (hookFunction.footer) {\n      result += `  ${hookFunction.footer}`;\n    }\n    result += '}\\n';\n  }\n\n  return result;\n}\nfunction normalizeHookFunctions(hookFunctions) {\n  const result = {\n    vs: {},\n    fs: {}\n  };\n\n  hookFunctions.forEach(hook => {\n    let opts;\n    if (typeof hook !== 'string') {\n      opts = hook;\n      hook = opts.hook;\n    } else {\n      opts = {};\n    }\n    hook = hook.trim();\n    const [stage, signature] = hook.split(':');\n    const name = hook.replace(/\\(.+/, '');\n    result[stage][name] = Object.assign(opts, {signature});\n  });\n\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}