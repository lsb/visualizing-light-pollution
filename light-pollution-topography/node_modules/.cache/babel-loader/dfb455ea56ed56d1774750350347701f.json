{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { Vector3, Matrix4 } from 'math.gl';\nimport * as mat4 from 'gl-matrix/mat4';\nimport { Intersect } from '../constants';\nvar scratchVector = new Vector3();\nvar scratchVector2 = new Vector3();\n\nvar BoundingSphere = function () {\n  function BoundingSphere() {\n    var center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0];\n    var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;\n\n    _classCallCheck(this, BoundingSphere);\n\n    this.radius = -0;\n    this.center = new Vector3();\n    this.fromCenterRadius(center, radius);\n  }\n\n  _createClass(BoundingSphere, [{\n    key: \"fromCenterRadius\",\n    value: function fromCenterRadius(center, radius) {\n      this.center.from(center);\n      this.radius = radius;\n      return this;\n    }\n  }, {\n    key: \"fromCornerPoints\",\n    value: function fromCornerPoints(corner, oppositeCorner) {\n      oppositeCorner = scratchVector.from(oppositeCorner);\n      this.center = new Vector3().from(corner).add(oppositeCorner).scale(0.5);\n      this.radius = this.center.distance(oppositeCorner);\n      return this;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(right) {\n      return this === right || Boolean(right) && this.center.equals(right.center) && this.radius === right.radius;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new BoundingSphere(this.center, this.radius);\n    }\n  }, {\n    key: \"union\",\n    value: function union(boundingSphere) {\n      var leftCenter = this.center;\n      var leftRadius = this.radius;\n      var rightCenter = boundingSphere.center;\n      var rightRadius = boundingSphere.radius;\n      var toRightCenter = scratchVector.copy(rightCenter).subtract(leftCenter);\n      var centerSeparation = toRightCenter.magnitude();\n\n      if (leftRadius >= centerSeparation + rightRadius) {\n        return this.clone();\n      }\n\n      if (rightRadius >= centerSeparation + leftRadius) {\n        return boundingSphere.clone();\n      }\n\n      var halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;\n      scratchVector2.copy(toRightCenter).scale((-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation).add(leftCenter);\n      this.center.copy(scratchVector2);\n      this.radius = halfDistanceBetweenTangentPoints;\n      return this;\n    }\n  }, {\n    key: \"expand\",\n    value: function expand(point) {\n      point = scratchVector.from(point);\n      var radius = point.subtract(this.center).magnitude();\n\n      if (radius > this.radius) {\n        this.radius = radius;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"intersectPlane\",\n    value: function intersectPlane(plane) {\n      var center = this.center;\n      var radius = this.radius;\n      var normal = plane.normal;\n      var distanceToPlane = normal.dot(center) + plane.distance;\n\n      if (distanceToPlane < -radius) {\n        return Intersect.OUTSIDE;\n      }\n\n      if (distanceToPlane < radius) {\n        return Intersect.INTERSECTING;\n      }\n\n      return Intersect.INSIDE;\n    }\n  }, {\n    key: \"transform\",\n    value: function transform(_transform) {\n      this.center.transform(_transform);\n      var scale = mat4.getScaling(scratchVector, _transform);\n      this.radius = Math.max(scale[0], Math.max(scale[1], scale[2])) * this.radius;\n      return this;\n    }\n  }, {\n    key: \"distanceSquaredTo\",\n    value: function distanceSquaredTo(point) {\n      point = scratchVector.from(point);\n      var delta = point.subtract(this.center);\n      return delta.lengthSquared() - this.radius * this.radius;\n    }\n  }, {\n    key: \"distanceTo\",\n    value: function distanceTo(point) {\n      return Math.sqrt(this.distanceSquaredTo(point));\n    }\n  }]);\n\n  return BoundingSphere;\n}();\n\nexport { BoundingSphere as default };","map":{"version":3,"sources":["../../../src/lib/bounding-sphere.js"],"names":["scratchVector","scratchVector2","BoundingSphere","center","radius","corner","oppositeCorner","right","Boolean","boundingSphere","leftCenter","leftRadius","rightCenter","rightRadius","toRightCenter","centerSeparation","halfDistanceBetweenTangentPoints","point","plane","normal","distanceToPlane","Intersect","transform","scale","mat4","Math","delta"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/* eslint-disable */\nimport {Vector3, Matrix4} from 'math.gl';\nimport * as mat4 from 'gl-matrix/mat4';\nimport {Intersect} from '../constants';\n\n// import Rectangle from './rectangle';\n\n// const defaultProjection = new GeographicProjection();\n// const fromRectangle2DLowerLeft = new Vector3();\n// const fromRectangle2DUpperRight = new Vector3();\n// const fromRectangle2DSouthwest = new Cartographic();\n// const fromRectangle2DNortheast = new Cartographic();\n\n// const fromRectangle3DScratch = [];\n\nconst scratchVector = new Vector3();\nconst scratchVector2 = new Vector3();\n\nexport default class BoundingSphere {\n  constructor(center = [0, 0, 0], radius = 0.0) {\n    this.radius = -0;\n    this.center = new Vector3();\n    this.fromCenterRadius(center, radius);\n  }\n\n  fromCenterRadius(center, radius) {\n    this.center.from(center);\n    this.radius = radius;\n    return this;\n  }\n\n  // Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere\n  // tighly and fully encompases the box.\n  fromCornerPoints(corner, oppositeCorner) {\n    oppositeCorner = scratchVector.from(oppositeCorner);\n    this.center = new Vector3()\n      .from(corner)\n      .add(oppositeCorner)\n      .scale(0.5);\n    this.radius = this.center.distance(oppositeCorner);\n    return this;\n  }\n\n  // Compares the provided BoundingSphere componentwise\n  equals(right) {\n    return (\n      this === right ||\n      (Boolean(right) && this.center.equals(right.center) && this.radius === right.radius)\n    );\n  }\n\n  // Duplicates a BoundingSphere instance.\n  clone() {\n    return new BoundingSphere(this.center, this.radius);\n  }\n\n  // Computes a bounding sphere that contains both the left and right bounding spheres.\n  union(boundingSphere) {\n    const leftCenter = this.center;\n    const leftRadius = this.radius;\n    const rightCenter = boundingSphere.center;\n    const rightRadius = boundingSphere.radius;\n\n    const toRightCenter = scratchVector.copy(rightCenter).subtract(leftCenter);\n    const centerSeparation = toRightCenter.magnitude();\n\n    if (leftRadius >= centerSeparation + rightRadius) {\n      // Left sphere wins.\n      return this.clone();\n    }\n\n    if (rightRadius >= centerSeparation + leftRadius) {\n      // Right sphere wins.\n      return boundingSphere.clone();\n    }\n\n    // There are two tangent points, one on far side of each sphere.\n    const halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;\n\n    // Compute the center point halfway between the two tangent points.\n    scratchVector2\n      .copy(toRightCenter)\n      .scale((-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation)\n      .add(leftCenter);\n\n    this.center.copy(scratchVector2);\n    this.radius = halfDistanceBetweenTangentPoints;\n\n    return this;\n  }\n\n  // Computes a bounding sphere by enlarging the provided sphere to contain the provided point.\n  expand(point) {\n    point = scratchVector.from(point);\n    const radius = point.subtract(this.center).magnitude();\n    if (radius > this.radius) {\n      this.radius = radius;\n    }\n    return this;\n  }\n\n  // Determines which side of a plane a sphere is located.\n  intersectPlane(plane) {\n    var center = this.center;\n    var radius = this.radius;\n    var normal = plane.normal;\n    var distanceToPlane = normal.dot(center) + plane.distance;\n\n    // The center point is negative side of the plane normal\n    if (distanceToPlane < -radius) {\n      return Intersect.OUTSIDE;\n    }\n    // The center point is positive side of the plane, but radius extends beyond it; partial overlap\n    if (distanceToPlane < radius) {\n      return Intersect.INTERSECTING;\n    }\n    // The center point and radius is positive side of the plane\n    return Intersect.INSIDE;\n  }\n\n  // Applies a 4x4 affine transformation matrix to a bounding sphere.\n  //    *\n  // @param {BoundingSphere} sphere The bounding sphere to apply the transformation to.\n  // @param {Matrix4} transform The transformation matrix to apply to the bounding sphere.\n  // @returns {BoundingSphere} The modified this parameter or a new BoundingSphere instance if none was provided.\n  transform(transform) {\n    this.center.transform(transform);\n    const scale = mat4.getScaling(scratchVector, transform);\n    this.radius = Math.max(scale[0], Math.max(scale[1], scale[2])) * this.radius;\n    return this;\n  }\n\n  // Computes the estimated distance squared from the closest point on a bounding sphere to a point.\n  distanceSquaredTo(point) {\n    point = scratchVector.from(point);\n    const delta = point.subtract(this.center);\n    return delta.lengthSquared() - this.radius * this.radius;\n  }\n\n  distanceTo(point) {\n    return Math.sqrt(this.distanceSquaredTo(point));\n  }\n}\n"]},"metadata":{},"sourceType":"module"}