{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport WorkerPool from './worker-pool';\nvar DEFAULT_MAX_CONCURRENCY = 5;\n\nvar WorkerFarm = function () {\n  _createClass(WorkerFarm, null, [{\n    key: \"isSupported\",\n    value: function isSupported() {\n      return typeof Worker !== 'undefined';\n    }\n  }]);\n\n  function WorkerFarm(_ref) {\n    var _ref$maxConcurrency = _ref.maxConcurrency,\n        maxConcurrency = _ref$maxConcurrency === void 0 ? DEFAULT_MAX_CONCURRENCY : _ref$maxConcurrency,\n        onMessage = _ref.onMessage,\n        _ref$onDebug = _ref.onDebug,\n        onDebug = _ref$onDebug === void 0 ? function () {} : _ref$onDebug;\n\n    _classCallCheck(this, WorkerFarm);\n\n    this.maxConcurrency = maxConcurrency;\n    this.onMessage = onMessage;\n    this.onDebug = onDebug;\n    this.workerPools = new Map();\n  }\n\n  _createClass(WorkerFarm, [{\n    key: \"setProps\",\n    value: function setProps(props) {\n      if ('maxConcurrency' in props) {\n        this.maxConcurrency = props.maxConcurrency;\n      }\n\n      if ('onDebug' in props) {\n        this.onDebug = props.onDebug;\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.workerPools.forEach(function (workerPool) {\n        return workerPool.destroy();\n      });\n    }\n  }, {\n    key: \"process\",\n    value: function () {\n      var _process = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(workerSource, workerName, data) {\n        var workerPool;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                workerPool = this._getWorkerPool(workerSource, workerName);\n                return _context.abrupt(\"return\", workerPool.process(data));\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function process(_x, _x2, _x3) {\n        return _process.apply(this, arguments);\n      }\n\n      return process;\n    }()\n  }, {\n    key: \"_getWorkerPool\",\n    value: function _getWorkerPool(workerSource, workerName) {\n      var workerPool = this.workerPools.get(workerName);\n\n      if (!workerPool) {\n        workerPool = new WorkerPool({\n          source: workerSource,\n          name: workerName,\n          onMessage: this.onMessage,\n          maxConcurrency: this.maxConcurrency,\n          onDebug: this.onDebug\n        });\n        this.workerPools.set(workerName, workerPool);\n      }\n\n      return workerPool;\n    }\n  }]);\n\n  return WorkerFarm;\n}();\n\nexport { WorkerFarm as default };","map":{"version":3,"sources":["../../../src/worker-utils/worker-farm.js"],"names":["DEFAULT_MAX_CONCURRENCY","WorkerFarm","maxConcurrency","onMessage","onDebug","props","workerPool","workerSource","workerName","data","source","name"],"mappings":";;;;AAAA,OAAA,UAAA,MAAA,eAAA;AAEA,IAAMA,uBAAuB,GAA7B,CAAA;;IAKqBC,U;;;kCACE;AACnB,aAAO,OAAA,MAAA,KAAP,WAAA;AACD;;;AAMD,WAAA,UAAA,CAAA,IAAA,EAAuF;AAAA,QAAA,mBAAA,GAAA,IAAA,CAA1EC,cAA0E;AAAA,QAA1EA,cAA0E,GAAA,mBAAA,KAAA,KAAA,CAAA,GAAzDF,uBAAyD,GAAA,mBAAA;AAAA,QAAhCG,SAAgC,GAAA,IAAA,CAAhCA,SAAgC;AAAA,QAAA,YAAA,GAAA,IAAA,CAArBC,OAAqB;AAAA,QAArBA,OAAqB,GAAA,YAAA,KAAA,KAAA,CAAA,GAAX,YAAM,CAAK,CAAA,GAAA,YAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,UAAA,CAAA;;AACrF,SAAA,cAAA,GAAA,cAAA;AACA,SAAA,SAAA,GAAA,SAAA;AACA,SAAA,OAAA,GAAA,OAAA;AACA,SAAA,WAAA,GAAmB,IAAnB,GAAmB,EAAnB;AACD;;;;6BAEQC,K,EAAO;AACd,UAAI,oBAAJ,KAAA,EAA+B;AAC7B,aAAA,cAAA,GAAsBA,KAAK,CAA3B,cAAA;AACD;;AAED,UAAI,aAAJ,KAAA,EAAwB;AACtB,aAAA,OAAA,GAAeA,KAAK,CAApB,OAAA;AACD;AACF;;;8BAES;AACR,WAAA,WAAA,CAAA,OAAA,CAAyB,UAAA,UAAA,EAAU;AAAA,eAAIC,UAAU,CAAd,OAAIA,EAAJ;AAAnC,OAAA;AACD;;;;iFAOaC,Y,EAAcC,U,EAAYC,I;;;;;;AAChCH,gBAAAA,U,GAAa,KAAA,cAAA,CAAA,YAAA,EAAA,UAAA,CAAbA;iDACCA,UAAU,CAAVA,OAAAA,CAAAA,IAAAA,C;;;;;;;;;;;;;;;;;;mCAKMC,Y,EAAcC,U,EAAY;AACvC,UAAIF,UAAU,GAAG,KAAA,WAAA,CAAA,GAAA,CAAjB,UAAiB,CAAjB;;AACA,UAAI,CAAJ,UAAA,EAAiB;AACfA,QAAAA,UAAU,GAAG,IAAA,UAAA,CAAe;AAC1BI,UAAAA,MAAM,EADoB,YAAA;AAE1BC,UAAAA,IAAI,EAFsB,UAAA;AAG1BR,UAAAA,SAAS,EAAE,KAHe,SAAA;AAI1BD,UAAAA,cAAc,EAAE,KAJU,cAAA;AAK1BE,UAAAA,OAAO,EAAE,KAAKA;AALY,SAAf,CAAbE;AAOA,aAAA,WAAA,CAAA,GAAA,CAAA,UAAA,EAAA,UAAA;AACD;;AACD,aAAA,UAAA;AACD;;;;;;SAvDkBL,U","sourcesContent":["import WorkerPool from './worker-pool';\n\nconst DEFAULT_MAX_CONCURRENCY = 5;\n\n/**\n * Process multiple data messages with a \"farm\" of different workers (in worker pools)\n */\nexport default class WorkerFarm {\n  static isSupported() {\n    return typeof Worker !== 'undefined';\n  }\n\n  /**\n   * @param processor {function | string} - worker function\n   * @param maxConcurrency {number} - max count of workers\n   */\n  constructor({maxConcurrency = DEFAULT_MAX_CONCURRENCY, onMessage, onDebug = () => {}}) {\n    this.maxConcurrency = maxConcurrency;\n    this.onMessage = onMessage;\n    this.onDebug = onDebug;\n    this.workerPools = new Map();\n  }\n\n  setProps(props) {\n    if ('maxConcurrency' in props) {\n      this.maxConcurrency = props.maxConcurrency;\n    }\n\n    if ('onDebug' in props) {\n      this.onDebug = props.onDebug;\n    }\n  }\n\n  destroy() {\n    this.workerPools.forEach(workerPool => workerPool.destroy());\n  }\n\n  /**\n   * Process binary data in a worker\n   * @param {any} data - data (containing binary typed arrays) to be transferred to worker\n   * @returns a Promise with data containing typed arrays transferred back from work\n   */\n  async process(workerSource, workerName, data) {\n    const workerPool = this._getWorkerPool(workerSource, workerName);\n    return workerPool.process(data);\n  }\n\n  // PRIVATE\n\n  _getWorkerPool(workerSource, workerName) {\n    let workerPool = this.workerPools.get(workerName);\n    if (!workerPool) {\n      workerPool = new WorkerPool({\n        source: workerSource,\n        name: workerName,\n        onMessage: this.onMessage,\n        maxConcurrency: this.maxConcurrency,\n        onDebug: this.onDebug\n      });\n      this.workerPools.set(workerName, workerPool);\n    }\n    return workerPool;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}