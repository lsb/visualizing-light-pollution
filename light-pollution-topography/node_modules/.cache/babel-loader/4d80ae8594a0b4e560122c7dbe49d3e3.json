{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport Martini from '@mapbox/martini';\nimport { getMeshBoundingBox } from '@loaders.gl/loader-utils';\n\nfunction getTerrain(imageData, tileSize, elevationDecoder) {\n  var rScaler = elevationDecoder.rScaler,\n      bScaler = elevationDecoder.bScaler,\n      gScaler = elevationDecoder.gScaler,\n      offset = elevationDecoder.offset;\n  var gridSize = tileSize + 1;\n  var terrain = new Float32Array(gridSize * gridSize);\n\n  for (var i = 0, y = 0; y < tileSize; y++) {\n    for (var x = 0; x < tileSize; x++, i++) {\n      var k = i * 4;\n      var r = imageData[k + 0];\n      var g = imageData[k + 1];\n      var b = imageData[k + 2];\n      terrain[i + y] = r * rScaler + g * gScaler + b * bScaler + offset;\n    }\n  }\n\n  for (var _i = gridSize * (gridSize - 1), _x = 0; _x < gridSize - 1; _x++, _i++) {\n    terrain[_i] = terrain[_i - gridSize];\n  }\n\n  for (var _i2 = gridSize - 1, _y = 0; _y < gridSize; _y++, _i2 += gridSize) {\n    terrain[_i2] = terrain[_i2 - 1];\n  }\n\n  return terrain;\n}\n\nfunction getMeshAttributes(vertices, terrain, tileSize, bounds) {\n  var gridSize = tileSize + 1;\n  var numOfVerticies = vertices.length / 2;\n  var positions = new Float32Array(numOfVerticies * 3);\n  var texCoords = new Float32Array(numOfVerticies * 2);\n\n  var _ref = bounds || [0, 0, tileSize, tileSize],\n      _ref2 = _slicedToArray(_ref, 4),\n      minX = _ref2[0],\n      minY = _ref2[1],\n      maxX = _ref2[2],\n      maxY = _ref2[3];\n\n  var xScale = (maxX - minX) / tileSize;\n  var yScale = (maxY - minY) / tileSize;\n\n  for (var i = 0; i < numOfVerticies; i++) {\n    var x = vertices[i * 2];\n    var y = vertices[i * 2 + 1];\n    var pixelIdx = y * gridSize + x;\n    positions[3 * i + 0] = x * xScale + minX;\n    positions[3 * i + 1] = -y * yScale + maxY;\n    positions[3 * i + 2] = terrain[pixelIdx];\n    texCoords[2 * i + 0] = x / tileSize;\n    texCoords[2 * i + 1] = y / tileSize;\n  }\n\n  return {\n    POSITION: {\n      value: positions,\n      size: 3\n    },\n    TEXCOORD_0: {\n      value: texCoords,\n      size: 2\n    }\n  };\n}\n\nfunction getMartiniTileMesh(terrainImage, terrainOptions) {\n  if (terrainImage === null) {\n    return null;\n  }\n\n  var meshMaxError = terrainOptions.meshMaxError,\n      bounds = terrainOptions.bounds,\n      elevationDecoder = terrainOptions.elevationDecoder;\n  var data = terrainImage.data;\n  var tileSize = terrainImage.width;\n  var gridSize = tileSize + 1;\n  var terrain = getTerrain(data, tileSize, elevationDecoder);\n  var martini = new Martini(gridSize);\n  var tile = martini.createTile(terrain);\n\n  var _tile$getMesh = tile.getMesh(meshMaxError),\n      vertices = _tile$getMesh.vertices,\n      triangles = _tile$getMesh.triangles;\n\n  var attributes = getMeshAttributes(vertices, terrain, tileSize, bounds);\n  return {\n    loaderData: {\n      header: {}\n    },\n    header: {\n      vertexCount: triangles.length,\n      boundingBox: getMeshBoundingBox(attributes)\n    },\n    mode: 4,\n    indices: {\n      value: triangles,\n      size: 1\n    },\n    attributes: attributes\n  };\n}\n\nexport default function loadTerrain(_x2, _x3, _x4) {\n  return _loadTerrain.apply(this, arguments);\n}\n\nfunction _loadTerrain() {\n  _loadTerrain = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(arrayBuffer, options, context) {\n    var image;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            options.image = options.image || {};\n            options.image.type = 'data';\n            _context.next = 4;\n            return context.parse(arrayBuffer, options, options.baseUri);\n\n          case 4:\n            image = _context.sent;\n            return _context.abrupt(\"return\", getMartiniTileMesh(image, options.terrain));\n\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _loadTerrain.apply(this, arguments);\n}","map":{"version":3,"sources":["../../../src/lib/parse-terrain.js"],"names":["rScaler","bScaler","gScaler","offset","elevationDecoder","gridSize","tileSize","terrain","i","y","x","k","r","imageData","g","b","numOfVerticies","vertices","positions","texCoords","minX","minY","maxX","maxY","bounds","xScale","yScale","pixelIdx","POSITION","value","size","TEXCOORD_0","terrainImage","meshMaxError","terrainOptions","data","getTerrain","martini","tile","triangles","attributes","getMeshAttributes","loaderData","header","vertexCount","boundingBox","getMeshBoundingBox","mode","indices","options","image","context","getMartiniTileMesh"],"mappings":"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","sourcesContent":["import Martini from '@mapbox/martini';\nimport {getMeshBoundingBox} from '@loaders.gl/loader-utils';\n\nfunction getTerrain(imageData, tileSize, elevationDecoder) {\n  const {rScaler, bScaler, gScaler, offset} = elevationDecoder;\n\n  const gridSize = tileSize + 1;\n  // From Martini demo\n  // https://observablehq.com/@mourner/martin-real-time-rtin-terrain-mesh\n  const terrain = new Float32Array(gridSize * gridSize);\n  // decode terrain values\n  for (let i = 0, y = 0; y < tileSize; y++) {\n    for (let x = 0; x < tileSize; x++, i++) {\n      const k = i * 4;\n      const r = imageData[k + 0];\n      const g = imageData[k + 1];\n      const b = imageData[k + 2];\n      terrain[i + y] = r * rScaler + g * gScaler + b * bScaler + offset;\n    }\n  }\n  // backfill bottom border\n  for (let i = gridSize * (gridSize - 1), x = 0; x < gridSize - 1; x++, i++) {\n    terrain[i] = terrain[i - gridSize];\n  }\n  // backfill right border\n  for (let i = gridSize - 1, y = 0; y < gridSize; y++, i += gridSize) {\n    terrain[i] = terrain[i - 1];\n  }\n  return terrain;\n}\n\nfunction getMeshAttributes(vertices, terrain, tileSize, bounds) {\n  const gridSize = tileSize + 1;\n  const numOfVerticies = vertices.length / 2;\n  // vec3. x, y in pixels, z in meters\n  const positions = new Float32Array(numOfVerticies * 3);\n  // vec2. 1 to 1 relationship with position. represents the uv on the texture image. 0,0 to 1,1.\n  const texCoords = new Float32Array(numOfVerticies * 2);\n\n  const [minX, minY, maxX, maxY] = bounds || [0, 0, tileSize, tileSize];\n  const xScale = (maxX - minX) / tileSize;\n  const yScale = (maxY - minY) / tileSize;\n\n  for (let i = 0; i < numOfVerticies; i++) {\n    const x = vertices[i * 2];\n    const y = vertices[i * 2 + 1];\n    const pixelIdx = y * gridSize + x;\n\n    positions[3 * i + 0] = x * xScale + minX;\n    positions[3 * i + 1] = -y * yScale + maxY;\n    positions[3 * i + 2] = terrain[pixelIdx];\n\n    texCoords[2 * i + 0] = x / tileSize;\n    texCoords[2 * i + 1] = y / tileSize;\n  }\n\n  return {\n    POSITION: {value: positions, size: 3},\n    TEXCOORD_0: {value: texCoords, size: 2}\n    // NORMAL: {}, - optional, but creates the high poly look with lighting\n  };\n}\n\nfunction getMartiniTileMesh(terrainImage, terrainOptions) {\n  if (terrainImage === null) {\n    return null;\n  }\n  const {meshMaxError, bounds, elevationDecoder} = terrainOptions;\n\n  const data = terrainImage.data;\n  const tileSize = terrainImage.width;\n  const gridSize = tileSize + 1;\n\n  const terrain = getTerrain(data, tileSize, elevationDecoder);\n\n  const martini = new Martini(gridSize);\n  const tile = martini.createTile(terrain);\n  const {vertices, triangles} = tile.getMesh(meshMaxError);\n\n  const attributes = getMeshAttributes(vertices, terrain, tileSize, bounds);\n\n  return {\n    // Data return by this loader implementation\n    loaderData: {\n      header: {}\n    },\n    header: {\n      vertexCount: triangles.length,\n      boundingBox: getMeshBoundingBox(attributes)\n    },\n    mode: 4, // TRIANGLES\n    indices: {value: triangles, size: 1},\n    attributes\n  };\n}\n\nexport default async function loadTerrain(arrayBuffer, options, context) {\n  options.image = options.image || {};\n  options.image.type = 'data';\n  const image = await context.parse(arrayBuffer, options, options.baseUri);\n  // Extend function to support additional mesh generation options (square grid or delatin)\n  return getMartiniTileMesh(image, options.terrain);\n}\n"]},"metadata":{},"sourceType":"module"}