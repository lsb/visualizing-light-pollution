{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport Geometry from '../geometry/geometry';\nimport { uid } from '@luma.gl/webgl';\n\nvar SphereGeometry = function (_Geometry) {\n  _inherits(SphereGeometry, _Geometry);\n\n  function SphereGeometry() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, SphereGeometry);\n\n    var _props$id = props.id,\n        id = _props$id === void 0 ? uid('sphere-geometry') : _props$id;\n\n    var _tesselateSphere = tesselateSphere(props),\n        indices = _tesselateSphere.indices,\n        attributes = _tesselateSphere.attributes;\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(SphereGeometry).call(this, _objectSpread({}, props, {\n      id: id,\n      indices: indices,\n      attributes: _objectSpread({}, attributes, props.attributes)\n    })));\n  }\n\n  return SphereGeometry;\n}(Geometry);\n\nexport { SphereGeometry as default };\n\nfunction tesselateSphere(props) {\n  var _props$nlat = props.nlat,\n      nlat = _props$nlat === void 0 ? 10 : _props$nlat,\n      _props$nlong = props.nlong,\n      nlong = _props$nlong === void 0 ? 10 : _props$nlong;\n  var _props$radius = props.radius,\n      radius = _props$radius === void 0 ? 1 : _props$radius;\n  var startLat = 0;\n  var endLat = Math.PI;\n  var latRange = endLat - startLat;\n  var startLong = 0;\n  var endLong = 2 * Math.PI;\n  var longRange = endLong - startLong;\n  var numVertices = (nlat + 1) * (nlong + 1);\n\n  if (typeof radius === 'number') {\n    var value = radius;\n\n    radius = function radius(n1, n2, n3, u, v) {\n      return value;\n    };\n  }\n\n  var positions = new Float32Array(numVertices * 3);\n  var normals = new Float32Array(numVertices * 3);\n  var texCoords = new Float32Array(numVertices * 2);\n  var IndexType = numVertices > 0xffff ? Uint32Array : Uint16Array;\n  var indices = new IndexType(nlat * nlong * 6);\n\n  for (var y = 0; y <= nlat; y++) {\n    for (var x = 0; x <= nlong; x++) {\n      var u = x / nlong;\n      var v = y / nlat;\n      var index = x + y * (nlong + 1);\n      var i2 = index * 2;\n      var i3 = index * 3;\n      var theta = longRange * u;\n      var phi = latRange * v;\n      var sinTheta = Math.sin(theta);\n      var cosTheta = Math.cos(theta);\n      var sinPhi = Math.sin(phi);\n      var cosPhi = Math.cos(phi);\n      var ux = cosTheta * sinPhi;\n      var uy = cosPhi;\n      var uz = sinTheta * sinPhi;\n      var r = radius(ux, uy, uz, u, v);\n      positions[i3 + 0] = r * ux;\n      positions[i3 + 1] = r * uy;\n      positions[i3 + 2] = r * uz;\n      normals[i3 + 0] = ux;\n      normals[i3 + 1] = uy;\n      normals[i3 + 2] = uz;\n      texCoords[i2 + 0] = u;\n      texCoords[i2 + 1] = 1 - v;\n    }\n  }\n\n  var numVertsAround = nlong + 1;\n\n  for (var _x = 0; _x < nlong; _x++) {\n    for (var _y = 0; _y < nlat; _y++) {\n      var _index = (_x * nlat + _y) * 6;\n\n      indices[_index + 0] = _y * numVertsAround + _x;\n      indices[_index + 1] = _y * numVertsAround + _x + 1;\n      indices[_index + 2] = (_y + 1) * numVertsAround + _x;\n      indices[_index + 3] = (_y + 1) * numVertsAround + _x;\n      indices[_index + 4] = _y * numVertsAround + _x + 1;\n      indices[_index + 5] = (_y + 1) * numVertsAround + _x + 1;\n    }\n  }\n\n  return {\n    indices: {\n      size: 1,\n      value: indices\n    },\n    attributes: {\n      POSITION: {\n        size: 3,\n        value: positions\n      },\n      NORMAL: {\n        size: 3,\n        value: normals\n      },\n      TEXCOORD_0: {\n        size: 2,\n        value: texCoords\n      }\n    }\n  };\n}","map":{"version":3,"sources":["../../../src/geometries/sphere-geometry.js"],"names":["SphereGeometry","Geometry","props","id","uid","indices","attributes","tesselateSphere","nlat","nlong","radius","startLat","endLat","Math","latRange","startLong","endLong","longRange","numVertices","value","positions","normals","texCoords","IndexType","y","x","u","v","index","i2","i3","theta","phi","sinTheta","cosTheta","sinPhi","cosPhi","ux","uy","uz","r","numVertsAround","size","POSITION","NORMAL","TEXCOORD_0"],"mappings":"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","sourcesContent":["import Geometry from '../geometry/geometry';\nimport {uid} from '@luma.gl/webgl';\n\nexport default class SphereGeometry extends Geometry {\n  constructor(props = {}) {\n    const {id = uid('sphere-geometry')} = props;\n    const {indices, attributes} = tesselateSphere(props);\n    super({\n      ...props,\n      id,\n      indices,\n      attributes: {...attributes, ...props.attributes}\n    });\n  }\n}\n\n// Primitives inspired by TDL http://code.google.com/p/webglsamples/,\n// copyright 2011 Google Inc. new BSD License\n// (http://www.opensource.org/licenses/bsd-license.php).\n/* eslint-disable max-statements, complexity */\nfunction tesselateSphere(props) {\n  const {nlat = 10, nlong = 10} = props;\n  let {radius = 1} = props;\n\n  const startLat = 0;\n  const endLat = Math.PI;\n  const latRange = endLat - startLat;\n  const startLong = 0;\n  const endLong = 2 * Math.PI;\n  const longRange = endLong - startLong;\n  const numVertices = (nlat + 1) * (nlong + 1);\n\n  if (typeof radius === 'number') {\n    const value = radius;\n    radius = (n1, n2, n3, u, v) => value;\n  }\n\n  const positions = new Float32Array(numVertices * 3);\n  const normals = new Float32Array(numVertices * 3);\n  const texCoords = new Float32Array(numVertices * 2);\n\n  const IndexType = numVertices > 0xffff ? Uint32Array : Uint16Array;\n  const indices = new IndexType(nlat * nlong * 6);\n\n  // Create positions, normals and texCoords\n  for (let y = 0; y <= nlat; y++) {\n    for (let x = 0; x <= nlong; x++) {\n      const u = x / nlong;\n      const v = y / nlat;\n\n      const index = x + y * (nlong + 1);\n      const i2 = index * 2;\n      const i3 = index * 3;\n\n      const theta = longRange * u;\n      const phi = latRange * v;\n      const sinTheta = Math.sin(theta);\n      const cosTheta = Math.cos(theta);\n      const sinPhi = Math.sin(phi);\n      const cosPhi = Math.cos(phi);\n      const ux = cosTheta * sinPhi;\n      const uy = cosPhi;\n      const uz = sinTheta * sinPhi;\n\n      const r = radius(ux, uy, uz, u, v);\n\n      positions[i3 + 0] = r * ux;\n      positions[i3 + 1] = r * uy;\n      positions[i3 + 2] = r * uz;\n\n      normals[i3 + 0] = ux;\n      normals[i3 + 1] = uy;\n      normals[i3 + 2] = uz;\n\n      texCoords[i2 + 0] = u;\n      texCoords[i2 + 1] = 1 - v;\n    }\n  }\n\n  // Create indices\n  const numVertsAround = nlong + 1;\n  for (let x = 0; x < nlong; x++) {\n    for (let y = 0; y < nlat; y++) {\n      const index = (x * nlat + y) * 6;\n\n      indices[index + 0] = y * numVertsAround + x;\n      indices[index + 1] = y * numVertsAround + x + 1;\n      indices[index + 2] = (y + 1) * numVertsAround + x;\n\n      indices[index + 3] = (y + 1) * numVertsAround + x;\n      indices[index + 4] = y * numVertsAround + x + 1;\n      indices[index + 5] = (y + 1) * numVertsAround + x + 1;\n    }\n  }\n\n  return {\n    indices: {size: 1, value: indices},\n    attributes: {\n      POSITION: {size: 3, value: positions},\n      NORMAL: {size: 3, value: normals},\n      TEXCOORD_0: {size: 2, value: texCoords}\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}