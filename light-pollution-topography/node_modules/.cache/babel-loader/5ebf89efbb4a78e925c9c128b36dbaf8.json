{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport Resource from './resource';\nimport Texture from './texture';\nimport Framebuffer from './framebuffer';\nimport { parseUniformName, getUniformSetter } from './uniforms';\nimport { VertexShader, FragmentShader } from './shader';\nimport ProgramConfiguration from './program-configuration';\nimport { copyUniform, checkUniformValues } from './uniforms';\nimport { isWebGL2, withParameters, log } from '@luma.gl/gltools';\nimport { assertWebGL2Context, getKey } from '../webgl-utils';\nimport { getPrimitiveDrawMode } from '../webgl-utils/attribute-utils';\nimport { uid, assert } from '../utils';\nvar LOG_PROGRAM_PERF_PRIORITY = 4;\nvar GL_SEPARATE_ATTRIBS = 0x8c8d;\nvar V6_DEPRECATED_METHODS = ['setVertexArray', 'setAttributes', 'setBuffers', 'unsetBuffers', 'use', 'getUniformCount', 'getUniformInfo', 'getUniformLocation', 'getUniformValue', 'getVarying', 'getFragDataLocation', 'getAttachedShaders', 'getAttributeCount', 'getAttributeLocation', 'getAttributeInfo'];\n\nvar Program = function (_Resource) {\n  _inherits(Program, _Resource);\n\n  function Program(gl) {\n    var _this;\n\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Program);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Program).call(this, gl, props));\n\n    _this.stubRemovedMethods('Program', 'v6.0', V6_DEPRECATED_METHODS);\n\n    _this._isCached = false;\n\n    _this.initialize(props);\n\n    Object.seal(_assertThisInitialized(_this));\n\n    _this._setId(props.id);\n\n    return _this;\n  }\n\n  _createClass(Program, [{\n    key: \"initialize\",\n    value: function initialize() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var hash = props.hash,\n          vs = props.vs,\n          fs = props.fs,\n          varyings = props.varyings,\n          _props$bufferMode = props.bufferMode,\n          bufferMode = _props$bufferMode === void 0 ? GL_SEPARATE_ATTRIBS : _props$bufferMode;\n      this.hash = hash || '';\n      this.vs = typeof vs === 'string' ? new VertexShader(this.gl, {\n        id: \"\".concat(props.id, \"-vs\"),\n        source: vs\n      }) : vs;\n      this.fs = typeof fs === 'string' ? new FragmentShader(this.gl, {\n        id: \"\".concat(props.id, \"-fs\"),\n        source: fs\n      }) : fs;\n      assert(this.vs instanceof VertexShader);\n      assert(this.fs instanceof FragmentShader);\n      this.uniforms = {};\n      this._textureUniforms = {};\n      this._texturesRenderable = true;\n\n      if (varyings && varyings.length > 0) {\n        assertWebGL2Context(this.gl);\n        this.varyings = varyings;\n        this.gl.transformFeedbackVaryings(this.handle, varyings, bufferMode);\n      }\n\n      this._compileAndLink();\n\n      this._readUniformLocationsFromLinkedProgram();\n\n      this.configuration = new ProgramConfiguration(this);\n      return this.setProps(props);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (this._isCached) {\n        return this;\n      }\n\n      return _get(_getPrototypeOf(Program.prototype), \"delete\", this).call(this, options);\n    }\n  }, {\n    key: \"setProps\",\n    value: function setProps(props) {\n      if ('uniforms' in props) {\n        this.setUniforms(props.uniforms);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(_ref) {\n      var _this2 = this;\n\n      var logPriority = _ref.logPriority,\n          _ref$drawMode = _ref.drawMode,\n          drawMode = _ref$drawMode === void 0 ? 4 : _ref$drawMode,\n          vertexCount = _ref.vertexCount,\n          _ref$offset = _ref.offset,\n          offset = _ref$offset === void 0 ? 0 : _ref$offset,\n          start = _ref.start,\n          end = _ref.end,\n          _ref$isIndexed = _ref.isIndexed,\n          isIndexed = _ref$isIndexed === void 0 ? false : _ref$isIndexed,\n          _ref$indexType = _ref.indexType,\n          indexType = _ref$indexType === void 0 ? 5123 : _ref$indexType,\n          _ref$instanceCount = _ref.instanceCount,\n          instanceCount = _ref$instanceCount === void 0 ? 0 : _ref$instanceCount,\n          _ref$isInstanced = _ref.isInstanced,\n          isInstanced = _ref$isInstanced === void 0 ? instanceCount > 0 : _ref$isInstanced,\n          _ref$vertexArray = _ref.vertexArray,\n          vertexArray = _ref$vertexArray === void 0 ? null : _ref$vertexArray,\n          transformFeedback = _ref.transformFeedback,\n          framebuffer = _ref.framebuffer,\n          _ref$parameters = _ref.parameters,\n          parameters = _ref$parameters === void 0 ? {} : _ref$parameters,\n          uniforms = _ref.uniforms,\n          samplers = _ref.samplers;\n\n      if (uniforms || samplers) {\n        log.deprecated('Program.draw({uniforms})', 'Program.setUniforms(uniforms)')();\n        this.setUniforms(uniforms || {});\n      }\n\n      if (log.priority >= logPriority) {\n        var fb = framebuffer ? framebuffer.id : 'default';\n        var message = \"mode=\".concat(getKey(this.gl, drawMode), \" verts=\").concat(vertexCount, \" \") + \"instances=\".concat(instanceCount, \" indexType=\").concat(getKey(this.gl, indexType), \" \") + \"isInstanced=\".concat(isInstanced, \" isIndexed=\").concat(isIndexed, \" \") + \"Framebuffer=\".concat(fb);\n        log.log(logPriority, message)();\n      }\n\n      assert(vertexArray);\n      this.gl.useProgram(this.handle);\n\n      if (!this._areTexturesRenderable() || vertexCount === 0 || isInstanced && instanceCount === 0) {\n        return false;\n      }\n\n      vertexArray.bindForDraw(vertexCount, instanceCount, function () {\n        if (framebuffer !== undefined) {\n          parameters = Object.assign({}, parameters, {\n            framebuffer: framebuffer\n          });\n        }\n\n        if (transformFeedback) {\n          var primitiveMode = getPrimitiveDrawMode(drawMode);\n          transformFeedback.begin(primitiveMode);\n        }\n\n        _this2._bindTextures();\n\n        withParameters(_this2.gl, parameters, function () {\n          if (isIndexed && isInstanced) {\n            _this2.gl.drawElementsInstanced(drawMode, vertexCount, indexType, offset, instanceCount);\n          } else if (isIndexed && isWebGL2(_this2.gl) && !isNaN(start) && !isNaN(end)) {\n            _this2.gl.drawRangeElements(drawMode, start, end, vertexCount, indexType, offset);\n          } else if (isIndexed) {\n            _this2.gl.drawElements(drawMode, vertexCount, indexType, offset);\n          } else if (isInstanced) {\n            _this2.gl.drawArraysInstanced(drawMode, offset, vertexCount, instanceCount);\n          } else {\n            _this2.gl.drawArrays(drawMode, offset, vertexCount);\n          }\n        });\n\n        if (transformFeedback) {\n          transformFeedback.end();\n        }\n      });\n      return true;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms() {\n      var uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (log.priority >= 2) {\n        checkUniformValues(uniforms, this.id, this._uniformSetters);\n      }\n\n      this.gl.useProgram(this.handle);\n\n      for (var uniformName in uniforms) {\n        var uniform = uniforms[uniformName];\n        var uniformSetter = this._uniformSetters[uniformName];\n\n        if (uniformSetter) {\n          var value = uniform;\n          var textureUpdate = false;\n\n          if (value instanceof Framebuffer) {\n            value = value.texture;\n          }\n\n          if (value instanceof Texture) {\n            textureUpdate = this.uniforms[uniformName] !== uniform;\n\n            if (textureUpdate) {\n              if (uniformSetter.textureIndex === undefined) {\n                uniformSetter.textureIndex = this._textureIndexCounter++;\n              }\n\n              var texture = value;\n              var textureIndex = uniformSetter.textureIndex;\n              texture.bind(textureIndex);\n              value = textureIndex;\n\n              if (!texture.loaded) {\n                this._texturesRenderable = false;\n              }\n\n              this._textureUniforms[uniformName] = texture;\n            } else {\n              value = uniformSetter.textureIndex;\n            }\n          } else if (this._textureUniforms[uniformName]) {\n            delete this._textureUniforms[uniformName];\n          }\n\n          if (uniformSetter(value) || textureUpdate) {\n            copyUniform(this.uniforms, uniformName, uniform);\n          }\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"_areTexturesRenderable\",\n    value: function _areTexturesRenderable() {\n      if (this._texturesRenderable) {\n        return true;\n      }\n\n      this._texturesRenderable = true;\n\n      for (var uniformName in this._textureUniforms) {\n        var texture = this._textureUniforms[uniformName];\n        this._texturesRenderable = this._texturesRenderable && texture.loaded;\n      }\n\n      return this._texturesRenderable;\n    }\n  }, {\n    key: \"_bindTextures\",\n    value: function _bindTextures() {\n      for (var uniformName in this._textureUniforms) {\n        var textureIndex = this._uniformSetters[uniformName].textureIndex;\n\n        this._textureUniforms[uniformName].bind(textureIndex);\n      }\n    }\n  }, {\n    key: \"_createHandle\",\n    value: function _createHandle() {\n      return this.gl.createProgram();\n    }\n  }, {\n    key: \"_deleteHandle\",\n    value: function _deleteHandle() {\n      this.gl.deleteProgram(this.handle);\n    }\n  }, {\n    key: \"_getOptionsFromHandle\",\n    value: function _getOptionsFromHandle(handle) {\n      var shaderHandles = this.gl.getAttachedShaders(handle);\n      var opts = {};\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = shaderHandles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var shaderHandle = _step.value;\n          var type = this.gl.getShaderParameter(this.handle, 35663);\n\n          switch (type) {\n            case 35633:\n              opts.vs = new VertexShader({\n                handle: shaderHandle\n              });\n              break;\n\n            case 35632:\n              opts.fs = new FragmentShader({\n                handle: shaderHandle\n              });\n              break;\n\n            default:\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n            _iterator[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return opts;\n    }\n  }, {\n    key: \"_getParameter\",\n    value: function _getParameter(pname) {\n      return this.gl.getProgramParameter(this.handle, pname);\n    }\n  }, {\n    key: \"_setId\",\n    value: function _setId(id) {\n      if (!id) {\n        var programName = this._getName();\n\n        this.id = uid(programName);\n      }\n    }\n  }, {\n    key: \"_getName\",\n    value: function _getName() {\n      var programName = this.vs.getName() || this.fs.getName();\n      programName = programName.replace(/shader/i, '');\n      programName = programName ? \"\".concat(programName, \"-program\") : 'program';\n      return programName;\n    }\n  }, {\n    key: \"_compileAndLink\",\n    value: function _compileAndLink() {\n      var gl = this.gl;\n      gl.attachShader(this.handle, this.vs.handle);\n      gl.attachShader(this.handle, this.fs.handle);\n      log.time(LOG_PROGRAM_PERF_PRIORITY, \"linkProgram for \".concat(this._getName()))();\n      gl.linkProgram(this.handle);\n      log.timeEnd(LOG_PROGRAM_PERF_PRIORITY, \"linkProgram for \".concat(this._getName()))();\n\n      if (gl.debug || log.level > 0) {\n        gl.validateProgram(this.handle);\n        var linked = gl.getProgramParameter(this.handle, 35714);\n\n        if (!linked) {\n          throw new Error(\"Error linking: \".concat(gl.getProgramInfoLog(this.handle)));\n        }\n      }\n    }\n  }, {\n    key: \"_readUniformLocationsFromLinkedProgram\",\n    value: function _readUniformLocationsFromLinkedProgram() {\n      var gl = this.gl;\n      this._uniformSetters = {};\n      this._uniformCount = this._getParameter(35718);\n\n      for (var i = 0; i < this._uniformCount; i++) {\n        var info = this.gl.getActiveUniform(this.handle, i);\n\n        var _parseUniformName = parseUniformName(info.name),\n            name = _parseUniformName.name,\n            isArray = _parseUniformName.isArray;\n\n        var location = gl.getUniformLocation(this.handle, name);\n        this._uniformSetters[name] = getUniformSetter(gl, location, info, isArray);\n\n        if (info.size > 1) {\n          for (var l = 0; l < info.size; l++) {\n            location = gl.getUniformLocation(this.handle, \"\".concat(name, \"[\").concat(l, \"]\"));\n            this._uniformSetters[\"\".concat(name, \"[\").concat(l, \"]\")] = getUniformSetter(gl, location, info, isArray);\n          }\n        }\n      }\n\n      this._textureIndexCounter = 0;\n    }\n  }, {\n    key: \"getActiveUniforms\",\n    value: function getActiveUniforms(uniformIndices, pname) {\n      return this.gl.getActiveUniforms(this.handle, uniformIndices, pname);\n    }\n  }, {\n    key: \"getUniformBlockIndex\",\n    value: function getUniformBlockIndex(blockName) {\n      return this.gl.getUniformBlockIndex(this.handle, blockName);\n    }\n  }, {\n    key: \"getActiveUniformBlockParameter\",\n    value: function getActiveUniformBlockParameter(blockIndex, pname) {\n      return this.gl.getActiveUniformBlockParameter(this.handle, blockIndex, pname);\n    }\n  }, {\n    key: \"uniformBlockBinding\",\n    value: function uniformBlockBinding(blockIndex, blockBinding) {\n      this.gl.uniformBlockBinding(this.handle, blockIndex, blockBinding);\n    }\n  }]);\n\n  return Program;\n}(Resource);\n\nexport { Program as default };","map":{"version":3,"sources":["../../../src/classes/program.js"],"names":["LOG_PROGRAM_PERF_PRIORITY","GL_SEPARATE_ATTRIBS","V6_DEPRECATED_METHODS","Program","Resource","props","Object","hash","vs","fs","varyings","bufferMode","id","source","assert","assertWebGL2Context","options","logPriority","drawMode","vertexCount","offset","start","end","isIndexed","indexType","instanceCount","isInstanced","vertexArray","transformFeedback","framebuffer","parameters","uniforms","samplers","log","fb","message","getKey","primitiveMode","getPrimitiveDrawMode","withParameters","isWebGL2","isNaN","checkUniformValues","uniform","uniformSetter","value","textureUpdate","texture","textureIndex","copyUniform","handle","shaderHandles","opts","shaderHandle","type","pname","programName","uid","gl","linked","i","info","name","isArray","parseUniformName","location","getUniformSetter","l","uniformIndices","blockName","blockIndex","blockBinding"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\n\nimport Resource from './resource';\nimport Texture from './texture';\nimport Framebuffer from './framebuffer';\nimport {parseUniformName, getUniformSetter} from './uniforms';\nimport {VertexShader, FragmentShader} from './shader';\nimport ProgramConfiguration from './program-configuration';\nimport {copyUniform, checkUniformValues} from './uniforms';\n\nimport {isWebGL2, withParameters, log} from '@luma.gl/gltools';\nimport {assertWebGL2Context, getKey} from '../webgl-utils';\nimport {getPrimitiveDrawMode} from '../webgl-utils/attribute-utils';\nimport {uid, assert} from '../utils';\n\nconst LOG_PROGRAM_PERF_PRIORITY = 4;\n\nconst GL_SEPARATE_ATTRIBS = 0x8c8d;\n\nconst V6_DEPRECATED_METHODS = [\n  'setVertexArray',\n  'setAttributes',\n  'setBuffers',\n  'unsetBuffers',\n\n  'use',\n  'getUniformCount',\n  'getUniformInfo',\n  'getUniformLocation',\n  'getUniformValue',\n\n  'getVarying',\n  'getFragDataLocation',\n  'getAttachedShaders',\n  'getAttributeCount',\n  'getAttributeLocation',\n  'getAttributeInfo'\n];\n\nexport default class Program extends Resource {\n  constructor(gl, props = {}) {\n    super(gl, props);\n\n    this.stubRemovedMethods('Program', 'v6.0', V6_DEPRECATED_METHODS);\n\n    // Experimental flag to avoid deleting Program object while it is cached\n    this._isCached = false;\n\n    this.initialize(props);\n\n    Object.seal(this);\n\n    this._setId(props.id);\n  }\n\n  initialize(props = {}) {\n    const {hash, vs, fs, varyings, bufferMode = GL_SEPARATE_ATTRIBS} = props;\n\n    this.hash = hash || ''; // Used by ProgramManager\n\n    // Create shaders if needed\n    this.vs =\n      typeof vs === 'string' ? new VertexShader(this.gl, {id: `${props.id}-vs`, source: vs}) : vs;\n    this.fs =\n      typeof fs === 'string' ? new FragmentShader(this.gl, {id: `${props.id}-fs`, source: fs}) : fs;\n    assert(this.vs instanceof VertexShader);\n    assert(this.fs instanceof FragmentShader);\n\n    // uniforms\n    this.uniforms = {};\n\n    this._textureUniforms = {};\n    this._texturesRenderable = true;\n\n    // Setup varyings if supplied\n    if (varyings && varyings.length > 0) {\n      assertWebGL2Context(this.gl);\n      this.varyings = varyings;\n      this.gl.transformFeedbackVaryings(this.handle, varyings, bufferMode);\n    }\n\n    this._compileAndLink();\n    this._readUniformLocationsFromLinkedProgram();\n    this.configuration = new ProgramConfiguration(this);\n\n    return this.setProps(props);\n  }\n\n  delete(options = {}) {\n    if (this._isCached) {\n      // This object is cached, do not delete\n      return this;\n    }\n    return super.delete(options);\n  }\n\n  setProps(props) {\n    if ('uniforms' in props) {\n      this.setUniforms(props.uniforms);\n    }\n    return this;\n  }\n\n  // A good thing about the WebGL API is that there are so many ways to draw things ;)\n  // This function unifies those ways into a single call using common parameters with sane defaults\n  draw({\n    logPriority, // Probe log priority, enables Model to do more integrated logging\n\n    drawMode = GL.TRIANGLES,\n    vertexCount,\n    offset = 0,\n    start,\n    end,\n    isIndexed = false,\n    indexType = GL.UNSIGNED_SHORT,\n    instanceCount = 0,\n    isInstanced = instanceCount > 0,\n\n    vertexArray = null,\n    transformFeedback,\n    framebuffer,\n    parameters = {},\n\n    // Deprecated\n    uniforms,\n    samplers\n  }) {\n    if (uniforms || samplers) {\n      // DEPRECATED: v7.0 (deprecated earlier but warning not properly implemented)\n      log.deprecated('Program.draw({uniforms})', 'Program.setUniforms(uniforms)')();\n      this.setUniforms(uniforms || {});\n    }\n\n    if (log.priority >= logPriority) {\n      const fb = framebuffer ? framebuffer.id : 'default';\n      const message =\n        `mode=${getKey(this.gl, drawMode)} verts=${vertexCount} ` +\n        `instances=${instanceCount} indexType=${getKey(this.gl, indexType)} ` +\n        `isInstanced=${isInstanced} isIndexed=${isIndexed} ` +\n        `Framebuffer=${fb}`;\n      log.log(logPriority, message)();\n    }\n\n    // TODO - move vertex array binding and transform feedback binding to withParameters?\n    assert(vertexArray);\n\n    this.gl.useProgram(this.handle);\n\n    if (\n      // Note: async textures set as uniforms might still be loading.\n      // Now that all uniforms have been updated, check if any texture\n      // in the uniforms is not yet initialized, then we don't draw\n      !this._areTexturesRenderable() ||\n      // Avoid WebGL draw call when not rendering any data\n      vertexCount === 0 ||\n      (isInstanced && instanceCount === 0)\n    ) {\n      return false;\n    }\n\n    vertexArray.bindForDraw(vertexCount, instanceCount, () => {\n      if (framebuffer !== undefined) {\n        parameters = Object.assign({}, parameters, {framebuffer});\n      }\n\n      if (transformFeedback) {\n        const primitiveMode = getPrimitiveDrawMode(drawMode);\n        transformFeedback.begin(primitiveMode);\n      }\n\n      this._bindTextures();\n\n      withParameters(this.gl, parameters, () => {\n        // TODO - Use polyfilled WebGL2RenderingContext instead of ANGLE extension\n        if (isIndexed && isInstanced) {\n          this.gl.drawElementsInstanced(drawMode, vertexCount, indexType, offset, instanceCount);\n        } else if (isIndexed && isWebGL2(this.gl) && !isNaN(start) && !isNaN(end)) {\n          this.gl.drawRangeElements(drawMode, start, end, vertexCount, indexType, offset);\n        } else if (isIndexed) {\n          this.gl.drawElements(drawMode, vertexCount, indexType, offset);\n        } else if (isInstanced) {\n          this.gl.drawArraysInstanced(drawMode, offset, vertexCount, instanceCount);\n        } else {\n          this.gl.drawArrays(drawMode, offset, vertexCount);\n        }\n      });\n\n      if (transformFeedback) {\n        transformFeedback.end();\n      }\n    });\n\n    return true;\n  }\n\n  setUniforms(uniforms = {}) {\n    if (log.priority >= 2) {\n      checkUniformValues(uniforms, this.id, this._uniformSetters);\n    }\n\n    this.gl.useProgram(this.handle);\n\n    for (const uniformName in uniforms) {\n      const uniform = uniforms[uniformName];\n      const uniformSetter = this._uniformSetters[uniformName];\n\n      if (uniformSetter) {\n        let value = uniform;\n        let textureUpdate = false;\n\n        if (value instanceof Framebuffer) {\n          value = value.texture;\n        }\n        if (value instanceof Texture) {\n          textureUpdate = this.uniforms[uniformName] !== uniform;\n\n          if (textureUpdate) {\n            // eslint-disable-next-line max-depth\n            if (uniformSetter.textureIndex === undefined) {\n              uniformSetter.textureIndex = this._textureIndexCounter++;\n            }\n\n            // Bind texture to index\n            const texture = value;\n            const {textureIndex} = uniformSetter;\n\n            texture.bind(textureIndex);\n            value = textureIndex;\n\n            if (!texture.loaded) {\n              this._texturesRenderable = false;\n            }\n\n            this._textureUniforms[uniformName] = texture;\n          } else {\n            value = uniformSetter.textureIndex;\n          }\n        } else if (this._textureUniforms[uniformName]) {\n          delete this._textureUniforms[uniformName];\n        }\n\n        // NOTE(Tarek): uniformSetter returns whether\n        //   value had to be updated or not.\n        if (uniformSetter(value) || textureUpdate) {\n          copyUniform(this.uniforms, uniformName, uniform);\n        }\n      }\n    }\n\n    return this;\n  }\n\n  // PRIVATE METHODS\n\n  // Checks if all texture-values uniforms are renderable (i.e. loaded)\n  // Note: This is currently done before every draw call\n  _areTexturesRenderable() {\n    if (this._texturesRenderable) {\n      return true;\n    }\n\n    this._texturesRenderable = true;\n\n    for (const uniformName in this._textureUniforms) {\n      const texture = this._textureUniforms[uniformName];\n      this._texturesRenderable = this._texturesRenderable && texture.loaded;\n    }\n\n    return this._texturesRenderable;\n  }\n\n  // Binds textures\n  // Note: This is currently done before every draw call\n  _bindTextures() {\n    for (const uniformName in this._textureUniforms) {\n      const textureIndex = this._uniformSetters[uniformName].textureIndex;\n      this._textureUniforms[uniformName].bind(textureIndex);\n    }\n  }\n\n  // RESOURCE METHODS\n\n  _createHandle() {\n    return this.gl.createProgram();\n  }\n\n  _deleteHandle() {\n    this.gl.deleteProgram(this.handle);\n  }\n\n  // Extract opts needed to initialize a `Program` from an independently created WebGLProgram handle\n  _getOptionsFromHandle(handle) {\n    const shaderHandles = this.gl.getAttachedShaders(handle);\n    const opts = {};\n    for (const shaderHandle of shaderHandles) {\n      const type = this.gl.getShaderParameter(this.handle, GL.SHADER_TYPE);\n      switch (type) {\n        case GL.VERTEX_SHADER:\n          opts.vs = new VertexShader({handle: shaderHandle});\n          break;\n        case GL.FRAGMENT_SHADER:\n          opts.fs = new FragmentShader({handle: shaderHandle});\n          break;\n        default:\n      }\n    }\n    return opts;\n  }\n\n  _getParameter(pname) {\n    return this.gl.getProgramParameter(this.handle, pname);\n  }\n\n  // If program is not named, name it after shader names\n  // TODO - this.id will already have been initialized\n  _setId(id) {\n    if (!id) {\n      const programName = this._getName();\n      this.id = uid(programName);\n    }\n  }\n\n  // Generate a default name for the program based on names of the shaders\n  _getName() {\n    let programName = this.vs.getName() || this.fs.getName();\n    programName = programName.replace(/shader/i, '');\n    programName = programName ? `${programName}-program` : 'program';\n    return programName;\n  }\n\n  _compileAndLink() {\n    const {gl} = this;\n    gl.attachShader(this.handle, this.vs.handle);\n    gl.attachShader(this.handle, this.fs.handle);\n    log.time(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this._getName()}`)();\n    gl.linkProgram(this.handle);\n    log.timeEnd(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this._getName()}`)();\n\n    // Avoid checking program linking error in production\n    if (gl.debug || log.level > 0) {\n      gl.validateProgram(this.handle);\n      const linked = gl.getProgramParameter(this.handle, gl.LINK_STATUS);\n      if (!linked) {\n        throw new Error(`Error linking: ${gl.getProgramInfoLog(this.handle)}`);\n      }\n    }\n  }\n\n  // query uniform locations and build name to setter map.\n  // TODO - This overlaps with ProgramConfiguration?\n  _readUniformLocationsFromLinkedProgram() {\n    const {gl} = this;\n    this._uniformSetters = {};\n    this._uniformCount = this._getParameter(GL.ACTIVE_UNIFORMS);\n    for (let i = 0; i < this._uniformCount; i++) {\n      const info = this.gl.getActiveUniform(this.handle, i);\n      const {name, isArray} = parseUniformName(info.name);\n      let location = gl.getUniformLocation(this.handle, name);\n      this._uniformSetters[name] = getUniformSetter(gl, location, info, isArray);\n      if (info.size > 1) {\n        for (let l = 0; l < info.size; l++) {\n          location = gl.getUniformLocation(this.handle, `${name}[${l}]`);\n          this._uniformSetters[`${name}[${l}]`] = getUniformSetter(gl, location, info, isArray);\n        }\n      }\n    }\n    this._textureIndexCounter = 0;\n  }\n\n  // TO BE REMOVED in v7?\n\n  // Rretrieves information about active uniforms identifed by their indices (`uniformIndices`)\n  // https://\n  // developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/getActiveUniforms\n  getActiveUniforms(uniformIndices, pname) {\n    return this.gl.getActiveUniforms(this.handle, uniformIndices, pname);\n  }\n\n  // Retrieves the index of a uniform block\n  getUniformBlockIndex(blockName) {\n    return this.gl.getUniformBlockIndex(this.handle, blockName);\n  }\n\n  // Retrieves information about an active uniform block (`blockIndex`)\n  // https://\n  // developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/getActiveUniformBlockParameter\n  getActiveUniformBlockParameter(blockIndex, pname) {\n    return this.gl.getActiveUniformBlockParameter(this.handle, blockIndex, pname);\n  }\n\n  // Binds a uniform block (`blockIndex`) to a specific binding point (`blockBinding`)\n  uniformBlockBinding(blockIndex, blockBinding) {\n    this.gl.uniformBlockBinding(this.handle, blockIndex, blockBinding);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}