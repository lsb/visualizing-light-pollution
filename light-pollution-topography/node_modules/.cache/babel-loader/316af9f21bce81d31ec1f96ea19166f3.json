{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { assert } from '../utils';\nvar FS100 = \"void main() {gl_FragColor = vec4(0);}\";\nvar FS_GLES = \"out vec4 transform_output;\\nvoid main() {\\n  transform_output = vec4(0);\\n}\";\nvar FS300 = \"#version 300 es\\n\".concat(FS_GLES);\nexport function getQualifierDetails(line, qualifiers) {\n  qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];\n  var words = line.replace(/^\\s+/, '').split(/\\s+/);\n\n  var _words = _slicedToArray(words, 3),\n      qualifier = _words[0],\n      type = _words[1],\n      definition = _words[2];\n\n  if (!qualifiers.includes(qualifier) || !type || !definition) {\n    return null;\n  }\n\n  var name = definition.split(';')[0];\n  return {\n    qualifier: qualifier,\n    type: type,\n    name: name\n  };\n}\nexport function getPassthroughFS() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$version = _ref.version,\n      version = _ref$version === void 0 ? 100 : _ref$version,\n      input = _ref.input,\n      inputType = _ref.inputType,\n      output = _ref.output;\n\n  if (!input) {\n    if (version === 300) {\n      return FS300;\n    } else if (version > 300) {\n      return \"#version \".concat(version, \"\\n\").concat(FS_GLES);\n    }\n\n    return FS100;\n  }\n\n  var outputValue = convertToVec4(input, inputType);\n\n  if (version >= 300) {\n    return \"#version \".concat(version, \" \").concat(version === 300 ? 'es' : '', \"\\nin \").concat(inputType, \" \").concat(input, \";\\nout vec4 \").concat(output, \";\\nvoid main() {\\n  \").concat(output, \" = \").concat(outputValue, \";\\n}\");\n  }\n\n  return \"varying \".concat(inputType, \" \").concat(input, \";\\nvoid main() {\\n  gl_FragColor = \").concat(outputValue, \";\\n}\");\n}\nexport function typeToChannelSuffix(type) {\n  switch (type) {\n    case 'float':\n      return 'x';\n\n    case 'vec2':\n      return 'xy';\n\n    case 'vec3':\n      return 'xyz';\n\n    case 'vec4':\n      return 'xyzw';\n\n    default:\n      assert(false);\n      return null;\n  }\n}\nexport function typeToChannelCount(type) {\n  switch (type) {\n    case 'float':\n      return 1;\n\n    case 'vec2':\n      return 2;\n\n    case 'vec3':\n      return 3;\n\n    case 'vec4':\n      return 4;\n\n    default:\n      assert(false);\n      return null;\n  }\n}\nexport function convertToVec4(variable, type) {\n  switch (type) {\n    case 'float':\n      return \"vec4(\".concat(variable, \", 0.0, 0.0, 1.0)\");\n\n    case 'vec2':\n      return \"vec4(\".concat(variable, \", 0.0, 1.0)\");\n\n    case 'vec3':\n      return \"vec4(\".concat(variable, \", 1.0)\");\n\n    case 'vec4':\n      return variable;\n\n    default:\n      assert(false);\n      return null;\n  }\n}","map":{"version":3,"sources":["../../../src/utils/shader-utils.js"],"names":["FS100","FS_GLES","FS300","qualifiers","Array","words","line","qualifier","type","definition","name","version","input","inputType","output","outputValue","convertToVec4","assert"],"mappings":"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","sourcesContent":["import {assert} from '../utils';\nconst FS100 = `void main() {gl_FragColor = vec4(0);}`;\nconst FS_GLES = `\\\nout vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}`;\nconst FS300 = `#version 300 es\\n${FS_GLES}`;\n\n// Prase given glsl line and return qualifier details or null\nexport function getQualifierDetails(line, qualifiers) {\n  qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];\n  const words = line.replace(/^\\s+/, '').split(/\\s+/);\n  // TODO add support for precession qualifiers (highp, mediump and lowp)\n  const [qualifier, type, definition] = words;\n  if (!qualifiers.includes(qualifier) || !type || !definition) {\n    return null;\n  }\n  const name = definition.split(';')[0];\n  return {qualifier, type, name};\n}\n\n// Given the shader version, input and output variable names,\n// builds and return a pass through fragment shader.\nexport function getPassthroughFS({version = 100, input, inputType, output} = {}) {\n  if (!input) {\n    if (version === 300) {\n      // Fast-path for WebGL 2.0\n      return FS300;\n    } else if (version > 300) {\n      // Use the supplied version for OpenGL/ES 3.2+\n      return `#version ${version}\\n${FS_GLES}`;\n    }\n    // Fast-path for WebGL 1.0\n    return FS100;\n  }\n  const outputValue = convertToVec4(input, inputType);\n  if (version >= 300) {\n    // If version is 300, assume WebGL 2.0\n    return `\\\n#version ${version} ${version === 300 ? 'es' : ''}\nin ${inputType} ${input};\nout vec4 ${output};\nvoid main() {\n  ${output} = ${outputValue};\n}`;\n  }\n  // WebGL 1.0\n  return `\\\nvarying ${inputType} ${input};\nvoid main() {\n  gl_FragColor = ${outputValue};\n}`;\n}\n\n// convert glsl type to suffix\nexport function typeToChannelSuffix(type) {\n  switch (type) {\n    case 'float':\n      return 'x';\n    case 'vec2':\n      return 'xy';\n    case 'vec3':\n      return 'xyz';\n    case 'vec4':\n      return 'xyzw';\n    default:\n      assert(false);\n      return null;\n  }\n}\n\n// convert glsl type to channel count\nexport function typeToChannelCount(type) {\n  switch (type) {\n    case 'float':\n      return 1;\n    case 'vec2':\n      return 2;\n    case 'vec3':\n      return 3;\n    case 'vec4':\n      return 4;\n    default:\n      assert(false);\n      return null;\n  }\n}\n\n// Returns glsl instruction for converting to vec4\nexport function convertToVec4(variable, type) {\n  switch (type) {\n    case 'float':\n      return `vec4(${variable}, 0.0, 0.0, 1.0)`;\n    case 'vec2':\n      return `vec4(${variable}, 0.0, 1.0)`;\n    case 'vec3':\n      return `vec4(${variable}, 1.0)`;\n    case 'vec4':\n      return variable;\n    default:\n      assert(false);\n      return null;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}