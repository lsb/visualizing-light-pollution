{"ast":null,"code":"import _createForOfIteratorHelper from \"/home/lsb/wikidatageo/dark-sky-vacations/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _getPrototypeOf from \"/home/lsb/wikidatageo/dark-sky-vacations/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"/home/lsb/wikidatageo/dark-sky-vacations/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _regeneratorRuntime from \"/home/lsb/wikidatageo/dark-sky-vacations/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/lsb/wikidatageo/dark-sky-vacations/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _defineProperty from \"/home/lsb/wikidatageo/dark-sky-vacations/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"/home/lsb/wikidatageo/dark-sky-vacations/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/lsb/wikidatageo/dark-sky-vacations/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _createSuper from \"/home/lsb/wikidatageo/dark-sky-vacations/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _inherits from \"/home/lsb/wikidatageo/dark-sky-vacations/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _wrapAsyncGenerator from \"/home/lsb/wikidatageo/dark-sky-vacations/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator\";\nimport _awaitAsyncGenerator from \"/home/lsb/wikidatageo/dark-sky-vacations/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator\";\nimport _asyncIterator from \"/home/lsb/wikidatageo/dark-sky-vacations/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncIterator\";\nimport _asyncGeneratorDelegate from \"/home/lsb/wikidatageo/dark-sky-vacations/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncGeneratorDelegate\";\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(readAllSync);\n\n// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { Vector } from '../vector';\nimport { MessageHeader } from '../enum';\nimport { Footer } from './metadata/file';\nimport streamAdapters from '../io/adapters';\nimport { ByteStream, AsyncByteStream } from '../io/stream';\nimport { RandomAccessFile, AsyncRandomAccessFile } from '../io/file';\nimport { VectorLoader, JSONVectorLoader } from '../visitor/vectorloader';\nimport { RecordBatch, _InternalEmptyPlaceholderRecordBatch } from '../recordbatch';\nimport { ITERATOR_DONE, ReadableInterop } from '../io/interfaces';\nimport { MessageReader, AsyncMessageReader, JSONMessageReader, checkForMagicArrowString, magicLength, magicAndPadding, magicX2AndPadding } from './message';\nimport { isPromise, isIterable, isAsyncIterable, isIteratorResult, isArrowJSON, isFileHandle, isFetchResponse, isReadableDOMStream, isReadableNodeStream } from '../util/compat';\nexport var RecordBatchReader = /*#__PURE__*/function (_ReadableInterop) {\n  _inherits(RecordBatchReader, _ReadableInterop);\n\n  var _super = _createSuper(RecordBatchReader);\n\n  function RecordBatchReader(impl) {\n    var _this2;\n\n    _classCallCheck(this, RecordBatchReader);\n\n    _this2 = _super.call(this);\n    _this2._impl = impl;\n    return _this2;\n  }\n\n  _createClass(RecordBatchReader, [{\n    key: \"isSync\",\n    value: function isSync() {\n      return this._impl.isSync();\n    }\n  }, {\n    key: \"isAsync\",\n    value: function isAsync() {\n      return this._impl.isAsync();\n    }\n  }, {\n    key: \"isFile\",\n    value: function isFile() {\n      return this._impl.isFile();\n    }\n  }, {\n    key: \"isStream\",\n    value: function isStream() {\n      return this._impl.isStream();\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      return this._impl.next();\n    }\n  }, {\n    key: \"throw\",\n    value: function _throw(value) {\n      return this._impl.throw(value);\n    }\n  }, {\n    key: \"return\",\n    value: function _return(value) {\n      return this._impl.return(value);\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      return this._impl.cancel();\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(schema) {\n      this._impl.reset(schema);\n\n      this._DOMStream = undefined;\n      this._nodeStream = undefined;\n      return this;\n    }\n  }, {\n    key: \"open\",\n    value: function open(options) {\n      var _this3 = this;\n\n      var opening = this._impl.open(options);\n\n      return isPromise(opening) ? opening.then(function () {\n        return _this3;\n      }) : this;\n    }\n  }, {\n    key: \"readRecordBatch\",\n    value: function readRecordBatch(index) {\n      return this._impl.isFile() ? this._impl.readRecordBatch(index) : null;\n    }\n  }, {\n    key: Symbol.iterator,\n    value: function value() {\n      return this._impl[Symbol.iterator]();\n    }\n  }, {\n    key: Symbol.asyncIterator,\n    value: function value() {\n      return this._impl[Symbol.asyncIterator]();\n    }\n  }, {\n    key: \"toDOMStream\",\n    value: function toDOMStream() {\n      var _this4 = this;\n\n      return streamAdapters.toDOMStream(this.isSync() ? _defineProperty({}, Symbol.iterator, function () {\n        return _this4;\n      }) : _defineProperty({}, Symbol.asyncIterator, function () {\n        return _this4;\n      }));\n    }\n  }, {\n    key: \"toNodeStream\",\n    value: function toNodeStream() {\n      var _this5 = this;\n\n      return streamAdapters.toNodeStream(this.isSync() ? _defineProperty({}, Symbol.iterator, function () {\n        return _this5;\n      }) : _defineProperty({}, Symbol.asyncIterator, function () {\n        return _this5;\n      }), {\n        objectMode: true\n      });\n    }\n    /** @nocollapse */\n    // @ts-ignore\n\n  }, {\n    key: \"closed\",\n    get: function get() {\n      return this._impl.closed;\n    }\n  }, {\n    key: \"schema\",\n    get: function get() {\n      return this._impl.schema;\n    }\n  }, {\n    key: \"autoDestroy\",\n    get: function get() {\n      return this._impl.autoDestroy;\n    }\n  }, {\n    key: \"dictionaries\",\n    get: function get() {\n      return this._impl.dictionaries;\n    }\n  }, {\n    key: \"numDictionaries\",\n    get: function get() {\n      return this._impl.numDictionaries;\n    }\n  }, {\n    key: \"numRecordBatches\",\n    get: function get() {\n      return this._impl.numRecordBatches;\n    }\n  }, {\n    key: \"footer\",\n    get: function get() {\n      return this._impl.isFile() ? this._impl.footer : null;\n    }\n  }], [{\n    key: \"throughNode\",\n    value: function throughNode(options) {\n      throw new Error(\"\\\"throughNode\\\" not available in this environment\");\n    }\n    /** @nocollapse */\n\n  }, {\n    key: \"throughDOM\",\n    value: function throughDOM( // @ts-ignore\n    writableStrategy, // @ts-ignore\n    readableStrategy) {\n      throw new Error(\"\\\"throughDOM\\\" not available in this environment\");\n    }\n    /** @nocollapse */\n\n  }, {\n    key: \"from\",\n    value: function from(source) {\n      if (source instanceof RecordBatchReader) {\n        return source;\n      } else if (isArrowJSON(source)) {\n        return fromArrowJSON(source);\n      } else if (isFileHandle(source)) {\n        return fromFileHandle(source);\n      } else if (isPromise(source)) {\n        return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.t0 = RecordBatchReader;\n                  _context.next = 3;\n                  return source;\n\n                case 3:\n                  _context.t1 = _context.sent;\n                  _context.next = 6;\n                  return _context.t0.from.call(_context.t0, _context.t1);\n\n                case 6:\n                  return _context.abrupt(\"return\", _context.sent);\n\n                case 7:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee);\n        }))();\n      } else if (isFetchResponse(source) || isReadableDOMStream(source) || isReadableNodeStream(source) || isAsyncIterable(source)) {\n        return fromAsyncByteStream(new AsyncByteStream(source));\n      }\n\n      return fromByteStream(new ByteStream(source));\n    }\n    /** @nocollapse */\n\n  }, {\n    key: \"readAll\",\n    value: function readAll(source) {\n      if (source instanceof RecordBatchReader) {\n        return source.isSync() ? readAllSync(source) : readAllAsync(source);\n      } else if (isArrowJSON(source) || ArrayBuffer.isView(source) || isIterable(source) || isIteratorResult(source)) {\n        return readAllSync(source);\n      }\n\n      return readAllAsync(source);\n    }\n  }]);\n\n  return RecordBatchReader;\n}(ReadableInterop); //\n// Since TS is a structural type system, we define the following subclass stubs\n// so that concrete types exist to associate with with the interfaces below.\n//\n// The implementation for each RecordBatchReader is hidden away in the set of\n// `RecordBatchReaderImpl` classes in the second half of this file. This allows\n// us to export a single RecordBatchReader class, and swap out the impl based\n// on the io primitives or underlying arrow (JSON, file, or stream) at runtime.\n//\n// Async/await makes our job a bit harder, since it forces everything to be\n// either fully sync or fully async. This is why the logic for the reader impls\n// has been duplicated into both sync and async variants. Since the RBR\n// delegates to its impl, an RBR with an AsyncRecordBatchFileReaderImpl for\n// example will return async/await-friendly Promises, but one with a (sync)\n// RecordBatchStreamReaderImpl will always return values. Nothing should be\n// different about their logic, aside from the async handling. This is also why\n// this code looks highly structured, as it should be nearly identical and easy\n// to follow.\n//\n\n/** @ignore */\n\nexport var RecordBatchStreamReader = /*#__PURE__*/function (_RecordBatchReader) {\n  _inherits(RecordBatchStreamReader, _RecordBatchReader);\n\n  var _super2 = _createSuper(RecordBatchStreamReader);\n\n  function RecordBatchStreamReader(_impl) {\n    var _this6;\n\n    _classCallCheck(this, RecordBatchStreamReader);\n\n    _this6 = _super2.call(this, _impl);\n    _this6._impl = _impl;\n    return _this6;\n  }\n\n  _createClass(RecordBatchStreamReader, [{\n    key: Symbol.iterator,\n    value: function value() {\n      return this._impl[Symbol.iterator]();\n    }\n  }, {\n    key: Symbol.asyncIterator,\n    value: function value() {\n      var _this = this;\n\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.delegateYield(_asyncGeneratorDelegate(_asyncIterator(_this[Symbol.iterator]()), _awaitAsyncGenerator), \"t0\", 1);\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }))();\n    }\n  }]);\n\n  return RecordBatchStreamReader;\n}(RecordBatchReader);\n/** @ignore */\n\nexport var AsyncRecordBatchStreamReader = /*#__PURE__*/function (_RecordBatchReader2) {\n  _inherits(AsyncRecordBatchStreamReader, _RecordBatchReader2);\n\n  var _super3 = _createSuper(AsyncRecordBatchStreamReader);\n\n  function AsyncRecordBatchStreamReader(_impl) {\n    var _this7;\n\n    _classCallCheck(this, AsyncRecordBatchStreamReader);\n\n    _this7 = _super3.call(this, _impl);\n    _this7._impl = _impl;\n    return _this7;\n  }\n\n  _createClass(AsyncRecordBatchStreamReader, [{\n    key: Symbol.iterator,\n    value: function value() {\n      throw new Error(\"AsyncRecordBatchStreamReader is not Iterable\");\n    }\n  }, {\n    key: Symbol.asyncIterator,\n    value: function value() {\n      return this._impl[Symbol.asyncIterator]();\n    }\n  }]);\n\n  return AsyncRecordBatchStreamReader;\n}(RecordBatchReader);\n/** @ignore */\n\nexport var RecordBatchFileReader = /*#__PURE__*/function (_RecordBatchStreamRea) {\n  _inherits(RecordBatchFileReader, _RecordBatchStreamRea);\n\n  var _super4 = _createSuper(RecordBatchFileReader);\n\n  function RecordBatchFileReader(_impl) {\n    var _this8;\n\n    _classCallCheck(this, RecordBatchFileReader);\n\n    _this8 = _super4.call(this, _impl);\n    _this8._impl = _impl;\n    return _this8;\n  }\n\n  return RecordBatchFileReader;\n}(RecordBatchStreamReader);\n/** @ignore */\n\nexport var AsyncRecordBatchFileReader = /*#__PURE__*/function (_AsyncRecordBatchStre) {\n  _inherits(AsyncRecordBatchFileReader, _AsyncRecordBatchStre);\n\n  var _super5 = _createSuper(AsyncRecordBatchFileReader);\n\n  function AsyncRecordBatchFileReader(_impl) {\n    var _this9;\n\n    _classCallCheck(this, AsyncRecordBatchFileReader);\n\n    _this9 = _super5.call(this, _impl);\n    _this9._impl = _impl;\n    return _this9;\n  }\n\n  return AsyncRecordBatchFileReader;\n}(AsyncRecordBatchStreamReader);\n/** @ignore */\n\nvar RecordBatchReaderImpl = /*#__PURE__*/function () {\n  function RecordBatchReaderImpl() {\n    var dictionaries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Map();\n\n    _classCallCheck(this, RecordBatchReaderImpl);\n\n    this.closed = false;\n    this.autoDestroy = true;\n    this._dictionaryIndex = 0;\n    this._recordBatchIndex = 0;\n    this.dictionaries = dictionaries;\n  }\n\n  _createClass(RecordBatchReaderImpl, [{\n    key: \"isSync\",\n    value: function isSync() {\n      return false;\n    }\n  }, {\n    key: \"isAsync\",\n    value: function isAsync() {\n      return false;\n    }\n  }, {\n    key: \"isFile\",\n    value: function isFile() {\n      return false;\n    }\n  }, {\n    key: \"isStream\",\n    value: function isStream() {\n      return false;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(schema) {\n      this._dictionaryIndex = 0;\n      this._recordBatchIndex = 0;\n      this.schema = schema;\n      this.dictionaries = new Map();\n      return this;\n    }\n  }, {\n    key: \"_loadRecordBatch\",\n    value: function _loadRecordBatch(header, body) {\n      return new RecordBatch(this.schema, header.length, this._loadVectors(header, body, this.schema.fields));\n    }\n  }, {\n    key: \"_loadDictionaryBatch\",\n    value: function _loadDictionaryBatch(header, body) {\n      var id = header.id,\n          isDelta = header.isDelta,\n          data = header.data;\n      var dictionaries = this.dictionaries,\n          schema = this.schema;\n      var dictionary = dictionaries.get(id);\n\n      if (isDelta || !dictionary) {\n        var type = schema.dictionaries.get(id);\n        return dictionary && isDelta ? dictionary.concat(Vector.new(this._loadVectors(data, body, [type])[0])) : Vector.new(this._loadVectors(data, body, [type])[0]);\n      }\n\n      return dictionary;\n    }\n  }, {\n    key: \"_loadVectors\",\n    value: function _loadVectors(header, body, types) {\n      return new VectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);\n    }\n  }, {\n    key: \"numDictionaries\",\n    get: function get() {\n      return this._dictionaryIndex;\n    }\n  }, {\n    key: \"numRecordBatches\",\n    get: function get() {\n      return this._recordBatchIndex;\n    }\n  }]);\n\n  return RecordBatchReaderImpl;\n}();\n/** @ignore */\n\n\nvar RecordBatchStreamReaderImpl = /*#__PURE__*/function (_RecordBatchReaderImp) {\n  _inherits(RecordBatchStreamReaderImpl, _RecordBatchReaderImp);\n\n  var _super6 = _createSuper(RecordBatchStreamReaderImpl);\n\n  function RecordBatchStreamReaderImpl(source, dictionaries) {\n    var _this10;\n\n    _classCallCheck(this, RecordBatchStreamReaderImpl);\n\n    _this10 = _super6.call(this, dictionaries);\n    _this10._reader = !isArrowJSON(source) ? new MessageReader(_this10._handle = source) : new JSONMessageReader(_this10._handle = source);\n    return _this10;\n  }\n\n  _createClass(RecordBatchStreamReaderImpl, [{\n    key: \"isSync\",\n    value: function isSync() {\n      return true;\n    }\n  }, {\n    key: \"isStream\",\n    value: function isStream() {\n      return true;\n    }\n  }, {\n    key: Symbol.iterator,\n    value: function value() {\n      return this;\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      if (!this.closed && (this.closed = true)) {\n        this.reset()._reader.return();\n\n        this._reader = null;\n        this.dictionaries = null;\n      }\n    }\n  }, {\n    key: \"open\",\n    value: function open(options) {\n      if (!this.closed) {\n        this.autoDestroy = shouldAutoDestroy(this, options);\n\n        if (!(this.schema || (this.schema = this._reader.readSchema()))) {\n          this.cancel();\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"throw\",\n    value: function _throw(value) {\n      if (!this.closed && this.autoDestroy && (this.closed = true)) {\n        return this.reset()._reader.throw(value);\n      }\n\n      return ITERATOR_DONE;\n    }\n  }, {\n    key: \"return\",\n    value: function _return(value) {\n      if (!this.closed && this.autoDestroy && (this.closed = true)) {\n        return this.reset()._reader.return(value);\n      }\n\n      return ITERATOR_DONE;\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      if (this.closed) {\n        return ITERATOR_DONE;\n      }\n\n      var message,\n          reader = this._reader;\n\n      while (message = this._readNextMessageAndValidate()) {\n        if (message.isSchema()) {\n          this.reset(message.header());\n        } else if (message.isRecordBatch()) {\n          this._recordBatchIndex++;\n          var header = message.header();\n          var buffer = reader.readMessageBody(message.bodyLength);\n\n          var recordBatch = this._loadRecordBatch(header, buffer);\n\n          return {\n            done: false,\n            value: recordBatch\n          };\n        } else if (message.isDictionaryBatch()) {\n          this._dictionaryIndex++;\n\n          var _header = message.header();\n\n          var _buffer = reader.readMessageBody(message.bodyLength);\n\n          var vector = this._loadDictionaryBatch(_header, _buffer);\n\n          this.dictionaries.set(_header.id, vector);\n        }\n      }\n\n      if (this.schema && this._recordBatchIndex === 0) {\n        this._recordBatchIndex++;\n        return {\n          done: false,\n          value: new _InternalEmptyPlaceholderRecordBatch(this.schema)\n        };\n      }\n\n      return this.return();\n    }\n  }, {\n    key: \"_readNextMessageAndValidate\",\n    value: function _readNextMessageAndValidate(type) {\n      return this._reader.readMessage(type);\n    }\n  }]);\n\n  return RecordBatchStreamReaderImpl;\n}(RecordBatchReaderImpl);\n/** @ignore */\n\n\nvar AsyncRecordBatchStreamReaderImpl = /*#__PURE__*/function (_RecordBatchReaderImp2) {\n  _inherits(AsyncRecordBatchStreamReaderImpl, _RecordBatchReaderImp2);\n\n  var _super7 = _createSuper(AsyncRecordBatchStreamReaderImpl);\n\n  function AsyncRecordBatchStreamReaderImpl(source, dictionaries) {\n    var _this11;\n\n    _classCallCheck(this, AsyncRecordBatchStreamReaderImpl);\n\n    _this11 = _super7.call(this, dictionaries);\n    _this11._reader = new AsyncMessageReader(_this11._handle = source);\n    return _this11;\n  }\n\n  _createClass(AsyncRecordBatchStreamReaderImpl, [{\n    key: \"isAsync\",\n    value: function isAsync() {\n      return true;\n    }\n  }, {\n    key: \"isStream\",\n    value: function isStream() {\n      return true;\n    }\n  }, {\n    key: Symbol.asyncIterator,\n    value: function value() {\n      return this;\n    }\n  }, {\n    key: \"cancel\",\n    value: function () {\n      var _cancel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(!this.closed && (this.closed = true))) {\n                  _context3.next = 5;\n                  break;\n                }\n\n                _context3.next = 3;\n                return this.reset()._reader.return();\n\n              case 3:\n                this._reader = null;\n                this.dictionaries = null;\n\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function cancel() {\n        return _cancel.apply(this, arguments);\n      }\n\n      return cancel;\n    }()\n  }, {\n    key: \"open\",\n    value: function () {\n      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(options) {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (this.closed) {\n                  _context4.next = 10;\n                  break;\n                }\n\n                this.autoDestroy = shouldAutoDestroy(this, options);\n                _context4.t0 = this.schema;\n\n                if (_context4.t0) {\n                  _context4.next = 7;\n                  break;\n                }\n\n                _context4.next = 6;\n                return this._reader.readSchema();\n\n              case 6:\n                _context4.t0 = this.schema = _context4.sent;\n\n              case 7:\n                if (_context4.t0) {\n                  _context4.next = 10;\n                  break;\n                }\n\n                _context4.next = 10;\n                return this.cancel();\n\n              case 10:\n                return _context4.abrupt(\"return\", this);\n\n              case 11:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function open(_x2) {\n        return _open.apply(this, arguments);\n      }\n\n      return open;\n    }()\n  }, {\n    key: \"throw\",\n    value: function () {\n      var _throw2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(value) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!(!this.closed && this.autoDestroy && (this.closed = true))) {\n                  _context5.next = 4;\n                  break;\n                }\n\n                _context5.next = 3;\n                return this.reset()._reader.throw(value);\n\n              case 3:\n                return _context5.abrupt(\"return\", _context5.sent);\n\n              case 4:\n                return _context5.abrupt(\"return\", ITERATOR_DONE);\n\n              case 5:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function _throw(_x3) {\n        return _throw2.apply(this, arguments);\n      }\n\n      return _throw;\n    }()\n  }, {\n    key: \"return\",\n    value: function () {\n      var _return2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(value) {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!(!this.closed && this.autoDestroy && (this.closed = true))) {\n                  _context6.next = 4;\n                  break;\n                }\n\n                _context6.next = 3;\n                return this.reset()._reader.return(value);\n\n              case 3:\n                return _context6.abrupt(\"return\", _context6.sent);\n\n              case 4:\n                return _context6.abrupt(\"return\", ITERATOR_DONE);\n\n              case 5:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function _return(_x4) {\n        return _return2.apply(this, arguments);\n      }\n\n      return _return;\n    }()\n  }, {\n    key: \"next\",\n    value: function () {\n      var _next = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var message, reader, header, buffer, recordBatch, _header2, _buffer2, vector;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (!this.closed) {\n                  _context7.next = 2;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", ITERATOR_DONE);\n\n              case 2:\n                reader = this._reader;\n\n              case 3:\n                _context7.next = 5;\n                return this._readNextMessageAndValidate();\n\n              case 5:\n                if (!(message = _context7.sent)) {\n                  _context7.next = 31;\n                  break;\n                }\n\n                if (!message.isSchema()) {\n                  _context7.next = 11;\n                  break;\n                }\n\n                _context7.next = 9;\n                return this.reset(message.header());\n\n              case 9:\n                _context7.next = 29;\n                break;\n\n              case 11:\n                if (!message.isRecordBatch()) {\n                  _context7.next = 21;\n                  break;\n                }\n\n                this._recordBatchIndex++;\n                header = message.header();\n                _context7.next = 16;\n                return reader.readMessageBody(message.bodyLength);\n\n              case 16:\n                buffer = _context7.sent;\n                recordBatch = this._loadRecordBatch(header, buffer);\n                return _context7.abrupt(\"return\", {\n                  done: false,\n                  value: recordBatch\n                });\n\n              case 21:\n                if (!message.isDictionaryBatch()) {\n                  _context7.next = 29;\n                  break;\n                }\n\n                this._dictionaryIndex++;\n                _header2 = message.header();\n                _context7.next = 26;\n                return reader.readMessageBody(message.bodyLength);\n\n              case 26:\n                _buffer2 = _context7.sent;\n                vector = this._loadDictionaryBatch(_header2, _buffer2);\n                this.dictionaries.set(_header2.id, vector);\n\n              case 29:\n                _context7.next = 3;\n                break;\n\n              case 31:\n                if (!(this.schema && this._recordBatchIndex === 0)) {\n                  _context7.next = 34;\n                  break;\n                }\n\n                this._recordBatchIndex++;\n                return _context7.abrupt(\"return\", {\n                  done: false,\n                  value: new _InternalEmptyPlaceholderRecordBatch(this.schema)\n                });\n\n              case 34:\n                _context7.next = 36;\n                return this.return();\n\n              case 36:\n                return _context7.abrupt(\"return\", _context7.sent);\n\n              case 37:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function next() {\n        return _next.apply(this, arguments);\n      }\n\n      return next;\n    }()\n  }, {\n    key: \"_readNextMessageAndValidate\",\n    value: function () {\n      var _readNextMessageAndValidate2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(type) {\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return this._reader.readMessage(type);\n\n              case 2:\n                return _context8.abrupt(\"return\", _context8.sent);\n\n              case 3:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function _readNextMessageAndValidate(_x5) {\n        return _readNextMessageAndValidate2.apply(this, arguments);\n      }\n\n      return _readNextMessageAndValidate;\n    }()\n  }]);\n\n  return AsyncRecordBatchStreamReaderImpl;\n}(RecordBatchReaderImpl);\n/** @ignore */\n\n\nvar RecordBatchFileReaderImpl = /*#__PURE__*/function (_RecordBatchStreamRea2) {\n  _inherits(RecordBatchFileReaderImpl, _RecordBatchStreamRea2);\n\n  var _super8 = _createSuper(RecordBatchFileReaderImpl);\n\n  function RecordBatchFileReaderImpl(source, dictionaries) {\n    _classCallCheck(this, RecordBatchFileReaderImpl);\n\n    return _super8.call(this, source instanceof RandomAccessFile ? source : new RandomAccessFile(source), dictionaries);\n  }\n\n  _createClass(RecordBatchFileReaderImpl, [{\n    key: \"isSync\",\n    value: function isSync() {\n      return true;\n    }\n  }, {\n    key: \"isFile\",\n    value: function isFile() {\n      return true;\n    }\n  }, {\n    key: \"open\",\n    value: function open(options) {\n      if (!this.closed && !this._footer) {\n        this.schema = (this._footer = this._readFooter()).schema;\n\n        var _iterator = _createForOfIteratorHelper(this._footer.dictionaryBatches()),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var block = _step.value;\n            block && this._readDictionaryBatch(this._dictionaryIndex++);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      return _get(_getPrototypeOf(RecordBatchFileReaderImpl.prototype), \"open\", this).call(this, options);\n    }\n  }, {\n    key: \"readRecordBatch\",\n    value: function readRecordBatch(index) {\n      if (this.closed) {\n        return null;\n      }\n\n      if (!this._footer) {\n        this.open();\n      }\n\n      var block = this._footer && this._footer.getRecordBatch(index);\n\n      if (block && this._handle.seek(block.offset)) {\n        var message = this._reader.readMessage(MessageHeader.RecordBatch);\n\n        if (message && message.isRecordBatch()) {\n          var header = message.header();\n\n          var buffer = this._reader.readMessageBody(message.bodyLength);\n\n          var recordBatch = this._loadRecordBatch(header, buffer);\n\n          return recordBatch;\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_readDictionaryBatch\",\n    value: function _readDictionaryBatch(index) {\n      var block = this._footer && this._footer.getDictionaryBatch(index);\n\n      if (block && this._handle.seek(block.offset)) {\n        var message = this._reader.readMessage(MessageHeader.DictionaryBatch);\n\n        if (message && message.isDictionaryBatch()) {\n          var header = message.header();\n\n          var buffer = this._reader.readMessageBody(message.bodyLength);\n\n          var vector = this._loadDictionaryBatch(header, buffer);\n\n          this.dictionaries.set(header.id, vector);\n        }\n      }\n    }\n  }, {\n    key: \"_readFooter\",\n    value: function _readFooter() {\n      var _handle = this._handle;\n      var offset = _handle.size - magicAndPadding;\n\n      var length = _handle.readInt32(offset);\n\n      var buffer = _handle.readAt(offset - length, length);\n\n      return Footer.decode(buffer);\n    }\n  }, {\n    key: \"_readNextMessageAndValidate\",\n    value: function _readNextMessageAndValidate(type) {\n      if (!this._footer) {\n        this.open();\n      }\n\n      if (this._footer && this._recordBatchIndex < this.numRecordBatches) {\n        var block = this._footer && this._footer.getRecordBatch(this._recordBatchIndex);\n\n        if (block && this._handle.seek(block.offset)) {\n          return this._reader.readMessage(type);\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"footer\",\n    get: function get() {\n      return this._footer;\n    }\n  }, {\n    key: \"numDictionaries\",\n    get: function get() {\n      return this._footer ? this._footer.numDictionaries : 0;\n    }\n  }, {\n    key: \"numRecordBatches\",\n    get: function get() {\n      return this._footer ? this._footer.numRecordBatches : 0;\n    }\n  }]);\n\n  return RecordBatchFileReaderImpl;\n}(RecordBatchStreamReaderImpl);\n/** @ignore */\n\n\nvar AsyncRecordBatchFileReaderImpl = /*#__PURE__*/function (_AsyncRecordBatchStre2) {\n  _inherits(AsyncRecordBatchFileReaderImpl, _AsyncRecordBatchStre2);\n\n  var _super9 = _createSuper(AsyncRecordBatchFileReaderImpl);\n\n  function AsyncRecordBatchFileReaderImpl(source) {\n    _classCallCheck(this, AsyncRecordBatchFileReaderImpl);\n\n    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      rest[_key - 1] = arguments[_key];\n    }\n\n    var byteLength = typeof rest[0] !== 'number' ? rest.shift() : undefined;\n    var dictionaries = rest[0] instanceof Map ? rest.shift() : undefined;\n    return _super9.call(this, source instanceof AsyncRandomAccessFile ? source : new AsyncRandomAccessFile(source, byteLength), dictionaries);\n  }\n\n  _createClass(AsyncRecordBatchFileReaderImpl, [{\n    key: \"isFile\",\n    value: function isFile() {\n      return true;\n    }\n  }, {\n    key: \"isAsync\",\n    value: function isAsync() {\n      return true;\n    }\n  }, {\n    key: \"open\",\n    value: function () {\n      var _open2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(options) {\n        var _iterator2, _step2, block;\n\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                if (!(!this.closed && !this._footer)) {\n                  _context9.next = 23;\n                  break;\n                }\n\n                _context9.next = 3;\n                return this._readFooter();\n\n              case 3:\n                this.schema = (this._footer = _context9.sent).schema;\n                _iterator2 = _createForOfIteratorHelper(this._footer.dictionaryBatches());\n                _context9.prev = 5;\n\n                _iterator2.s();\n\n              case 7:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context9.next = 15;\n                  break;\n                }\n\n                block = _step2.value;\n                _context9.t0 = block;\n\n                if (!_context9.t0) {\n                  _context9.next = 13;\n                  break;\n                }\n\n                _context9.next = 13;\n                return this._readDictionaryBatch(this._dictionaryIndex++);\n\n              case 13:\n                _context9.next = 7;\n                break;\n\n              case 15:\n                _context9.next = 20;\n                break;\n\n              case 17:\n                _context9.prev = 17;\n                _context9.t1 = _context9[\"catch\"](5);\n\n                _iterator2.e(_context9.t1);\n\n              case 20:\n                _context9.prev = 20;\n\n                _iterator2.f();\n\n                return _context9.finish(20);\n\n              case 23:\n                _context9.next = 25;\n                return _get(_getPrototypeOf(AsyncRecordBatchFileReaderImpl.prototype), \"open\", this).call(this, options);\n\n              case 25:\n                return _context9.abrupt(\"return\", _context9.sent);\n\n              case 26:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this, [[5, 17, 20, 23]]);\n      }));\n\n      function open(_x6) {\n        return _open2.apply(this, arguments);\n      }\n\n      return open;\n    }()\n  }, {\n    key: \"readRecordBatch\",\n    value: function () {\n      var _readRecordBatch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(index) {\n        var block, message, header, buffer, recordBatch;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                if (!this.closed) {\n                  _context10.next = 2;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\", null);\n\n              case 2:\n                if (this._footer) {\n                  _context10.next = 5;\n                  break;\n                }\n\n                _context10.next = 5;\n                return this.open();\n\n              case 5:\n                block = this._footer && this._footer.getRecordBatch(index);\n                _context10.t0 = block;\n\n                if (!_context10.t0) {\n                  _context10.next = 11;\n                  break;\n                }\n\n                _context10.next = 10;\n                return this._handle.seek(block.offset);\n\n              case 10:\n                _context10.t0 = _context10.sent;\n\n              case 11:\n                if (!_context10.t0) {\n                  _context10.next = 22;\n                  break;\n                }\n\n                _context10.next = 14;\n                return this._reader.readMessage(MessageHeader.RecordBatch);\n\n              case 14:\n                message = _context10.sent;\n\n                if (!(message && message.isRecordBatch())) {\n                  _context10.next = 22;\n                  break;\n                }\n\n                header = message.header();\n                _context10.next = 19;\n                return this._reader.readMessageBody(message.bodyLength);\n\n              case 19:\n                buffer = _context10.sent;\n                recordBatch = this._loadRecordBatch(header, buffer);\n                return _context10.abrupt(\"return\", recordBatch);\n\n              case 22:\n                return _context10.abrupt(\"return\", null);\n\n              case 23:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function readRecordBatch(_x7) {\n        return _readRecordBatch.apply(this, arguments);\n      }\n\n      return readRecordBatch;\n    }()\n  }, {\n    key: \"_readDictionaryBatch\",\n    value: function () {\n      var _readDictionaryBatch2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(index) {\n        var block, message, header, buffer, vector;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                block = this._footer && this._footer.getDictionaryBatch(index);\n                _context11.t0 = block;\n\n                if (!_context11.t0) {\n                  _context11.next = 6;\n                  break;\n                }\n\n                _context11.next = 5;\n                return this._handle.seek(block.offset);\n\n              case 5:\n                _context11.t0 = _context11.sent;\n\n              case 6:\n                if (!_context11.t0) {\n                  _context11.next = 17;\n                  break;\n                }\n\n                _context11.next = 9;\n                return this._reader.readMessage(MessageHeader.DictionaryBatch);\n\n              case 9:\n                message = _context11.sent;\n\n                if (!(message && message.isDictionaryBatch())) {\n                  _context11.next = 17;\n                  break;\n                }\n\n                header = message.header();\n                _context11.next = 14;\n                return this._reader.readMessageBody(message.bodyLength);\n\n              case 14:\n                buffer = _context11.sent;\n                vector = this._loadDictionaryBatch(header, buffer);\n                this.dictionaries.set(header.id, vector);\n\n              case 17:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function _readDictionaryBatch(_x8) {\n        return _readDictionaryBatch2.apply(this, arguments);\n      }\n\n      return _readDictionaryBatch;\n    }()\n  }, {\n    key: \"_readFooter\",\n    value: function () {\n      var _readFooter2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {\n        var _handle, offset, length, buffer;\n\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _handle = this._handle;\n                _context12.t0 = _handle._pending;\n\n                if (!_context12.t0) {\n                  _context12.next = 5;\n                  break;\n                }\n\n                _context12.next = 5;\n                return _handle._pending;\n\n              case 5:\n                offset = _handle.size - magicAndPadding;\n                _context12.next = 8;\n                return _handle.readInt32(offset);\n\n              case 8:\n                length = _context12.sent;\n                _context12.next = 11;\n                return _handle.readAt(offset - length, length);\n\n              case 11:\n                buffer = _context12.sent;\n                return _context12.abrupt(\"return\", Footer.decode(buffer));\n\n              case 13:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function _readFooter() {\n        return _readFooter2.apply(this, arguments);\n      }\n\n      return _readFooter;\n    }()\n  }, {\n    key: \"_readNextMessageAndValidate\",\n    value: function () {\n      var _readNextMessageAndValidate3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(type) {\n        var block;\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                if (this._footer) {\n                  _context13.next = 3;\n                  break;\n                }\n\n                _context13.next = 3;\n                return this.open();\n\n              case 3:\n                if (!(this._footer && this._recordBatchIndex < this.numRecordBatches)) {\n                  _context13.next = 14;\n                  break;\n                }\n\n                block = this._footer.getRecordBatch(this._recordBatchIndex);\n                _context13.t0 = block;\n\n                if (!_context13.t0) {\n                  _context13.next = 10;\n                  break;\n                }\n\n                _context13.next = 9;\n                return this._handle.seek(block.offset);\n\n              case 9:\n                _context13.t0 = _context13.sent;\n\n              case 10:\n                if (!_context13.t0) {\n                  _context13.next = 14;\n                  break;\n                }\n\n                _context13.next = 13;\n                return this._reader.readMessage(type);\n\n              case 13:\n                return _context13.abrupt(\"return\", _context13.sent);\n\n              case 14:\n                return _context13.abrupt(\"return\", null);\n\n              case 15:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function _readNextMessageAndValidate(_x9) {\n        return _readNextMessageAndValidate3.apply(this, arguments);\n      }\n\n      return _readNextMessageAndValidate;\n    }()\n  }, {\n    key: \"footer\",\n    get: function get() {\n      return this._footer;\n    }\n  }, {\n    key: \"numDictionaries\",\n    get: function get() {\n      return this._footer ? this._footer.numDictionaries : 0;\n    }\n  }, {\n    key: \"numRecordBatches\",\n    get: function get() {\n      return this._footer ? this._footer.numRecordBatches : 0;\n    }\n  }]);\n\n  return AsyncRecordBatchFileReaderImpl;\n}(AsyncRecordBatchStreamReaderImpl);\n/** @ignore */\n\n\nvar RecordBatchJSONReaderImpl = /*#__PURE__*/function (_RecordBatchStreamRea3) {\n  _inherits(RecordBatchJSONReaderImpl, _RecordBatchStreamRea3);\n\n  var _super10 = _createSuper(RecordBatchJSONReaderImpl);\n\n  function RecordBatchJSONReaderImpl(source, dictionaries) {\n    _classCallCheck(this, RecordBatchJSONReaderImpl);\n\n    return _super10.call(this, source, dictionaries);\n  }\n\n  _createClass(RecordBatchJSONReaderImpl, [{\n    key: \"_loadVectors\",\n    value: function _loadVectors(header, body, types) {\n      return new JSONVectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);\n    }\n  }]);\n\n  return RecordBatchJSONReaderImpl;\n}(RecordBatchStreamReaderImpl); //\n// Define some helper functions and static implementations down here. There's\n// a bit of branching in the static methods that can lead to the same routines\n// being executed, so we've broken those out here for readability.\n//\n\n/** @ignore */\n\n\nfunction shouldAutoDestroy(self, options) {\n  return options && typeof options['autoDestroy'] === 'boolean' ? options['autoDestroy'] : self['autoDestroy'];\n}\n/** @ignore */\n\n\nfunction readAllSync(source) {\n  var reader;\n  return _regeneratorRuntime.wrap(function readAllSync$(_context14) {\n    while (1) {\n      switch (_context14.prev = _context14.next) {\n        case 0:\n          reader = RecordBatchReader.from(source);\n          _context14.prev = 1;\n\n          if (reader.open({\n            autoDestroy: false\n          }).closed) {\n            _context14.next = 6;\n            break;\n          }\n\n        case 3:\n          _context14.next = 5;\n          return reader;\n\n        case 5:\n          if (!reader.reset().open().closed) {\n            _context14.next = 3;\n            break;\n          }\n\n        case 6:\n          _context14.prev = 6;\n          reader.cancel();\n          return _context14.finish(6);\n\n        case 9:\n        case \"end\":\n          return _context14.stop();\n      }\n    }\n  }, _marked, null, [[1,, 6, 9]]);\n}\n/** @ignore */\n\n\nfunction readAllAsync(_x) {\n  return _readAllAsync.apply(this, arguments);\n}\n/** @ignore */\n\n\nfunction _readAllAsync() {\n  _readAllAsync = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(source) {\n    var reader;\n    return _regeneratorRuntime.wrap(function _callee14$(_context15) {\n      while (1) {\n        switch (_context15.prev = _context15.next) {\n          case 0:\n            _context15.next = 2;\n            return _awaitAsyncGenerator(RecordBatchReader.from(source));\n\n          case 2:\n            reader = _context15.sent;\n            _context15.prev = 3;\n            _context15.next = 6;\n            return _awaitAsyncGenerator(reader.open({\n              autoDestroy: false\n            }));\n\n          case 6:\n            if (_context15.sent.closed) {\n              _context15.next = 12;\n              break;\n            }\n\n          case 7:\n            _context15.next = 9;\n            return reader;\n\n          case 9:\n            _context15.next = 11;\n            return _awaitAsyncGenerator(reader.reset().open());\n\n          case 11:\n            if (!_context15.sent.closed) {\n              _context15.next = 7;\n              break;\n            }\n\n          case 12:\n            _context15.prev = 12;\n            _context15.next = 15;\n            return _awaitAsyncGenerator(reader.cancel());\n\n          case 15:\n            return _context15.finish(12);\n\n          case 16:\n          case \"end\":\n            return _context15.stop();\n        }\n      }\n    }, _callee14, null, [[3,, 12, 16]]);\n  }));\n  return _readAllAsync.apply(this, arguments);\n}\n\nfunction fromArrowJSON(source) {\n  return new RecordBatchStreamReader(new RecordBatchJSONReaderImpl(source));\n}\n/** @ignore */\n\n\nfunction fromByteStream(source) {\n  var bytes = source.peek(magicLength + 7 & ~7);\n  return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes) ? new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(source.read())) : new RecordBatchStreamReader(new RecordBatchStreamReaderImpl( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15() {\n    return _regeneratorRuntime.wrap(function _callee15$(_context16) {\n      while (1) {\n        switch (_context16.prev = _context16.next) {\n          case 0:\n          case \"end\":\n            return _context16.stop();\n        }\n      }\n    }, _callee15);\n  })()));\n}\n/** @ignore */\n\n\nfunction fromAsyncByteStream(_x10) {\n  return _fromAsyncByteStream.apply(this, arguments);\n}\n/** @ignore */\n\n\nfunction _fromAsyncByteStream() {\n  _fromAsyncByteStream = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee17(source) {\n    var bytes;\n    return _regeneratorRuntime.wrap(function _callee17$(_context18) {\n      while (1) {\n        switch (_context18.prev = _context18.next) {\n          case 0:\n            _context18.next = 2;\n            return source.peek(magicLength + 7 & ~7);\n\n          case 2:\n            bytes = _context18.sent;\n\n            if (!(bytes && bytes.byteLength >= 4)) {\n              _context18.next = 18;\n              break;\n            }\n\n            if (checkForMagicArrowString(bytes)) {\n              _context18.next = 8;\n              break;\n            }\n\n            _context18.t1 = new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(source));\n            _context18.next = 15;\n            break;\n\n          case 8:\n            _context18.t2 = RecordBatchFileReader;\n            _context18.t3 = RecordBatchFileReaderImpl;\n            _context18.next = 12;\n            return source.read();\n\n          case 12:\n            _context18.t4 = _context18.sent;\n            _context18.t5 = new _context18.t3(_context18.t4);\n            _context18.t1 = new _context18.t2(_context18.t5);\n\n          case 15:\n            _context18.t0 = _context18.t1;\n            _context18.next = 19;\n            break;\n\n          case 18:\n            _context18.t0 = new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(_wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16() {\n              return _regeneratorRuntime.wrap(function _callee16$(_context17) {\n                while (1) {\n                  switch (_context17.prev = _context17.next) {\n                    case 0:\n                    case \"end\":\n                      return _context17.stop();\n                  }\n                }\n              }, _callee16);\n            }))()));\n\n          case 19:\n            return _context18.abrupt(\"return\", _context18.t0);\n\n          case 20:\n          case \"end\":\n            return _context18.stop();\n        }\n      }\n    }, _callee17);\n  }));\n  return _fromAsyncByteStream.apply(this, arguments);\n}\n\nfunction fromFileHandle(_x11) {\n  return _fromFileHandle.apply(this, arguments);\n}\n\nfunction _fromFileHandle() {\n  _fromFileHandle = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee18(source) {\n    var _yield$source$stat, size, file;\n\n    return _regeneratorRuntime.wrap(function _callee18$(_context19) {\n      while (1) {\n        switch (_context19.prev = _context19.next) {\n          case 0:\n            _context19.next = 2;\n            return source.stat();\n\n          case 2:\n            _yield$source$stat = _context19.sent;\n            size = _yield$source$stat.size;\n            file = new AsyncRandomAccessFile(source, size);\n\n            if (!(size >= magicX2AndPadding)) {\n              _context19.next = 12;\n              break;\n            }\n\n            _context19.t0 = checkForMagicArrowString;\n            _context19.next = 9;\n            return file.readAt(0, magicLength + 7 & ~7);\n\n          case 9:\n            _context19.t1 = _context19.sent;\n\n            if (!(0, _context19.t0)(_context19.t1)) {\n              _context19.next = 12;\n              break;\n            }\n\n            return _context19.abrupt(\"return\", new AsyncRecordBatchFileReader(new AsyncRecordBatchFileReaderImpl(file)));\n\n          case 12:\n            return _context19.abrupt(\"return\", new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(file)));\n\n          case 13:\n          case \"end\":\n            return _context19.stop();\n        }\n      }\n    }, _callee18);\n  }));\n  return _fromFileHandle.apply(this, arguments);\n}","map":{"version":3,"sources":["ipc/reader.ts"],"names":[],"mappings":"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","sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Vector } from '../vector';\nimport { DataType } from '../type';\nimport { MessageHeader } from '../enum';\nimport { Footer } from './metadata/file';\nimport { Schema, Field } from '../schema';\nimport streamAdapters from '../io/adapters';\nimport { Message } from './metadata/message';\nimport * as metadata from './metadata/message';\nimport { ArrayBufferViewInput } from '../util/buffer';\nimport { ByteStream, AsyncByteStream } from '../io/stream';\nimport { RandomAccessFile, AsyncRandomAccessFile } from '../io/file';\nimport { VectorLoader, JSONVectorLoader } from '../visitor/vectorloader';\nimport { RecordBatch, _InternalEmptyPlaceholderRecordBatch } from '../recordbatch';\nimport {\n    FileHandle,\n    ArrowJSONLike,\n    ITERATOR_DONE,\n    ReadableInterop,\n} from '../io/interfaces';\nimport {\n    MessageReader, AsyncMessageReader, JSONMessageReader,\n    checkForMagicArrowString, magicLength, magicAndPadding, magicX2AndPadding\n} from './message';\nimport {\n    isPromise,\n    isIterable, isAsyncIterable,\n    isIteratorResult, isArrowJSON,\n    isFileHandle, isFetchResponse,\n    isReadableDOMStream, isReadableNodeStream\n} from '../util/compat';\n\n/** @ignore */ export type FromArg0 = ArrowJSONLike;\n/** @ignore */ export type FromArg1 = PromiseLike<ArrowJSONLike>;\n/** @ignore */ export type FromArg2 = Iterable<ArrayBufferViewInput> | ArrayBufferViewInput;\n/** @ignore */ export type FromArg3 = PromiseLike<Iterable<ArrayBufferViewInput> | ArrayBufferViewInput>;\n/** @ignore */ export type FromArg4 = Response | NodeJS.ReadableStream | ReadableStream<ArrayBufferViewInput> | AsyncIterable<ArrayBufferViewInput>;\n/** @ignore */ export type FromArg5 = FileHandle | PromiseLike<FileHandle> | PromiseLike<FromArg4>;\n/** @ignore */ export type FromArgs = FromArg0 | FromArg1 | FromArg2 | FromArg3 | FromArg4 | FromArg5;\n\n/** @ignore */ type OpenOptions = { autoDestroy?: boolean; };\n/** @ignore */ type RecordBatchReaders<T extends { [key: string]: DataType } = any> = RecordBatchFileReader<T> | RecordBatchStreamReader<T>;\n/** @ignore */ type AsyncRecordBatchReaders<T extends { [key: string]: DataType } = any> = AsyncRecordBatchFileReader<T> | AsyncRecordBatchStreamReader<T>;\n/** @ignore */ type RecordBatchFileReaders<T extends { [key: string]: DataType } = any> = RecordBatchFileReader<T> | AsyncRecordBatchFileReader<T>;\n/** @ignore */ type RecordBatchStreamReaders<T extends { [key: string]: DataType } = any> = RecordBatchStreamReader<T> | AsyncRecordBatchStreamReader<T>;\n\nexport class RecordBatchReader<T extends { [key: string]: DataType } = any> extends ReadableInterop<RecordBatch<T>> {\n\n    protected _impl: RecordBatchReaderImpls<T>;\n    protected constructor(impl: RecordBatchReaderImpls<T>) {\n        super();\n        this._impl = impl;\n    }\n\n    public get closed() { return this._impl.closed; }\n    public get schema() { return this._impl.schema; }\n    public get autoDestroy() { return this._impl.autoDestroy; }\n    public get dictionaries() { return this._impl.dictionaries; }\n    public get numDictionaries() { return this._impl.numDictionaries; }\n    public get numRecordBatches() { return this._impl.numRecordBatches; }\n    public get footer() { return this._impl.isFile() ? this._impl.footer : null; }\n\n    public isSync(): this is RecordBatchReaders<T> { return this._impl.isSync(); }\n    public isAsync(): this is AsyncRecordBatchReaders<T> { return this._impl.isAsync(); }\n    public isFile(): this is RecordBatchFileReaders<T> { return this._impl.isFile(); }\n    public isStream(): this is RecordBatchStreamReaders<T> { return this._impl.isStream(); }\n\n    public next() {\n        return this._impl.next();\n    }\n    public throw(value?: any) {\n        return this._impl.throw(value);\n    }\n    public return(value?: any) {\n        return this._impl.return(value);\n    }\n    public cancel() {\n        return this._impl.cancel();\n    }\n    public reset(schema?: Schema<T> | null): this {\n        this._impl.reset(schema);\n        this._DOMStream = undefined;\n        this._nodeStream = undefined;\n        return this;\n    }\n    public open(options?: OpenOptions) {\n        const opening = this._impl.open(options);\n        return isPromise(opening) ? opening.then(() => this) : this;\n    }\n    public readRecordBatch(index: number): RecordBatch<T> | null | Promise<RecordBatch<T> | null> {\n        return this._impl.isFile() ? this._impl.readRecordBatch(index) : null;\n    }\n    public [Symbol.iterator](): IterableIterator<RecordBatch<T>> {\n        return (<IterableIterator<RecordBatch<T>>> this._impl)[Symbol.iterator]();\n    }\n    public [Symbol.asyncIterator](): AsyncIterableIterator<RecordBatch<T>> {\n        return (<AsyncIterableIterator<RecordBatch<T>>> this._impl)[Symbol.asyncIterator]();\n    }\n    public toDOMStream() {\n        return streamAdapters.toDOMStream<RecordBatch<T>>(\n            (this.isSync()\n                ? { [Symbol.iterator]: () => this } as Iterable<RecordBatch<T>>\n                : { [Symbol.asyncIterator]: () => this } as AsyncIterable<RecordBatch<T>>));\n    }\n    public toNodeStream() {\n        return streamAdapters.toNodeStream<RecordBatch<T>>(\n            (this.isSync()\n                ? { [Symbol.iterator]: () => this } as Iterable<RecordBatch<T>>\n                : { [Symbol.asyncIterator]: () => this } as AsyncIterable<RecordBatch<T>>),\n            { objectMode: true });\n    }\n\n    /** @nocollapse */\n    // @ts-ignore\n    public static throughNode(options?: import('stream').DuplexOptions & { autoDestroy: boolean }): import('stream').Duplex {\n        throw new Error(`\"throughNode\" not available in this environment`);\n    }\n    /** @nocollapse */\n    public static throughDOM<T extends { [key: string]: DataType }>(\n        // @ts-ignore\n        writableStrategy?: ByteLengthQueuingStrategy,\n        // @ts-ignore\n        readableStrategy?: { autoDestroy: boolean }\n    ): { writable: WritableStream<Uint8Array>, readable: ReadableStream<RecordBatch<T>> } {\n        throw new Error(`\"throughDOM\" not available in this environment`);\n    }\n\n    public static from<T extends RecordBatchReader>(source: T): T;\n    public static from<T extends { [key: string]: DataType } = any>(source: FromArg0): RecordBatchStreamReader<T>;\n    public static from<T extends { [key: string]: DataType } = any>(source: FromArg1): Promise<RecordBatchStreamReader<T>>;\n    public static from<T extends { [key: string]: DataType } = any>(source: FromArg2): RecordBatchFileReader<T> | RecordBatchStreamReader<T>;\n    public static from<T extends { [key: string]: DataType } = any>(source: FromArg3): Promise<RecordBatchFileReader<T> | RecordBatchStreamReader<T>>;\n    public static from<T extends { [key: string]: DataType } = any>(source: FromArg4): Promise<RecordBatchFileReader<T> | AsyncRecordBatchReaders<T>>;\n    public static from<T extends { [key: string]: DataType } = any>(source: FromArg5): Promise<AsyncRecordBatchFileReader<T> | AsyncRecordBatchStreamReader<T>>;\n    /** @nocollapse */\n    public static from<T extends { [key: string]: DataType } = any>(source: any) {\n        if (source instanceof RecordBatchReader) {\n            return source;\n        } else if (isArrowJSON(source)) {\n            return fromArrowJSON<T>(source);\n        } else if (isFileHandle(source)) {\n            return fromFileHandle<T>(source);\n        } else if (isPromise<any>(source)) {\n            return (async () => await RecordBatchReader.from<any>(await source))();\n        } else if (isFetchResponse(source) || isReadableDOMStream(source) || isReadableNodeStream(source) || isAsyncIterable(source)) {\n            return fromAsyncByteStream<T>(new AsyncByteStream(source));\n        }\n        return fromByteStream<T>(new ByteStream(source));\n    }\n\n    public static readAll<T extends RecordBatchReader>(source: T): T extends RecordBatchReaders ? IterableIterator<T> : AsyncIterableIterator<T>;\n    public static readAll<T extends { [key: string]: DataType } = any>(source: FromArg0): IterableIterator<RecordBatchStreamReader<T>>;\n    public static readAll<T extends { [key: string]: DataType } = any>(source: FromArg1): AsyncIterableIterator<RecordBatchStreamReader<T>>;\n    public static readAll<T extends { [key: string]: DataType } = any>(source: FromArg2): IterableIterator<RecordBatchFileReader<T> | RecordBatchStreamReader<T>>;\n    public static readAll<T extends { [key: string]: DataType } = any>(source: FromArg3): AsyncIterableIterator<RecordBatchFileReader<T> | RecordBatchStreamReader<T>>;\n    public static readAll<T extends { [key: string]: DataType } = any>(source: FromArg4): AsyncIterableIterator<RecordBatchFileReader<T> | AsyncRecordBatchReaders<T>>;\n    public static readAll<T extends { [key: string]: DataType } = any>(source: FromArg5): AsyncIterableIterator<AsyncRecordBatchFileReader<T> | AsyncRecordBatchStreamReader<T>>;\n    /** @nocollapse */\n    public static readAll<T extends { [key: string]: DataType } = any>(source: any) {\n        if (source instanceof RecordBatchReader) {\n            return source.isSync() ? readAllSync(source) : readAllAsync(source as AsyncRecordBatchReaders<T>);\n        } else if (isArrowJSON(source) || ArrayBuffer.isView(source) || isIterable<ArrayBufferViewInput>(source) || isIteratorResult(source)) {\n            return readAllSync<T>(source) as IterableIterator<RecordBatchReaders<T>>;\n        }\n        return readAllAsync<T>(source) as AsyncIterableIterator<RecordBatchReaders<T> | AsyncRecordBatchReaders<T>>;\n    }\n}\n\n//\n// Since TS is a structural type system, we define the following subclass stubs\n// so that concrete types exist to associate with with the interfaces below.\n//\n// The implementation for each RecordBatchReader is hidden away in the set of\n// `RecordBatchReaderImpl` classes in the second half of this file. This allows\n// us to export a single RecordBatchReader class, and swap out the impl based\n// on the io primitives or underlying arrow (JSON, file, or stream) at runtime.\n//\n// Async/await makes our job a bit harder, since it forces everything to be\n// either fully sync or fully async. This is why the logic for the reader impls\n// has been duplicated into both sync and async variants. Since the RBR\n// delegates to its impl, an RBR with an AsyncRecordBatchFileReaderImpl for\n// example will return async/await-friendly Promises, but one with a (sync)\n// RecordBatchStreamReaderImpl will always return values. Nothing should be\n// different about their logic, aside from the async handling. This is also why\n// this code looks highly structured, as it should be nearly identical and easy\n// to follow.\n//\n\n/** @ignore */\nexport class RecordBatchStreamReader<T extends { [key: string]: DataType } = any> extends RecordBatchReader<T> {\n    constructor(protected _impl: RecordBatchStreamReaderImpl<T>) { super (_impl); }\n    public [Symbol.iterator]() { return (this._impl as IterableIterator<RecordBatch<T>>)[Symbol.iterator](); }\n    public async *[Symbol.asyncIterator](): AsyncIterableIterator<RecordBatch<T>> { yield* this[Symbol.iterator](); }\n}\n/** @ignore */\nexport class AsyncRecordBatchStreamReader<T extends { [key: string]: DataType } = any> extends RecordBatchReader<T> {\n    constructor(protected _impl: AsyncRecordBatchStreamReaderImpl<T>) { super (_impl); }\n    public [Symbol.iterator](): IterableIterator<RecordBatch<T>> { throw new Error(`AsyncRecordBatchStreamReader is not Iterable`); }\n    public [Symbol.asyncIterator]() { return (this._impl as AsyncIterableIterator<RecordBatch<T>>)[Symbol.asyncIterator](); }\n}\n/** @ignore */\nexport class RecordBatchFileReader<T extends { [key: string]: DataType } = any> extends RecordBatchStreamReader<T> {\n    constructor(protected _impl: RecordBatchFileReaderImpl<T>) { super (_impl); }\n}\n/** @ignore */\nexport class AsyncRecordBatchFileReader<T extends { [key: string]: DataType } = any> extends AsyncRecordBatchStreamReader<T> {\n    constructor(protected _impl: AsyncRecordBatchFileReaderImpl<T>) { super (_impl); }\n}\n\n//\n// Now override the return types for each sync/async RecordBatchReader variant\n//\n\n/** @ignore */\nexport interface RecordBatchStreamReader<T extends { [key: string]: DataType } = any> extends RecordBatchReader<T> {\n    open(options?: OpenOptions | undefined): this;\n    cancel(): void;\n    throw(value?: any): IteratorResult<any>;\n    return(value?: any): IteratorResult<any>;\n    next(value?: any): IteratorResult<RecordBatch<T>>;\n}\n\n/** @ignore */\nexport interface AsyncRecordBatchStreamReader<T extends { [key: string]: DataType } = any> extends RecordBatchReader<T> {\n    open(options?: OpenOptions | undefined): Promise<this>;\n    cancel(): Promise<void>;\n    throw(value?: any): Promise<IteratorResult<any>>;\n    return(value?: any): Promise<IteratorResult<any>>;\n    next(value?: any): Promise<IteratorResult<RecordBatch<T>>>;\n}\n\n/** @ignore */\nexport interface RecordBatchFileReader<T extends { [key: string]: DataType } = any> extends RecordBatchStreamReader<T> {\n    footer: Footer;\n    readRecordBatch(index: number): RecordBatch<T> | null;\n}\n\n/** @ignore */\nexport interface AsyncRecordBatchFileReader<T extends { [key: string]: DataType } = any> extends AsyncRecordBatchStreamReader<T> {\n    footer: Footer;\n    readRecordBatch(index: number): Promise<RecordBatch<T> | null>;\n}\n\n/** @ignore */\ntype RecordBatchReaderImpls<T extends { [key: string]: DataType } = any> =\n     RecordBatchJSONReaderImpl<T> |\n     RecordBatchFileReaderImpl<T> |\n     RecordBatchStreamReaderImpl<T> |\n     AsyncRecordBatchFileReaderImpl<T> |\n     AsyncRecordBatchStreamReaderImpl<T>;\n\n/** @ignore */\ninterface RecordBatchReaderImpl<T extends { [key: string]: DataType } = any> {\n\n    closed: boolean;\n    schema: Schema<T>;\n    autoDestroy: boolean;\n    dictionaries: Map<number, Vector>;\n\n    isFile(): this is RecordBatchFileReaders<T>;\n    isStream(): this is RecordBatchStreamReaders<T>;\n    isSync(): this is RecordBatchReaders<T>;\n    isAsync(): this is AsyncRecordBatchReaders<T>;\n\n    reset(schema?: Schema<T> | null): this;\n}\n\n/** @ignore */\ninterface RecordBatchStreamReaderImpl<T extends { [key: string]: DataType } = any> extends RecordBatchReaderImpl<T> {\n\n    open(options?: OpenOptions): this;\n    cancel(): void;\n\n    throw(value?: any): IteratorResult<any>;\n    return(value?: any): IteratorResult<any>;\n    next(value?: any): IteratorResult<RecordBatch<T>>;\n\n    [Symbol.iterator](): IterableIterator<RecordBatch<T>>;\n}\n\n/** @ignore */\ninterface AsyncRecordBatchStreamReaderImpl<T extends { [key: string]: DataType } = any> extends RecordBatchReaderImpl<T> {\n\n    open(options?: OpenOptions): Promise<this>;\n    cancel(): Promise<void>;\n\n    throw(value?: any): Promise<IteratorResult<any>>;\n    return(value?: any): Promise<IteratorResult<any>>;\n    next(value?: any): Promise<IteratorResult<RecordBatch<T>>>;\n\n    [Symbol.asyncIterator](): AsyncIterableIterator<RecordBatch<T>>;\n}\n\n/** @ignore */\ninterface RecordBatchFileReaderImpl<T extends { [key: string]: DataType } = any> extends RecordBatchStreamReaderImpl<T> {\n    readRecordBatch(index: number): RecordBatch<T> | null;\n}\n\n/** @ignore */\ninterface AsyncRecordBatchFileReaderImpl<T extends { [key: string]: DataType } = any> extends AsyncRecordBatchStreamReaderImpl<T> {\n    readRecordBatch(index: number): Promise<RecordBatch<T> | null>;\n}\n\n/** @ignore */\nabstract class RecordBatchReaderImpl<T extends { [key: string]: DataType } = any> implements RecordBatchReaderImpl<T> {\n\n    // @ts-ignore\n    public schema: Schema;\n    public closed = false;\n    public autoDestroy = true;\n    public dictionaries: Map<number, Vector>;\n\n    protected _dictionaryIndex = 0;\n    protected _recordBatchIndex = 0;\n    public get numDictionaries() { return this._dictionaryIndex; }\n    public get numRecordBatches() { return this._recordBatchIndex; }\n\n    constructor(dictionaries = new Map<number, Vector>()) {\n        this.dictionaries = dictionaries;\n    }\n\n    public isSync(): this is RecordBatchReaders<T> { return false; }\n    public isAsync(): this is AsyncRecordBatchReaders<T> { return false; }\n    public isFile(): this is RecordBatchFileReaders<T> { return false; }\n    public isStream(): this is RecordBatchStreamReaders<T> { return false; }\n\n    public reset(schema?: Schema<T> | null) {\n        this._dictionaryIndex = 0;\n        this._recordBatchIndex = 0;\n        this.schema = <any> schema;\n        this.dictionaries = new Map();\n        return this;\n    }\n\n    protected _loadRecordBatch(header: metadata.RecordBatch, body: any) {\n        return new RecordBatch<T>(this.schema, header.length, this._loadVectors(header, body, this.schema.fields));\n    }\n    protected _loadDictionaryBatch(header: metadata.DictionaryBatch, body: any) {\n        const { id, isDelta, data } = header;\n        const { dictionaries, schema } = this;\n        const dictionary = dictionaries.get(id);\n        if (isDelta || !dictionary) {\n            const type = schema.dictionaries.get(id)!;\n            return (dictionary && isDelta ? dictionary.concat(\n                Vector.new(this._loadVectors(data, body, [type])[0])) :\n                Vector.new(this._loadVectors(data, body, [type])[0])) as Vector;\n        }\n        return dictionary;\n    }\n    protected _loadVectors(header: metadata.RecordBatch, body: any, types: (Field | DataType)[]) {\n        return new VectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);\n    }\n}\n\n/** @ignore */\nclass RecordBatchStreamReaderImpl<T extends { [key: string]: DataType } = any> extends RecordBatchReaderImpl<T> implements IterableIterator<RecordBatch<T>> {\n\n    protected _reader: MessageReader;\n    protected _handle: ByteStream | ArrowJSONLike;\n\n    constructor(source: ByteStream | ArrowJSONLike, dictionaries?: Map<number, Vector>) {\n        super(dictionaries);\n        this._reader = !isArrowJSON(source)\n            ? new MessageReader(this._handle = source)\n            : new JSONMessageReader(this._handle = source);\n    }\n\n    public isSync(): this is RecordBatchReaders<T> { return true; }\n    public isStream(): this is RecordBatchStreamReaders<T> { return true; }\n    public [Symbol.iterator](): IterableIterator<RecordBatch<T>> {\n        return this as IterableIterator<RecordBatch<T>>;\n    }\n    public cancel() {\n        if (!this.closed && (this.closed = true)) {\n            this.reset()._reader.return();\n            this._reader = <any> null;\n            this.dictionaries = <any> null;\n        }\n    }\n    public open(options?: OpenOptions) {\n        if (!this.closed) {\n            this.autoDestroy = shouldAutoDestroy(this, options);\n            if (!(this.schema || (this.schema = this._reader.readSchema()!))) {\n                this.cancel();\n            }\n        }\n        return this;\n    }\n    public throw(value?: any): IteratorResult<any> {\n        if (!this.closed && this.autoDestroy && (this.closed = true)) {\n            return this.reset()._reader.throw(value);\n        }\n        return ITERATOR_DONE;\n    }\n    public return(value?: any): IteratorResult<any> {\n        if (!this.closed && this.autoDestroy && (this.closed = true)) {\n            return this.reset()._reader.return(value);\n        }\n        return ITERATOR_DONE;\n    }\n    public next(): IteratorResult<RecordBatch<T>> {\n        if (this.closed) { return ITERATOR_DONE; }\n        let message: Message | null, { _reader: reader } = this;\n        while (message = this._readNextMessageAndValidate()) {\n            if (message.isSchema()) {\n                this.reset(message.header());\n            } else if (message.isRecordBatch()) {\n                this._recordBatchIndex++;\n                const header = message.header();\n                const buffer = reader.readMessageBody(message.bodyLength);\n                const recordBatch = this._loadRecordBatch(header, buffer);\n                return { done: false, value: recordBatch };\n            } else if (message.isDictionaryBatch()) {\n                this._dictionaryIndex++;\n                const header = message.header();\n                const buffer = reader.readMessageBody(message.bodyLength);\n                const vector = this._loadDictionaryBatch(header, buffer);\n                this.dictionaries.set(header.id, vector);\n            }\n        }\n        if (this.schema && this._recordBatchIndex === 0) {\n            this._recordBatchIndex++;\n            return { done: false, value: new _InternalEmptyPlaceholderRecordBatch<T>(this.schema) };\n        }\n        return this.return();\n    }\n    protected _readNextMessageAndValidate<T extends MessageHeader>(type?: T | null) {\n        return this._reader.readMessage<T>(type);\n    }\n}\n\n/** @ignore */\nclass AsyncRecordBatchStreamReaderImpl<T extends { [key: string]: DataType } = any> extends RecordBatchReaderImpl<T> implements AsyncIterableIterator<RecordBatch<T>> {\n\n    protected _handle: AsyncByteStream;\n    protected _reader: AsyncMessageReader;\n\n    constructor(source: AsyncByteStream, dictionaries?: Map<number, Vector>) {\n        super(dictionaries);\n        this._reader = new AsyncMessageReader(this._handle = source);\n    }\n    public isAsync(): this is AsyncRecordBatchReaders<T> { return true; }\n    public isStream(): this is RecordBatchStreamReaders<T> { return true; }\n    public [Symbol.asyncIterator](): AsyncIterableIterator<RecordBatch<T>> {\n        return this as AsyncIterableIterator<RecordBatch<T>>;\n    }\n    public async cancel() {\n        if (!this.closed && (this.closed = true)) {\n            await this.reset()._reader.return();\n            this._reader = <any> null;\n            this.dictionaries = <any> null;\n        }\n    }\n    public async open(options?: OpenOptions) {\n        if (!this.closed) {\n            this.autoDestroy = shouldAutoDestroy(this, options);\n            if (!(this.schema || (this.schema = (await this._reader.readSchema())!))) {\n                await this.cancel();\n            }\n        }\n        return this;\n    }\n    public async throw(value?: any): Promise<IteratorResult<any>> {\n        if (!this.closed && this.autoDestroy && (this.closed = true)) {\n            return await this.reset()._reader.throw(value);\n        }\n        return ITERATOR_DONE;\n    }\n    public async return(value?: any): Promise<IteratorResult<any>> {\n        if (!this.closed && this.autoDestroy && (this.closed = true)) {\n            return await this.reset()._reader.return(value);\n        }\n        return ITERATOR_DONE;\n    }\n    public async next() {\n        if (this.closed) { return ITERATOR_DONE; }\n        let message: Message | null, { _reader: reader } = this;\n        while (message = await this._readNextMessageAndValidate()) {\n            if (message.isSchema()) {\n                await this.reset(message.header());\n            } else if (message.isRecordBatch()) {\n                this._recordBatchIndex++;\n                const header = message.header();\n                const buffer = await reader.readMessageBody(message.bodyLength);\n                const recordBatch = this._loadRecordBatch(header, buffer);\n                return { done: false, value: recordBatch };\n            } else if (message.isDictionaryBatch()) {\n                this._dictionaryIndex++;\n                const header = message.header();\n                const buffer = await reader.readMessageBody(message.bodyLength);\n                const vector = this._loadDictionaryBatch(header, buffer);\n                this.dictionaries.set(header.id, vector);\n            }\n        }\n        if (this.schema && this._recordBatchIndex === 0) {\n            this._recordBatchIndex++;\n            return { done: false, value: new _InternalEmptyPlaceholderRecordBatch<T>(this.schema) };\n        }\n        return await this.return();\n    }\n    protected async _readNextMessageAndValidate<T extends MessageHeader>(type?: T | null) {\n        return await this._reader.readMessage<T>(type);\n    }\n}\n\n/** @ignore */\nclass RecordBatchFileReaderImpl<T extends { [key: string]: DataType } = any> extends RecordBatchStreamReaderImpl<T> {\n\n    // @ts-ignore\n    protected _footer?: Footer;\n    // @ts-ignore\n    protected _handle: RandomAccessFile;\n    public get footer() { return this._footer!; }\n    public get numDictionaries() { return this._footer ? this._footer.numDictionaries : 0; }\n    public get numRecordBatches() { return this._footer ? this._footer.numRecordBatches : 0; }\n\n    constructor(source: RandomAccessFile | ArrayBufferViewInput, dictionaries?: Map<number, Vector>) {\n        super(source instanceof RandomAccessFile ? source : new RandomAccessFile(source), dictionaries);\n    }\n    public isSync(): this is RecordBatchReaders<T> { return true; }\n    public isFile(): this is RecordBatchFileReaders<T> { return true; }\n    public open(options?: OpenOptions) {\n        if (!this.closed && !this._footer) {\n            this.schema = (this._footer = this._readFooter()).schema;\n            for (const block of this._footer.dictionaryBatches()) {\n                block && this._readDictionaryBatch(this._dictionaryIndex++);\n            }\n        }\n        return super.open(options);\n    }\n    public readRecordBatch(index: number) {\n        if (this.closed) { return null; }\n        if (!this._footer) { this.open(); }\n        const block = this._footer && this._footer.getRecordBatch(index);\n        if (block && this._handle.seek(block.offset)) {\n            const message = this._reader.readMessage(MessageHeader.RecordBatch);\n            if (message && message.isRecordBatch()) {\n                const header = message.header();\n                const buffer = this._reader.readMessageBody(message.bodyLength);\n                const recordBatch = this._loadRecordBatch(header, buffer);\n                return recordBatch;\n            }\n        }\n        return null;\n    }\n    protected _readDictionaryBatch(index: number) {\n        const block = this._footer && this._footer.getDictionaryBatch(index);\n        if (block && this._handle.seek(block.offset)) {\n            const message = this._reader.readMessage(MessageHeader.DictionaryBatch);\n            if (message && message.isDictionaryBatch()) {\n                const header = message.header();\n                const buffer = this._reader.readMessageBody(message.bodyLength);\n                const vector = this._loadDictionaryBatch(header, buffer);\n                this.dictionaries.set(header.id, vector);\n            }\n        }\n    }\n    protected _readFooter() {\n        const { _handle } = this;\n        const offset = _handle.size - magicAndPadding;\n        const length = _handle.readInt32(offset);\n        const buffer = _handle.readAt(offset - length, length);\n        return Footer.decode(buffer);\n    }\n    protected _readNextMessageAndValidate<T extends MessageHeader>(type?: T | null): Message<T> | null {\n        if (!this._footer) { this.open(); }\n        if (this._footer && this._recordBatchIndex < this.numRecordBatches) {\n            const block = this._footer && this._footer.getRecordBatch(this._recordBatchIndex);\n            if (block && this._handle.seek(block.offset)) {\n                return this._reader.readMessage(type);\n            }\n        }\n        return null;\n    }\n}\n\n/** @ignore */\nclass AsyncRecordBatchFileReaderImpl<T extends { [key: string]: DataType } = any> extends AsyncRecordBatchStreamReaderImpl<T>\n    implements AsyncRecordBatchFileReaderImpl<T> {\n\n    protected _footer?: Footer;\n    // @ts-ignore\n    protected _handle: AsyncRandomAccessFile;\n    public get footer() { return this._footer!; }\n    public get numDictionaries() { return this._footer ? this._footer.numDictionaries : 0; }\n    public get numRecordBatches() { return this._footer ? this._footer.numRecordBatches : 0; }\n\n    constructor(source: FileHandle, byteLength?: number, dictionaries?: Map<number, Vector>);\n    constructor(source: FileHandle | AsyncRandomAccessFile, dictionaries?: Map<number, Vector>);\n    constructor(source: FileHandle | AsyncRandomAccessFile, ...rest: any[]) {\n        const byteLength = typeof rest[0] !== 'number' ? <number> rest.shift() : undefined;\n        const dictionaries = rest[0] instanceof Map ? <Map<number, Vector>> rest.shift() : undefined;\n        super(source instanceof AsyncRandomAccessFile ? source : new AsyncRandomAccessFile(source, byteLength), dictionaries);\n    }\n    public isFile(): this is RecordBatchFileReaders<T> { return true; }\n    public isAsync(): this is AsyncRecordBatchReaders<T> { return true; }\n    public async open(options?: OpenOptions) {\n        if (!this.closed && !this._footer) {\n            this.schema = (this._footer = await this._readFooter()).schema;\n            for (const block of this._footer.dictionaryBatches()) {\n                block && await this._readDictionaryBatch(this._dictionaryIndex++);\n            }\n        }\n        return await super.open(options);\n    }\n    public async readRecordBatch(index: number) {\n        if (this.closed) { return null; }\n        if (!this._footer) { await this.open(); }\n        const block = this._footer && this._footer.getRecordBatch(index);\n        if (block && (await this._handle.seek(block.offset))) {\n            const message = await this._reader.readMessage(MessageHeader.RecordBatch);\n            if (message && message.isRecordBatch()) {\n                const header = message.header();\n                const buffer = await this._reader.readMessageBody(message.bodyLength);\n                const recordBatch = this._loadRecordBatch(header, buffer);\n                return recordBatch;\n            }\n        }\n        return null;\n    }\n    protected async _readDictionaryBatch(index: number) {\n        const block = this._footer && this._footer.getDictionaryBatch(index);\n        if (block && (await this._handle.seek(block.offset))) {\n            const message = await this._reader.readMessage(MessageHeader.DictionaryBatch);\n            if (message && message.isDictionaryBatch()) {\n                const header = message.header();\n                const buffer = await this._reader.readMessageBody(message.bodyLength);\n                const vector = this._loadDictionaryBatch(header, buffer);\n                this.dictionaries.set(header.id, vector);\n            }\n        }\n    }\n    protected async _readFooter() {\n        const { _handle } = this;\n        _handle._pending && await _handle._pending;\n        const offset = _handle.size - magicAndPadding;\n        const length = await _handle.readInt32(offset);\n        const buffer = await _handle.readAt(offset - length, length);\n        return Footer.decode(buffer);\n    }\n    protected async _readNextMessageAndValidate<T extends MessageHeader>(type?: T | null): Promise<Message<T> | null> {\n        if (!this._footer) { await this.open(); }\n        if (this._footer && this._recordBatchIndex < this.numRecordBatches) {\n            const block = this._footer.getRecordBatch(this._recordBatchIndex);\n            if (block && await this._handle.seek(block.offset)) {\n                return await this._reader.readMessage(type);\n            }\n        }\n        return null;\n    }\n}\n\n/** @ignore */\nclass RecordBatchJSONReaderImpl<T extends { [key: string]: DataType } = any> extends RecordBatchStreamReaderImpl<T> {\n    constructor(source: ArrowJSONLike, dictionaries?: Map<number, Vector>) {\n        super(source, dictionaries);\n    }\n    protected _loadVectors(header: metadata.RecordBatch, body: any, types: (Field | DataType)[]) {\n        return new JSONVectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);\n    }\n}\n\n//\n// Define some helper functions and static implementations down here. There's\n// a bit of branching in the static methods that can lead to the same routines\n// being executed, so we've broken those out here for readability.\n//\n\n/** @ignore */\nfunction shouldAutoDestroy(self: { autoDestroy: boolean }, options?: OpenOptions) {\n    return options && (typeof options['autoDestroy'] === 'boolean') ? options['autoDestroy'] : self['autoDestroy'];\n}\n\n/** @ignore */\nfunction* readAllSync<T extends { [key: string]: DataType } = any>(source: RecordBatchReaders<T> | FromArg0 | FromArg2) {\n    const reader = RecordBatchReader.from<T>(<any> source) as RecordBatchReaders<T>;\n    try {\n        if (!reader.open({ autoDestroy: false }).closed) {\n            do { yield reader; } while (!(reader.reset().open()).closed);\n        }\n    } finally { reader.cancel(); }\n}\n\n/** @ignore */\nasync function* readAllAsync<T extends { [key: string]: DataType } = any>(source: AsyncRecordBatchReaders<T> | FromArg1 | FromArg3 | FromArg4 | FromArg5) {\n    const reader = await RecordBatchReader.from<T>(<any> source) as RecordBatchReader<T>;\n    try {\n        if (!(await reader.open({ autoDestroy: false })).closed) {\n            do { yield reader; } while (!(await reader.reset().open()).closed);\n        }\n    } finally { await reader.cancel(); }\n}\n\n/** @ignore */\nfunction fromArrowJSON<T extends { [key: string]: DataType }>(source: ArrowJSONLike) {\n    return new RecordBatchStreamReader(new RecordBatchJSONReaderImpl<T>(source));\n}\n\n/** @ignore */\nfunction fromByteStream<T extends { [key: string]: DataType }>(source: ByteStream) {\n    const bytes = source.peek((magicLength + 7) & ~7);\n    return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes)\n        ? new RecordBatchStreamReader(new RecordBatchStreamReaderImpl<T>(source))\n        : new RecordBatchFileReader(new RecordBatchFileReaderImpl<T>(source.read()))\n        : new RecordBatchStreamReader(new RecordBatchStreamReaderImpl<T>(function*(): any {}()));\n}\n\n/** @ignore */\nasync function fromAsyncByteStream<T extends { [key: string]: DataType }>(source: AsyncByteStream) {\n    const bytes = await source.peek((magicLength + 7) & ~7);\n    return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes)\n        ? new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl<T>(source))\n        : new RecordBatchFileReader(new RecordBatchFileReaderImpl<T>(await source.read()))\n        : new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl<T>(async function*(): any {}()));\n}\n\n/** @ignore */\nasync function fromFileHandle<T extends { [key: string]: DataType }>(source: FileHandle) {\n    const { size } = await source.stat();\n    const file = new AsyncRandomAccessFile(source, size);\n    if (size >= magicX2AndPadding) {\n        if (checkForMagicArrowString(await file.readAt(0, (magicLength + 7) & ~7))) {\n            return new AsyncRecordBatchFileReader(new AsyncRecordBatchFileReaderImpl<T>(file));\n        }\n    }\n    return new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl<T>(file));\n}\n"]},"metadata":{},"sourceType":"module"}