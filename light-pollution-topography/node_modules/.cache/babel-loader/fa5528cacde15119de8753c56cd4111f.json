{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport Buffer from '../classes/buffer';\nimport { getKey } from '../webgl-utils';\nimport { getCompositeGLType } from '../webgl-utils/attribute-utils';\nimport { formatValue } from '../utils';\nexport function getDebugTableForVertexArray() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      vertexArray = _ref.vertexArray,\n      _ref$header = _ref.header,\n      header = _ref$header === void 0 ? 'Attributes' : _ref$header;\n\n  if (!vertexArray.configuration) {\n    return {};\n  }\n\n  var table = {};\n\n  if (vertexArray.elements) {\n    table.ELEMENT_ARRAY_BUFFER = getDebugTableRow(vertexArray, vertexArray.elements, null, header);\n  }\n\n  var attributes = vertexArray.values;\n\n  for (var attributeLocation in attributes) {\n    var info = vertexArray._getAttributeInfo(attributeLocation);\n\n    if (info) {\n      var rowHeader = \"\".concat(attributeLocation, \": \").concat(info.name);\n      var accessor = vertexArray.accessors[info.location];\n\n      if (accessor) {\n        rowHeader = \"\".concat(attributeLocation, \": \").concat(getGLSLDeclaration(info.name, accessor));\n      }\n\n      table[rowHeader] = getDebugTableRow(vertexArray, attributes[attributeLocation], accessor, header);\n    }\n  }\n\n  return table;\n}\n\nfunction getDebugTableRow(vertexArray, attribute, accessor, header) {\n  var _ref4;\n\n  var gl = vertexArray.gl;\n\n  if (!attribute) {\n    var _ref2;\n\n    return _ref2 = {}, _defineProperty(_ref2, header, 'null'), _defineProperty(_ref2, 'Format ', 'N/A'), _ref2;\n  }\n\n  var type = 'NOT PROVIDED';\n  var size = 'N/A';\n  var verts = 'N/A';\n  var bytes = 'N/A';\n  var isInteger;\n  var marker;\n  var value;\n\n  if (accessor) {\n    type = accessor.type;\n    size = accessor.size;\n    type = String(type).replace('Array', '');\n    isInteger = type.indexOf('nt') !== -1;\n  }\n\n  if (attribute instanceof Buffer) {\n    var _ref3;\n\n    var buffer = attribute;\n\n    var _buffer$getDebugData = buffer.getDebugData(),\n        data = _buffer$getDebugData.data,\n        modified = _buffer$getDebugData.modified;\n\n    marker = modified ? '*' : '';\n    value = data;\n    bytes = buffer.byteLength;\n    verts = bytes / data.BYTES_PER_ELEMENT / size;\n    var format;\n\n    if (accessor) {\n      var instanced = accessor.divisor > 0;\n      format = \"\".concat(instanced ? 'I ' : 'P ', \" \").concat(verts, \" (x\").concat(size, \"=\").concat(bytes, \" bytes \").concat(getKey(gl, type), \")\");\n    } else {\n      isInteger = true;\n      format = \"\".concat(bytes, \" bytes\");\n    }\n\n    return _ref3 = {}, _defineProperty(_ref3, header, \"\".concat(marker).concat(formatValue(value, {\n      size: size,\n      isInteger: isInteger\n    }))), _defineProperty(_ref3, 'Format ', format), _ref3;\n  }\n\n  value = attribute;\n  size = attribute.length;\n  type = String(attribute.constructor.name).replace('Array', '');\n  isInteger = type.indexOf('nt') !== -1;\n  return _ref4 = {}, _defineProperty(_ref4, header, \"\".concat(formatValue(value, {\n    size: size,\n    isInteger: isInteger\n  }), \" (constant)\")), _defineProperty(_ref4, 'Format ', \"\".concat(size, \"x\").concat(type, \" (constant)\")), _ref4;\n}\n\nfunction getGLSLDeclaration(name, accessor) {\n  var type = accessor.type,\n      size = accessor.size;\n  var typeAndName = getCompositeGLType(type, size);\n  return typeAndName ? \"\".concat(name, \" (\").concat(typeAndName.name, \")\") : name;\n}","map":{"version":3,"sources":["../../../src/debug/debug-vertex-array.js"],"names":["vertexArray","header","table","getDebugTableRow","attributes","info","rowHeader","accessor","getGLSLDeclaration","gl","type","size","verts","bytes","String","isInteger","attribute","buffer","data","modified","marker","value","instanced","format","getKey","formatValue","typeAndName","getCompositeGLType"],"mappings":"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","sourcesContent":["import Buffer from '../classes/buffer';\nimport {getKey} from '../webgl-utils';\nimport {getCompositeGLType} from '../webgl-utils/attribute-utils';\nimport {formatValue} from '../utils';\n\n// Creates object suitable as input for console.table\nexport function getDebugTableForVertexArray({vertexArray, header = 'Attributes'} = {}) {\n  if (!vertexArray.configuration) {\n    return {};\n  }\n\n  const table = {}; // {[header]: {}};\n\n  // Add index (elements) if available\n  if (vertexArray.elements) {\n    // const elements = Object.assign({size: 1}, vertexArray.elements);\n    table.ELEMENT_ARRAY_BUFFER = getDebugTableRow(vertexArray, vertexArray.elements, null, header);\n  }\n\n  // Add used attributes\n  const attributes = vertexArray.values;\n\n  for (const attributeLocation in attributes) {\n    const info = vertexArray._getAttributeInfo(attributeLocation);\n    if (info) {\n      let rowHeader = `${attributeLocation}: ${info.name}`;\n      const accessor = vertexArray.accessors[info.location];\n      if (accessor) {\n        rowHeader = `${attributeLocation}: ${getGLSLDeclaration(info.name, accessor)}`;\n      }\n      table[rowHeader] = getDebugTableRow(\n        vertexArray,\n        attributes[attributeLocation],\n        accessor,\n        header\n      );\n    }\n  }\n\n  return table;\n}\n\n/* eslint-disable max-statements */\nfunction getDebugTableRow(vertexArray, attribute, accessor, header) {\n  const {gl} = vertexArray;\n\n  if (!attribute) {\n    return {\n      [header]: 'null',\n      'Format ': 'N/A'\n    };\n  }\n\n  let type = 'NOT PROVIDED';\n  let size = 'N/A';\n  let verts = 'N/A';\n  let bytes = 'N/A';\n\n  let isInteger;\n  let marker;\n  let value;\n\n  if (accessor) {\n    type = accessor.type;\n    size = accessor.size;\n\n    // Generate a type name by dropping Array from Float32Array etc.\n    type = String(type).replace('Array', '');\n\n    // Look for 'nt' to detect integer types, e.g. Int32Array, Uint32Array\n    isInteger = type.indexOf('nt') !== -1;\n  }\n\n  if (attribute instanceof Buffer) {\n    const buffer = attribute;\n\n    const {data, modified} = buffer.getDebugData();\n    marker = modified ? '*' : '';\n\n    value = data;\n    bytes = buffer.byteLength;\n    verts = bytes / data.BYTES_PER_ELEMENT / size;\n\n    let format;\n\n    if (accessor) {\n      const instanced = accessor.divisor > 0;\n      format = `${instanced ? 'I ' : 'P '} ${verts} (x${size}=${bytes} bytes ${getKey(gl, type)})`;\n    } else {\n      // element buffer\n      isInteger = true;\n      format = `${bytes} bytes`;\n    }\n\n    return {\n      [header]: `${marker}${formatValue(value, {size, isInteger})}`,\n      'Format ': format\n    };\n  }\n\n  // CONSTANT VALUE\n  value = attribute;\n  size = attribute.length;\n  // Generate a type name by dropping Array from Float32Array etc.\n  type = String(attribute.constructor.name).replace('Array', '');\n  // Look for 'nt' to detect integer types, e.g. Int32Array, Uint32Array\n  isInteger = type.indexOf('nt') !== -1;\n\n  return {\n    [header]: `${formatValue(value, {size, isInteger})} (constant)`,\n    'Format ': `${size}x${type} (constant)`\n  };\n}\n/* eslint-ensable max-statements */\n\nfunction getGLSLDeclaration(name, accessor) {\n  const {type, size} = accessor;\n  const typeAndName = getCompositeGLType(type, size);\n  return typeAndName ? `${name} (${typeAndName.name})` : name;\n}\n"]},"metadata":{},"sourceType":"module"}