{"ast":null,"code":"import _classCallCheck from \"/dev/shm/wikidatageo/light-pollution-topography/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/dev/shm/wikidatageo/light-pollution-topography/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nvar Martini = /*#__PURE__*/function () {\n  function Martini() {\n    var gridSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 257;\n\n    _classCallCheck(this, Martini);\n\n    this.gridSize = gridSize;\n    var tileSize = gridSize - 1;\n    if (tileSize & tileSize - 1) throw new Error(\"Expected grid size to be 2^n+1, got \".concat(gridSize, \".\"));\n    this.numTriangles = tileSize * tileSize * 2 - 2;\n    this.numParentTriangles = this.numTriangles - tileSize * tileSize;\n    this.indices = new Uint32Array(this.gridSize * this.gridSize); // coordinates for all possible triangles in an RTIN tile\n\n    this.coords = new Uint16Array(this.numTriangles * 4); // get triangle coordinates from its index in an implicit binary tree\n\n    for (var i = 0; i < this.numTriangles; i++) {\n      var id = i + 2;\n      var ax = 0,\n          ay = 0,\n          bx = 0,\n          by = 0,\n          cx = 0,\n          cy = 0;\n\n      if (id & 1) {\n        bx = by = cx = tileSize; // bottom-left triangle\n      } else {\n        ax = ay = cy = tileSize; // top-right triangle\n      }\n\n      while ((id >>= 1) > 1) {\n        var mx = ax + bx >> 1;\n        var my = ay + by >> 1;\n\n        if (id & 1) {\n          // left half\n          bx = ax;\n          by = ay;\n          ax = cx;\n          ay = cy;\n        } else {\n          // right half\n          ax = bx;\n          ay = by;\n          bx = cx;\n          by = cy;\n        }\n\n        cx = mx;\n        cy = my;\n      }\n\n      var k = i * 4;\n      this.coords[k + 0] = ax;\n      this.coords[k + 1] = ay;\n      this.coords[k + 2] = bx;\n      this.coords[k + 3] = by;\n    }\n  }\n\n  _createClass(Martini, [{\n    key: \"createTile\",\n    value: function createTile(terrain) {\n      return new Tile(terrain, this);\n    }\n  }]);\n\n  return Martini;\n}();\n\nexport { Martini as default };\n\nvar Tile = /*#__PURE__*/function () {\n  function Tile(terrain, martini) {\n    _classCallCheck(this, Tile);\n\n    var size = martini.gridSize;\n    if (terrain.length !== size * size) throw new Error(\"Expected terrain data of length \".concat(size * size, \" (\").concat(size, \" x \").concat(size, \"), got \").concat(terrain.length, \".\"));\n    this.terrain = terrain;\n    this.martini = martini;\n    this.errors = new Float32Array(terrain.length);\n    this.update();\n  }\n\n  _createClass(Tile, [{\n    key: \"update\",\n    value: function update() {\n      var _this$martini = this.martini,\n          numTriangles = _this$martini.numTriangles,\n          numParentTriangles = _this$martini.numParentTriangles,\n          coords = _this$martini.coords,\n          size = _this$martini.gridSize;\n      var terrain = this.terrain,\n          errors = this.errors; // iterate over all possible triangles, starting from the smallest level\n\n      for (var i = numTriangles - 1; i >= 0; i--) {\n        var k = i * 4;\n        var ax = coords[k + 0];\n        var ay = coords[k + 1];\n        var bx = coords[k + 2];\n        var by = coords[k + 3];\n        var mx = ax + bx >> 1;\n        var my = ay + by >> 1;\n        var cx = mx + my - ay;\n        var cy = my + ax - mx; // calculate error in the middle of the long edge of the triangle\n\n        var interpolatedHeight = (terrain[ay * size + ax] + terrain[by * size + bx]) / 2;\n        var middleIndex = my * size + mx;\n        var middleError = Math.abs(interpolatedHeight - terrain[middleIndex]);\n        errors[middleIndex] = Math.max(errors[middleIndex], middleError);\n\n        if (i < numParentTriangles) {\n          // bigger triangles; accumulate error with children\n          var leftChildIndex = (ay + cy >> 1) * size + (ax + cx >> 1);\n          var rightChildIndex = (by + cy >> 1) * size + (bx + cx >> 1);\n          errors[middleIndex] = Math.max(errors[middleIndex], errors[leftChildIndex], errors[rightChildIndex]);\n        }\n      }\n    }\n  }, {\n    key: \"getMesh\",\n    value: function getMesh() {\n      var maxError = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var _this$martini2 = this.martini,\n          size = _this$martini2.gridSize,\n          indices = _this$martini2.indices;\n      var errors = this.errors;\n      var numVertices = 0;\n      var numTriangles = 0;\n      var max = size - 1; // use an index grid to keep track of vertices that were already used to avoid duplication\n\n      indices.fill(0); // retrieve mesh in two stages that both traverse the error map:\n      // - countElements: find used vertices (and assign each an index), and count triangles (for minimum allocation)\n      // - processTriangle: fill the allocated vertices & triangles typed arrays\n\n      function countElements(ax, ay, bx, by, cx, cy) {\n        var mx = ax + bx >> 1;\n        var my = ay + by >> 1;\n\n        if (Math.abs(ax - cx) + Math.abs(ay - cy) > 1 && errors[my * size + mx] > maxError) {\n          countElements(cx, cy, ax, ay, mx, my);\n          countElements(bx, by, cx, cy, mx, my);\n        } else {\n          indices[ay * size + ax] = indices[ay * size + ax] || ++numVertices;\n          indices[by * size + bx] = indices[by * size + bx] || ++numVertices;\n          indices[cy * size + cx] = indices[cy * size + cx] || ++numVertices;\n          numTriangles++;\n        }\n      }\n\n      countElements(0, 0, max, max, max, 0);\n      countElements(max, max, 0, 0, 0, max);\n      var vertices = new Uint16Array(numVertices * 2);\n      var triangles = new Uint32Array(numTriangles * 3);\n      var triIndex = 0;\n\n      function processTriangle(ax, ay, bx, by, cx, cy) {\n        var mx = ax + bx >> 1;\n        var my = ay + by >> 1;\n\n        if (Math.abs(ax - cx) + Math.abs(ay - cy) > 1 && errors[my * size + mx] > maxError) {\n          // triangle doesn't approximate the surface well enough; drill down further\n          processTriangle(cx, cy, ax, ay, mx, my);\n          processTriangle(bx, by, cx, cy, mx, my);\n        } else {\n          // add a triangle\n          var a = indices[ay * size + ax] - 1;\n          var b = indices[by * size + bx] - 1;\n          var c = indices[cy * size + cx] - 1;\n          vertices[2 * a] = ax;\n          vertices[2 * a + 1] = ay;\n          vertices[2 * b] = bx;\n          vertices[2 * b + 1] = by;\n          vertices[2 * c] = cx;\n          vertices[2 * c + 1] = cy;\n          triangles[triIndex++] = a;\n          triangles[triIndex++] = b;\n          triangles[triIndex++] = c;\n        }\n      }\n\n      processTriangle(0, 0, max, max, max, 0);\n      processTriangle(max, max, 0, 0, 0, max);\n      return {\n        vertices: vertices,\n        triangles: triangles\n      };\n    }\n  }]);\n\n  return Tile;\n}();","map":{"version":3,"sources":["/dev/shm/wikidatageo/light-pollution-topography/node_modules/@mapbox/martini/index.js"],"names":["Martini","gridSize","tileSize","Error","numTriangles","numParentTriangles","indices","Uint32Array","coords","Uint16Array","i","id","ax","ay","bx","by","cx","cy","mx","my","k","terrain","Tile","martini","size","length","errors","Float32Array","update","interpolatedHeight","middleIndex","middleError","Math","abs","max","leftChildIndex","rightChildIndex","maxError","numVertices","fill","countElements","vertices","triangles","triIndex","processTriangle","a","b","c"],"mappings":"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","sourcesContent":["\nexport default class Martini {\n    constructor(gridSize = 257) {\n        this.gridSize = gridSize;\n        const tileSize = gridSize - 1;\n        if (tileSize & (tileSize - 1)) throw new Error(\n            `Expected grid size to be 2^n+1, got ${gridSize}.`);\n\n        this.numTriangles = tileSize * tileSize * 2 - 2;\n        this.numParentTriangles = this.numTriangles - tileSize * tileSize;\n\n        this.indices = new Uint32Array(this.gridSize * this.gridSize);\n\n        // coordinates for all possible triangles in an RTIN tile\n        this.coords = new Uint16Array(this.numTriangles * 4);\n\n        // get triangle coordinates from its index in an implicit binary tree\n        for (let i = 0; i < this.numTriangles; i++) {\n            let id = i + 2;\n            let ax = 0, ay = 0, bx = 0, by = 0, cx = 0, cy = 0;\n            if (id & 1) {\n                bx = by = cx = tileSize; // bottom-left triangle\n            } else {\n                ax = ay = cy = tileSize; // top-right triangle\n            }\n            while ((id >>= 1) > 1) {\n                const mx = (ax + bx) >> 1;\n                const my = (ay + by) >> 1;\n\n                if (id & 1) { // left half\n                    bx = ax; by = ay;\n                    ax = cx; ay = cy;\n                } else { // right half\n                    ax = bx; ay = by;\n                    bx = cx; by = cy;\n                }\n                cx = mx; cy = my;\n            }\n            const k = i * 4;\n            this.coords[k + 0] = ax;\n            this.coords[k + 1] = ay;\n            this.coords[k + 2] = bx;\n            this.coords[k + 3] = by;\n        }\n    }\n\n    createTile(terrain) {\n        return new Tile(terrain, this);\n    }\n}\n\nclass Tile {\n    constructor(terrain, martini) {\n        const size = martini.gridSize;\n        if (terrain.length !== size * size) throw new Error(\n            `Expected terrain data of length ${size * size} (${size} x ${size}), got ${terrain.length}.`);\n\n        this.terrain = terrain;\n        this.martini = martini;\n        this.errors = new Float32Array(terrain.length);\n        this.update();\n    }\n\n    update() {\n        const {numTriangles, numParentTriangles, coords, gridSize: size} = this.martini;\n        const {terrain, errors} = this;\n\n        // iterate over all possible triangles, starting from the smallest level\n        for (let i = numTriangles - 1; i >= 0; i--) {\n            const k = i * 4;\n            const ax = coords[k + 0];\n            const ay = coords[k + 1];\n            const bx = coords[k + 2];\n            const by = coords[k + 3];\n            const mx = (ax + bx) >> 1;\n            const my = (ay + by) >> 1;\n            const cx = mx + my - ay;\n            const cy = my + ax - mx;\n\n            // calculate error in the middle of the long edge of the triangle\n            const interpolatedHeight = (terrain[ay * size + ax] + terrain[by * size + bx]) / 2;\n            const middleIndex = my * size + mx;\n            const middleError = Math.abs(interpolatedHeight - terrain[middleIndex]);\n\n            errors[middleIndex] = Math.max(errors[middleIndex], middleError);\n\n            if (i < numParentTriangles) { // bigger triangles; accumulate error with children\n                const leftChildIndex = ((ay + cy) >> 1) * size + ((ax + cx) >> 1);\n                const rightChildIndex = ((by + cy) >> 1) * size + ((bx + cx) >> 1);\n                errors[middleIndex] = Math.max(errors[middleIndex], errors[leftChildIndex], errors[rightChildIndex]);\n            }\n        }\n    }\n\n    getMesh(maxError = 0) {\n        const {gridSize: size, indices} = this.martini;\n        const {errors} = this;\n        let numVertices = 0;\n        let numTriangles = 0;\n        const max = size - 1;\n\n        // use an index grid to keep track of vertices that were already used to avoid duplication\n        indices.fill(0);\n\n        // retrieve mesh in two stages that both traverse the error map:\n        // - countElements: find used vertices (and assign each an index), and count triangles (for minimum allocation)\n        // - processTriangle: fill the allocated vertices & triangles typed arrays\n\n        function countElements(ax, ay, bx, by, cx, cy) {\n            const mx = (ax + bx) >> 1;\n            const my = (ay + by) >> 1;\n\n            if (Math.abs(ax - cx) + Math.abs(ay - cy) > 1 && errors[my * size + mx] > maxError) {\n                countElements(cx, cy, ax, ay, mx, my);\n                countElements(bx, by, cx, cy, mx, my);\n            } else {\n                indices[ay * size + ax] = indices[ay * size + ax] || ++numVertices;\n                indices[by * size + bx] = indices[by * size + bx] || ++numVertices;\n                indices[cy * size + cx] = indices[cy * size + cx] || ++numVertices;\n                numTriangles++;\n            }\n        }\n        countElements(0, 0, max, max, max, 0);\n        countElements(max, max, 0, 0, 0, max);\n\n        const vertices = new Uint16Array(numVertices * 2);\n        const triangles = new Uint32Array(numTriangles * 3);\n        let triIndex = 0;\n\n        function processTriangle(ax, ay, bx, by, cx, cy) {\n            const mx = (ax + bx) >> 1;\n            const my = (ay + by) >> 1;\n\n            if (Math.abs(ax - cx) + Math.abs(ay - cy) > 1 && errors[my * size + mx] > maxError) {\n                // triangle doesn't approximate the surface well enough; drill down further\n                processTriangle(cx, cy, ax, ay, mx, my);\n                processTriangle(bx, by, cx, cy, mx, my);\n\n            } else {\n                // add a triangle\n                const a = indices[ay * size + ax] - 1;\n                const b = indices[by * size + bx] - 1;\n                const c = indices[cy * size + cx] - 1;\n\n                vertices[2 * a] = ax;\n                vertices[2 * a + 1] = ay;\n\n                vertices[2 * b] = bx;\n                vertices[2 * b + 1] = by;\n\n                vertices[2 * c] = cx;\n                vertices[2 * c + 1] = cy;\n\n                triangles[triIndex++] = a;\n                triangles[triIndex++] = b;\n                triangles[triIndex++] = c;\n            }\n        }\n        processTriangle(0, 0, max, max, max, 0);\n        processTriangle(max, max, 0, 0, 0, max);\n\n        return {vertices, triangles};\n    }\n}\n"]},"metadata":{},"sourceType":"module"}