{"ast":null,"code":"import typedArrayManager from './typed-array-manager';\nimport { Vector3 } from 'math.gl';\nexport function createMat4() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\nexport function mod(value, divisor) {\n  var modulus = value % divisor;\n  return modulus < 0 ? divisor + modulus : modulus;\n}\nexport function extractCameraVectors(_ref) {\n  var viewMatrix = _ref.viewMatrix,\n      viewMatrixInverse = _ref.viewMatrixInverse;\n  return {\n    eye: [viewMatrixInverse[12], viewMatrixInverse[13], viewMatrixInverse[14]],\n    direction: [-viewMatrix[2], -viewMatrix[6], -viewMatrix[10]],\n    up: [viewMatrix[1], viewMatrix[5], viewMatrix[9]],\n    right: [viewMatrix[0], viewMatrix[4], viewMatrix[8]]\n  };\n}\nvar cameraPosition = new Vector3();\nvar cameraDirection = new Vector3();\nvar cameraUp = new Vector3();\nvar cameraRight = new Vector3();\nvar nearCenter = new Vector3();\nvar farCenter = new Vector3();\nvar a = new Vector3();\nexport function getFrustumPlanes(_ref2) {\n  var aspect = _ref2.aspect,\n      near = _ref2.near,\n      far = _ref2.far,\n      fovyRadians = _ref2.fovyRadians,\n      position = _ref2.position,\n      direction = _ref2.direction,\n      up = _ref2.up,\n      right = _ref2.right;\n  cameraDirection.copy(direction);\n  var nearFarScale = 1 / cameraDirection.len();\n  cameraDirection.normalize();\n  cameraPosition.copy(position);\n  cameraUp.copy(up);\n  var widthScale = 1 / cameraUp.len();\n  cameraUp.normalize();\n  cameraRight.copy(right).normalize();\n  var nearHeight = 2 * Math.tan(fovyRadians / 2) * near * widthScale;\n  var nearWidth = nearHeight * aspect;\n  nearCenter.copy(cameraDirection).scale(near * nearFarScale).add(cameraPosition);\n  farCenter.copy(cameraDirection).scale(far * nearFarScale).add(cameraPosition);\n  var normal = cameraDirection.clone().negate();\n  var distance = normal.dot(nearCenter);\n  var planes = {\n    near: {\n      distance: distance,\n      normal: normal\n    },\n    far: {\n      distance: cameraDirection.dot(farCenter),\n      normal: cameraDirection.clone()\n    }\n  };\n  a.copy(cameraRight).scale(nearWidth * 0.5).add(nearCenter).subtract(cameraPosition).normalize();\n  normal = new Vector3(a).cross(cameraUp);\n  distance = cameraPosition.dot(normal);\n  planes.right = {\n    normal: normal,\n    distance: distance\n  };\n  a.copy(cameraRight).scale(-nearWidth * 0.5).add(nearCenter).subtract(cameraPosition).normalize();\n  normal = new Vector3(cameraUp).cross(a);\n  distance = cameraPosition.dot(normal);\n  planes.left = {\n    normal: normal,\n    distance: distance\n  };\n  a.copy(cameraUp).scale(nearHeight * 0.5).add(nearCenter).subtract(cameraPosition).normalize();\n  normal = new Vector3(cameraRight).cross(a);\n  distance = cameraPosition.dot(normal);\n  planes.top = {\n    normal: normal,\n    distance: distance\n  };\n  a.copy(cameraUp).scale(-nearHeight * 0.5).add(nearCenter).subtract(cameraPosition).normalize();\n  normal = new Vector3(a).cross(cameraRight);\n  distance = cameraPosition.dot(normal);\n  planes.bottom = {\n    normal: normal,\n    distance: distance\n  };\n  return planes;\n}\nexport function fp64LowPart(x) {\n  return x - Math.fround(x);\n}\nvar scratchArray;\nexport function toDoublePrecisionArray(typedArray, _ref3) {\n  var _ref3$size = _ref3.size,\n      size = _ref3$size === void 0 ? 1 : _ref3$size,\n      _ref3$startIndex = _ref3.startIndex,\n      startIndex = _ref3$startIndex === void 0 ? 0 : _ref3$startIndex,\n      endIndex = _ref3.endIndex;\n\n  if (!Number.isFinite(endIndex)) {\n    endIndex = typedArray.length;\n  }\n\n  var count = (endIndex - startIndex) / size;\n  scratchArray = typedArrayManager.allocate(scratchArray, count, {\n    type: Float32Array,\n    size: size * 2\n  });\n  var sourceIndex = startIndex;\n  var targetIndex = 0;\n\n  while (sourceIndex < endIndex) {\n    for (var j = 0; j < size; j++) {\n      var value = typedArray[sourceIndex++];\n      scratchArray[targetIndex + j] = value;\n      scratchArray[targetIndex + j + size] = fp64LowPart(value);\n    }\n\n    targetIndex += size * 2;\n  }\n\n  return scratchArray.subarray(0, count * size * 2);\n}","map":{"version":3,"sources":["../../../src/utils/math-utils.js"],"names":["modulus","value","divisor","viewMatrix","viewMatrixInverse","eye","direction","up","right","cameraPosition","cameraDirection","cameraUp","cameraRight","nearCenter","farCenter","a","aspect","near","far","fovyRadians","position","nearFarScale","widthScale","nearHeight","Math","nearWidth","normal","distance","planes","x","size","startIndex","endIndex","Number","typedArray","count","scratchArray","type","sourceIndex","targetIndex","j","fp64LowPart"],"mappings":"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","sourcesContent":["// Extensions to math.gl library. Intended to be folded back.\nimport typedArrayManager from './typed-array-manager';\nimport {Vector3} from 'math.gl';\n\n// Helper, avoids low-precision 32 bit matrices from gl-matrix mat4.create()\nexport function createMat4() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\n\nexport function mod(value, divisor) {\n  const modulus = value % divisor;\n  return modulus < 0 ? divisor + modulus : modulus;\n}\n\n// Extract camera vectors (move to math library?)\nexport function extractCameraVectors({viewMatrix, viewMatrixInverse}) {\n  // Read the translation from the inverse view matrix\n  return {\n    eye: [viewMatrixInverse[12], viewMatrixInverse[13], viewMatrixInverse[14]],\n    direction: [-viewMatrix[2], -viewMatrix[6], -viewMatrix[10]],\n    up: [viewMatrix[1], viewMatrix[5], viewMatrix[9]],\n    right: [viewMatrix[0], viewMatrix[4], viewMatrix[8]]\n  };\n}\n\nconst cameraPosition = new Vector3();\nconst cameraDirection = new Vector3();\nconst cameraUp = new Vector3();\nconst cameraRight = new Vector3();\nconst nearCenter = new Vector3();\nconst farCenter = new Vector3();\nconst a = new Vector3();\n\n/* eslint-disable max-statements */\n\n// Extract frustum planes in common space.\n// Note that common space is left-handed\n// (with y pointing down)\nexport function getFrustumPlanes({aspect, near, far, fovyRadians, position, direction, up, right}) {\n  cameraDirection.copy(direction);\n\n  // Account for any scaling of the z axis (e.g. in\n  // mercator view matrix)\n  const nearFarScale = 1 / cameraDirection.len();\n  cameraDirection.normalize();\n\n  cameraPosition.copy(position);\n\n  cameraUp.copy(up);\n  // Account for scaling of the xy axis\n  const widthScale = 1 / cameraUp.len();\n  cameraUp.normalize();\n  cameraRight.copy(right).normalize();\n\n  const nearHeight = 2 * Math.tan(fovyRadians / 2) * near * widthScale;\n  const nearWidth = nearHeight * aspect;\n\n  nearCenter\n    .copy(cameraDirection)\n    .scale(near * nearFarScale)\n    .add(cameraPosition);\n  farCenter\n    .copy(cameraDirection)\n    .scale(far * nearFarScale)\n    .add(cameraPosition);\n\n  let normal = cameraDirection.clone().negate();\n  let distance = normal.dot(nearCenter);\n\n  const planes = {\n    near: {\n      distance,\n      normal\n    },\n    far: {\n      distance: cameraDirection.dot(farCenter),\n      normal: cameraDirection.clone()\n    }\n  };\n\n  a.copy(cameraRight)\n    .scale(nearWidth * 0.5)\n    .add(nearCenter)\n    .subtract(cameraPosition)\n    .normalize();\n  normal = new Vector3(a).cross(cameraUp);\n  distance = cameraPosition.dot(normal);\n  planes.right = {normal, distance};\n\n  a.copy(cameraRight)\n    .scale(-nearWidth * 0.5)\n    .add(nearCenter)\n    .subtract(cameraPosition)\n    .normalize();\n  normal = new Vector3(cameraUp).cross(a);\n  distance = cameraPosition.dot(normal);\n  planes.left = {normal, distance};\n\n  a.copy(cameraUp)\n    .scale(nearHeight * 0.5)\n    .add(nearCenter)\n    .subtract(cameraPosition)\n    .normalize();\n  normal = new Vector3(cameraRight).cross(a);\n  distance = cameraPosition.dot(normal);\n  planes.top = {normal, distance};\n\n  a.copy(cameraUp)\n    .scale(-nearHeight * 0.5)\n    .add(nearCenter)\n    .subtract(cameraPosition)\n    .normalize();\n  normal = new Vector3(a).cross(cameraRight);\n  distance = cameraPosition.dot(normal);\n  planes.bottom = {normal, distance};\n\n  return planes;\n}\n\n/**\n * Calculate the low part of a WebGL 64 bit float\n * @param x {number} - the input float number\n * @returns {number} - the lower 32 bit of the number\n */\nexport function fp64LowPart(x) {\n  return x - Math.fround(x);\n}\n\nlet scratchArray;\n\n/**\n * Split a Float64Array into a double-length Float32Array\n * @param typedArray {Float64Array}\n * @param size {Number} - per attribute size\n * @param [startIndex] {Number} - start index in the source array\n * @param [endIndex] {Number} - end index in the source array\n * @returns {Float32Array} - high part, low part for each attribute:\n    [1xHi, 1yHi, 1zHi, 1xLow, 1yLow, 1zLow, 2xHi, ...]\n */\nexport function toDoublePrecisionArray(typedArray, {size = 1, startIndex = 0, endIndex}) {\n  if (!Number.isFinite(endIndex)) {\n    endIndex = typedArray.length;\n  }\n  const count = (endIndex - startIndex) / size;\n  scratchArray = typedArrayManager.allocate(scratchArray, count, {\n    type: Float32Array,\n    size: size * 2\n  });\n\n  let sourceIndex = startIndex;\n  let targetIndex = 0;\n  while (sourceIndex < endIndex) {\n    for (let j = 0; j < size; j++) {\n      const value = typedArray[sourceIndex++];\n      scratchArray[targetIndex + j] = value;\n      scratchArray[targetIndex + j + size] = fp64LowPart(value);\n    }\n    targetIndex += size * 2;\n  }\n\n  return scratchArray.subarray(0, count * size * 2);\n}\n"]},"metadata":{},"sourceType":"module"}