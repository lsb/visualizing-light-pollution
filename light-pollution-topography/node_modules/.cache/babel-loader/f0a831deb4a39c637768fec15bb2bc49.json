{"ast":null,"code":"import { assert } from '@luma.gl/webgl';\nimport { combineInjects, getQualifierDetails, typeToChannelSuffix } from '@luma.gl/shadertools';\nvar SAMPLER_UNIFORM_PREFIX = 'transform_uSampler_';\nvar SIZE_UNIFORM_PREFIX = 'transform_uSize_';\nvar VS_POS_VARIABLE = 'transform_position';\nexport function updateForTextures(_ref) {\n  var vs = _ref.vs,\n      sourceTextureMap = _ref.sourceTextureMap,\n      targetTextureVarying = _ref.targetTextureVarying,\n      targetTexture = _ref.targetTexture;\n  var texAttributeNames = Object.keys(sourceTextureMap);\n  var sourceCount = texAttributeNames.length;\n  var targetTextureType = null;\n  var samplerTextureMap = {};\n  var updatedVs = vs;\n  var finalInject = {};\n\n  if (sourceCount > 0 || targetTextureVarying) {\n    var vsLines = updatedVs.split('\\n');\n    var updateVsLines = vsLines.slice();\n    vsLines.forEach(function (line, index, lines) {\n      if (sourceCount > 0) {\n        var updated = processAttributeDefinition(line, sourceTextureMap);\n\n        if (updated) {\n          var updatedLine = updated.updatedLine,\n              inject = updated.inject;\n          updateVsLines[index] = updatedLine;\n          finalInject = combineInjects([finalInject, inject]);\n          Object.assign(samplerTextureMap, updated.samplerTextureMap);\n          sourceCount--;\n        }\n      }\n\n      if (targetTextureVarying && !targetTextureType) {\n        targetTextureType = getVaryingType(line, targetTextureVarying);\n      }\n    });\n\n    if (targetTextureVarying) {\n      assert(targetTexture);\n      var sizeName = \"\".concat(SIZE_UNIFORM_PREFIX).concat(targetTextureVarying);\n      var uniformDeclaration = \"uniform vec2 \".concat(sizeName, \";\\n\");\n      var posInstructions = \"     vec2 \".concat(VS_POS_VARIABLE, \" = transform_getPos(\").concat(sizeName, \");\\n     gl_Position = vec4(\").concat(VS_POS_VARIABLE, \", 0, 1.);\\n\");\n      var inject = {\n        'vs:#decl': uniformDeclaration,\n        'vs:#main-start': posInstructions\n      };\n      finalInject = combineInjects([finalInject, inject]);\n    }\n\n    updatedVs = updateVsLines.join('\\n');\n  }\n\n  return {\n    vs: updatedVs,\n    targetTextureType: targetTextureType,\n    inject: finalInject,\n    samplerTextureMap: samplerTextureMap\n  };\n}\nexport function getSizeUniforms(_ref2) {\n  var sourceTextureMap = _ref2.sourceTextureMap,\n      targetTextureVarying = _ref2.targetTextureVarying,\n      targetTexture = _ref2.targetTexture;\n  var uniforms = {};\n  var width;\n  var height;\n\n  if (targetTextureVarying) {\n    width = targetTexture.width;\n    height = targetTexture.height;\n    uniforms[\"\".concat(SIZE_UNIFORM_PREFIX).concat(targetTextureVarying)] = [width, height];\n  }\n\n  for (var textureName in sourceTextureMap) {\n    var _sourceTextureMap$tex = sourceTextureMap[textureName];\n    width = _sourceTextureMap$tex.width;\n    height = _sourceTextureMap$tex.height;\n    uniforms[\"\".concat(SIZE_UNIFORM_PREFIX).concat(textureName)] = [width, height];\n  }\n\n  return uniforms;\n}\n\nfunction getAttributeDefinition(line) {\n  return getQualifierDetails(line, ['attribute', 'in']);\n}\n\nfunction getSamplerDeclerations(textureName) {\n  var samplerName = \"\".concat(SAMPLER_UNIFORM_PREFIX).concat(textureName);\n  var sizeName = \"\".concat(SIZE_UNIFORM_PREFIX).concat(textureName);\n  var uniformDeclerations = \"  uniform sampler2D \".concat(samplerName, \";\\n  uniform vec2 \").concat(sizeName, \";\");\n  return {\n    samplerName: samplerName,\n    sizeName: sizeName,\n    uniformDeclerations: uniformDeclerations\n  };\n}\n\nexport function getVaryingType(line, varying) {\n  var qualaiferDetails = getQualifierDetails(line, ['varying', 'out']);\n\n  if (!qualaiferDetails) {\n    return null;\n  }\n\n  return qualaiferDetails.name === varying ? qualaiferDetails.type : null;\n}\nexport function processAttributeDefinition(line, textureMap) {\n  var samplerTextureMap = {};\n  var attributeData = getAttributeDefinition(line);\n\n  if (!attributeData) {\n    return null;\n  }\n\n  var type = attributeData.type,\n      name = attributeData.name;\n\n  if (name && textureMap[name]) {\n    var updatedLine = \"// \".concat(line, \" => Replaced by Transform with a sampler\");\n\n    var _getSamplerDecleratio = getSamplerDeclerations(name),\n        samplerName = _getSamplerDecleratio.samplerName,\n        sizeName = _getSamplerDecleratio.sizeName,\n        uniformDeclerations = _getSamplerDecleratio.uniformDeclerations;\n\n    var channels = typeToChannelSuffix(type);\n    var sampleInstruction = \"  \".concat(type, \" \").concat(name, \" = transform_getInput(\").concat(samplerName, \", \").concat(sizeName, \").\").concat(channels, \";\\n\");\n    samplerTextureMap[samplerName] = name;\n    var inject = {\n      'vs:#decl': uniformDeclerations,\n      'vs:#main-start': sampleInstruction\n    };\n    return {\n      updatedLine: updatedLine,\n      inject: inject,\n      samplerTextureMap: samplerTextureMap\n    };\n  }\n\n  return null;\n}","map":{"version":3,"sources":["../../../src/transform/transform-shader-utils.js"],"names":["SAMPLER_UNIFORM_PREFIX","SIZE_UNIFORM_PREFIX","VS_POS_VARIABLE","vs","sourceTextureMap","targetTextureVarying","targetTexture","texAttributeNames","Object","sourceCount","targetTextureType","samplerTextureMap","updatedVs","finalInject","vsLines","updateVsLines","updated","processAttributeDefinition","updatedLine","inject","combineInjects","getVaryingType","assert","sizeName","uniformDeclaration","posInstructions","uniforms","width","height","getQualifierDetails","samplerName","uniformDeclerations","qualaiferDetails","attributeData","getAttributeDefinition","type","name","textureMap","getSamplerDeclerations","channels","typeToChannelSuffix","sampleInstruction"],"mappings":"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","sourcesContent":["import {assert} from '@luma.gl/webgl';\nimport {combineInjects, getQualifierDetails, typeToChannelSuffix} from '@luma.gl/shadertools';\n\nconst SAMPLER_UNIFORM_PREFIX = 'transform_uSampler_';\nconst SIZE_UNIFORM_PREFIX = 'transform_uSize_';\nconst VS_POS_VARIABLE = 'transform_position';\n\n// Scan provided vertex shader\n// for each texture attribute, inject sampler instructions and build uniforms for sampler\n// for texture target, get varying type and inject position instruction\nexport function updateForTextures({vs, sourceTextureMap, targetTextureVarying, targetTexture}) {\n  const texAttributeNames = Object.keys(sourceTextureMap);\n  let sourceCount = texAttributeNames.length;\n  let targetTextureType = null;\n  const samplerTextureMap = {};\n  let updatedVs = vs;\n  let finalInject = {};\n\n  if (sourceCount > 0 || targetTextureVarying) {\n    const vsLines = updatedVs.split('\\n');\n    const updateVsLines = vsLines.slice();\n    vsLines.forEach((line, index, lines) => {\n      // TODO add early exit\n      if (sourceCount > 0) {\n        const updated = processAttributeDefinition(line, sourceTextureMap);\n        if (updated) {\n          const {updatedLine, inject} = updated;\n          updateVsLines[index] = updatedLine;\n          // sampleInstructions.push(sampleInstruction);\n          finalInject = combineInjects([finalInject, inject]);\n          Object.assign(samplerTextureMap, updated.samplerTextureMap);\n          sourceCount--;\n        }\n      }\n      if (targetTextureVarying && !targetTextureType) {\n        targetTextureType = getVaryingType(line, targetTextureVarying);\n      }\n    });\n\n    if (targetTextureVarying) {\n      assert(targetTexture);\n      const sizeName = `${SIZE_UNIFORM_PREFIX}${targetTextureVarying}`;\n\n      const uniformDeclaration = `uniform vec2 ${sizeName};\\n`;\n      const posInstructions = `\\\n     vec2 ${VS_POS_VARIABLE} = transform_getPos(${sizeName});\n     gl_Position = vec4(${VS_POS_VARIABLE}, 0, 1.);\\n`;\n      const inject = {\n        'vs:#decl': uniformDeclaration,\n        'vs:#main-start': posInstructions\n      };\n      finalInject = combineInjects([finalInject, inject]);\n    }\n    updatedVs = updateVsLines.join('\\n');\n  }\n  return {\n    // updated vertex shader (commented texture attribute definition)\n    vs: updatedVs,\n    // type (float, vec2, vec3 of vec4) target texture varying\n    targetTextureType,\n    // required vertex and fragment shader injects\n    inject: finalInject,\n    // map of sampler name to texture name, can be used to set attributes\n    // usefull when swapping textures, as source and destination texture change when swap is called.\n    samplerTextureMap\n  };\n}\n\n// builds and returns an object contaning size uniform for each texture\nexport function getSizeUniforms({sourceTextureMap, targetTextureVarying, targetTexture}) {\n  const uniforms = {};\n  let width;\n  let height;\n  if (targetTextureVarying) {\n    ({width, height} = targetTexture);\n    uniforms[`${SIZE_UNIFORM_PREFIX}${targetTextureVarying}`] = [width, height];\n  }\n  for (const textureName in sourceTextureMap) {\n    ({width, height} = sourceTextureMap[textureName]);\n    uniforms[`${SIZE_UNIFORM_PREFIX}${textureName}`] = [width, height];\n  }\n  return uniforms;\n}\n\n// Checks if provided line is defining an attribute, if so returns details otherwise null\nfunction getAttributeDefinition(line) {\n  return getQualifierDetails(line, ['attribute', 'in']);\n}\n\nfunction getSamplerDeclerations(textureName) {\n  const samplerName = `${SAMPLER_UNIFORM_PREFIX}${textureName}`;\n  const sizeName = `${SIZE_UNIFORM_PREFIX}${textureName}`;\n  const uniformDeclerations = `\\\n  uniform sampler2D ${samplerName};\n  uniform vec2 ${sizeName};`;\n  return {samplerName, sizeName, uniformDeclerations};\n}\n\n// Return size (float, vec2 etc) of a given varying, null if doens't exist.\nexport function getVaryingType(line, varying) {\n  const qualaiferDetails = getQualifierDetails(line, ['varying', 'out']);\n  if (!qualaiferDetails) {\n    return null;\n  }\n  return qualaiferDetails.name === varying ? qualaiferDetails.type : null;\n}\n\n// build required definitions, sample instructions for each texture attribute\nexport function processAttributeDefinition(line, textureMap) {\n  const samplerTextureMap = {};\n  const attributeData = getAttributeDefinition(line);\n  if (!attributeData) {\n    return null;\n  }\n  const {type, name} = attributeData;\n  if (name && textureMap[name]) {\n    // eslint-disable-next-line no-useless-escape\n    const updatedLine = `\\// ${line} => Replaced by Transform with a sampler`;\n    const {samplerName, sizeName, uniformDeclerations} = getSamplerDeclerations(name);\n\n    const channels = typeToChannelSuffix(type);\n    const sampleInstruction = `  ${type} ${name} = transform_getInput(${samplerName}, ${sizeName}).${channels};\\n`;\n\n    samplerTextureMap[samplerName] = name;\n    const inject = {\n      'vs:#decl': uniformDeclerations,\n      'vs:#main-start': sampleInstruction\n    };\n\n    // samplerNameMap\n    return {\n      // update vertex shader line.\n      updatedLine,\n      // inject object with sampler instructions.\n      inject,\n      // sampler name to texture name map\n      samplerTextureMap\n    };\n  }\n  return null;\n}\n"]},"metadata":{},"sourceType":"module"}