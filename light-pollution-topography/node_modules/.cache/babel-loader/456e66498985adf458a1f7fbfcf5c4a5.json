{"ast":null,"code":"import { decodeRGB565, GL } from '@loaders.gl/math';\nexport function normalize3DTileColorAttribute(tile, colors, batchTable) {\n  if (!colors && (!tile || !tile.batchIds || !batchTable)) {\n    return null;\n  }\n\n  var batchIds = tile.batchIds,\n      isRGB565 = tile.isRGB565,\n      pointCount = tile.pointCount;\n\n  if (batchIds && batchTable) {\n    var colorArray = new Uint8ClampedArray(pointCount * 3);\n\n    for (var i = 0; i < pointCount; i++) {\n      var batchId = batchIds[i];\n      var dimensions = batchTable.getProperty(batchId, 'dimensions');\n      var color = dimensions.map(function (d) {\n        return d * 255;\n      });\n      colorArray[i * 3] = color[0];\n      colorArray[i * 3 + 1] = color[1];\n      colorArray[i * 3 + 2] = color[2];\n    }\n\n    return {\n      type: GL.UNSIGNED_BYTE,\n      value: colorArray,\n      size: 3,\n      normalized: true\n    };\n  }\n\n  if (isRGB565) {\n    var _colorArray = new Uint8ClampedArray(pointCount * 3);\n\n    for (var _i = 0; _i < pointCount; _i++) {\n      var _color = decodeRGB565(colors[_i]);\n\n      _colorArray[_i * 3] = _color[0];\n      _colorArray[_i * 3 + 1] = _color[1];\n      _colorArray[_i * 3 + 2] = _color[2];\n    }\n\n    return {\n      type: GL.UNSIGNED_BYTE,\n      value: _colorArray,\n      size: 3,\n      normalized: true\n    };\n  }\n\n  if (colors && colors.length === pointCount * 3) {\n    return {\n      type: GL.UNSIGNED_BYTE,\n      value: colors,\n      size: 3,\n      normalized: true\n    };\n  }\n\n  return {\n    type: GL.UNSIGNED_BYTE,\n    value: colors,\n    size: 4,\n    normalized: true\n  };\n}","map":{"version":3,"sources":["../../../../../src/lib/parsers/helpers/normalize-3d-tile-colors.js"],"names":["tile","batchIds","isRGB565","pointCount","colorArray","i","batchId","dimensions","batchTable","color","d","type","GL","value","size","normalized","decodeRGB565","colors"],"mappings":"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","sourcesContent":["import {decodeRGB565, GL} from '@loaders.gl/math';\n\n/* eslint-disable complexity*/\nexport function normalize3DTileColorAttribute(tile, colors, batchTable) {\n  // no colors defined\n  if (!colors && (!tile || !tile.batchIds || !batchTable)) {\n    return null;\n  }\n\n  const {batchIds, isRGB565, pointCount} = tile;\n  // Batch table, look up colors in table\n  if (batchIds && batchTable) {\n    const colorArray = new Uint8ClampedArray(pointCount * 3);\n    for (let i = 0; i < pointCount; i++) {\n      const batchId = batchIds[i];\n      // TODO figure out what is `dimensions` used for\n      const dimensions = batchTable.getProperty(batchId, 'dimensions');\n      const color = dimensions.map(d => d * 255);\n      colorArray[i * 3] = color[0];\n      colorArray[i * 3 + 1] = color[1];\n      colorArray[i * 3 + 2] = color[2];\n    }\n    return {\n      type: GL.UNSIGNED_BYTE,\n      value: colorArray,\n      size: 3,\n      normalized: true\n    };\n  }\n\n  // RGB565 case, convert to RGB\n  if (isRGB565) {\n    const colorArray = new Uint8ClampedArray(pointCount * 3);\n    for (let i = 0; i < pointCount; i++) {\n      const color = decodeRGB565(colors[i]);\n      colorArray[i * 3] = color[0];\n      colorArray[i * 3 + 1] = color[1];\n      colorArray[i * 3 + 2] = color[2];\n    }\n    return {\n      type: GL.UNSIGNED_BYTE,\n      value: colorArray,\n      size: 3,\n      normalized: true\n    };\n  }\n\n  // RGB case (tile.isTranslucent)\n  if (colors && colors.length === pointCount * 3) {\n    return {\n      type: GL.UNSIGNED_BYTE,\n      value: colors,\n      size: 3,\n      normalized: true\n    };\n  }\n\n  // DEFAULT: RGBA case\n  return {\n    type: GL.UNSIGNED_BYTE,\n    value: colors,\n    size: 4,\n    normalized: true\n  };\n}\n/* eslint-enable complexity*/\n"]},"metadata":{},"sourceType":"module"}