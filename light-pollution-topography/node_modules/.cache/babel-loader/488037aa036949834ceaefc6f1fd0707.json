{"ast":null,"code":"import getShaderName from './get-shader-name';\nimport getShaderTypeName from './get-shader-type-name';\nexport default function formatGLSLCompilerError(errLog, src, shaderType) {\n  var _parseGLSLCompilerErr = parseGLSLCompilerError(errLog, src, shaderType),\n      shaderName = _parseGLSLCompilerErr.shaderName,\n      errors = _parseGLSLCompilerErr.errors,\n      warnings = _parseGLSLCompilerErr.warnings;\n\n  return \"GLSL compilation error in \".concat(shaderName, \"\\n\\n\").concat(errors, \"\\n\").concat(warnings);\n}\nexport function parseGLSLCompilerError(errLog, src, shaderType, shaderName) {\n  var errorStrings = errLog.split(/\\r?\\n/);\n  var errors = {};\n  var warnings = {};\n  var name = shaderName || getShaderName(src) || '(unnamed)';\n  var shaderDescription = \"\".concat(getShaderTypeName(shaderType), \" shader \").concat(name);\n\n  for (var i = 0; i < errorStrings.length; i++) {\n    var errorString = errorStrings[i];\n\n    if (errorString.length <= 1) {\n      continue;\n    }\n\n    var segments = errorString.split(':');\n    var type = segments[0];\n    var line = parseInt(segments[2], 10);\n\n    if (isNaN(line)) {\n      throw new Error(\"GLSL compilation error in \".concat(shaderDescription, \": \").concat(errLog));\n    }\n\n    if (type !== 'WARNING') {\n      errors[line] = errorString;\n    } else {\n      warnings[line] = errorString;\n    }\n  }\n\n  var lines = addLineNumbers(src);\n  return {\n    shaderName: shaderDescription,\n    errors: formatErrors(errors, lines),\n    warnings: formatErrors(warnings, lines)\n  };\n}\n\nfunction formatErrors(errors, lines) {\n  var message = '';\n\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n\n    if (!errors[i + 3] && !errors[i + 2] && !errors[i + 1]) {\n      continue;\n    }\n\n    message += \"\".concat(line, \"\\n\");\n\n    if (errors[i + 1]) {\n      var error = errors[i + 1];\n      var segments = error.split(':', 3);\n      var type = segments[0];\n      var column = parseInt(segments[1], 10) || 0;\n      var err = error.substring(segments.join(':').length + 1).trim();\n      message += padLeft(\"^^^ \".concat(type, \": \").concat(err, \"\\n\\n\"), column);\n    }\n  }\n\n  return message;\n}\n\nfunction addLineNumbers(string) {\n  var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var delim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ': ';\n  var lines = string.split(/\\r?\\n/);\n  var maxDigits = String(lines.length + start - 1).length;\n  return lines.map(function (line, i) {\n    var lineNumber = i + start;\n    var digits = String(lineNumber).length;\n    var prefix = padLeft(lineNumber, maxDigits - digits);\n    return prefix + delim + line;\n  });\n}\n\nfunction padLeft(string, digits) {\n  var result = '';\n\n  for (var i = 0; i < digits; ++i) {\n    result += ' ';\n  }\n\n  return \"\".concat(result).concat(string);\n}","map":{"version":3,"sources":["../../../src/glsl-utils/format-glsl-error.js"],"names":["shaderName","errors","warnings","parseGLSLCompilerError","errorStrings","errLog","name","getShaderName","shaderDescription","getShaderTypeName","i","errorString","segments","type","line","parseInt","isNaN","lines","addLineNumbers","formatErrors","message","error","column","err","padLeft","start","delim","string","maxDigits","String","lineNumber","digits","prefix","result"],"mappings":"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","sourcesContent":["// TODO - formatGLSLCompilerError should not depend on this\nimport getShaderName from './get-shader-name';\nimport getShaderTypeName from './get-shader-type-name';\n\n// Formats GLSL compiler error log into single string\nexport default function formatGLSLCompilerError(errLog, src, shaderType) {\n  const {shaderName, errors, warnings} = parseGLSLCompilerError(errLog, src, shaderType);\n  return `GLSL compilation error in ${shaderName}\\n\\n${errors}\\n${warnings}`;\n}\n\n/**\n * Parse a GLSL compiler error log into a string showing the source code around each error.\n * Based on https://github.com/wwwtyro/gl-format-compiler-error (public domain)\n */\n/* eslint-disable no-continue, max-statements */\nexport function parseGLSLCompilerError(errLog, src, shaderType, shaderName) {\n  const errorStrings = errLog.split(/\\r?\\n/);\n  const errors = {};\n  const warnings = {};\n\n  // Patch the shader name\n  const name = shaderName || getShaderName(src) || '(unnamed)';\n  const shaderDescription = `${getShaderTypeName(shaderType)} shader ${name}`;\n\n  // Parse the error - note: browser and driver dependent\n  for (let i = 0; i < errorStrings.length; i++) {\n    const errorString = errorStrings[i];\n    if (errorString.length <= 1) {\n      continue;\n    }\n    const segments = errorString.split(':');\n    const type = segments[0];\n    const line = parseInt(segments[2], 10);\n    if (isNaN(line)) {\n      throw new Error(`GLSL compilation error in ${shaderDescription}: ${errLog}`);\n    }\n    if (type !== 'WARNING') {\n      errors[line] = errorString;\n    } else {\n      warnings[line] = errorString;\n    }\n  }\n\n  // Format the error inline with the code\n  const lines = addLineNumbers(src);\n\n  return {\n    shaderName: shaderDescription,\n    errors: formatErrors(errors, lines),\n    warnings: formatErrors(warnings, lines)\n  };\n}\n\n// helper function, outputs annotated errors or warnings\nfunction formatErrors(errors, lines) {\n  let message = '';\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    if (!errors[i + 3] && !errors[i + 2] && !errors[i + 1]) {\n      continue;\n    }\n    message += `${line}\\n`;\n    if (errors[i + 1]) {\n      const error = errors[i + 1];\n      const segments = error.split(':', 3);\n      const type = segments[0];\n      const column = parseInt(segments[1], 10) || 0;\n      const err = error.substring(segments.join(':').length + 1).trim();\n      message += padLeft(`^^^ ${type}: ${err}\\n\\n`, column);\n    }\n  }\n  return message;\n}\n\n/**\n * Prepends line numbers to each line of a string.\n * The line numbers will be left-padded with spaces to ensure an\n * aligned layout when rendered using monospace fonts.\n * @param {String} string - multi-line string to add line numbers to\n * @param {Number} start=1 - number of spaces to add\n * @param {String} delim =': ' - injected between line number and original line\n * @return {String[]} strings - array of string, one per line, with line numbers added\n */\nfunction addLineNumbers(string, start = 1, delim = ': ') {\n  const lines = string.split(/\\r?\\n/);\n  const maxDigits = String(lines.length + start - 1).length;\n  return lines.map((line, i) => {\n    const lineNumber = i + start;\n    const digits = String(lineNumber).length;\n    const prefix = padLeft(lineNumber, maxDigits - digits);\n    return prefix + delim + line;\n  });\n}\n\n/**\n * Pads a string with a number of spaces (space characters) to the left\n * @param {String} string - string to pad\n * @param {Number} digits - number of spaces to add\n * @return {String} string - The padded string\n */\nfunction padLeft(string, digits) {\n  let result = '';\n  for (let i = 0; i < digits; ++i) {\n    result += ' ';\n  }\n  return `${result}${string}`;\n}\n"]},"metadata":{},"sourceType":"module"}