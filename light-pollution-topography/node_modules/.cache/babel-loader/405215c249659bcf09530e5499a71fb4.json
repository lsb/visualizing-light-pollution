{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { toRadians } from '@math.gl/core';\nvar WGS84_RADIUS_X = 6378137.0;\nvar qualityFactor = Math.PI / 2;\nexport function lodJudge(tile, frameState) {\n  var viewport = frameState.viewport;\n  var metersPerPixel = viewport.metersPerPixel;\n  var mbsLat = tile.header.mbs[1];\n  var mbsLon = tile.header.mbs[0];\n  var mbsZ = tile.header.mbs[2];\n  var mbsR = tile.header.mbs[3];\n  var height = viewport.height,\n      width = viewport.width,\n      latitude = viewport.latitude,\n      longitude = viewport.longitude;\n  var viewportCenter = [longitude, latitude];\n  var mbsCenter = [mbsLon, mbsLat, mbsZ];\n  var mbsLatProjected = [longitude, mbsLat];\n  var mbsLonProjected = [mbsLon, latitude];\n  var diagonalInMeters = Math.sqrt(height * height + width * width) * metersPerPixel[0];\n  var distanceInMeters = getDistanceFromLatLon(viewportCenter, mbsCenter);\n  var visibleHeight = height * 0.5 + mbsR / WGS84_RADIUS_X;\n  var visibleWidth = width * 0.5 + mbsR / WGS84_RADIUS_X;\n\n  if (distanceInMeters > diagonalInMeters + mbsR / WGS84_RADIUS_X) {\n    return 'OUT';\n  }\n\n  if (getDistanceFromLatLon(viewportCenter, mbsLatProjected) > visibleHeight) {\n    return 'OUT';\n  }\n\n  if (getDistanceFromLatLon(viewportCenter, mbsLonProjected) > visibleWidth) {\n    return 'OUT';\n  }\n\n  if (tile.lodMetricValue === 0) {\n    return 'DIG';\n  }\n\n  var screenSize = getI3ScreenSize(tile, frameState);\n  screenSize *= qualityFactor;\n\n  if (screenSize < 0.5) {\n    return 'OUT';\n  }\n\n  if (!tile.header.children || screenSize <= tile.lodMetricValue) {\n    return 'DRAW';\n  } else if (tile.header.children) {\n    return 'DIG';\n  }\n\n  return 'OUT';\n}\n\nfunction projectVertexToSphere(_ref) {\n  var _ref2 = _slicedToArray(_ref, 3),\n      x = _ref2[0],\n      y = _ref2[1],\n      z = _ref2[2];\n\n  var azim = toRadians(x);\n  var incl = toRadians(y);\n  var radius = 1.0 + z / WGS84_RADIUS_X;\n  var radCosInc = radius * Math.cos(incl);\n  x = radCosInc * Math.cos(azim);\n  y = radCosInc * Math.sin(azim);\n  z = radius * Math.sin(incl);\n  return [x, y, z];\n}\n\nfunction getDistanceFromLatLon(_ref3, _ref4) {\n  var _ref5 = _slicedToArray(_ref3, 3),\n      observerLon = _ref5[0],\n      observerLat = _ref5[1],\n      _ref5$ = _ref5[2],\n      observerZ = _ref5$ === void 0 ? 0.0 : _ref5$;\n\n  var _ref6 = _slicedToArray(_ref4, 3),\n      centerLon = _ref6[0],\n      centerLat = _ref6[1],\n      _ref6$ = _ref6[2],\n      centerZ = _ref6$ === void 0 ? 0.0 : _ref6$;\n\n  var projectedCenter = projectVertexToSphere([centerLon, centerLat, centerZ]);\n  var projectedObserver = projectVertexToSphere([observerLon, observerLat, observerZ]);\n  var dx = projectedObserver[0] - projectedCenter[0];\n  var dy = projectedObserver[1] - projectedCenter[1];\n  var dz = projectedObserver[2] - projectedCenter[2];\n  return dx * dx + dy * dy + dz * dz;\n}\n\nexport function getI3ScreenSize(tile, frameState) {\n  var viewport = frameState.viewport;\n  var mbsLat = tile.header.mbs[1];\n  var mbsLon = tile.header.mbs[0];\n  var mbsZ = tile.header.mbs[2];\n  var mbsR = tile.header.mbs[3];\n  var mbsCenter = [mbsLon, mbsLat, mbsZ];\n  var cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  var dSquared = getDistanceFromLatLon(cameraPositionCartographic, mbsCenter);\n  var mbsRNormalized = mbsR / WGS84_RADIUS_X;\n  var d = dSquared - mbsRNormalized * mbsRNormalized;\n  var fltMax = 3.4028235e38;\n\n  if (d <= 0.0) {\n    return 0.5 * fltMax;\n  }\n\n  var screenSizeFactor = calculateScreenSizeFactor(tile, frameState);\n  screenSizeFactor *= mbsRNormalized / Math.sqrt(d) / viewport.scale;\n  return screenSizeFactor;\n}\n\nfunction calculateScreenSizeFactor(tile, frameState) {\n  var _frameState$viewport = frameState.viewport,\n      width = _frameState$viewport.width,\n      height = _frameState$viewport.height,\n      pixelProjectionMatrix = _frameState$viewport.pixelProjectionMatrix;\n  var tanOfHalfVFAngle = Math.tan(Math.atan(Math.sqrt(1.0 / (pixelProjectionMatrix[0] * pixelProjectionMatrix[0]) + 1.0 / (pixelProjectionMatrix[5] * pixelProjectionMatrix[5]))));\n  var screenCircleFactor = Math.sqrt(height * height + width * width) / tanOfHalfVFAngle;\n  return screenCircleFactor;\n}","map":{"version":3,"sources":["../../../../src/tileset/helpers/i3s-lod.js"],"names":["WGS84_RADIUS_X","qualityFactor","Math","viewport","frameState","metersPerPixel","mbsLat","tile","mbsLon","mbsZ","mbsR","height","width","latitude","longitude","viewportCenter","mbsCenter","mbsLatProjected","mbsLonProjected","diagonalInMeters","distanceInMeters","getDistanceFromLatLon","visibleHeight","visibleWidth","screenSize","getI3ScreenSize","x","y","z","azim","toRadians","incl","radius","radCosInc","observerLon","observerLat","observerZ","centerLon","centerLat","centerZ","projectedCenter","projectVertexToSphere","projectedObserver","dx","dy","dz","cameraPositionCartographic","dSquared","mbsRNormalized","d","fltMax","screenSizeFactor","calculateScreenSizeFactor","pixelProjectionMatrix","tanOfHalfVFAngle","screenCircleFactor"],"mappings":"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","sourcesContent":["import {toRadians} from '@math.gl/core';\n\nconst WGS84_RADIUS_X = 6378137.0;\n// use this to bias the lod switching  (1+ results in increasing the LOD quality)\nconst qualityFactor = Math.PI / 2; // empirical derived bias factor\n/* eslint-disable max-statements */\nexport function lodJudge(tile, frameState) {\n  const viewport = frameState.viewport;\n  const metersPerPixel = viewport.metersPerPixel;\n\n  const mbsLat = tile.header.mbs[1];\n  const mbsLon = tile.header.mbs[0];\n  const mbsZ = tile.header.mbs[2];\n  const mbsR = tile.header.mbs[3];\n\n  const {height, width, latitude, longitude} = viewport;\n\n  const viewportCenter = [longitude, latitude];\n  const mbsCenter = [mbsLon, mbsLat, mbsZ];\n  const mbsLatProjected = [longitude, mbsLat];\n  const mbsLonProjected = [mbsLon, latitude];\n\n  const diagonalInMeters = Math.sqrt(height * height + width * width) * metersPerPixel[0];\n  const distanceInMeters = getDistanceFromLatLon(viewportCenter, mbsCenter);\n\n  const visibleHeight = height * 0.5 + mbsR / WGS84_RADIUS_X;\n  const visibleWidth = width * 0.5 + mbsR / WGS84_RADIUS_X;\n\n  if (distanceInMeters > diagonalInMeters + mbsR / WGS84_RADIUS_X) {\n    return 'OUT';\n  }\n  if (getDistanceFromLatLon(viewportCenter, mbsLatProjected) > visibleHeight) {\n    return 'OUT';\n  }\n  if (getDistanceFromLatLon(viewportCenter, mbsLonProjected) > visibleWidth) {\n    return 'OUT';\n  }\n\n  if (tile.lodMetricValue === 0) {\n    return 'DIG';\n  }\n\n  // For the maxScreenThreshold error metric, maxError means that you should replace the node with it's children\n  // as soon as the nodes bounding sphere has a screen radius larger than maxError pixels.\n  // In this sense a value of 0 means you should always load it's children,\n  // or if it's a leaf node, you should always display it.\n  let screenSize = getI3ScreenSize(tile, frameState); // in pixels\n  screenSize *= qualityFactor;\n  if (screenSize < 0.5) {\n    return 'OUT';\n  }\n  // Hack: 1000 is a Magic number to get the correct LoD\n  if (!tile.header.children || screenSize <= tile.lodMetricValue) {\n    return 'DRAW';\n  } else if (tile.header.children) {\n    return 'DIG';\n  }\n  return 'OUT';\n}\n\n/* eslint-enable max-statements */\n\nfunction projectVertexToSphere([x, y, z]) {\n  const azim = toRadians(x);\n  const incl = toRadians(y);\n  const radius = 1.0 + z / WGS84_RADIUS_X;\n  const radCosInc = radius * Math.cos(incl);\n  x = radCosInc * Math.cos(azim);\n  y = radCosInc * Math.sin(azim);\n  z = radius * Math.sin(incl);\n  return [x, y, z];\n}\n\nfunction getDistanceFromLatLon(\n  [observerLon, observerLat, observerZ = 0.0],\n  [centerLon, centerLat, centerZ = 0.0]\n) {\n  const projectedCenter = projectVertexToSphere([centerLon, centerLat, centerZ]);\n  const projectedObserver = projectVertexToSphere([observerLon, observerLat, observerZ]);\n  const dx = projectedObserver[0] - projectedCenter[0];\n  const dy = projectedObserver[1] - projectedCenter[1];\n  const dz = projectedObserver[2] - projectedCenter[2];\n  return dx * dx + dy * dy + dz * dz;\n}\n\nexport function getI3ScreenSize(tile, frameState) {\n  const viewport = frameState.viewport;\n  // https://stackoverflow.com/questions/21648630/radius-of-projected-sphere-in-screen-space\n  const mbsLat = tile.header.mbs[1];\n  const mbsLon = tile.header.mbs[0];\n  const mbsZ = tile.header.mbs[2];\n  const mbsR = tile.header.mbs[3];\n\n  const mbsCenter = [mbsLon, mbsLat, mbsZ];\n  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  const dSquared = getDistanceFromLatLon(cameraPositionCartographic, mbsCenter);\n  const mbsRNormalized = mbsR / WGS84_RADIUS_X;\n  const d = dSquared - mbsRNormalized * mbsRNormalized;\n  const fltMax = 3.4028235e38; // convert from 0x7f7fffff which is the maximum\n  if (d <= 0.0) {\n    return 0.5 * fltMax;\n  }\n  let screenSizeFactor = calculateScreenSizeFactor(tile, frameState);\n  // viewport changed in deck.gl v8.0\n  screenSizeFactor *= mbsRNormalized / Math.sqrt(d) / viewport.scale;\n  return screenSizeFactor;\n}\n\nfunction calculateScreenSizeFactor(tile, frameState) {\n  const {width, height, pixelProjectionMatrix} = frameState.viewport;\n  const tanOfHalfVFAngle = Math.tan(\n    Math.atan(\n      Math.sqrt(\n        1.0 / (pixelProjectionMatrix[0] * pixelProjectionMatrix[0]) +\n          1.0 / (pixelProjectionMatrix[5] * pixelProjectionMatrix[5])\n      )\n    )\n  );\n\n  const screenCircleFactor = Math.sqrt(height * height + width * width) / tanOfHalfVFAngle;\n\n  return screenCircleFactor;\n}\n"]},"metadata":{},"sourceType":"module"}