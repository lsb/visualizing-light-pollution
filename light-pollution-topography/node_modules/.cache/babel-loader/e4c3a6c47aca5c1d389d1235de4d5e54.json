{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nexport var TypedArrayManager = function () {\n  function TypedArrayManager() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$overAlloc = _ref.overAlloc,\n        overAlloc = _ref$overAlloc === void 0 ? 2 : _ref$overAlloc,\n        _ref$poolSize = _ref.poolSize,\n        poolSize = _ref$poolSize === void 0 ? 100 : _ref$poolSize;\n\n    _classCallCheck(this, TypedArrayManager);\n\n    this.overAlloc = overAlloc;\n    this.poolSize = poolSize;\n    this._pool = [];\n  }\n\n  _createClass(TypedArrayManager, [{\n    key: \"allocate\",\n    value: function allocate(typedArray, count, _ref2) {\n      var _ref2$size = _ref2.size,\n          size = _ref2$size === void 0 ? 1 : _ref2$size,\n          type = _ref2.type,\n          _ref2$padding = _ref2.padding,\n          padding = _ref2$padding === void 0 ? 0 : _ref2$padding,\n          _ref2$copy = _ref2.copy,\n          copy = _ref2$copy === void 0 ? false : _ref2$copy;\n      var Type = type || typedArray && typedArray.constructor || Float32Array;\n      var newSize = count * size + padding;\n\n      if (ArrayBuffer.isView(typedArray)) {\n        if (newSize <= typedArray.length) {\n          return typedArray;\n        }\n\n        if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {\n          return new Type(typedArray.buffer, 0, newSize);\n        }\n      }\n\n      var newArray = this._allocate(Type, newSize);\n\n      if (typedArray && copy) {\n        newArray.set(typedArray);\n      } else {\n        newArray.fill(0, 0, 4);\n      }\n\n      this._release(typedArray);\n\n      return newArray;\n    }\n  }, {\n    key: \"release\",\n    value: function release(typedArray) {\n      this._release(typedArray);\n    }\n  }, {\n    key: \"_allocate\",\n    value: function _allocate(Type, size) {\n      size = Math.max(Math.ceil(size * this.overAlloc), 1);\n      var pool = this._pool;\n      var byteLength = Type.BYTES_PER_ELEMENT * size;\n      var i = pool.findIndex(function (b) {\n        return b.byteLength >= byteLength;\n      });\n\n      if (i >= 0) {\n        return new Type(pool.splice(i, 1)[0], 0, size);\n      }\n\n      return new Type(size);\n    }\n  }, {\n    key: \"_release\",\n    value: function _release(typedArray) {\n      if (!ArrayBuffer.isView(typedArray)) {\n        return;\n      }\n\n      var pool = this._pool;\n      var buffer = typedArray.buffer;\n      var byteLength = buffer.byteLength;\n      var i = pool.findIndex(function (b) {\n        return b.byteLength >= byteLength;\n      });\n\n      if (i < 0) {\n        pool.push(buffer);\n      } else if (i > 0 || pool.length < this.poolSize) {\n        pool.splice(i, 0, buffer);\n      }\n\n      if (pool.length > this.poolSize) {\n        pool.shift();\n      }\n    }\n  }]);\n\n  return TypedArrayManager;\n}();\nexport default new TypedArrayManager();","map":{"version":3,"sources":["../../../src/utils/typed-array-manager.js"],"names":["TypedArrayManager","overAlloc","poolSize","size","type","padding","copy","Type","typedArray","newSize","count","ArrayBuffer","newArray","Math","pool","byteLength","i","b","buffer"],"mappings":"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","sourcesContent":["export class TypedArrayManager {\n  constructor({overAlloc = 2, poolSize = 100} = {}) {\n    this.overAlloc = overAlloc;\n    this.poolSize = poolSize;\n\n    this._pool = [];\n  }\n\n  allocate(typedArray, count, {size = 1, type, padding = 0, copy = false}) {\n    const Type = type || (typedArray && typedArray.constructor) || Float32Array;\n\n    const newSize = count * size + padding;\n    if (ArrayBuffer.isView(typedArray)) {\n      if (newSize <= typedArray.length) {\n        return typedArray;\n      }\n      if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {\n        return new Type(typedArray.buffer, 0, newSize);\n      }\n    }\n\n    const newArray = this._allocate(Type, newSize);\n\n    if (typedArray && copy) {\n      newArray.set(typedArray);\n    } else {\n      // Hack - viewing a buffer with a different type may create NaNs\n      // which crashes the Attribute validation\n      newArray.fill(0, 0, 4);\n    }\n\n    this._release(typedArray);\n    return newArray;\n  }\n\n  release(typedArray) {\n    this._release(typedArray);\n  }\n\n  _allocate(Type, size) {\n    // Allocate at least one element to ensure a valid buffer\n    size = Math.max(Math.ceil(size * this.overAlloc), 1);\n\n    // Check if available in pool\n    const pool = this._pool;\n    const byteLength = Type.BYTES_PER_ELEMENT * size;\n    const i = pool.findIndex(b => b.byteLength >= byteLength);\n    if (i >= 0) {\n      // Create a new array using an existing buffer\n      return new Type(pool.splice(i, 1)[0], 0, size);\n    }\n    return new Type(size);\n  }\n\n  _release(typedArray) {\n    if (!ArrayBuffer.isView(typedArray)) {\n      return;\n    }\n    const pool = this._pool;\n    const {buffer} = typedArray;\n    // Save the buffer of the released array into the pool\n    // Sort buffers by size\n    // TODO - implement binary search?\n    const {byteLength} = buffer;\n    const i = pool.findIndex(b => b.byteLength >= byteLength);\n    if (i < 0) {\n      pool.push(buffer);\n    } else if (i > 0 || pool.length < this.poolSize) {\n      pool.splice(i, 0, buffer);\n    }\n    if (pool.length > this.poolSize) {\n      // Drop the smallest one\n      pool.shift();\n    }\n  }\n}\n\nexport default new TypedArrayManager();\n"]},"metadata":{},"sourceType":"module"}