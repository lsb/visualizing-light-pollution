{"ast":null,"code":"import { Vector3, isArray, toRadians, toDegrees, config } from 'math.gl';\nimport { WGS84_CONSTANTS } from './constants';\n\nvar noop = function noop(x) {\n  return x;\n};\n\nvar scratchVector = new Vector3();\nexport function fromCartographic(cartographic, vector) {\n  var map = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;\n\n  if (isArray(cartographic)) {\n    vector[0] = map(cartographic[0]);\n    vector[1] = map(cartographic[1]);\n    vector[2] = cartographic[2];\n  } else if ('longitude' in cartographic) {\n    vector[0] = map(cartographic.longitude);\n    vector[1] = map(cartographic.latitude);\n    vector[2] = cartographic.height;\n  } else {\n    vector[0] = map(cartographic.x);\n    vector[1] = map(cartographic.y);\n    vector[2] = cartographic.z;\n  }\n\n  return vector;\n}\nexport function fromCartographicToRadians(cartographic) {\n  var vector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scratchVector;\n  return fromCartographic(cartographic, vector, config.cartographicRadians ? noop : toRadians);\n}\nexport function fromCartographicToDegrees(cartographic) {\n  var vector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scratchVector;\n  return fromCartographic(cartographic, vector, config.cartographicRadians ? toDegrees : noop);\n}\nexport function toCartographic(vector, cartographic) {\n  var map = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;\n\n  if (isArray(cartographic)) {\n    cartographic[0] = map(vector[0]);\n    cartographic[1] = map(vector[1]);\n    cartographic[2] = vector[2];\n  } else if ('longitude' in cartographic) {\n    cartographic.longitude = map(vector[0]);\n    cartographic.latitude = map(vector[1]);\n    cartographic.height = vector[2];\n  } else {\n    cartographic.x = map(vector[0]);\n    cartographic.y = map(vector[1]);\n    cartographic.z = vector[2];\n  }\n\n  return cartographic;\n}\nexport function toCartographicFromRadians(vector, cartographic) {\n  return toCartographic(vector, cartographic, config.cartographicRadians ? noop : toDegrees);\n}\nexport function toCartographicFromDegrees(vector, cartographic) {\n  return toCartographic(vector, cartographic, config.cartographicRadians ? toRadians : noop);\n}\nexport function isWGS84(vector) {\n  if (!vector) {\n    return false;\n  }\n\n  scratchVector.from(vector);\n  var oneOverRadiiSquared = WGS84_CONSTANTS.oneOverRadiiSquared,\n      centerToleranceSquared = WGS84_CONSTANTS.centerToleranceSquared;\n  var x2 = vector[0] * vector[0] * oneOverRadiiSquared[0];\n  var y2 = vector[1] * vector[1] * oneOverRadiiSquared[1];\n  var z2 = vector[2] * vector[2] * oneOverRadiiSquared[2];\n  return Math.abs(x2 + y2 + z2 - 1) < centerToleranceSquared;\n}","map":{"version":3,"sources":["../../src/type-utils.js"],"names":["noop","scratchVector","map","isArray","vector","cartographic","fromCartographic","config","toCartographic","oneOverRadiiSquared","centerToleranceSquared","WGS84_CONSTANTS","x2","y2","z2","Math"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Vector3, isArray, toRadians, toDegrees, config} from 'math.gl';\nimport {WGS84_CONSTANTS} from './constants';\n\nconst noop = x => x;\n\nconst scratchVector = new Vector3();\n\nexport function fromCartographic(cartographic, vector, map = noop) {\n  if (isArray(cartographic)) {\n    vector[0] = map(cartographic[0]);\n    vector[1] = map(cartographic[1]);\n    vector[2] = cartographic[2];\n  } else if ('longitude' in cartographic) {\n    vector[0] = map(cartographic.longitude);\n    vector[1] = map(cartographic.latitude);\n    vector[2] = cartographic.height;\n  } else {\n    vector[0] = map(cartographic.x);\n    vector[1] = map(cartographic.y);\n    vector[2] = cartographic.z;\n  }\n  return vector;\n}\n\nexport function fromCartographicToRadians(cartographic, vector = scratchVector) {\n  return fromCartographic(cartographic, vector, config.cartographicRadians ? noop : toRadians);\n}\n\nexport function fromCartographicToDegrees(cartographic, vector = scratchVector) {\n  return fromCartographic(cartographic, vector, config.cartographicRadians ? toDegrees : noop);\n}\n\nexport function toCartographic(vector, cartographic, map = noop) {\n  if (isArray(cartographic)) {\n    cartographic[0] = map(vector[0]);\n    cartographic[1] = map(vector[1]);\n    cartographic[2] = vector[2];\n  } else if ('longitude' in cartographic) {\n    cartographic.longitude = map(vector[0]);\n    cartographic.latitude = map(vector[1]);\n    cartographic.height = vector[2];\n  } else {\n    cartographic.x = map(vector[0]);\n    cartographic.y = map(vector[1]);\n    cartographic.z = vector[2];\n  }\n  return cartographic;\n}\n\nexport function toCartographicFromRadians(vector, cartographic) {\n  return toCartographic(vector, cartographic, config.cartographicRadians ? noop : toDegrees);\n}\n\nexport function toCartographicFromDegrees(vector, cartographic) {\n  return toCartographic(vector, cartographic, config.cartographicRadians ? toRadians : noop);\n}\n\nexport function isWGS84(vector) {\n  if (!vector) {\n    return false;\n  }\n  scratchVector.from(vector);\n  const {oneOverRadiiSquared, centerToleranceSquared} = WGS84_CONSTANTS;\n  const x2 = vector[0] * vector[0] * oneOverRadiiSquared[0];\n  const y2 = vector[1] * vector[1] * oneOverRadiiSquared[1];\n  const z2 = vector[2] * vector[2] * oneOverRadiiSquared[2];\n  return Math.abs(x2 + y2 + z2 - 1) < centerToleranceSquared;\n}\n"]},"metadata":{},"sourceType":"module"}