{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { assert } from '../utils';\nimport { parsePropTypes } from './filters/prop-types';\nvar VERTEX_SHADER = 'vs';\nvar FRAGMENT_SHADER = 'fs';\n\nvar ShaderModule = function () {\n  function ShaderModule(_ref) {\n    var name = _ref.name,\n        vs = _ref.vs,\n        fs = _ref.fs,\n        _ref$dependencies = _ref.dependencies,\n        dependencies = _ref$dependencies === void 0 ? [] : _ref$dependencies,\n        uniforms = _ref.uniforms,\n        getUniforms = _ref.getUniforms,\n        _ref$deprecations = _ref.deprecations,\n        deprecations = _ref$deprecations === void 0 ? [] : _ref$deprecations,\n        _ref$defines = _ref.defines,\n        defines = _ref$defines === void 0 ? {} : _ref$defines,\n        _ref$inject = _ref.inject,\n        inject = _ref$inject === void 0 ? {} : _ref$inject,\n        vertexShader = _ref.vertexShader,\n        fragmentShader = _ref.fragmentShader;\n\n    _classCallCheck(this, ShaderModule);\n\n    assert(typeof name === 'string');\n    this.name = name;\n    this.vs = vs || vertexShader;\n    this.fs = fs || fragmentShader;\n    this.getModuleUniforms = getUniforms;\n    this.dependencies = dependencies;\n    this.deprecations = this._parseDeprecationDefinitions(deprecations);\n    this.defines = defines;\n    this.injections = normalizeInjections(inject);\n\n    if (uniforms) {\n      this.uniforms = parsePropTypes(uniforms);\n    }\n  }\n\n  _createClass(ShaderModule, [{\n    key: \"getModuleSource\",\n    value: function getModuleSource(type) {\n      var moduleSource;\n\n      switch (type) {\n        case VERTEX_SHADER:\n          moduleSource = this.vs || '';\n          break;\n\n        case FRAGMENT_SHADER:\n          moduleSource = this.fs || '';\n          break;\n\n        default:\n          assert(false);\n      }\n\n      return \"#define MODULE_\".concat(this.name.toUpperCase().replace(/[^0-9a-z]/gi, '_'), \"\\n\").concat(moduleSource, \"// END MODULE_\").concat(this.name, \"\\n\\n\");\n    }\n  }, {\n    key: \"getUniforms\",\n    value: function getUniforms(opts, uniforms) {\n      if (this.getModuleUniforms) {\n        return this.getModuleUniforms(opts, uniforms);\n      }\n\n      if (this.uniforms) {\n        return this._defaultGetUniforms(opts);\n      }\n\n      return {};\n    }\n  }, {\n    key: \"getDefines\",\n    value: function getDefines() {\n      return this.defines;\n    }\n  }, {\n    key: \"checkDeprecations\",\n    value: function checkDeprecations(shaderSource, log) {\n      this.deprecations.forEach(function (def) {\n        if (def.regex.test(shaderSource)) {\n          if (def.deprecated) {\n            log.deprecated(def.old, def[\"new\"])();\n          } else {\n            log.removed(def.old, def[\"new\"])();\n          }\n        }\n      });\n    }\n  }, {\n    key: \"_parseDeprecationDefinitions\",\n    value: function _parseDeprecationDefinitions(deprecations) {\n      deprecations.forEach(function (def) {\n        switch (def.type) {\n          case 'function':\n            def.regex = new RegExp(\"\\\\b\".concat(def.old, \"\\\\(\"));\n            break;\n\n          default:\n            def.regex = new RegExp(\"\".concat(def.type, \" \").concat(def.old, \";\"));\n        }\n      });\n      return deprecations;\n    }\n  }, {\n    key: \"_defaultGetUniforms\",\n    value: function _defaultGetUniforms() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var uniforms = {};\n      var propTypes = this.uniforms;\n\n      for (var key in propTypes) {\n        var propDef = propTypes[key];\n\n        if (key in opts && !propDef[\"private\"]) {\n          if (propDef.validate) {\n            assert(propDef.validate(opts[key], propDef), \"\".concat(this.name, \": invalid \").concat(key));\n          }\n\n          uniforms[key] = opts[key];\n        } else {\n          uniforms[key] = propDef.value;\n        }\n      }\n\n      return uniforms;\n    }\n  }]);\n\n  return ShaderModule;\n}();\n\nexport { ShaderModule as default };\nexport function normalizeShaderModule(module) {\n  if (!module.normalized) {\n    module.normalized = true;\n\n    if (module.uniforms && !module.getUniforms) {\n      var shaderModule = new ShaderModule(module);\n      module.getUniforms = shaderModule.getUniforms.bind(shaderModule);\n    }\n  }\n\n  return module;\n}\n\nfunction normalizeInjections(injections) {\n  var result = {\n    vs: {},\n    fs: {}\n  };\n\n  for (var hook in injections) {\n    var injection = injections[hook];\n    var stage = hook.slice(0, 2);\n\n    if (typeof injection === 'string') {\n      injection = {\n        injection: injection\n      };\n    }\n\n    result[stage][hook] = injection;\n  }\n\n  return result;\n}","map":{"version":3,"sources":["../../../src/lib/shader-module.js"],"names":["VERTEX_SHADER","FRAGMENT_SHADER","ShaderModule","name","vs","fs","dependencies","uniforms","getUniforms","deprecations","defines","inject","vertexShader","fragmentShader","assert","normalizeInjections","parsePropTypes","type","moduleSource","opts","shaderSource","log","def","propTypes","propDef","key","module","shaderModule","result","injection","injections","stage","hook"],"mappings":"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","sourcesContent":["import {assert} from '../utils';\nimport {parsePropTypes} from './filters/prop-types';\n\nconst VERTEX_SHADER = 'vs';\nconst FRAGMENT_SHADER = 'fs';\n\nexport default class ShaderModule {\n  constructor({\n    name,\n    vs,\n    fs,\n    dependencies = [],\n    uniforms,\n    getUniforms,\n    deprecations = [],\n    defines = {},\n    inject = {},\n    // DEPRECATED\n    vertexShader,\n    fragmentShader\n  }) {\n    assert(typeof name === 'string');\n    this.name = name;\n    this.vs = vs || vertexShader;\n    this.fs = fs || fragmentShader;\n    this.getModuleUniforms = getUniforms;\n    this.dependencies = dependencies;\n    this.deprecations = this._parseDeprecationDefinitions(deprecations);\n    this.defines = defines;\n    this.injections = normalizeInjections(inject);\n\n    if (uniforms) {\n      this.uniforms = parsePropTypes(uniforms);\n    }\n  }\n\n  // Extracts the source code chunk for the specified shader type from the named shader module\n  getModuleSource(type) {\n    let moduleSource;\n    switch (type) {\n      case VERTEX_SHADER:\n        moduleSource = this.vs || '';\n        break;\n      case FRAGMENT_SHADER:\n        moduleSource = this.fs || '';\n        break;\n      default:\n        assert(false);\n    }\n\n    return `\\\n#define MODULE_${this.name.toUpperCase().replace(/[^0-9a-z]/gi, '_')}\n${moduleSource}\\\n// END MODULE_${this.name}\n\n`;\n  }\n\n  getUniforms(opts, uniforms) {\n    if (this.getModuleUniforms) {\n      return this.getModuleUniforms(opts, uniforms);\n    }\n    // Build uniforms from the uniforms array\n    if (this.uniforms) {\n      return this._defaultGetUniforms(opts);\n    }\n    return {};\n  }\n\n  getDefines() {\n    return this.defines;\n  }\n\n  // Warn about deprecated uniforms or functions\n  checkDeprecations(shaderSource, log) {\n    this.deprecations.forEach(def => {\n      if (def.regex.test(shaderSource)) {\n        if (def.deprecated) {\n          log.deprecated(def.old, def.new)();\n        } else {\n          log.removed(def.old, def.new)();\n        }\n      }\n    });\n  }\n\n  _parseDeprecationDefinitions(deprecations) {\n    deprecations.forEach(def => {\n      switch (def.type) {\n        case 'function':\n          def.regex = new RegExp(`\\\\b${def.old}\\\\(`);\n          break;\n        default:\n          def.regex = new RegExp(`${def.type} ${def.old};`);\n      }\n    });\n\n    return deprecations;\n  }\n\n  _defaultGetUniforms(opts = {}) {\n    const uniforms = {};\n    const propTypes = this.uniforms;\n\n    for (const key in propTypes) {\n      const propDef = propTypes[key];\n      if (key in opts && !propDef.private) {\n        if (propDef.validate) {\n          assert(propDef.validate(opts[key], propDef), `${this.name}: invalid ${key}`);\n        }\n        uniforms[key] = opts[key];\n      } else {\n        uniforms[key] = propDef.value;\n      }\n    }\n\n    return uniforms;\n  }\n}\n\n// This utility mutates the original module\n// Keeping for backward compatibility\n// TODO - remove in v8\nexport function normalizeShaderModule(module) {\n  if (!module.normalized) {\n    module.normalized = true;\n    if (module.uniforms && !module.getUniforms) {\n      const shaderModule = new ShaderModule(module);\n      module.getUniforms = shaderModule.getUniforms.bind(shaderModule);\n    }\n  }\n  return module;\n}\n\nfunction normalizeInjections(injections) {\n  const result = {\n    vs: {},\n    fs: {}\n  };\n\n  for (const hook in injections) {\n    let injection = injections[hook];\n    const stage = hook.slice(0, 2);\n\n    if (typeof injection === 'string') {\n      injection = {\n        injection\n      };\n    }\n\n    result[stage][hook] = injection;\n  }\n\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}