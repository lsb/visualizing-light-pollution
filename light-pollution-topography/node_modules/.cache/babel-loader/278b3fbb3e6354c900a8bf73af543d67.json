{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { Vector3 } from '@math.gl/core';\nimport { GL } from '@loaders.gl/math';\nimport Tile3DFeatureTable from '../classes/tile-3d-feature-table';\nimport Tile3DBatchTable from '../classes/tile-3d-batch-table';\nimport { parse3DTileHeaderSync } from './helpers/parse-3d-tile-header';\nimport { parse3DTileTablesHeaderSync, parse3DTileTablesSync } from './helpers/parse-3d-tile-tables';\nimport { normalize3DTileColorAttribute } from './helpers/normalize-3d-tile-colors';\nimport { normalize3DTileNormalAttribute } from './helpers/normalize-3d-tile-normals';\nimport { normalize3DTilePositionAttribute } from './helpers/normalize-3d-tile-positions';\nexport function parsePointCloud3DTile(_x, _x2, _x3, _x4, _x5) {\n  return _parsePointCloud3DTile.apply(this, arguments);\n}\n\nfunction _parsePointCloud3DTile() {\n  _parsePointCloud3DTile = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(tile, arrayBuffer, byteOffset, options, context) {\n    var _parsePointCloudTable, featureTable, batchTable;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset, options);\n            byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset, options);\n            byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);\n            initializeTile(tile);\n            _parsePointCloudTable = parsePointCloudTables(tile), featureTable = _parsePointCloudTable.featureTable, batchTable = _parsePointCloudTable.batchTable;\n            _context.next = 7;\n            return parseDraco(tile, featureTable, batchTable, options, context);\n\n          case 7:\n            parsePositions(tile, featureTable, options);\n            parseColors(tile, featureTable, batchTable, options);\n            parseNormals(tile, featureTable, options);\n            return _context.abrupt(\"return\", byteOffset);\n\n          case 11:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _parsePointCloud3DTile.apply(this, arguments);\n}\n\nfunction initializeTile(tile) {\n  tile.attributes = {\n    positions: null,\n    colors: null,\n    normals: null,\n    batchIds: null\n  };\n  tile.isQuantized = false;\n  tile.isTranslucent = false;\n  tile.isRGB565 = false;\n  tile.isOctEncoded16P = false;\n}\n\nfunction parsePointCloudTables(tile) {\n  var featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);\n  var pointsLength = featureTable.getGlobalProperty('POINTS_LENGTH');\n\n  if (!Number.isFinite(pointsLength)) {\n    throw new Error('POINTS_LENGTH must be defined');\n  }\n\n  featureTable.featuresLength = pointsLength;\n  tile.featuresLength = pointsLength;\n  tile.pointsLength = pointsLength;\n  tile.pointCount = pointsLength;\n  tile.rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', GL.FLOAT, 3);\n  var batchTable = parseBatchIds(tile, featureTable);\n  return {\n    featureTable: featureTable,\n    batchTable: batchTable\n  };\n}\n\nfunction parsePositions(tile, featureTable, options) {\n  if (!tile.attributes.positions) {\n    if (featureTable.hasProperty('POSITION')) {\n      tile.attributes.positions = featureTable.getPropertyArray('POSITION', GL.FLOAT, 3);\n    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n      var positions = featureTable.getPropertyArray('POSITION_QUANTIZED', GL.UNSIGNED_SHORT, 3);\n      tile.isQuantized = true;\n      tile.quantizedRange = (1 << 16) - 1;\n      tile.quantizedVolumeScale = featureTable.getGlobalProperty('QUANTIZED_VOLUME_SCALE', GL.FLOAT, 3);\n\n      if (!tile.quantizedVolumeScale) {\n        throw new Error('QUANTIZED_VOLUME_SCALE must be defined for quantized positions.');\n      }\n\n      tile.quantizedVolumeOffset = featureTable.getGlobalProperty('QUANTIZED_VOLUME_OFFSET', GL.FLOAT, 3);\n\n      if (!tile.quantizedVolumeOffset) {\n        throw new Error('QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.');\n      }\n\n      tile.attributes.positions = normalize3DTilePositionAttribute(tile, positions, options);\n    }\n  }\n\n  if (!tile.attributes.positions) {\n    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');\n  }\n}\n\nfunction parseColors(tile, featureTable, batchTable) {\n  if (!tile.attributes.colors) {\n    var colors = null;\n\n    if (featureTable.hasProperty('RGBA')) {\n      colors = featureTable.getPropertyArray('RGBA', GL.UNSIGNED_BYTE, 4);\n      tile.isTranslucent = true;\n    } else if (featureTable.hasProperty('RGB')) {\n      colors = featureTable.getPropertyArray('RGB', GL.UNSIGNED_BYTE, 3);\n    } else if (featureTable.hasProperty('RGB565')) {\n      colors = featureTable.getPropertyArray('RGB565', GL.UNSIGNED_SHORT, 1);\n      tile.isRGB565 = true;\n    }\n\n    tile.attributes.colors = normalize3DTileColorAttribute(tile, colors, batchTable);\n  }\n\n  if (featureTable.hasProperty('CONSTANT_RGBA')) {\n    tile.constantRGBA = featureTable.getGlobalProperty('CONSTANT_RGBA', GL.UNSIGNED_BYTE, 4);\n  }\n}\n\nfunction parseNormals(tile, featureTable) {\n  if (!tile.attributes.normals) {\n    var normals = null;\n\n    if (featureTable.hasProperty('NORMAL')) {\n      normals = featureTable.getPropertyArray('NORMAL', GL.FLOAT, 3);\n    } else if (featureTable.hasProperty('NORMAL_OCT16P')) {\n      normals = featureTable.getPropertyArray('NORMAL_OCT16P', GL.UNSIGNED_BYTE, 2);\n      tile.isOctEncoded16P = true;\n    }\n\n    tile.attributes.normals = normalize3DTileNormalAttribute(tile, normals);\n  }\n}\n\nfunction parseBatchIds(tile, featureTable) {\n  var batchTable = null;\n\n  if (!tile.batchIds && featureTable.hasProperty('BATCH_ID')) {\n    tile.batchIds = featureTable.getPropertyArray('BATCH_ID', GL.UNSIGNED_SHORT, 1);\n\n    if (tile.batchIds) {\n      var batchFeatureLength = featureTable.getGlobalProperty('BATCH_LENGTH');\n\n      if (!batchFeatureLength) {\n        throw new Error('Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.');\n      }\n\n      var batchTableJson = tile.batchTableJson,\n          batchTableBinary = tile.batchTableBinary;\n      batchTable = new Tile3DBatchTable(batchTableJson, batchTableBinary, batchFeatureLength);\n    }\n  }\n\n  return batchTable;\n}\n\nfunction parseDraco(_x6, _x7, _x8, _x9, _x10) {\n  return _parseDraco.apply(this, arguments);\n}\n\nfunction _parseDraco() {\n  _parseDraco = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(tile, featureTable, batchTable, options, context) {\n    var dracoBuffer, dracoFeatureTableProperties, dracoBatchTableProperties, batchTableDraco, featureTableDraco, dracoByteOffset, dracoByteLength, dracoData;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            batchTableDraco = batchTable && batchTable.getExtension('3DTILES_draco_point_compression');\n\n            if (batchTableDraco) {\n              dracoBatchTableProperties = batchTableDraco.properties;\n            }\n\n            featureTableDraco = featureTable.getExtension('3DTILES_draco_point_compression');\n\n            if (!featureTableDraco) {\n              _context2.next = 15;\n              break;\n            }\n\n            dracoFeatureTableProperties = featureTableDraco.properties;\n            dracoByteOffset = featureTableDraco.byteOffset;\n            dracoByteLength = featureTableDraco.byteLength;\n\n            if (!(!dracoFeatureTableProperties || !Number.isFinite(dracoByteOffset) || !dracoByteLength)) {\n              _context2.next = 9;\n              break;\n            }\n\n            throw new Error('Draco properties, byteOffset, and byteLength must be defined');\n\n          case 9:\n            dracoBuffer = tile.featureTableBinary.slice(dracoByteOffset, dracoByteOffset + dracoByteLength);\n            tile.hasPositions = Number.isFinite(dracoFeatureTableProperties.POSITION);\n            tile.hasColors = Number.isFinite(dracoFeatureTableProperties.RGB) || Number.isFinite(dracoFeatureTableProperties.RGBA);\n            tile.hasNormals = Number.isFinite(dracoFeatureTableProperties.NORMAL);\n            tile.hasBatchIds = Number.isFinite(dracoFeatureTableProperties.BATCH_ID);\n            tile.isTranslucent = Number.isFinite(dracoFeatureTableProperties.RGBA);\n\n          case 15:\n            if (dracoBuffer) {\n              _context2.next = 17;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", true);\n\n          case 17:\n            dracoData = {\n              buffer: dracoBuffer,\n              properties: _objectSpread({}, dracoFeatureTableProperties, {}, dracoBatchTableProperties),\n              featureTableProperties: dracoFeatureTableProperties,\n              batchTableProperties: dracoBatchTableProperties,\n              dequantizeInShader: false\n            };\n            _context2.next = 20;\n            return loadDraco(tile, dracoData, options, context);\n\n          case 20:\n            return _context2.abrupt(\"return\", _context2.sent);\n\n          case 21:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _parseDraco.apply(this, arguments);\n}\n\nexport function loadDraco(_x11, _x12, _x13, _x14) {\n  return _loadDraco.apply(this, arguments);\n}\n\nfunction _loadDraco() {\n  _loadDraco = _asyncToGenerator(_regeneratorRuntime.mark(function _callee3(tile, dracoData, options, context) {\n    var parse, data, decodedPositions, decodedColors, decodedNormals, decodedBatchIds, isQuantizedDraco, isOctEncodedDraco, quantization, range;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            parse = context.parse;\n            _context3.next = 3;\n            return parse(dracoData.buffer, {});\n\n          case 3:\n            data = _context3.sent;\n            decodedPositions = data.attributes.POSITION && data.attributes.POSITION.value;\n            decodedColors = data.attributes.COLOR_0 && data.attributes.COLOR_0.value;\n            decodedNormals = data.attributes.NORMAL && data.attributes.NORMAL.value;\n            decodedBatchIds = data.attributes.BATCH_ID && data.attributes.BATCH_ID.value;\n            isQuantizedDraco = decodedPositions && data.attributes.POSITION.value.quantization;\n            isOctEncodedDraco = decodedNormals && data.attributes.NORMAL.value.quantization;\n\n            if (isQuantizedDraco) {\n              quantization = data.POSITION.data.quantization;\n              range = quantization.range;\n              tile.quantizedVolumeScale = new Vector3(range, range, range);\n              tile.quantizedVolumeOffset = new Vector3(quantization.minValues);\n              tile.quantizedRange = (1 << quantization.quantizationBits) - 1.0;\n              tile.isQuantizedDraco = true;\n            }\n\n            if (isOctEncodedDraco) {\n              tile.octEncodedRange = (1 << data.NORMAL.data.quantization.quantizationBits) - 1.0;\n              tile.isOctEncodedDraco = true;\n            }\n\n            tile.attributes = {\n              positions: decodedPositions,\n              colors: normalize3DTileColorAttribute(tile, decodedColors),\n              normals: decodedNormals,\n              batchIds: decodedBatchIds\n            };\n\n          case 13:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _loadDraco.apply(this, arguments);\n}","map":{"version":3,"sources":["../../../../src/lib/parsers/parse-3d-tile-point-cloud.js"],"names":["byteOffset","parse3DTileHeaderSync","parse3DTileTablesHeaderSync","parse3DTileTablesSync","initializeTile","featureTable","batchTable","parsePointCloudTables","parseDraco","parsePositions","parseColors","parseNormals","tile","positions","colors","normals","batchIds","pointsLength","Number","GL","parseBatchIds","normalize3DTilePositionAttribute","normalize3DTileColorAttribute","normalize3DTileNormalAttribute","batchFeatureLength","batchTableJson","batchTableBinary","batchTableDraco","dracoBatchTableProperties","featureTableDraco","dracoFeatureTableProperties","dracoByteOffset","dracoByteLength","dracoBuffer","dracoData","buffer","properties","featureTableProperties","batchTableProperties","dequantizeInShader","loadDraco","parse","context","data","decodedPositions","decodedColors","decodedNormals","decodedBatchIds","isQuantizedDraco","isOctEncodedDraco","quantization","range"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Vector3} from '@math.gl/core';\nimport {GL} from '@loaders.gl/math'; // 'math.gl/geometry';\n\nimport Tile3DFeatureTable from '../classes/tile-3d-feature-table';\nimport Tile3DBatchTable from '../classes/tile-3d-batch-table';\nimport {parse3DTileHeaderSync} from './helpers/parse-3d-tile-header';\nimport {parse3DTileTablesHeaderSync, parse3DTileTablesSync} from './helpers/parse-3d-tile-tables';\nimport {normalize3DTileColorAttribute} from './helpers/normalize-3d-tile-colors';\nimport {normalize3DTileNormalAttribute} from './helpers/normalize-3d-tile-normals';\nimport {normalize3DTilePositionAttribute} from './helpers/normalize-3d-tile-positions';\n\nexport async function parsePointCloud3DTile(tile, arrayBuffer, byteOffset, options, context) {\n  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset, options);\n  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset, options);\n  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);\n  initializeTile(tile);\n\n  const {featureTable, batchTable} = parsePointCloudTables(tile);\n\n  await parseDraco(tile, featureTable, batchTable, options, context);\n\n  parsePositions(tile, featureTable, options);\n  parseColors(tile, featureTable, batchTable, options);\n  parseNormals(tile, featureTable, options);\n\n  return byteOffset;\n}\n\nfunction initializeTile(tile) {\n  // Initialize point cloud tile defaults\n  tile.attributes = {\n    positions: null,\n    colors: null,\n    normals: null,\n    batchIds: null\n  };\n  tile.isQuantized = false;\n  tile.isTranslucent = false;\n  tile.isRGB565 = false;\n  tile.isOctEncoded16P = false;\n}\n\nfunction parsePointCloudTables(tile) {\n  const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);\n\n  const pointsLength = featureTable.getGlobalProperty('POINTS_LENGTH');\n  if (!Number.isFinite(pointsLength)) {\n    throw new Error('POINTS_LENGTH must be defined');\n  }\n  featureTable.featuresLength = pointsLength;\n\n  tile.featuresLength = pointsLength;\n  tile.pointsLength = pointsLength;\n  tile.pointCount = pointsLength;\n\n  tile.rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', GL.FLOAT, 3);\n\n  const batchTable = parseBatchIds(tile, featureTable);\n\n  return {featureTable, batchTable};\n}\n\nfunction parsePositions(tile, featureTable, options) {\n  if (!tile.attributes.positions) {\n    if (featureTable.hasProperty('POSITION')) {\n      tile.attributes.positions = featureTable.getPropertyArray('POSITION', GL.FLOAT, 3);\n    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n      const positions = featureTable.getPropertyArray('POSITION_QUANTIZED', GL.UNSIGNED_SHORT, 3);\n\n      tile.isQuantized = true;\n      tile.quantizedRange = (1 << 16) - 1;\n\n      tile.quantizedVolumeScale = featureTable.getGlobalProperty(\n        'QUANTIZED_VOLUME_SCALE',\n        GL.FLOAT,\n        3\n      );\n      if (!tile.quantizedVolumeScale) {\n        throw new Error('QUANTIZED_VOLUME_SCALE must be defined for quantized positions.');\n      }\n\n      tile.quantizedVolumeOffset = featureTable.getGlobalProperty(\n        'QUANTIZED_VOLUME_OFFSET',\n        GL.FLOAT,\n        3\n      );\n      if (!tile.quantizedVolumeOffset) {\n        throw new Error('QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.');\n      }\n\n      tile.attributes.positions = normalize3DTilePositionAttribute(tile, positions, options);\n    }\n  }\n\n  if (!tile.attributes.positions) {\n    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');\n  }\n}\n\nfunction parseColors(tile, featureTable, batchTable) {\n  if (!tile.attributes.colors) {\n    let colors = null;\n    if (featureTable.hasProperty('RGBA')) {\n      colors = featureTable.getPropertyArray('RGBA', GL.UNSIGNED_BYTE, 4);\n      tile.isTranslucent = true;\n    } else if (featureTable.hasProperty('RGB')) {\n      colors = featureTable.getPropertyArray('RGB', GL.UNSIGNED_BYTE, 3);\n    } else if (featureTable.hasProperty('RGB565')) {\n      colors = featureTable.getPropertyArray('RGB565', GL.UNSIGNED_SHORT, 1);\n      tile.isRGB565 = true;\n    }\n\n    tile.attributes.colors = normalize3DTileColorAttribute(tile, colors, batchTable);\n  }\n\n  if (featureTable.hasProperty('CONSTANT_RGBA')) {\n    tile.constantRGBA = featureTable.getGlobalProperty('CONSTANT_RGBA', GL.UNSIGNED_BYTE, 4);\n  }\n}\n\nfunction parseNormals(tile, featureTable) {\n  if (!tile.attributes.normals) {\n    let normals = null;\n    if (featureTable.hasProperty('NORMAL')) {\n      normals = featureTable.getPropertyArray('NORMAL', GL.FLOAT, 3);\n    } else if (featureTable.hasProperty('NORMAL_OCT16P')) {\n      normals = featureTable.getPropertyArray('NORMAL_OCT16P', GL.UNSIGNED_BYTE, 2);\n      tile.isOctEncoded16P = true;\n    }\n\n    tile.attributes.normals = normalize3DTileNormalAttribute(tile, normals);\n  }\n}\n\nfunction parseBatchIds(tile, featureTable) {\n  let batchTable = null;\n  if (!tile.batchIds && featureTable.hasProperty('BATCH_ID')) {\n    tile.batchIds = featureTable.getPropertyArray('BATCH_ID', GL.UNSIGNED_SHORT, 1);\n\n    if (tile.batchIds) {\n      const batchFeatureLength = featureTable.getGlobalProperty('BATCH_LENGTH');\n      if (!batchFeatureLength) {\n        throw new Error('Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.');\n      }\n      const {batchTableJson, batchTableBinary} = tile;\n      batchTable = new Tile3DBatchTable(batchTableJson, batchTableBinary, batchFeatureLength);\n    }\n  }\n  return batchTable;\n}\n\n// eslint-disable-next-line complexity\nasync function parseDraco(tile, featureTable, batchTable, options, context) {\n  let dracoBuffer;\n  let dracoFeatureTableProperties;\n  let dracoBatchTableProperties;\n  const batchTableDraco = batchTable && batchTable.getExtension('3DTILES_draco_point_compression');\n  if (batchTableDraco) {\n    dracoBatchTableProperties = batchTableDraco.properties;\n  }\n\n  const featureTableDraco = featureTable.getExtension('3DTILES_draco_point_compression');\n  if (featureTableDraco) {\n    dracoFeatureTableProperties = featureTableDraco.properties;\n    const dracoByteOffset = featureTableDraco.byteOffset;\n    const dracoByteLength = featureTableDraco.byteLength;\n    if (!dracoFeatureTableProperties || !Number.isFinite(dracoByteOffset) || !dracoByteLength) {\n      throw new Error('Draco properties, byteOffset, and byteLength must be defined');\n    }\n\n    dracoBuffer = tile.featureTableBinary.slice(dracoByteOffset, dracoByteOffset + dracoByteLength);\n\n    tile.hasPositions = Number.isFinite(dracoFeatureTableProperties.POSITION);\n    tile.hasColors =\n      Number.isFinite(dracoFeatureTableProperties.RGB) ||\n      Number.isFinite(dracoFeatureTableProperties.RGBA);\n    tile.hasNormals = Number.isFinite(dracoFeatureTableProperties.NORMAL);\n    tile.hasBatchIds = Number.isFinite(dracoFeatureTableProperties.BATCH_ID);\n    tile.isTranslucent = Number.isFinite(dracoFeatureTableProperties.RGBA);\n  }\n\n  if (!dracoBuffer) {\n    return true;\n  }\n\n  const dracoData = {\n    buffer: dracoBuffer,\n    properties: {...dracoFeatureTableProperties, ...dracoBatchTableProperties},\n    featureTableProperties: dracoFeatureTableProperties,\n    batchTableProperties: dracoBatchTableProperties,\n    dequantizeInShader: false\n  };\n\n  return await loadDraco(tile, dracoData, options, context);\n}\n\n// eslint-disable-next-line complexity, max-statements\nexport async function loadDraco(tile, dracoData, options, context) {\n  const {parse} = context;\n  const data = await parse(dracoData.buffer, {});\n\n  const decodedPositions = data.attributes.POSITION && data.attributes.POSITION.value;\n  const decodedColors = data.attributes.COLOR_0 && data.attributes.COLOR_0.value;\n  const decodedNormals = data.attributes.NORMAL && data.attributes.NORMAL.value;\n  const decodedBatchIds = data.attributes.BATCH_ID && data.attributes.BATCH_ID.value;\n  const isQuantizedDraco = decodedPositions && data.attributes.POSITION.value.quantization;\n  const isOctEncodedDraco = decodedNormals && data.attributes.NORMAL.value.quantization;\n  if (isQuantizedDraco) {\n    // Draco quantization range == quantized volume scale - size in meters of the quantized volume\n    // Internal quantized range is the range of values of the quantized data, e.g. 255 for 8-bit, 1023 for 10-bit, etc\n    const quantization = data.POSITION.data.quantization;\n    const range = quantization.range;\n    tile.quantizedVolumeScale = new Vector3(range, range, range);\n    tile.quantizedVolumeOffset = new Vector3(quantization.minValues);\n    tile.quantizedRange = (1 << quantization.quantizationBits) - 1.0;\n    tile.isQuantizedDraco = true;\n  }\n  if (isOctEncodedDraco) {\n    tile.octEncodedRange = (1 << data.NORMAL.data.quantization.quantizationBits) - 1.0;\n    tile.isOctEncodedDraco = true;\n  }\n\n  tile.attributes = {\n    positions: decodedPositions,\n    colors: normalize3DTileColorAttribute(tile, decodedColors),\n    normals: decodedNormals,\n    batchIds: decodedBatchIds\n  };\n}\n\n// TODO - this is the remaining code from Cesium's parser\n/*\n  const batchTable = new Tile3DBatchTable(tile);\n\n  // parseDracoBuffer(tile, featureTable, batchTable);\n\n  if (!tile.attributes.positions) {\n    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');\n  }\n}\n/*\n\n  if (!tile.attributes.positions) {\n    if (featureTable.hasProperty('POSITION')) {\n      tile.attributes.positions = featureTable.getPropertyArray('POSITION', GL.FLOAT, 3);\n    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n      tile.attributes.positions = featureTable.getPropertyArray('POSITION_QUANTIZED', GL.UNSIGNED_SHORT, 3);\n\n\n  if (!tile.colors) {\n    if (featureTable.hasProperty('RGBA')) {\n      tile.colors = featureTable.getPropertyArray('RGBA', GL.UNSIGNED_BYTE, 4);\n      tile.isTranslucent = true;\n    } else if (featureTable.hasProperty('RGB')) {\n      tile.colors = featureTable.getPropertyArray('RGB', GL.UNSIGNED_BYTE, 3);\n    } else if (featureTable.hasPropertry('RGB565')) {\n      tile.colors = featureTable.getPropertyArray('RGB565', GL.UNSIGNED_SHORT, 1);\n      tile.isRGB565 = true;\n    }\n  }\n\n  if (!tile.attributes.normals) {\n    if (featureTable.getPropertry('NORMAL')) {\n      tile.attributes.normals = featureTable.getPropertyArray('NORMAL', GL.FLOAT, 3);\n    } else if (featureTable.getProperty('NORMAL_OCT16P')) {\n      tile.attributes.normals = featureTable.getPropertyArray('NORMAL_OCT16P', GL.UNSIGNED_BYTE, 2);\n      tile.isOctEncoded16P = true;\n    }\n  }\n\n  if (!tile.batchIds) {\n    if (featureTable.hasProperty('BATCH_ID')) {\n      tile.batchIds = featureTable.getPropertyArray('BATCH_ID', GL.UNSIGNED_SHORT, 1);\n    }\n  }\n\n  if (!tile.attributes.positions) {\n    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');\n  }\n\n  if (featureTable.getPropertry('CONSTANT_RGBA')) {\n    tile.constantRGBA = featureTable.getGlobalProperty('CONSTANT_RGBA', GL.UNSIGNED_BYTE, 4);\n  }\n\n  if (tile.batchIds) {\n    const batchLength = featureTable.getGlobalProperty('BATCH_LENGTH');\n    if (!defined(batchLength)) {\n      throw new Error('Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.');\n    }\n\n    if (defined(batchTableBinary)) {\n      // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n      batchTableBinary = new Uint8Array(batchTableBinary);\n    }\n\n    if (defined(pointCloud._batchTableLoaded)) {\n      pointCloud._batchTableLoaded(batchLength, batchTableJson, batchTableBinary);\n    }\n  }\n\n  // If points are not batched and there are per-point properties, use these properties for styling purposes\n  var styleableProperties;\n  if (!hasBatchIds && defined(batchTableBinary)) {\n    tile.styleableProperties = Cesium3DTileBatchTable.getBinaryProperties(\n      pointsLength,\n      batchTableJson,\n      batchTableBinary\n    );\n  }\n\n  tile.draco = draco;\n}\n\n// Separate parsing and decoding of Draco\nexport function parseDracoBuffer(tile, featureTable, batchTable) {\n  let dracoBuffer;\n  let dracoFeatureTableProperties;\n  let dracoBatchTableProperties;\n\n  const batchTableDraco = batchTable.getExtension('3DTILES_draco_point_compression');\n  if (batchTableDraco) {\n    dracoBatchTableProperties = batchTableDraco.properties;\n  }\n\n  const featureTableDraco = featureTable.getExtension('3DTILES_draco_point_compression');\n  if (featureTableDraco) {\n    dracoFeatureTableProperties = featureTableDraco.properties;\n    const dracoByteOffset = featureTableDraco.byteOffset;\n    const dracoByteLength = featureTableDraco.byteLength;\n    if (!dracoFeatureTableProperties || !dracoByteOffset || !dracoByteLength) {\n      throw new Error('Draco properties, byteOffset, and byteLength must be defined');\n    }\n\n    dracoBuffer = arraySlice(\n      featureTableBinary,\n      dracoByteOffset,\n      dracoByteOffset + dracoByteLength\n    );\n    tile.hasPositions = dracoFeatureTableProperties.POSITION;\n    tile.hasColors = dracoFeatureTableProperties.RGB || dracoFeatureTableProperties.RGBA;\n    tile.hasNormals = dracoFeatureTableProperties.NORMAL;\n    tile.hasBatchIds = dracoFeatureTableProperties.BATCH_ID;\n    tile.isTranslucent = dracoFeatureTableProperties.RGBA;\n  }\n\n  if (dracoBuffer) {\n    tile.draco = {\n      buffer: dracoBuffer,\n      properties: {...dracoFeatureTableProperties, ...dracoBatchTableProperties},\n      featureTableProperties: dracoFeatureTableProperties,\n      batchTableProperties: dracoBatchTableProperties,\n      dequantizeInShader: false\n    };\n\n    tile.decodingState = DECODING_STATE.NEEDS_DECODE;\n  }\n}\n\n/*\nfunction decodeDraco(tile, context) {\n  if (tile.decodingState === DECODING_STATE.READY) {\n    return false;\n  }\n  if (tile.decodingState === DECODING_STATE.NEEDS_DECODE) {\n    var parsedContent = tile._parsedContent;\n    var draco = parsedContent.draco;\n    var decodePromise = DracoLoader.decodePointCloud(draco, context);\n    if (defined(decodePromise)) {\n      tile.decodingState = DECODING_STATE.DECODING;\n      decodePromise.then(function(result) {\n        tile.decodingState = DECODING_STATE.READY;\n        var decodedPositions = defined(result.POSITION) ? result.POSITION.array : undefined;\n        var decodedRgb = defined(result.RGB) ? result.RGB.array : undefined;\n        var decodedRgba = defined(result.RGBA) ? result.RGBA.array : undefined;\n        var decodedNormals = defined(result.NORMAL) ? result.NORMAL.array : undefined;\n        var decodedBatchIds = defined(result.BATCH_ID) ? result.BATCH_ID.array : undefined;\n        var isQuantizedDraco = defined(decodedPositions) && defined(result.POSITION.data.quantization);\n        var isOctEncodedDraco = defined(decodedNormals) && defined(result.NORMAL.data.quantization);\n        if (isQuantizedDraco) {\n          // Draco quantization range == quantized volume scale - size in meters of the quantized volume\n          // Internal quantized range is the range of values of the quantized data, e.g. 255 for 8-bit, 1023 for 10-bit, etc\n          var quantization = result.POSITION.data.quantization;\n          var range = quantization.range;\n          tile._quantizedVolumeScale = Cartesian3.fromElements(range, range, range);\n          tile._quantizedVolumeOffset = Cartesian3.unpack(quantization.minValues);\n          tile._quantizedRange = (1 << quantization.quantizationBits) - 1.0;\n          tile._isQuantizedDraco = true;\n        }\n        if (isOctEncodedDraco) {\n          tile._octEncodedRange = (1 << result.NORMAL.data.quantization.quantizationBits) - 1.0;\n          tile._isOctEncodedDraco = true;\n        }\n        var styleableProperties = parsedContent.styleableProperties;\n        var batchTableProperties = draco.batchTableProperties;\n        for (var name in batchTableProperties) {\n          if (batchTableProperties.hasOwnProperty(name)) {\n            var property = result[name];\n            if (!defined(styleableProperties)) {\n              styleableProperties = {};\n            }\n            styleableProperties[name] = {\n              typedArray : property.array,\n              componentCount : property.data.componentsPerAttribute\n            };\n          }\n        }\n        parsedContent.positions = defaultValue(decodedPositions, parsedContent.positions);\n        parsedContent.colors = defaultValue(defaultValue(decodedRgba, decodedRgb), parsedContent.colors);\n        parsedContent.normals = defaultValue(decodedNormals, parsedContent.normals);\n        parsedContent.batchIds = defaultValue(decodedBatchIds, parsedContent.batchIds);\n        parsedContent.styleableProperties = styleableProperties;\n      }).otherwise(function(error) {\n        tile.decodingState = DECODING_STATE.FAILED;\n        tile._readyPromise.reject(error);\n      });\n    }\n  }\n  return true;\n}\n*/\n"]},"metadata":{},"sourceType":"module"}