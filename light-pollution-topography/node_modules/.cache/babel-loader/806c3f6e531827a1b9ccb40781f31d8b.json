{"ast":null,"code":"var ERR_TYPE_DEDUCTION = 'Failed to deduce GL constant from typed array';\nexport function getGLTypeFromTypedArray(arrayOrType) {\n  var type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;\n\n  switch (type) {\n    case Float32Array:\n      return 5126;\n\n    case Uint16Array:\n      return 5123;\n\n    case Uint32Array:\n      return 5125;\n\n    case Uint8Array:\n      return 5121;\n\n    case Uint8ClampedArray:\n      return 5121;\n\n    case Int8Array:\n      return 5120;\n\n    case Int16Array:\n      return 5122;\n\n    case Int32Array:\n      return 5124;\n\n    default:\n      throw new Error(ERR_TYPE_DEDUCTION);\n  }\n}\nexport function getTypedArrayFromGLType(glType) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$clamped = _ref.clamped,\n      clamped = _ref$clamped === void 0 ? true : _ref$clamped;\n\n  switch (glType) {\n    case 5126:\n      return Float32Array;\n\n    case 5123:\n    case 33635:\n    case 32819:\n    case 32820:\n      return Uint16Array;\n\n    case 5125:\n      return Uint32Array;\n\n    case 5121:\n      return clamped ? Uint8ClampedArray : Uint8Array;\n\n    case 5120:\n      return Int8Array;\n\n    case 5122:\n      return Int16Array;\n\n    case 5124:\n      return Int32Array;\n\n    default:\n      throw new Error('Failed to deduce typed array type from GL constant');\n  }\n}\nexport function flipRows(_ref2) {\n  var data = _ref2.data,\n      width = _ref2.width,\n      height = _ref2.height,\n      _ref2$bytesPerPixel = _ref2.bytesPerPixel,\n      bytesPerPixel = _ref2$bytesPerPixel === void 0 ? 4 : _ref2$bytesPerPixel,\n      temp = _ref2.temp;\n  var bytesPerRow = width * bytesPerPixel;\n  temp = temp || new Uint8Array(bytesPerRow);\n\n  for (var y = 0; y < height / 2; ++y) {\n    var topOffset = y * bytesPerRow;\n    var bottomOffset = (height - y - 1) * bytesPerRow;\n    temp.set(data.subarray(topOffset, topOffset + bytesPerRow));\n    data.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);\n    data.set(temp, bottomOffset);\n  }\n}\nexport function scalePixels(_ref3) {\n  var data = _ref3.data,\n      width = _ref3.width,\n      height = _ref3.height;\n  var newWidth = Math.round(width / 2);\n  var newHeight = Math.round(height / 2);\n  var newData = new Uint8Array(newWidth * newHeight * 4);\n\n  for (var y = 0; y < newHeight; y++) {\n    for (var x = 0; x < newWidth; x++) {\n      for (var c = 0; c < 4; c++) {\n        newData[(y * newWidth + x) * 4 + c] = data[(y * 2 * width + x * 2) * 4 + c];\n      }\n    }\n  }\n\n  return {\n    data: newData,\n    width: newWidth,\n    height: newHeight\n  };\n}","map":{"version":3,"sources":["../../../src/webgl-utils/typed-array-utils.js"],"names":["ERR_TYPE_DEDUCTION","type","ArrayBuffer","arrayOrType","clamped","data","width","height","bytesPerPixel","temp","bytesPerRow","y","topOffset","bottomOffset","newWidth","Math","newHeight","newData","x","c"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\n\nconst ERR_TYPE_DEDUCTION = 'Failed to deduce GL constant from typed array';\n\n// Converts TYPED ARRAYS to corresponding GL constant\n// Used to auto deduce gl parameter types\nexport function getGLTypeFromTypedArray(arrayOrType) {\n  // If typed array, look up constructor\n  const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;\n  switch (type) {\n    case Float32Array:\n      return GL.FLOAT;\n    case Uint16Array:\n      return GL.UNSIGNED_SHORT;\n    case Uint32Array:\n      return GL.UNSIGNED_INT;\n    case Uint8Array:\n      return GL.UNSIGNED_BYTE;\n    case Uint8ClampedArray:\n      return GL.UNSIGNED_BYTE;\n    case Int8Array:\n      return GL.BYTE;\n    case Int16Array:\n      return GL.SHORT;\n    case Int32Array:\n      return GL.INT;\n    default:\n      throw new Error(ERR_TYPE_DEDUCTION);\n  }\n}\n\n// Converts GL constant to corresponding TYPED ARRAY\n// Used to auto deduce gl parameter types\n\n/* eslint-disable complexity */\nexport function getTypedArrayFromGLType(glType, {clamped = true} = {}) {\n  // Sorted in some order of likelihood to reduce amount of comparisons\n  switch (glType) {\n    case GL.FLOAT:\n      return Float32Array;\n    case GL.UNSIGNED_SHORT:\n    case GL.UNSIGNED_SHORT_5_6_5:\n    case GL.UNSIGNED_SHORT_4_4_4_4:\n    case GL.UNSIGNED_SHORT_5_5_5_1:\n      return Uint16Array;\n    case GL.UNSIGNED_INT:\n      return Uint32Array;\n    case GL.UNSIGNED_BYTE:\n      return clamped ? Uint8ClampedArray : Uint8Array;\n    case GL.BYTE:\n      return Int8Array;\n    case GL.SHORT:\n      return Int16Array;\n    case GL.INT:\n      return Int32Array;\n    default:\n      throw new Error('Failed to deduce typed array type from GL constant');\n  }\n}\n/* eslint-enable complexity */\n\n// Flip rows (can be used on arrays returned from `Framebuffer.readPixels`)\n// https://stackoverflow.com/questions/41969562/\n// how-can-i-flip-the-result-of-webglrenderingcontext-readpixels\nexport function flipRows({data, width, height, bytesPerPixel = 4, temp}) {\n  const bytesPerRow = width * bytesPerPixel;\n\n  // make a temp buffer to hold one row\n  temp = temp || new Uint8Array(bytesPerRow);\n  for (let y = 0; y < height / 2; ++y) {\n    const topOffset = y * bytesPerRow;\n    const bottomOffset = (height - y - 1) * bytesPerRow;\n    // make copy of a row on the top half\n    temp.set(data.subarray(topOffset, topOffset + bytesPerRow));\n    // copy a row from the bottom half to the top\n    data.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);\n    // copy the copy of the top half row to the bottom half\n    data.set(temp, bottomOffset);\n  }\n}\n\nexport function scalePixels({data, width, height}) {\n  const newWidth = Math.round(width / 2);\n  const newHeight = Math.round(height / 2);\n  const newData = new Uint8Array(newWidth * newHeight * 4);\n  for (let y = 0; y < newHeight; y++) {\n    for (let x = 0; x < newWidth; x++) {\n      for (let c = 0; c < 4; c++) {\n        newData[(y * newWidth + x) * 4 + c] = data[(y * 2 * width + x * 2) * 4 + c];\n      }\n    }\n  }\n  return {data: newData, width: newWidth, height: newHeight};\n}\n"]},"metadata":{},"sourceType":"module"}