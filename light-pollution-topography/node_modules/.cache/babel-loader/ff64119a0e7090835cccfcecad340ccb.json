{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { Vector3, Matrix3 } from 'math.gl';\nimport BoundingSphere from './bounding-sphere';\nimport { Intersect } from '../constants';\nimport makeOrientedBoundingBoxfromPoints from '../algorithms/bounding-box-from-points';\nvar scratchVector = new Vector3();\nvar scratchOffset = new Vector3();\nvar scratchVectorU = new Vector3();\nvar scratchVectorV = new Vector3();\nvar scratchVectorW = new Vector3();\nvar scratchPPrime = new Vector3();\nvar scratchCorner = new Vector3();\nvar scratchToCenter = new Vector3();\nvar fromOrientedBoundingBoxScratchU = new Vector3();\nvar fromOrientedBoundingBoxScratchV = new Vector3();\nvar fromOrientedBoundingBoxScratchW = new Vector3();\nvar MATRIX3 = {\n  COLUMN0ROW0: 0,\n  COLUMN0ROW1: 1,\n  COLUMN0ROW2: 2,\n  COLUMN1ROW0: 3,\n  COLUMN1ROW1: 4,\n  COLUMN1ROW2: 5,\n  COLUMN2ROW0: 6,\n  COLUMN2ROW1: 7,\n  COLUMN2ROW2: 8\n};\n\nvar OrientedBoundingBox = function () {\n  function OrientedBoundingBox() {\n    var center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0];\n    var halfAxes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0, 0, 0, 0, 0, 0, 0];\n\n    _classCallCheck(this, OrientedBoundingBox);\n\n    this.center = new Vector3().from(center);\n    this.halfAxes = new Matrix3(halfAxes);\n  }\n\n  _createClass(OrientedBoundingBox, [{\n    key: \"clone\",\n    value: function clone(result) {\n      return new OrientedBoundingBox(this.center, this.halfAxes);\n    }\n  }, {\n    key: \"fromPoints\",\n    value: function fromPoints(points) {\n      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new OrientedBoundingBox();\n      return makeOrientedBoundingBoxfromPoints(points, result);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(right) {\n      return this === right || Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes);\n    }\n  }, {\n    key: \"getBoundingSphere\",\n    value: function getBoundingSphere() {\n      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new BoundingSphere();\n      var halfAxes = this.halfAxes;\n      var u = halfAxes.getColumn(0, fromOrientedBoundingBoxScratchU);\n      var v = halfAxes.getColumn(1, fromOrientedBoundingBoxScratchV);\n      var w = halfAxes.getColumn(2, fromOrientedBoundingBoxScratchW);\n      var cornerVector = scratchVector.copy(u).add(v).add(w);\n      result.center.copy(this.center);\n      result.radius = cornerVector.magnitude();\n      return result;\n    }\n  }, {\n    key: \"intersectPlane\",\n    value: function intersectPlane(plane) {\n      var center = this.center;\n      var normal = plane.normal;\n      var halfAxes = this.halfAxes;\n      var normalX = normal.x;\n      var normalY = normal.y;\n      var normalZ = normal.z;\n      var radEffective = Math.abs(normalX * halfAxes[MATRIX3.COLUMN0ROW0] + normalY * halfAxes[MATRIX3.COLUMN0ROW1] + normalZ * halfAxes[MATRIX3.COLUMN0ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN1ROW0] + normalY * halfAxes[MATRIX3.COLUMN1ROW1] + normalZ * halfAxes[MATRIX3.COLUMN1ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN2ROW0] + normalY * halfAxes[MATRIX3.COLUMN2ROW1] + normalZ * halfAxes[MATRIX3.COLUMN2ROW2]);\n      var distanceToPlane = normal.dot(center) + plane.distance;\n\n      if (distanceToPlane <= -radEffective) {\n        return Intersect.OUTSIDE;\n      } else if (distanceToPlane >= radEffective) {\n        return Intersect.INSIDE;\n      }\n\n      return Intersect.INTERSECTING;\n    }\n  }, {\n    key: \"distanceTo\",\n    value: function distanceTo(point) {\n      return Math.sqrt(this.distanceSquaredTo(point));\n    }\n  }, {\n    key: \"distanceSquaredTo\",\n    value: function distanceSquaredTo(point) {\n      var offset = scratchOffset.from(point).subtract(this.center);\n      var halfAxes = this.halfAxes;\n      var u = halfAxes.getColumn(0, scratchVectorU);\n      var v = halfAxes.getColumn(1, scratchVectorV);\n      var w = halfAxes.getColumn(2, scratchVectorW);\n      var uHalf = u.magnitude();\n      var vHalf = v.magnitude();\n      var wHalf = w.magnitude();\n      u.normalize();\n      v.normalize();\n      w.normalize();\n      var pPrime = scratchPPrime;\n      pPrime.x = offset.dot(u);\n      pPrime.y = offset.dot(v);\n      pPrime.z = offset.dot(w);\n      var distanceSquared = 0.0;\n      var d;\n\n      if (pPrime.x < -uHalf) {\n        d = pPrime.x + uHalf;\n        distanceSquared += d * d;\n      } else if (pPrime.x > uHalf) {\n        d = pPrime.x - uHalf;\n        distanceSquared += d * d;\n      }\n\n      if (pPrime.y < -vHalf) {\n        d = pPrime.y + vHalf;\n        distanceSquared += d * d;\n      } else if (pPrime.y > vHalf) {\n        d = pPrime.y - vHalf;\n        distanceSquared += d * d;\n      }\n\n      if (pPrime.z < -wHalf) {\n        d = pPrime.z + wHalf;\n        distanceSquared += d * d;\n      } else if (pPrime.z > wHalf) {\n        d = pPrime.z - wHalf;\n        distanceSquared += d * d;\n      }\n\n      return distanceSquared;\n    }\n  }, {\n    key: \"computePlaneDistances\",\n    value: function computePlaneDistances(position, direction) {\n      var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [[], []];\n      var minDist = Number.POSITIVE_INFINITY;\n      var maxDist = Number.NEGATIVE_INFINITY;\n      var center = this.center;\n      var halfAxes = this.halfAxes;\n      var u = halfAxes.getColumn(0, scratchVectorU);\n      var v = halfAxes.getColumn(1, scratchVectorV);\n      var w = halfAxes.getColumn(2, scratchVectorW);\n      var corner = scratchCorner.copy(u).add(v).add(w).add(center);\n      var toCenter = scratchToCenter.copy(corner).subtract(position);\n      var mag = direction.dot(toCenter);\n      minDist = Math.min(mag, minDist);\n      maxDist = Math.max(mag, maxDist);\n      corner.copy(center).add(u).add(v).subtract(w);\n      toCenter.copy(corner).subtract(position);\n      mag = direction.dot(toCenter);\n      minDist = Math.min(mag, minDist);\n      maxDist = Math.max(mag, maxDist);\n      corner.copy(center).add(u).subtract(v).add(w);\n      toCenter.copy(corner).subtract(position);\n      mag = direction.dot(toCenter);\n      minDist = Math.min(mag, minDist);\n      maxDist = Math.max(mag, maxDist);\n      corner.copy(center).add(u).subtract(v).subtract(w);\n      toCenter.copy(corner).subtract(position);\n      mag = direction.dot(toCenter);\n      minDist = Math.min(mag, minDist);\n      maxDist = Math.max(mag, maxDist);\n      center.copy(corner).subtract(u).add(v).add(w);\n      toCenter.copy(corner).subtract(position);\n      mag = direction.dot(toCenter);\n      minDist = Math.min(mag, minDist);\n      maxDist = Math.max(mag, maxDist);\n      center.copy(corner).subtract(u).add(v).subtract(w);\n      toCenter.copy(corner).subtract(position);\n      mag = direction.dot(toCenter);\n      minDist = Math.min(mag, minDist);\n      maxDist = Math.max(mag, maxDist);\n      center.copy(corner).subtract(u).subtract(v).add(w);\n      toCenter.copy(corner).subtract(position);\n      mag = direction.dot(toCenter);\n      minDist = Math.min(mag, minDist);\n      maxDist = Math.max(mag, maxDist);\n      center.copy(corner).subtract(u).subtract(v).subtract(w);\n      toCenter.copy(corner).subtract(position);\n      mag = direction.dot(toCenter);\n      minDist = Math.min(mag, minDist);\n      maxDist = Math.max(mag, maxDist);\n      result.start = minDist;\n      result.stop = maxDist;\n      return result;\n    }\n  }, {\n    key: \"getTransform\",\n    value: function getTransform() {}\n  }]);\n\n  return OrientedBoundingBox;\n}();\n\nexport { OrientedBoundingBox as default };","map":{"version":3,"sources":["../../../src/lib/oriented-bounding-box.js"],"names":["scratchVector","scratchOffset","scratchVectorU","scratchVectorV","scratchVectorW","scratchPPrime","scratchCorner","scratchToCenter","fromOrientedBoundingBoxScratchU","fromOrientedBoundingBoxScratchV","fromOrientedBoundingBoxScratchW","MATRIX3","COLUMN0ROW0","COLUMN0ROW1","COLUMN0ROW2","COLUMN1ROW0","COLUMN1ROW1","COLUMN1ROW2","COLUMN2ROW0","COLUMN2ROW1","COLUMN2ROW2","OrientedBoundingBox","center","halfAxes","result","points","makeOrientedBoundingBoxfromPoints","right","Boolean","u","v","w","cornerVector","plane","normal","normalX","normalY","normalZ","radEffective","Math","distanceToPlane","Intersect","point","offset","uHalf","vHalf","wHalf","pPrime","distanceSquared","d","position","direction","minDist","Number","maxDist","corner","toCenter","mag"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Vector3, Matrix3} from 'math.gl';\nimport BoundingSphere from './bounding-sphere';\nimport {Intersect} from '../constants';\nimport makeOrientedBoundingBoxfromPoints from '../algorithms/bounding-box-from-points';\nconst scratchVector = new Vector3();\n\nconst scratchOffset = new Vector3();\nconst scratchVectorU = new Vector3();\nconst scratchVectorV = new Vector3();\nconst scratchVectorW = new Vector3();\nconst scratchPPrime = new Vector3();\nconst scratchCorner = new Vector3();\nconst scratchToCenter = new Vector3();\n\nconst fromOrientedBoundingBoxScratchU = new Vector3();\nconst fromOrientedBoundingBoxScratchV = new Vector3();\nconst fromOrientedBoundingBoxScratchW = new Vector3();\n\nconst MATRIX3 = {\n  COLUMN0ROW0: 0,\n  COLUMN0ROW1: 1,\n  COLUMN0ROW2: 2,\n  COLUMN1ROW0: 3,\n  COLUMN1ROW1: 4,\n  COLUMN1ROW2: 5,\n  COLUMN2ROW0: 6,\n  COLUMN2ROW1: 7,\n  COLUMN2ROW2: 8\n};\n\nexport default class OrientedBoundingBox {\n  // An OrientedBoundingBox of some object is a closed and convex cuboid. It can provide a tighter bounding volume than {@link BoundingSphere} or {@link AxisAlignedBoundingBox} in many cases.\n  constructor(center = [0, 0, 0], halfAxes = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {\n    this.center = new Vector3().from(center);\n    this.halfAxes = new Matrix3(halfAxes);\n  }\n\n  // Duplicates a OrientedBoundingBox instance.\n  clone(result) {\n    return new OrientedBoundingBox(this.center, this.halfAxes);\n  }\n\n  fromPoints(points, result = new OrientedBoundingBox()) {\n    return makeOrientedBoundingBoxfromPoints(points, result);\n  }\n\n  // Compares the provided OrientedBoundingBox componentwise and returns\n  equals(right) {\n    return (\n      this === right ||\n      (Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes))\n    );\n  }\n\n  // Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box.\n  getBoundingSphere(result = new BoundingSphere()) {\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, fromOrientedBoundingBoxScratchU);\n    const v = halfAxes.getColumn(1, fromOrientedBoundingBoxScratchV);\n    const w = halfAxes.getColumn(2, fromOrientedBoundingBoxScratchW);\n\n    // Calculate \"corner\" vector\n    const cornerVector = scratchVector\n      .copy(u)\n      .add(v)\n      .add(w);\n\n    result.center.copy(this.center);\n    result.radius = cornerVector.magnitude();\n\n    return result;\n  }\n\n  /**\n   * Determines which side of a plane the oriented bounding box is located.\n   *\n   * @param {OrientedBoundingBox} box The oriented bounding box to test.\n   * @param {Plane} plane The plane to test against.\n   * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is on the opposite side, and {@link Intersect.INTERSECTING} if the box intersects the plane.\n   */\n  intersectPlane(plane) {\n    const center = this.center;\n    const normal = plane.normal;\n    const halfAxes = this.halfAxes;\n\n    const normalX = normal.x;\n    const normalY = normal.y;\n    const normalZ = normal.z;\n\n    // Plane is used as if it is its normal; the first three components are assumed to be normalized\n    const radEffective =\n      Math.abs(\n        normalX * halfAxes[MATRIX3.COLUMN0ROW0] +\n          normalY * halfAxes[MATRIX3.COLUMN0ROW1] +\n          normalZ * halfAxes[MATRIX3.COLUMN0ROW2]\n      ) +\n      Math.abs(\n        normalX * halfAxes[MATRIX3.COLUMN1ROW0] +\n          normalY * halfAxes[MATRIX3.COLUMN1ROW1] +\n          normalZ * halfAxes[MATRIX3.COLUMN1ROW2]\n      ) +\n      Math.abs(\n        normalX * halfAxes[MATRIX3.COLUMN2ROW0] +\n          normalY * halfAxes[MATRIX3.COLUMN2ROW1] +\n          normalZ * halfAxes[MATRIX3.COLUMN2ROW2]\n      );\n    const distanceToPlane = normal.dot(center) + plane.distance;\n\n    if (distanceToPlane <= -radEffective) {\n      // The entire box is on the negative side of the plane normal\n      return Intersect.OUTSIDE;\n    } else if (distanceToPlane >= radEffective) {\n      // The entire box is on the positive side of the plane normal\n      return Intersect.INSIDE;\n    }\n    return Intersect.INTERSECTING;\n  }\n\n  // Computes the estimated distance from the closest point on a bounding box to a point.\n  distanceTo(point) {\n    return Math.sqrt(this.distanceSquaredTo(point));\n  }\n\n  // Computes the estimated distance squared from the closest point on a bounding box to a point.\n  // See Geometric Tools for Computer Graphics 10.4.2\n\n  // eslint-disable-next-line max-statements\n  distanceSquaredTo(point) {\n    const offset = scratchOffset.from(point).subtract(this.center);\n\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n\n    const uHalf = u.magnitude();\n    const vHalf = v.magnitude();\n    const wHalf = w.magnitude();\n\n    u.normalize();\n    v.normalize();\n    w.normalize();\n\n    const pPrime = scratchPPrime;\n    pPrime.x = offset.dot(u);\n    pPrime.y = offset.dot(v);\n    pPrime.z = offset.dot(w);\n\n    let distanceSquared = 0.0;\n    let d;\n\n    if (pPrime.x < -uHalf) {\n      d = pPrime.x + uHalf;\n      distanceSquared += d * d;\n    } else if (pPrime.x > uHalf) {\n      d = pPrime.x - uHalf;\n      distanceSquared += d * d;\n    }\n\n    if (pPrime.y < -vHalf) {\n      d = pPrime.y + vHalf;\n      distanceSquared += d * d;\n    } else if (pPrime.y > vHalf) {\n      d = pPrime.y - vHalf;\n      distanceSquared += d * d;\n    }\n\n    if (pPrime.z < -wHalf) {\n      d = pPrime.z + wHalf;\n      distanceSquared += d * d;\n    } else if (pPrime.z > wHalf) {\n      d = pPrime.z - wHalf;\n      distanceSquared += d * d;\n    }\n\n    return distanceSquared;\n  }\n\n  // The distances calculated by the vector from the center of the bounding box\n  // to position projected onto direction.\n\n  // eslint-disable-next-line max-statements\n  computePlaneDistances(position, direction, result = [[], []]) {\n    let minDist = Number.POSITIVE_INFINITY;\n    let maxDist = Number.NEGATIVE_INFINITY;\n\n    const center = this.center;\n    const halfAxes = this.halfAxes;\n\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n\n    // project first corner\n    const corner = scratchCorner\n      .copy(u)\n      .add(v)\n      .add(w)\n      .add(center);\n\n    const toCenter = scratchToCenter.copy(corner).subtract(position);\n    let mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project second corner\n    corner\n      .copy(center)\n      .add(u)\n      .add(v)\n      .subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project third corner\n    corner\n      .copy(center)\n      .add(u)\n      .subtract(v)\n      .add(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project fourth corner\n    corner\n      .copy(center)\n      .add(u)\n      .subtract(v)\n      .subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project fifth corner\n    center\n      .copy(corner)\n      .subtract(u)\n      .add(v)\n      .add(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project sixth corner\n    center\n      .copy(corner)\n      .subtract(u)\n      .add(v)\n      .subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project seventh corner\n    center\n      .copy(corner)\n      .subtract(u)\n      .subtract(v)\n      .add(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project eighth corner\n    center\n      .copy(corner)\n      .subtract(u)\n      .subtract(v)\n      .subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    result.start = minDist;\n    result.stop = maxDist;\n    return result;\n  }\n\n  getTransform() {\n    // const modelMatrix = Matrix4.fromRotationTranslation(this.boundingVolume.halfAxes, this.boundingVolume.center);\n    // return modelMatrix;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}