!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var r=t();for(var n in r)("object"==typeof exports?exports:e)[n]=r[n]}}(window,(function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var o=t[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,r),o.l=!0,o.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)r.d(n,o,function(t){return e[t]}.bind(null,o));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=0)}([function(e,t,r){(function(t){const n=r(2),o="undefined"==typeof window?t:window;o.loaders=o.loaders||{},e.exports=Object.assign(o.loaders,n)}).call(this,r(1))},function(e,t){var r;r=function(){return this}();try{r=r||new Function("return this")()}catch(e){"object"==typeof window&&(r=window)}e.exports=r},function(e,t,r){"use strict";r.r(t);class n{constructor(e=257){this.gridSize=e;const t=e-1;if(t&t-1)throw new Error(`Expected grid size to be 2^n+1, got ${e}.`);this.numTriangles=t*t*2-2,this.numParentTriangles=this.numTriangles-t*t,this.indices=new Uint32Array(this.gridSize*this.gridSize),this.coords=new Uint16Array(4*this.numTriangles);for(let e=0;e<this.numTriangles;e++){let r=e+2,n=0,o=0,i=0,s=0,a=0,c=0;for(1&r?i=s=a=t:n=o=c=t;(r>>=1)>1;){const e=n+i>>1,t=o+s>>1;1&r?(i=n,s=o,n=a,o=c):(n=i,o=s,i=a,s=c),a=e,c=t}const l=4*e;this.coords[l+0]=n,this.coords[l+1]=o,this.coords[l+2]=i,this.coords[l+3]=s}}createTile(e){return new o(e,this)}}class o{constructor(e,t){const r=t.gridSize;if(e.length!==r*r)throw new Error(`Expected terrain data of length ${r*r} (${r} x ${r}), got ${e.length}.`);this.terrain=e,this.martini=t,this.errors=new Float32Array(e.length),this.update()}update(){const{numTriangles:e,numParentTriangles:t,coords:r,gridSize:n}=this.martini,{terrain:o,errors:i}=this;for(let s=e-1;s>=0;s--){const e=4*s,a=r[e+0],c=r[e+1],l=r[e+2],u=r[e+3],f=a+l>>1,d=c+u>>1,h=f+d-c,g=d+a-f,p=(o[c*n+a]+o[u*n+l])/2,m=d*n+f,w=Math.abs(p-o[m]);if(i[m]=Math.max(i[m],w),s<t){const e=(c+g>>1)*n+(a+h>>1),t=(u+g>>1)*n+(l+h>>1);i[m]=Math.max(i[m],i[e],i[t])}}}getMesh(e=0){const{gridSize:t,indices:r}=this.martini,{errors:n}=this;let o=0,i=0;const s=t-1;function a(s,c,l,u,f,d){const h=s+l>>1,g=c+u>>1;Math.abs(s-f)+Math.abs(c-d)>1&&n[g*t+h]>e?(a(f,d,s,c,h,g),a(l,u,f,d,h,g)):(r[c*t+s]=r[c*t+s]||++o,r[u*t+l]=r[u*t+l]||++o,r[d*t+f]=r[d*t+f]||++o,i++)}r.fill(0),a(0,0,s,s,s,0),a(s,s,0,0,0,s);const c=new Uint16Array(2*o),l=new Uint32Array(3*i);let u=0;function f(o,i,s,a,d,h){const g=o+s>>1,p=i+a>>1;if(Math.abs(o-d)+Math.abs(i-h)>1&&n[p*t+g]>e)f(d,h,o,i,g,p),f(s,a,d,h,g,p);else{const e=r[i*t+o]-1,n=r[a*t+s]-1,f=r[h*t+d]-1;c[2*e]=o,c[2*e+1]=i,c[2*n]=s,c[2*n+1]=a,c[2*f]=d,c[2*f+1]=h,l[u++]=e,l[u++]=n,l[u++]=f}}return f(0,0,s,s,s,0),f(s,s,0,0,0,s),{vertices:c,triangles:l}}}function i(e){if(!e||!e.POSITION)return null;let t=1/0,r=1/0,n=1/0,o=-1/0,i=-1/0,s=-1/0;const a=e.POSITION.value,c=a&&a.length;if(!c)return null;for(let e=0;e<c;e+=3){const c=a[e],l=a[e+1],u=a[e+2];t=c<t?c:t,r=l<r?l:r,n=u<n?u:n,o=c>o?c:o,i=l>i?l:i,s=u>s?u:s}return[[t,r,n],[o,i,s]]}function s(e,t){if(null===e)return null;const{meshMaxError:r,bounds:o,elevationDecoder:s}=t,a=e.data,c=e.width,l=c+1,u=function(e,t,r){const{rScaler:n,bScaler:o,gScaler:i,offset:s}=r,a=t+1,c=new Float32Array(a*a);for(let r=0,a=0;a<t;a++)for(let l=0;l<t;l++,r++){const t=4*r,l=e[t+0],u=e[t+1],f=e[t+2];c[r+a]=l*n+u*i+f*o+s}for(let e=a*(a-1),t=0;t<a-1;t++,e++)c[e]=c[e-a];for(let e=a-1,t=0;t<a;t++,e+=a)c[e]=c[e-1];return c}(a,c,s),f=new n(l).createTile(u),{vertices:d,triangles:h}=f.getMesh(r),g=function(e,t,r,n){const o=r+1,i=e.length/2,s=new Float32Array(3*i),a=new Float32Array(2*i),[c,l,u,f]=n||[0,0,r,r],d=(u-c)/r,h=(f-l)/r;for(let n=0;n<i;n++){const i=e[2*n],l=e[2*n+1],u=l*o+i;s[3*n+0]=i*d+c,s[3*n+1]=-l*h+f,s[3*n+2]=t[u],a[2*n+0]=i/r,a[2*n+1]=l/r}return{POSITION:{value:s,size:3},TEXCOORD_0:{value:a,size:2}}}(d,u,c,o);return{loaderData:{header:{}},header:{vertexCount:h.length,boundingBox:i(g)},mode:4,indices:{value:h,size:1},attributes:g}}const a={id:"terrain",name:"Terrain",version:"2.1.2",extensions:["png","pngraw"],mimeType:"image/png",options:{terrain:{workerUrl:"https://unpkg.com/@loaders.gl/terrain@2.1.2/dist/terrain-loader.worker.js",meshMaxError:10,elevationDecoder:{rScaler:1,gScaler:0,bScaler:0,offset:0}}}},c={...a,parse:async function(e,t,r){return t.image=t.image||{},t.image.type="data",s(await r.parse(e,t,t.baseUri),t.terrain)}};r.d(t,"TerrainLoader",(function(){return c})),r.d(t,"TerrainWorkerLoader",(function(){return a}))}])}));