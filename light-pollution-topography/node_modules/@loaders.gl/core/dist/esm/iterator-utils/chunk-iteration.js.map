{"version":3,"sources":["../../../src/iterator-utils/chunk-iteration.js"],"names":["makeChunkIterator","makeArrayBufferChunkIterator","makeStringChunkIterator","concatenateArrayBuffers","concatenateChunksAsync","asyncIterator","arrayBuffer","ArrayBuffer","string","chunk","bigArrayBufferOrString","options","Error","chunkSize","byteOffset","byteLength","chunkByteLength","Math","min","sourceArray","Uint8Array","chunkArray","set","offset","length","chunkLength","slice"],"mappings":"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","sourcesContent":["// Breaking big data into iterable chunks, concatenating iterable chunks into big data objects\n\nimport {concatenateArrayBuffers} from '../javascript-utils/memory-copy-utils';\n\n/**\n * Concatenates all data chunks yielded by an (async) iterator\n * Supports strings and ArrayBuffers\n *\n * This function can e.g. be used to enable atomic parsers to work on (async) iterator inputs\n */\nexport async function concatenateChunksAsync(asyncIterator) {\n  let arrayBuffer = new ArrayBuffer(0);\n  let string = '';\n  for await (const chunk of asyncIterator) {\n    if (typeof chunk === 'string') {\n      string += chunk;\n    } else {\n      arrayBuffer = concatenateArrayBuffers(arrayBuffer, chunk);\n    }\n  }\n  return string || arrayBuffer;\n}\n\n/**\n * Returns an iterator that breaks a big `ArrayBuffer` or string into chunks and yields them one-by-one.\n *\n * @param bigArrayBufferOrString\n * @param options\n * @param options.chunkSize\n * @returns iterator that yields chunks of specified size\n *\n * This function can e.g. be used to enable data sources that can only be read atomically\n * (such as `Blob` and `File` via `FileReader`) to still be parsed in batches.\n */\nexport function* makeChunkIterator(bigArrayBufferOrString, options = {}) {\n  if (typeof bigArrayBufferOrString === 'string') {\n    yield* makeStringChunkIterator(bigArrayBufferOrString, options);\n    return;\n  }\n  if (bigArrayBufferOrString instanceof ArrayBuffer) {\n    yield* makeArrayBufferChunkIterator(bigArrayBufferOrString, options);\n    return;\n  }\n  throw new Error('assert');\n}\n\n/**\n * Helper: Breaks a big ArrayBuffer into chunks and returns an iterator that yields them one-by-one\n */\nfunction* makeArrayBufferChunkIterator(arrayBuffer, options = {}) {\n  const {chunkSize = 256 * 1024} = options;\n\n  let byteOffset = 0;\n\n  while (byteOffset < arrayBuffer.byteLength) {\n    // Create a chunk of the right size\n    const chunkByteLength = Math.min(arrayBuffer.byteLength - byteOffset, chunkSize);\n    const chunk = new ArrayBuffer(chunkByteLength);\n\n    // Copy data from the big chunk\n    const sourceArray = new Uint8Array(arrayBuffer, byteOffset, chunkByteLength);\n    const chunkArray = new Uint8Array(chunk);\n    chunkArray.set(sourceArray);\n\n    // yield the chunk\n    byteOffset += chunkByteLength;\n    yield chunk;\n  }\n}\n\n/**\n * Helper: Breaks a big string into chunks and returns an iterator that yields them one-by-one\n */\nfunction* makeStringChunkIterator(string, options = {}) {\n  const {chunkSize = 256 * 1024} = options;\n\n  let offset = 0;\n\n  while (offset < string.length) {\n    // Create a chunk of the right size\n    const chunkLength = Math.min(string.length - offset, chunkSize);\n    const chunk = string.slice(offset, offset + chunkLength);\n    offset += chunkLength;\n\n    // yield the chunk\n    yield chunk;\n  }\n}\n"],"file":"chunk-iteration.js"}