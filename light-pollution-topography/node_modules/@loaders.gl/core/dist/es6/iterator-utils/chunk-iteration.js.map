{"version":3,"sources":["../../../src/iterator-utils/chunk-iteration.js"],"names":["concatenateArrayBuffers","concatenateChunksAsync","asyncIterator","arrayBuffer","ArrayBuffer","string","chunk","makeChunkIterator","bigArrayBufferOrString","options","makeStringChunkIterator","makeArrayBufferChunkIterator","Error","chunkSize","byteOffset","byteLength","chunkByteLength","Math","min","sourceArray","Uint8Array","chunkArray","set","offset","length","chunkLength","slice"],"mappings":";AAEA,SAAQA,uBAAR,QAAsC,uCAAtC;AAQA,OAAO,eAAeC,sBAAf,CAAsCC,aAAtC,EAAqD;AAC1D,MAAIC,WAAW,GAAG,IAAIC,WAAJ,CAAgB,CAAhB,CAAlB;AACA,MAAIC,MAAM,GAAG,EAAb;AAF0D;AAAA;;AAAA;;AAAA;AAG1D,wCAA0BH,aAA1B,oLAAyC;AAAA,YAAxBI,KAAwB;;AACvC,UAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC7BD,QAAAA,MAAM,IAAIC,KAAV;AACD,OAFD,MAEO;AACLH,QAAAA,WAAW,GAAGH,uBAAuB,CAACG,WAAD,EAAcG,KAAd,CAArC;AACD;AACF;AATyD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAU1D,SAAOD,MAAM,IAAIF,WAAjB;AACD;AAaD,OAAO,UAAUI,iBAAV,CAA4BC,sBAA5B,EAAoDC,OAAO,GAAG,EAA9D,EAAkE;AACvE,MAAI,OAAOD,sBAAP,KAAkC,QAAtC,EAAgD;AAC9C,WAAOE,uBAAuB,CAACF,sBAAD,EAAyBC,OAAzB,CAA9B;AACA;AACD;;AACD,MAAID,sBAAsB,YAAYJ,WAAtC,EAAmD;AACjD,WAAOO,4BAA4B,CAACH,sBAAD,EAAyBC,OAAzB,CAAnC;AACA;AACD;;AACD,QAAM,IAAIG,KAAJ,CAAU,QAAV,CAAN;AACD;;AAKD,UAAUD,4BAAV,CAAuCR,WAAvC,EAAoDM,OAAO,GAAG,EAA9D,EAAkE;AAChE,QAAM;AAACI,IAAAA,SAAS,GAAG,MAAM;AAAnB,MAA2BJ,OAAjC;AAEA,MAAIK,UAAU,GAAG,CAAjB;;AAEA,SAAOA,UAAU,GAAGX,WAAW,CAACY,UAAhC,EAA4C;AAE1C,UAAMC,eAAe,GAAGC,IAAI,CAACC,GAAL,CAASf,WAAW,CAACY,UAAZ,GAAyBD,UAAlC,EAA8CD,SAA9C,CAAxB;AACA,UAAMP,KAAK,GAAG,IAAIF,WAAJ,CAAgBY,eAAhB,CAAd;AAGA,UAAMG,WAAW,GAAG,IAAIC,UAAJ,CAAejB,WAAf,EAA4BW,UAA5B,EAAwCE,eAAxC,CAApB;AACA,UAAMK,UAAU,GAAG,IAAID,UAAJ,CAAed,KAAf,CAAnB;AACAe,IAAAA,UAAU,CAACC,GAAX,CAAeH,WAAf;AAGAL,IAAAA,UAAU,IAAIE,eAAd;AACA,UAAMV,KAAN;AACD;AACF;;AAKD,UAAUI,uBAAV,CAAkCL,MAAlC,EAA0CI,OAAO,GAAG,EAApD,EAAwD;AACtD,QAAM;AAACI,IAAAA,SAAS,GAAG,MAAM;AAAnB,MAA2BJ,OAAjC;AAEA,MAAIc,MAAM,GAAG,CAAb;;AAEA,SAAOA,MAAM,GAAGlB,MAAM,CAACmB,MAAvB,EAA+B;AAE7B,UAAMC,WAAW,GAAGR,IAAI,CAACC,GAAL,CAASb,MAAM,CAACmB,MAAP,GAAgBD,MAAzB,EAAiCV,SAAjC,CAApB;AACA,UAAMP,KAAK,GAAGD,MAAM,CAACqB,KAAP,CAAaH,MAAb,EAAqBA,MAAM,GAAGE,WAA9B,CAAd;AACAF,IAAAA,MAAM,IAAIE,WAAV;AAGA,UAAMnB,KAAN;AACD;AACF","sourcesContent":["// Breaking big data into iterable chunks, concatenating iterable chunks into big data objects\n\nimport {concatenateArrayBuffers} from '../javascript-utils/memory-copy-utils';\n\n/**\n * Concatenates all data chunks yielded by an (async) iterator\n * Supports strings and ArrayBuffers\n *\n * This function can e.g. be used to enable atomic parsers to work on (async) iterator inputs\n */\nexport async function concatenateChunksAsync(asyncIterator) {\n  let arrayBuffer = new ArrayBuffer(0);\n  let string = '';\n  for await (const chunk of asyncIterator) {\n    if (typeof chunk === 'string') {\n      string += chunk;\n    } else {\n      arrayBuffer = concatenateArrayBuffers(arrayBuffer, chunk);\n    }\n  }\n  return string || arrayBuffer;\n}\n\n/**\n * Returns an iterator that breaks a big `ArrayBuffer` or string into chunks and yields them one-by-one.\n *\n * @param bigArrayBufferOrString\n * @param options\n * @param options.chunkSize\n * @returns iterator that yields chunks of specified size\n *\n * This function can e.g. be used to enable data sources that can only be read atomically\n * (such as `Blob` and `File` via `FileReader`) to still be parsed in batches.\n */\nexport function* makeChunkIterator(bigArrayBufferOrString, options = {}) {\n  if (typeof bigArrayBufferOrString === 'string') {\n    yield* makeStringChunkIterator(bigArrayBufferOrString, options);\n    return;\n  }\n  if (bigArrayBufferOrString instanceof ArrayBuffer) {\n    yield* makeArrayBufferChunkIterator(bigArrayBufferOrString, options);\n    return;\n  }\n  throw new Error('assert');\n}\n\n/**\n * Helper: Breaks a big ArrayBuffer into chunks and returns an iterator that yields them one-by-one\n */\nfunction* makeArrayBufferChunkIterator(arrayBuffer, options = {}) {\n  const {chunkSize = 256 * 1024} = options;\n\n  let byteOffset = 0;\n\n  while (byteOffset < arrayBuffer.byteLength) {\n    // Create a chunk of the right size\n    const chunkByteLength = Math.min(arrayBuffer.byteLength - byteOffset, chunkSize);\n    const chunk = new ArrayBuffer(chunkByteLength);\n\n    // Copy data from the big chunk\n    const sourceArray = new Uint8Array(arrayBuffer, byteOffset, chunkByteLength);\n    const chunkArray = new Uint8Array(chunk);\n    chunkArray.set(sourceArray);\n\n    // yield the chunk\n    byteOffset += chunkByteLength;\n    yield chunk;\n  }\n}\n\n/**\n * Helper: Breaks a big string into chunks and returns an iterator that yields them one-by-one\n */\nfunction* makeStringChunkIterator(string, options = {}) {\n  const {chunkSize = 256 * 1024} = options;\n\n  let offset = 0;\n\n  while (offset < string.length) {\n    // Create a chunk of the right size\n    const chunkLength = Math.min(string.length - offset, chunkSize);\n    const chunk = string.slice(offset, offset + chunkLength);\n    offset += chunkLength;\n\n    // yield the chunk\n    yield chunk;\n  }\n}\n"],"file":"chunk-iteration.js"}