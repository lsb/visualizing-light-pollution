"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.concatenateChunksAsync = concatenateChunksAsync;
exports.makeChunkIterator = makeChunkIterator;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncIterator"));

var _memoryCopyUtils = require("../javascript-utils/memory-copy-utils");

var _marked = _regenerator["default"].mark(makeChunkIterator),
    _marked2 = _regenerator["default"].mark(makeArrayBufferChunkIterator),
    _marked3 = _regenerator["default"].mark(makeStringChunkIterator);

function concatenateChunksAsync(_x) {
  return _concatenateChunksAsync.apply(this, arguments);
}

function _concatenateChunksAsync() {
  _concatenateChunksAsync = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(asyncIterator) {
    var arrayBuffer, string, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk;

    return _regenerator["default"].wrap(function _callee$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            arrayBuffer = new ArrayBuffer(0);
            string = '';
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _context4.prev = 4;
            _iterator = (0, _asyncIterator2["default"])(asyncIterator);

          case 6:
            _context4.next = 8;
            return _iterator.next();

          case 8:
            _step = _context4.sent;
            _iteratorNormalCompletion = _step.done;
            _context4.next = 12;
            return _step.value;

          case 12:
            _value = _context4.sent;

            if (_iteratorNormalCompletion) {
              _context4.next = 19;
              break;
            }

            chunk = _value;

            if (typeof chunk === 'string') {
              string += chunk;
            } else {
              arrayBuffer = (0, _memoryCopyUtils.concatenateArrayBuffers)(arrayBuffer, chunk);
            }

          case 16:
            _iteratorNormalCompletion = true;
            _context4.next = 6;
            break;

          case 19:
            _context4.next = 25;
            break;

          case 21:
            _context4.prev = 21;
            _context4.t0 = _context4["catch"](4);
            _didIteratorError = true;
            _iteratorError = _context4.t0;

          case 25:
            _context4.prev = 25;
            _context4.prev = 26;

            if (!(!_iteratorNormalCompletion && _iterator["return"] != null)) {
              _context4.next = 30;
              break;
            }

            _context4.next = 30;
            return _iterator["return"]();

          case 30:
            _context4.prev = 30;

            if (!_didIteratorError) {
              _context4.next = 33;
              break;
            }

            throw _iteratorError;

          case 33:
            return _context4.finish(30);

          case 34:
            return _context4.finish(25);

          case 35:
            return _context4.abrupt("return", string || arrayBuffer);

          case 36:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee, null, [[4, 21, 25, 35], [26,, 30, 34]]);
  }));
  return _concatenateChunksAsync.apply(this, arguments);
}

function makeChunkIterator(bigArrayBufferOrString) {
  var options,
      _args = arguments;
  return _regenerator["default"].wrap(function makeChunkIterator$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};

          if (!(typeof bigArrayBufferOrString === 'string')) {
            _context.next = 4;
            break;
          }

          return _context.delegateYield(makeStringChunkIterator(bigArrayBufferOrString, options), "t0", 3);

        case 3:
          return _context.abrupt("return");

        case 4:
          if (!(bigArrayBufferOrString instanceof ArrayBuffer)) {
            _context.next = 7;
            break;
          }

          return _context.delegateYield(makeArrayBufferChunkIterator(bigArrayBufferOrString, options), "t1", 6);

        case 6:
          return _context.abrupt("return");

        case 7:
          throw new Error('assert');

        case 8:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}

function makeArrayBufferChunkIterator(arrayBuffer) {
  var options,
      _options$chunkSize,
      chunkSize,
      byteOffset,
      chunkByteLength,
      chunk,
      sourceArray,
      chunkArray,
      _args2 = arguments;

  return _regenerator["default"].wrap(function makeArrayBufferChunkIterator$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};
          _options$chunkSize = options.chunkSize, chunkSize = _options$chunkSize === void 0 ? 256 * 1024 : _options$chunkSize;
          byteOffset = 0;

        case 3:
          if (!(byteOffset < arrayBuffer.byteLength)) {
            _context2.next = 14;
            break;
          }

          chunkByteLength = Math.min(arrayBuffer.byteLength - byteOffset, chunkSize);
          chunk = new ArrayBuffer(chunkByteLength);
          sourceArray = new Uint8Array(arrayBuffer, byteOffset, chunkByteLength);
          chunkArray = new Uint8Array(chunk);
          chunkArray.set(sourceArray);
          byteOffset += chunkByteLength;
          _context2.next = 12;
          return chunk;

        case 12:
          _context2.next = 3;
          break;

        case 14:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2);
}

function makeStringChunkIterator(string) {
  var options,
      _options$chunkSize2,
      chunkSize,
      offset,
      chunkLength,
      chunk,
      _args3 = arguments;

  return _regenerator["default"].wrap(function makeStringChunkIterator$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          options = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};
          _options$chunkSize2 = options.chunkSize, chunkSize = _options$chunkSize2 === void 0 ? 256 * 1024 : _options$chunkSize2;
          offset = 0;

        case 3:
          if (!(offset < string.length)) {
            _context3.next = 11;
            break;
          }

          chunkLength = Math.min(string.length - offset, chunkSize);
          chunk = string.slice(offset, offset + chunkLength);
          offset += chunkLength;
          _context3.next = 9;
          return chunk;

        case 9:
          _context3.next = 3;
          break;

        case 11:
        case "end":
          return _context3.stop();
      }
    }
  }, _marked3);
}
//# sourceMappingURL=chunk-iteration.js.map