"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decode = decode;
exports.encode = encode;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _gltfScenegraph = _interopRequireDefault(require("../gltf-scenegraph"));

var _gltfConstants = require("../gltf-constants");

function decode(gltfData, options) {
  var gltfScenegraph = new _gltfScenegraph["default"](gltfData);
  var json = gltfScenegraph.json;
  var extension = gltfScenegraph.getExtension(_gltfConstants.KHR_TECHNIQUES_WEBGL);

  if (extension) {
    var techniques = resolveTechniques(extension, gltfScenegraph);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (json.materials || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var material = _step.value;
        var materialExtension = gltfScenegraph.getObjectExtension(material, _gltfConstants.KHR_TECHNIQUES_WEBGL);

        if (materialExtension) {
          material.technique = Object.assign({}, materialExtension, techniques[materialExtension.technique]);
          material.technique.values = resolveValues(material.technique, gltfScenegraph);
        }

        gltfScenegraph.removeObjectExtension(material, _gltfConstants.KHR_TECHNIQUES_WEBGL);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    gltfScenegraph.removeExtension(_gltfConstants.KHR_TECHNIQUES_WEBGL);
  }
}

function encode(gltfData, options) {}

function resolveTechniques(_ref, gltfScenegraph) {
  var _ref$programs = _ref.programs,
      programs = _ref$programs === void 0 ? [] : _ref$programs,
      _ref$shaders = _ref.shaders,
      shaders = _ref$shaders === void 0 ? [] : _ref$shaders,
      _ref$techniques = _ref.techniques,
      techniques = _ref$techniques === void 0 ? [] : _ref$techniques;
  var textDecoder = new TextDecoder();
  shaders.forEach(function (shader) {
    if (Number.isFinite(shader.bufferView)) {
      shader.code = textDecoder.decode(gltfScenegraph.getTypedArrayForBufferView(shader.bufferView));
    } else {
      throw new Error('KHR_techniques_webgl: no shader code');
    }
  });
  programs.forEach(function (program) {
    program.fragmentShader = shaders[program.fragmentShader];
    program.vertexShader = shaders[program.vertexShader];
  });
  techniques.forEach(function (technique) {
    technique.program = programs[technique.program];
  });
  return techniques;
}

function resolveValues(technique, gltfScenegraph) {
  var values = Object.assign({}, technique.values);
  Object.keys(technique.uniforms || {}).forEach(function (uniform) {
    if (technique.uniforms[uniform].value && !(uniform in values)) {
      values[uniform] = technique.uniforms[uniform].value;
    }
  });
  Object.keys(values).forEach(function (uniform) {
    if ((0, _typeof2["default"])(values[uniform]) === 'object' && values[uniform].index !== undefined) {
      values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);
    }
  });
  return values;
}
//# sourceMappingURL=KHR_techniques_webgl.js.map