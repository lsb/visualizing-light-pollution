"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getURLFromTemplate = getURLFromTemplate;
exports.tileToBoundingBox = tileToBoundingBox;
exports.getTileIndices = getTileIndices;
exports.urlType = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _webMercator = require("@math.gl/web-mercator");

var TILE_SIZE = 512;
var urlType = {
  type: 'url',
  value: '',
  validate: function validate(value) {
    return typeof value === 'string' || Array.isArray(value) && value.every(function (url) {
      return typeof url === 'string';
    });
  },
  equals: function equals(value1, value2) {
    if (value1 === value2) {
      return true;
    }

    if (!Array.isArray(value1) || !Array.isArray(value2)) {
      return false;
    }

    var len = value1.length;

    if (len !== value2.length) {
      return false;
    }

    for (var i = 0; i < len; i++) {
      if (value1[i] !== value2[i]) {
        return false;
      }
    }

    return true;
  }
};
exports.urlType = urlType;

function getURLFromTemplate(template, properties) {
  if (!template || !template.length) {
    return null;
  }

  if (Array.isArray(template)) {
    var index = Math.abs(properties.x + properties.y) % template.length;
    template = template[index];
  }

  return template.replace(/\{ *([\w_-]+) *\}/g, function (_, property) {
    return properties[property];
  });
}

function getBoundingBox(viewport) {
  var corners = [viewport.unproject([0, 0]), viewport.unproject([viewport.width, 0]), viewport.unproject([0, viewport.height]), viewport.unproject([viewport.width, viewport.height])];
  return [Math.min(corners[0][0], corners[1][0], corners[2][0], corners[3][0]), Math.min(corners[0][1], corners[1][1], corners[2][1], corners[3][1]), Math.max(corners[0][0], corners[1][0], corners[2][0], corners[3][0]), Math.max(corners[0][1], corners[1][1], corners[2][1], corners[3][1])];
}

function getOSMTileIndex(lngLat, scale) {
  var _lngLatToWorld = (0, _webMercator.lngLatToWorld)(lngLat),
      _lngLatToWorld2 = (0, _slicedToArray2["default"])(_lngLatToWorld, 2),
      x = _lngLatToWorld2[0],
      y = _lngLatToWorld2[1];

  x *= scale / TILE_SIZE;
  y = (1 - y / TILE_SIZE) * scale;
  return [x, y];
}

function getTileIndex(_ref, scale) {
  var _ref2 = (0, _slicedToArray2["default"])(_ref, 2),
      x = _ref2[0],
      y = _ref2[1];

  return [x * scale / TILE_SIZE, y * scale / TILE_SIZE];
}

function getScale(z) {
  var tileSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TILE_SIZE;
  return Math.pow(2, z) * TILE_SIZE / tileSize;
}

function osmTile2lngLat(x, y, z) {
  var scale = getScale(z);
  var lng = x / scale * 360 - 180;
  var n = Math.PI - 2 * Math.PI * y / scale;
  var lat = 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
  return [lng, lat];
}

function tile2XY(x, y, z, tileSize) {
  var scale = getScale(z, tileSize);
  return [x / scale * TILE_SIZE, y / scale * TILE_SIZE];
}

function tileToBoundingBox(viewport, x, y, z) {
  var tileSize = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : TILE_SIZE;

  if (viewport.isGeospatial) {
    var _osmTile2lngLat = osmTile2lngLat(x, y, z),
        _osmTile2lngLat2 = (0, _slicedToArray2["default"])(_osmTile2lngLat, 2),
        west = _osmTile2lngLat2[0],
        north = _osmTile2lngLat2[1];

    var _osmTile2lngLat3 = osmTile2lngLat(x + 1, y + 1, z),
        _osmTile2lngLat4 = (0, _slicedToArray2["default"])(_osmTile2lngLat3, 2),
        east = _osmTile2lngLat4[0],
        south = _osmTile2lngLat4[1];

    return {
      west: west,
      north: north,
      east: east,
      south: south
    };
  }

  var _tile2XY = tile2XY(x, y, z, tileSize),
      _tile2XY2 = (0, _slicedToArray2["default"])(_tile2XY, 2),
      left = _tile2XY2[0],
      top = _tile2XY2[1];

  var _tile2XY3 = tile2XY(x + 1, y + 1, z, tileSize),
      _tile2XY4 = (0, _slicedToArray2["default"])(_tile2XY3, 2),
      right = _tile2XY4[0],
      bottom = _tile2XY4[1];

  return {
    left: left,
    top: top,
    right: right,
    bottom: bottom
  };
}

function getIdentityTileIndices(viewport, z, tileSize) {
  var bbox = getBoundingBox(viewport);
  var scale = getScale(z, tileSize);

  var _getTileIndex = getTileIndex([bbox[0], bbox[1]], scale),
      _getTileIndex2 = (0, _slicedToArray2["default"])(_getTileIndex, 2),
      minX = _getTileIndex2[0],
      minY = _getTileIndex2[1];

  var _getTileIndex3 = getTileIndex([bbox[2], bbox[3]], scale),
      _getTileIndex4 = (0, _slicedToArray2["default"])(_getTileIndex3, 2),
      maxX = _getTileIndex4[0],
      maxY = _getTileIndex4[1];

  var indices = [];

  for (var x = Math.floor(minX); x < maxX; x++) {
    for (var y = Math.floor(minY); y < maxY; y++) {
      indices.push({
        x: x,
        y: y,
        z: z
      });
    }
  }

  return indices;
}

function getOSMTileIndices(viewport, z) {
  var bbox = getBoundingBox(viewport);
  var scale = getScale(z);

  var _getOSMTileIndex = getOSMTileIndex([bbox[0], bbox[3]], scale),
      _getOSMTileIndex2 = (0, _slicedToArray2["default"])(_getOSMTileIndex, 2),
      minX = _getOSMTileIndex2[0],
      minY = _getOSMTileIndex2[1];

  var _getOSMTileIndex3 = getOSMTileIndex([bbox[2], bbox[1]], scale),
      _getOSMTileIndex4 = (0, _slicedToArray2["default"])(_getOSMTileIndex3, 2),
      maxX = _getOSMTileIndex4[0],
      maxY = _getOSMTileIndex4[1];

  var indices = [];
  minX = Math.floor(minX);
  maxX = Math.min(minX + scale, maxX);
  minY = Math.max(0, Math.floor(minY));
  maxY = Math.min(scale, maxY);

  for (var x = minX; x < maxX; x++) {
    for (var y = minY; y < maxY; y++) {
      var normalizedX = x - Math.floor(x / scale) * scale;
      indices.push({
        x: normalizedX,
        y: y,
        z: z
      });
    }
  }

  return indices;
}

function getTileIndices(viewport, maxZoom, minZoom) {
  var tileSize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : TILE_SIZE;
  var z = Math.ceil(viewport.zoom);

  if (Number.isFinite(minZoom) && z < minZoom) {
    return [];
  }

  if (Number.isFinite(maxZoom) && z > maxZoom) {
    z = maxZoom;
  }

  return viewport.isGeospatial ? getOSMTileIndices(viewport, z) : getIdentityTileIndices(viewport, z, tileSize);
}
//# sourceMappingURL=utils.js.map