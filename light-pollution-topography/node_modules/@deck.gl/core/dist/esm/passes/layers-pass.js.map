{"version":3,"sources":["../../../src/passes/layers-pass.js"],"names":["Pass","clear","setParameters","withParameters","cssToDeviceRatio","log","LayersPass","props","gl","framebuffer","target","_drawLayers","viewports","views","onViewportActive","clearCanvas","clearGLCanvas","renderStats","viewportOrDescriptor","viewport","view","id","subViewports","subViewport","stats","_drawLayersInViewport","push","layers","layerFilter","onError","pass","effects","moduleParameters","glViewport","getGLViewport","clearOpts","color","depth","scissorTest","scissor","renderStatus","totalCount","length","visibleCount","compositeCount","pickableCount","indexResolver","layerIndexResolver","layerIndex","layer","shouldDrawLayer","_shouldDrawLayer","layerRenderIndex","pickable","isComposite","_moduleParameters","_getModuleParameters","layerParameters","getLayerParameters","drawLayer","uniforms","parameters","err","error","visible","isPicking","startsWith","renderPass","overrides","Object","assign","create","context","mousePosition","pickingActive","devicePixelRatio","effect","getModuleParameters","startIndex","layerIndices","resolvers","isDrawn","indexOverride","_offset","layerId","parentId","parent","index","resolver","Number","isFinite","height","canvas","clientHeight","dimensions","pixelRatio","x","y","width","drawingBufferWidth","drawingBufferHeight"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport Pass from './pass';\nimport {clear, setParameters, withParameters, cssToDeviceRatio} from '@luma.gl/core';\nimport log from '../utils/log';\n\nexport default class LayersPass extends Pass {\n  render(props) {\n    const gl = this.gl;\n\n    setParameters(gl, {framebuffer: props.target});\n    return this._drawLayers(props);\n  }\n\n  // PRIVATE\n  // Draw a list of layers in a list of viewports\n  _drawLayers(props) {\n    const {viewports, views, onViewportActive, clearCanvas = true} = props;\n\n    const gl = this.gl;\n    if (clearCanvas) {\n      clearGLCanvas(gl);\n    }\n\n    const renderStats = [];\n\n    for (const viewportOrDescriptor of viewports) {\n      // Get a viewport from a viewport descriptor (which can be a plain viewport)\n      const viewport = viewportOrDescriptor.viewport || viewportOrDescriptor;\n      const view = views && views[viewport.id];\n\n      // Update context to point to this viewport\n      onViewportActive(viewport);\n\n      props.view = view;\n\n      // render this viewport\n      const subViewports = viewport.subViewports || [viewport];\n      for (const subViewport of subViewports) {\n        props.viewport = subViewport;\n\n        const stats = this._drawLayersInViewport(gl, props);\n        renderStats.push(stats);\n      }\n    }\n    return renderStats;\n  }\n\n  // Draws a list of layers in one viewport\n  // TODO - when picking we could completely skip rendering viewports that dont\n  // intersect with the picking rect\n  /* eslint-disable max-depth, max-statements */\n  _drawLayersInViewport(\n    gl,\n    {layers, layerFilter, onError, viewport, view, pass = 'unknown', effects, moduleParameters}\n  ) {\n    const glViewport = getGLViewport(gl, {viewport});\n\n    if (view && view.props.clear) {\n      const clearOpts = view.props.clear === true ? {color: true, depth: true} : view.props.clear;\n      withParameters(\n        gl,\n        {\n          scissorTest: true,\n          scissor: glViewport\n        },\n        () => clear(gl, clearOpts)\n      );\n    }\n\n    // render layers in normal colors\n    const renderStatus = {\n      totalCount: layers.length,\n      visibleCount: 0,\n      compositeCount: 0,\n      pickableCount: 0\n    };\n\n    setParameters(gl, {viewport: glViewport});\n\n    const indexResolver = layerIndexResolver();\n    // render layers in normal colors\n    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {\n      const layer = layers[layerIndex];\n      // Check if we should draw layer\n      const shouldDrawLayer = this._shouldDrawLayer(layer, viewport, pass, layerFilter);\n\n      // This is the \"logical\" index for ordering this layer in the stack\n      // used to calculate polygon offsets\n      // It can be the same as another layer\n      const layerRenderIndex = indexResolver(layer, shouldDrawLayer);\n\n      // Calculate stats\n      if (shouldDrawLayer && layer.props.pickable) {\n        renderStatus.pickableCount++;\n      }\n      if (layer.isComposite) {\n        renderStatus.compositeCount++;\n      }\n\n      // Draw the layer\n      if (shouldDrawLayer) {\n        renderStatus.visibleCount++;\n\n        const _moduleParameters = this._getModuleParameters(layer, effects, pass, moduleParameters);\n        const layerParameters = this.getLayerParameters(layer, layerIndex);\n        // overwrite layer.context.viewport with the sub viewport\n        _moduleParameters.viewport = viewport;\n\n        try {\n          layer.drawLayer({\n            moduleParameters: _moduleParameters,\n            uniforms: {layerIndex: layerRenderIndex},\n            parameters: layerParameters\n          });\n        } catch (err) {\n          if (onError) {\n            onError(err, layer);\n          } else {\n            log.error(`error during drawing of ${layer}`, err)();\n          }\n        }\n      }\n    }\n\n    return renderStatus;\n  }\n  /* eslint-enable max-depth, max-statements */\n\n  /* Methods for subclass overrides */\n  shouldDrawLayer(layer) {\n    return true;\n  }\n\n  getModuleParameters(layer, effects) {\n    return null;\n  }\n\n  getLayerParameters(layer, layerIndex) {\n    return layer.props.parameters;\n  }\n\n  /* Private */\n  _shouldDrawLayer(layer, viewport, pass, layerFilter) {\n    let shouldDrawLayer = this.shouldDrawLayer(layer) && !layer.isComposite && layer.props.visible;\n\n    if (shouldDrawLayer && layerFilter) {\n      shouldDrawLayer = layerFilter({\n        layer,\n        viewport,\n        isPicking: pass.startsWith('picking'),\n        renderPass: pass\n      });\n    }\n    return shouldDrawLayer;\n  }\n\n  _getModuleParameters(layer, effects, pass, overrides) {\n    const moduleParameters = Object.assign(Object.create(layer.props), {\n      viewport: layer.context.viewport,\n      mousePosition: layer.context.mousePosition,\n      pickingActive: 0,\n      devicePixelRatio: cssToDeviceRatio(this.gl)\n    });\n\n    if (effects) {\n      for (const effect of effects) {\n        Object.assign(moduleParameters, effect.getModuleParameters(layer));\n      }\n    }\n\n    return Object.assign(moduleParameters, this.getModuleParameters(layer, effects), overrides);\n  }\n}\n\n// If the _index prop is defined, return a layer index that's relative to its parent\n// Otherwise return the index of the layer among all rendered layers\n// This is done recursively, i.e. if the user overrides a layer's default index,\n// all its descendants will be resolved relative to that index.\n// This implementation assumes that parent layers always appear before its children\n// which is true if the layer array comes from the LayerManager\nexport function layerIndexResolver(startIndex = 0, layerIndices = {}) {\n  const resolvers = {};\n\n  return (layer, isDrawn) => {\n    const indexOverride = layer.props._offset;\n    const layerId = layer.id;\n    const parentId = layer.parent && layer.parent.id;\n\n    let index;\n\n    if (parentId in resolvers) {\n      const resolver = (resolvers[parentId] =\n        resolvers[parentId] || layerIndexResolver(layerIndices[parentId], layerIndices));\n      index = resolver(layer, isDrawn);\n      resolvers[layerId] = resolver;\n    } else if (Number.isFinite(indexOverride)) {\n      index = indexOverride + (layerIndices[parentId] || 0);\n      // Mark layer as needing its own resolver\n      // We don't actually create it until it's used for the first time\n      resolvers[layerId] = null;\n    } else {\n      index = startIndex;\n    }\n\n    if (isDrawn && index >= startIndex) {\n      startIndex = index + 1;\n    }\n\n    layerIndices[layerId] = index;\n    return index;\n  };\n}\n\n// Convert viewport top-left CSS coordinates to bottom up WebGL coordinates\nfunction getGLViewport(gl, {viewport}) {\n  // TODO - dummy default for node\n  // Fallback to width/height when clientWidth/clientHeight are 0 or undefined.\n  const height = gl.canvas ? gl.canvas.clientHeight || gl.canvas.height : 100;\n  // Convert viewport top-left CSS coordinates to bottom up WebGL coordinates\n  const dimensions = viewport;\n  const pixelRatio = cssToDeviceRatio(gl);\n  return [\n    dimensions.x * pixelRatio,\n    (height - dimensions.y - dimensions.height) * pixelRatio,\n    dimensions.width * pixelRatio,\n    dimensions.height * pixelRatio\n  ];\n}\n\nfunction clearGLCanvas(gl) {\n  const width = gl.drawingBufferWidth;\n  const height = gl.drawingBufferHeight;\n  // clear depth and color buffers, restoring transparency\n  setParameters(gl, {viewport: [0, 0, width, height]});\n  gl.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);\n}\n"],"file":"layers-pass.js"}