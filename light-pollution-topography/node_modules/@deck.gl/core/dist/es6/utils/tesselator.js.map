{"version":3,"sources":["../../../src/utils/tesselator.js"],"names":["createIterable","getAccessorFromBuffer","defaultTypedArrayManager","assert","Buffer","Tesselator","constructor","opts","attributes","typedArrayManager","indexStarts","vertexStarts","vertexCount","instanceCount","_attributeDefs","updateGeometry","Object","seal","assign","data","buffers","getGeometry","geometryBuffer","positionFormat","dataChanged","normalize","positionSize","size","startIndices","getGeometryFromBuffer","positions","Array","isArray","dataRange","_rebuildGeometry","updatePartialGeometry","startRow","endRow","updateGeometryAttributes","geometry","startIndex","Error","getGeometrySize","value","ArrayBuffer","isView","offset","stride","_allocate","copy","name","release","def","allocate","_forEachGeometry","visitor","iterable","objectInfo","object","index","Infinity","dataIndex","length","buffer","byteStride","byteLength","bufferValue","elementStride","BYTES_PER_ELEMENT","Boolean","context","vertexStart","indexStart","vertexEnd","geometrySize","geometryIndex"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {createIterable, getAccessorFromBuffer} from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\n\nimport {Buffer} from '@luma.gl/core';\n\nexport default class Tesselator {\n  constructor(opts = {}) {\n    const {attributes = {}} = opts;\n\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.indexStarts = null;\n    this.vertexStarts = null;\n    this.vertexCount = 0;\n    this.instanceCount = 0;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n\n    this.updateGeometry(opts);\n\n    Object.seal(this);\n  }\n\n  /* Public methods */\n  updateGeometry(opts) {\n    Object.assign(this.opts, opts);\n    const {\n      data,\n      buffers = {},\n      getGeometry,\n      geometryBuffer,\n      positionFormat,\n      dataChanged,\n      normalize = true\n    } = this.opts;\n    this.data = data;\n    this.getGeometry = getGeometry;\n    this.positionSize =\n      (geometryBuffer && geometryBuffer.size) || (positionFormat === 'XY' ? 2 : 3);\n    this.buffers = buffers;\n    this.normalize = normalize;\n\n    // Handle external logical value\n    if (geometryBuffer) {\n      assert(data.startIndices, 'binary data missing startIndices');\n      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n\n      if (!normalize) {\n        // skip packing and set attribute value directly\n        // TODO - avoid mutating user-provided object\n        buffers.positions = geometryBuffer;\n      }\n    }\n    this.geometryBuffer = buffers.positions;\n\n    if (Array.isArray(dataChanged)) {\n      // is partial update\n      for (const dataRange of dataChanged) {\n        this._rebuildGeometry(dataRange);\n      }\n    } else {\n      this._rebuildGeometry();\n    }\n  }\n\n  updatePartialGeometry({startRow, endRow}) {\n    this._rebuildGeometry({startRow, endRow});\n  }\n\n  /* Subclass interface */\n\n  // Update the positions of a single geometry\n  updateGeometryAttributes(geometry, startIndex, size) {\n    throw new Error('Not implemented');\n  }\n\n  // Returns the number of vertices in a geometry\n  getGeometrySize(geometry) {\n    throw new Error('Not implemented');\n  }\n\n  getGeometryFromBuffer(geometryBuffer) {\n    const value = geometryBuffer.value || geometryBuffer;\n    assert(ArrayBuffer.isView(value), 'cannot read geometries');\n\n    return getAccessorFromBuffer(value, {\n      size: this.positionSize,\n      offset: geometryBuffer.offset,\n      stride: geometryBuffer.stride,\n      startIndices: this.data.startIndices\n    });\n  }\n\n  /* Private utility methods */\n  _allocate(instanceCount, copy) {\n    // allocate attributes\n    const {attributes, buffers, _attributeDefs, typedArrayManager} = this;\n    for (const name in _attributeDefs) {\n      if (name in buffers) {\n        // Use external buffer\n        typedArrayManager.release(attributes[name]);\n        attributes[name] = null;\n      } else {\n        const def = _attributeDefs[name];\n        // If dataRange is supplied, this is a partial update.\n        // In case we need to reallocate the typed array, it will need the old values copied\n        // before performing partial update.\n        def.copy = copy;\n\n        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n      }\n    }\n  }\n\n  /**\n   * Visit all objects\n   * `data` is expected to be an iterable consistent with the base Layer expectation\n   */\n  _forEachGeometry(visitor, startRow, endRow) {\n    const {data, getGeometry} = this;\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n      const geometry = getGeometry(object, objectInfo);\n      visitor(geometry, objectInfo.index);\n    }\n  }\n\n  /* eslint-disable complexity,max-statements */\n  _rebuildGeometry(dataRange) {\n    if (!this.data || !this.getGeometry) {\n      return;\n    }\n\n    let {indexStarts, vertexStarts, instanceCount} = this;\n    const {data, geometryBuffer} = this;\n    const {startRow = 0, endRow = Infinity} = dataRange || {};\n\n    if (!dataRange) {\n      // Full update - regenerate buffer layout from scratch\n      indexStarts = [0];\n      vertexStarts = [0];\n    }\n    if (this.normalize || !geometryBuffer) {\n      this._forEachGeometry(\n        (geometry, dataIndex) => {\n          vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + this.getGeometrySize(geometry);\n        },\n        startRow,\n        endRow\n      );\n      // count instances\n      instanceCount = vertexStarts[vertexStarts.length - 1];\n    } else if (geometryBuffer.buffer instanceof Buffer) {\n      const byteStride = geometryBuffer.stride || this.positionSize * 4;\n      // assume user provided data is already normalized\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || geometryBuffer.buffer.byteLength / byteStride;\n    } else {\n      const bufferValue = geometryBuffer.value || geometryBuffer;\n      const elementStride =\n        geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n      // assume user provided data is already normalized\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || bufferValue.length / elementStride;\n    }\n\n    // allocate attributes\n    this._allocate(instanceCount, Boolean(dataRange));\n\n    this.indexStarts = indexStarts;\n    this.vertexStarts = vertexStarts;\n    this.instanceCount = instanceCount;\n\n    const context = {};\n\n    this._forEachGeometry(\n      (geometry, dataIndex) => {\n        context.vertexStart = vertexStarts[dataIndex];\n        context.indexStart = indexStarts[dataIndex];\n        const vertexEnd =\n          dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n        context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n        context.geometryIndex = dataIndex;\n        this.updateGeometryAttributes(geometry, context);\n      },\n      startRow,\n      endRow\n    );\n\n    this.vertexCount = indexStarts[indexStarts.length - 1];\n  }\n}\n"],"file":"tesselator.js"}