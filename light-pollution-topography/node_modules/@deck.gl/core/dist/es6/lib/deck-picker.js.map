{"version":3,"sources":["../../../src/lib/deck-picker.js"],"names":["Framebuffer","Texture2D","isWebGL2","readPixelsToArray","cssToDeviceRatio","cssToDevicePixels","assert","PickLayersPass","getClosestObject","getUniqueObjects","processPickInfo","getLayerPickingInfo","DeckPicker","constructor","gl","pickingFBO","pickLayersPass","layerFilter","lastPickedInfo","index","layerId","info","_onError","setProps","props","onError","finalize","delete","depthFBO","color","pickObject","opts","_pickClosestObject","pickObjects","_pickVisibleObjects","getLastPickedObject","x","y","layers","viewports","lastPickedLayerId","layer","id","find","l","coordinate","unproject","lngLat","Object","assign","object","_resizeBuffer","isSupported","colorBufferFloat","attach","format","type","resize","width","canvas","height","radius","depth","mode","unproject3D","onViewportActive","pixelRatio","devicePixelRange","devicePixel","Math","floor","deviceRadius","round","deviceRect","_getPickingRect","deviceX","deviceY","deviceWidth","deviceHeight","infos","result","affectedLayers","i","pickedColors","_drawAndSample","pass","redrawReason","pickInfo","z","pickedLayer","zValues","pickedX","pickedY","pickZ","distanceScales","metersPerUnit","position","pickedColor","clearPickingColor","values","push","restorePickingColors","emptyInfo","get","leftTop","deviceLeft","deviceTop","rightBottom","deviceRight","deviceBottom","pickInfos","uniqueInfos","Map","forEach","pickedObjectIndex","picked","has","set","Array","from","pickableLayers","filter","isPickable","length","render","Float32Array","Uint8Array","sourceX","sourceY","sourceWidth","sourceHeight","target","max","min"],"mappings":"AAoBA,SACEA,WADF,EAEEC,SAFF,EAGEC,QAHF,EAIEC,iBAJF,EAKEC,gBALF,EAMEC,iBANF,QAOO,eAPP;AASA,OAAOC,MAAP,MAAmB,iBAAnB;AACA,OAAOC,cAAP,MAA2B,4BAA3B;AACA,SAAQC,gBAAR,EAA0BC,gBAA1B,QAAiD,wBAAjD;AACA,SAAQC,eAAR,EAAyBC,mBAAzB,QAAmD,qBAAnD;AAEA,eAAe,MAAMC,UAAN,CAAiB;AAC9BC,EAAAA,WAAW,CAACC,EAAD,EAAK;AACd,SAAKA,EAAL,GAAUA,EAAV;AACA,SAAKC,UAAL,GAAkB,IAAlB;AACA,SAAKC,cAAL,GAAsB,IAAIT,cAAJ,CAAmBO,EAAnB,CAAtB;AACA,SAAKG,WAAL,GAAmB,IAAnB;AACA,SAAKC,cAAL,GAAsB;AAEpBC,MAAAA,KAAK,EAAE,CAAC,CAFY;AAGpBC,MAAAA,OAAO,EAAE,IAHW;AAIpBC,MAAAA,IAAI,EAAE;AAJc,KAAtB;AAMA,SAAKC,QAAL,GAAgB,IAAhB;AACD;;AAEDC,EAAAA,QAAQ,CAACC,KAAD,EAAQ;AACd,QAAI,iBAAiBA,KAArB,EAA4B;AAC1B,WAAKP,WAAL,GAAmBO,KAAK,CAACP,WAAzB;AACD;;AAED,QAAI,aAAaO,KAAjB,EAAwB;AACtB,WAAKF,QAAL,GAAgBE,KAAK,CAACC,OAAtB;AACD;AACF;;AAEDC,EAAAA,QAAQ,GAAG;AACT,QAAI,KAAKX,UAAT,EAAqB;AACnB,WAAKA,UAAL,CAAgBY,MAAhB;AACD;;AACD,QAAI,KAAKC,QAAT,EAAmB;AACjB,WAAKA,QAAL,CAAcC,KAAd,CAAoBF,MAApB;AACA,WAAKC,QAAL,CAAcD,MAAd;AACD;AACF;;AAGDG,EAAAA,UAAU,CAACC,IAAD,EAAO;AACf,WAAO,KAAKC,kBAAL,CAAwBD,IAAxB,CAAP;AACD;;AAGDE,EAAAA,WAAW,CAACF,IAAD,EAAO;AAChB,WAAO,KAAKG,mBAAL,CAAyBH,IAAzB,CAAP;AACD;;AAGDI,EAAAA,mBAAmB,CAAC;AAACC,IAAAA,CAAD;AAAIC,IAAAA,CAAJ;AAAOC,IAAAA,MAAP;AAAeC,IAAAA;AAAf,GAAD,EAA4BrB,cAAc,GAAG,KAAKA,cAAL,CAAoBG,IAAjE,EAAuE;AACxF,UAAMmB,iBAAiB,GAAGtB,cAAc,IAAIA,cAAc,CAACuB,KAAjC,IAA0CvB,cAAc,CAACuB,KAAf,CAAqBC,EAAzF;AACA,UAAMD,KAAK,GAAGD,iBAAiB,GAAGF,MAAM,CAACK,IAAP,CAAYC,CAAC,IAAIA,CAAC,CAACF,EAAF,KAASF,iBAA1B,CAAH,GAAkD,IAAjF;AACA,UAAMK,UAAU,GAAGN,SAAS,CAAC,CAAD,CAAT,IAAgBA,SAAS,CAAC,CAAD,CAAT,CAAaO,SAAb,CAAuB,CAACV,CAAD,EAAIC,CAAJ,CAAvB,CAAnC;AAEA,UAAMhB,IAAI,GAAG;AACXe,MAAAA,CADW;AAEXC,MAAAA,CAFW;AAGXQ,MAAAA,UAHW;AAKXE,MAAAA,MAAM,EAAEF,UALG;AAMXJ,MAAAA;AANW,KAAb;;AASA,QAAIA,KAAJ,EAAW;AACT,aAAOO,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB/B,cAAlB,EAAkCG,IAAlC,CAAP;AACD;;AACD,WAAO2B,MAAM,CAACC,MAAP,CAAc5B,IAAd,EAAoB;AAACQ,MAAAA,KAAK,EAAE,IAAR;AAAcqB,MAAAA,MAAM,EAAE,IAAtB;AAA4B/B,MAAAA,KAAK,EAAE,CAAC;AAApC,KAApB,CAAP;AACD;;AAGDgC,EAAAA,aAAa,GAAG;AACd,UAAM;AAACrC,MAAAA;AAAD,QAAO,IAAb;;AAEA,QAAI,CAAC,KAAKC,UAAV,EAAsB;AACpB,WAAKA,UAAL,GAAkB,IAAIf,WAAJ,CAAgBc,EAAhB,CAAlB;;AACA,UAAId,WAAW,CAACoD,WAAZ,CAAwBtC,EAAxB,EAA4B;AAACuC,QAAAA,gBAAgB,EAAE;AAAnB,OAA5B,CAAJ,EAA2D;AACzD,aAAKzB,QAAL,GAAgB,IAAI5B,WAAJ,CAAgBc,EAAhB,CAAhB;AACA,aAAKc,QAAL,CAAc0B,MAAd,CAAqB;AACnB,mBAAwB,IAAIrD,SAAJ,CAAca,EAAd,EAAkB;AACxCyC,YAAAA,MAAM,EAAErD,QAAQ,CAACY,EAAD,CAAR,eADgC;AAExC0C,YAAAA,IAAI;AAFoC,WAAlB;AADL,SAArB;AAMD;AACF;;AAED,SAAKzC,UAAL,CAAgB0C,MAAhB,CAAuB;AAACC,MAAAA,KAAK,EAAE5C,EAAE,CAAC6C,MAAH,CAAUD,KAAlB;AAAyBE,MAAAA,MAAM,EAAE9C,EAAE,CAAC6C,MAAH,CAAUC;AAA3C,KAAvB;AACA,SAAKhC,QAAL,CAAc6B,MAAd,CAAqB;AAACC,MAAAA,KAAK,EAAE5C,EAAE,CAAC6C,MAAH,CAAUD,KAAlB;AAAyBE,MAAAA,MAAM,EAAE9C,EAAE,CAAC6C,MAAH,CAAUC;AAA3C,KAArB;AACA,WAAO,KAAK7C,UAAZ;AACD;;AAIDiB,EAAAA,kBAAkB,CAAC;AACjBM,IAAAA,MADiB;AAEjBC,IAAAA,SAFiB;AAGjBH,IAAAA,CAHiB;AAIjBC,IAAAA,CAJiB;AAKjBwB,IAAAA,MAAM,GAAG,CALQ;AAMjBC,IAAAA,KAAK,GAAG,CANS;AAOjBC,IAAAA,IAAI,GAAG,OAPU;AAQjBC,IAAAA,WARiB;AASjBC,IAAAA;AATiB,GAAD,EAUf;AACD,SAAKd,aAAL;;AAIA,UAAMe,UAAU,GAAG9D,gBAAgB,CAAC,KAAKU,EAAN,CAAnC;AACA,UAAMqD,gBAAgB,GAAG9D,iBAAiB,CAAC,KAAKS,EAAN,EAAU,CAACsB,CAAD,EAAIC,CAAJ,CAAV,EAAkB,IAAlB,CAA1C;AACA,UAAM+B,WAAW,GAAG,CAClBD,gBAAgB,CAAC/B,CAAjB,GAAqBiC,IAAI,CAACC,KAAL,CAAWH,gBAAgB,CAACT,KAAjB,GAAyB,CAApC,CADH,EAElBS,gBAAgB,CAAC9B,CAAjB,GAAqBgC,IAAI,CAACC,KAAL,CAAWH,gBAAgB,CAACP,MAAjB,GAA0B,CAArC,CAFH,CAApB;AAKA,UAAMW,YAAY,GAAGF,IAAI,CAACG,KAAL,CAAWX,MAAM,GAAGK,UAApB,CAArB;AACA,UAAM;AAACR,MAAAA,KAAD;AAAQE,MAAAA;AAAR,QAAkB,KAAK7C,UAA7B;;AACA,UAAM0D,UAAU,GAAG,KAAKC,eAAL,CAAqB;AACtCC,MAAAA,OAAO,EAAEP,WAAW,CAAC,CAAD,CADkB;AAEtCQ,MAAAA,OAAO,EAAER,WAAW,CAAC,CAAD,CAFkB;AAGtCG,MAAAA,YAHsC;AAItCM,MAAAA,WAAW,EAAEnB,KAJyB;AAKtCoB,MAAAA,YAAY,EAAElB;AALwB,KAArB,CAAnB;;AAQA,QAAImB,KAAJ;AACA,UAAMC,MAAM,GAAG,EAAf;AACA,UAAMC,cAAc,GAAG,EAAvB;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGpB,KAApB,EAA2BoB,CAAC,EAA5B,EAAgC;AAC9B,YAAMC,YAAY,GAChBV,UAAU,IACV,KAAKW,cAAL,CAAoB;AAClB9C,QAAAA,MADkB;AAElBC,QAAAA,SAFkB;AAGlB0B,QAAAA,gBAHkB;AAIlBQ,QAAAA,UAJkB;AAKlBY,QAAAA,IAAI,oBAAatB,IAAb,CALc;AAMlBuB,QAAAA,YAAY,EAAEvB;AANI,OAApB,CAFF;;AAWA,YAAMwB,QAAQ,GAAG/E,gBAAgB,CAAC;AAChC2E,QAAAA,YADgC;AAEhC7C,QAAAA,MAFgC;AAGhCqC,QAAAA,OAAO,EAAEP,WAAW,CAAC,CAAD,CAHY;AAIhCQ,QAAAA,OAAO,EAAER,WAAW,CAAC,CAAD,CAJY;AAKhCG,QAAAA,YALgC;AAMhCE,QAAAA;AANgC,OAAD,CAAjC;AASA,UAAIe,CAAJ;;AACA,UAAID,QAAQ,CAACE,WAAT,IAAwBzB,WAAxB,IAAuC,KAAKpC,QAAhD,EAA0D;AACxD,cAAM8D,OAAO,GAAG,KAAKN,cAAL,CAAoB;AAClC9C,UAAAA,MAAM,EAAE,CAACiD,QAAQ,CAACE,WAAV,CAD0B;AAElClD,UAAAA,SAFkC;AAGlC0B,UAAAA,gBAHkC;AAIlCQ,UAAAA,UAAU,EAAE;AAACrC,YAAAA,CAAC,EAAEmD,QAAQ,CAACI,OAAb;AAAsBtD,YAAAA,CAAC,EAAEkD,QAAQ,CAACK,OAAlC;AAA2ClC,YAAAA,KAAK,EAAE,CAAlD;AAAqDE,YAAAA,MAAM,EAAE;AAA7D,WAJsB;AAKlCyB,UAAAA,IAAI,oBAAatB,IAAb,CAL8B;AAMlCuB,UAAAA,YAAY,EAAE,QANoB;AAOlCO,UAAAA,KAAK,EAAE;AAP2B,SAApB,CAAhB;;AAWAL,QAAAA,CAAC,GAAGE,OAAO,CAAC,CAAD,CAAP,GAAanD,SAAS,CAAC,CAAD,CAAT,CAAauD,cAAb,CAA4BC,aAA5B,CAA0C,CAA1C,CAAb,GAA4DxD,SAAS,CAAC,CAAD,CAAT,CAAayD,QAAb,CAAsB,CAAtB,CAAhE;AACD;;AAKD,UAAIT,QAAQ,CAACU,WAAT,IAAwBf,CAAC,GAAG,CAAJ,GAAQpB,KAApC,EAA2C;AACzC,cAAM1C,OAAO,GAAGmE,QAAQ,CAACU,WAAT,CAAqB,CAArB,IAA0B,CAA1C;AACAhB,QAAAA,cAAc,CAAC7D,OAAD,CAAd,GAA0B,IAA1B;AACAkB,QAAAA,MAAM,CAAClB,OAAD,CAAN,CAAgB8E,iBAAhB,CAAkCX,QAAQ,CAACU,WAA3C;AACD;;AAGDlB,MAAAA,KAAK,GAAGrE,eAAe,CAAC;AACtB6E,QAAAA,QADsB;AAEtBrE,QAAAA,cAAc,EAAE,KAAKA,cAFC;AAGtB6C,QAAAA,IAHsB;AAItBzB,QAAAA,MAJsB;AAKtBC,QAAAA,SALsB;AAMtBH,QAAAA,CANsB;AAOtBC,QAAAA,CAPsB;AAQtBmD,QAAAA,CARsB;AAStBtB,QAAAA;AATsB,OAAD,CAAvB;;AAYA,WAAK,MAAM7C,IAAX,IAAmB0D,KAAK,CAACoB,MAAN,EAAnB,EAAmC;AACjC,YAAI9E,IAAI,CAACoB,KAAT,EAAgB;AACduC,UAAAA,MAAM,CAACoB,IAAP,CAAY/E,IAAZ;AACD;AACF;;AAGD,UAAI,CAACkE,QAAQ,CAACU,WAAd,EAA2B;AACzB;AACD;AACF;;AAGD,SAAK,MAAM7E,OAAX,IAAsB6D,cAAtB,EAAsC;AACpC3C,MAAAA,MAAM,CAAClB,OAAD,CAAN,CAAgBiF,oBAAhB;AACD;;AAED,WAAO;AAACrB,MAAAA,MAAD;AAASsB,MAAAA,SAAS,EAAEvB,KAAK,IAAIA,KAAK,CAACwB,GAAN,CAAU,IAAV;AAA7B,KAAP;AACD;;AAGDrE,EAAAA,mBAAmB,CAAC;AAClBI,IAAAA,MADkB;AAElBC,IAAAA,SAFkB;AAGlBH,IAAAA,CAHkB;AAIlBC,IAAAA,CAJkB;AAKlBqB,IAAAA,KAAK,GAAG,CALU;AAMlBE,IAAAA,MAAM,GAAG,CANS;AAOlBG,IAAAA,IAAI,GAAG,OAPW;AAQlBE,IAAAA;AARkB,GAAD,EAShB;AACD,SAAKd,aAAL;;AAGA,UAAMe,UAAU,GAAG9D,gBAAgB,CAAC,KAAKU,EAAN,CAAnC;AACA,UAAM0F,OAAO,GAAGnG,iBAAiB,CAAC,KAAKS,EAAN,EAAU,CAACsB,CAAD,EAAIC,CAAJ,CAAV,EAAkB,IAAlB,CAAjC;AAGA,UAAMoE,UAAU,GAAGD,OAAO,CAACpE,CAA3B;AACA,UAAMsE,SAAS,GAAGF,OAAO,CAACnE,CAAR,GAAYmE,OAAO,CAAC5C,MAAtC;AAGA,UAAM+C,WAAW,GAAGtG,iBAAiB,CAAC,KAAKS,EAAN,EAAU,CAACsB,CAAC,GAAGsB,KAAL,EAAYrB,CAAC,GAAGuB,MAAhB,CAAV,EAAmC,IAAnC,CAArC;AACA,UAAMgD,WAAW,GAAGD,WAAW,CAACvE,CAAZ,GAAgBuE,WAAW,CAACjD,KAAhD;AACA,UAAMmD,YAAY,GAAGF,WAAW,CAACtE,CAAjC;AAEA,UAAMoC,UAAU,GAAG;AACjBrC,MAAAA,CAAC,EAAEqE,UADc;AAEjBpE,MAAAA,CAAC,EAAEwE,YAFc;AAIjBnD,MAAAA,KAAK,EAAEkD,WAAW,GAAGH,UAJJ;AAKjB7C,MAAAA,MAAM,EAAE8C,SAAS,GAAGG;AALH,KAAnB;;AAQA,UAAM1B,YAAY,GAAG,KAAKC,cAAL,CAAoB;AACvC9C,MAAAA,MADuC;AAEvCC,MAAAA,SAFuC;AAGvC0B,MAAAA,gBAHuC;AAIvCQ,MAAAA,UAJuC;AAKvCY,MAAAA,IAAI,oBAAatB,IAAb,CALmC;AAMvCuB,MAAAA,YAAY,EAAEvB;AANyB,KAApB,CAArB;;AASA,UAAM+C,SAAS,GAAGrG,gBAAgB,CAAC;AAAC0E,MAAAA,YAAD;AAAe7C,MAAAA;AAAf,KAAD,CAAlC;AAGA,UAAMyE,WAAW,GAAG,IAAIC,GAAJ,EAApB;AAEAF,IAAAA,SAAS,CAACG,OAAV,CAAkB1B,QAAQ,IAAI;AAC5B,UAAIlE,IAAI,GAAG;AACTQ,QAAAA,KAAK,EAAE0D,QAAQ,CAACU,WADP;AAETxD,QAAAA,KAAK,EAAE,IAFE;AAGTtB,QAAAA,KAAK,EAAEoE,QAAQ,CAAC2B,iBAHP;AAITC,QAAAA,MAAM,EAAE,IAJC;AAKT/E,QAAAA,CALS;AAMTC,QAAAA,CANS;AAOTqB,QAAAA,KAPS;AAQTE,QAAAA,MARS;AASTM,QAAAA;AATS,OAAX;AAYA7C,MAAAA,IAAI,GAAGV,mBAAmB,CAAC;AAAC8B,QAAAA,KAAK,EAAE8C,QAAQ,CAACE,WAAjB;AAA8BpE,QAAAA,IAA9B;AAAoC0C,QAAAA;AAApC,OAAD,CAA1B;;AACA,UAAI,CAACgD,WAAW,CAACK,GAAZ,CAAgB/F,IAAI,CAAC6B,MAArB,CAAL,EAAmC;AACjC6D,QAAAA,WAAW,CAACM,GAAZ,CAAgBhG,IAAI,CAAC6B,MAArB,EAA6B7B,IAA7B;AACD;AACF,KAjBD;AAmBA,WAAOiG,KAAK,CAACC,IAAN,CAAWR,WAAW,CAACZ,MAAZ,EAAX,CAAP;AACD;;AAGDf,EAAAA,cAAc,CAAC;AAAC9C,IAAAA,MAAD;AAASC,IAAAA,SAAT;AAAoB0B,IAAAA,gBAApB;AAAsCQ,IAAAA,UAAtC;AAAkDY,IAAAA,IAAlD;AAAwDC,IAAAA,YAAxD;AAAsEO,IAAAA;AAAtE,GAAD,EAA+E;AAC3FvF,IAAAA,MAAM,CAACmE,UAAU,CAACf,KAAX,GAAmB,CAAnB,IAAwBe,UAAU,CAACb,MAAX,GAAoB,CAA7C,CAAN;AAEA,UAAM4D,cAAc,GAAGlF,MAAM,CAACmF,MAAP,CAAchF,KAAK,IAAIA,KAAK,CAACiF,UAAN,EAAvB,CAAvB;;AACA,QAAIF,cAAc,CAACG,MAAf,GAAwB,CAA5B,EAA+B;AAC7B,aAAO,IAAP;AACD;;AAED,UAAM5G,UAAU,GAAG8E,KAAK,GAAG,KAAKjE,QAAR,GAAmB,KAAKb,UAAhD;AAEA,SAAKC,cAAL,CAAoB4G,MAApB,CAA2B;AACzBtF,MAAAA,MADyB;AAEzBrB,MAAAA,WAAW,EAAE,KAAKA,WAFO;AAGzBQ,MAAAA,OAAO,EAAE,KAAKH,QAHW;AAIzBiB,MAAAA,SAJyB;AAKzB0B,MAAAA,gBALyB;AAMzBlD,MAAAA,UANyB;AAOzB0D,MAAAA,UAPyB;AAQzBY,MAAAA,IARyB;AASzBC,MAAAA,YATyB;AAUzBO,MAAAA;AAVyB,KAA3B;AAeA,UAAM;AAACzD,MAAAA,CAAD;AAAIC,MAAAA,CAAJ;AAAOqB,MAAAA,KAAP;AAAcE,MAAAA;AAAd,QAAwBa,UAA9B;AACA,UAAMU,YAAY,GAAG,KAAKU,KAAK,GAAGgC,YAAH,GAAkBC,UAA5B,EAAwCpE,KAAK,GAAGE,MAAR,GAAiB,CAAzD,CAArB;AACAzD,IAAAA,iBAAiB,CAACY,UAAD,EAAa;AAC5BgH,MAAAA,OAAO,EAAE3F,CADmB;AAE5B4F,MAAAA,OAAO,EAAE3F,CAFmB;AAG5B4F,MAAAA,WAAW,EAAEvE,KAHe;AAI5BwE,MAAAA,YAAY,EAAEtE,MAJc;AAK5BuE,MAAAA,MAAM,EAAEhD;AALoB,KAAb,CAAjB;AAQA,WAAOA,YAAP;AACD;;AAIDT,EAAAA,eAAe,CAAC;AAACC,IAAAA,OAAD;AAAUC,IAAAA,OAAV;AAAmBL,IAAAA,YAAnB;AAAiCM,IAAAA,WAAjC;AAA8CC,IAAAA;AAA9C,GAAD,EAA8D;AAE3E,UAAM1C,CAAC,GAAGiC,IAAI,CAAC+D,GAAL,CAAS,CAAT,EAAYzD,OAAO,GAAGJ,YAAtB,CAAV;AACA,UAAMlC,CAAC,GAAGgC,IAAI,CAAC+D,GAAL,CAAS,CAAT,EAAYxD,OAAO,GAAGL,YAAtB,CAAV;AACA,UAAMb,KAAK,GAAGW,IAAI,CAACgE,GAAL,CAASxD,WAAT,EAAsBF,OAAO,GAAGJ,YAAV,GAAyB,CAA/C,IAAoDnC,CAAlE;AACA,UAAMwB,MAAM,GAAGS,IAAI,CAACgE,GAAL,CAASvD,YAAT,EAAuBF,OAAO,GAAGL,YAAV,GAAyB,CAAhD,IAAqDlC,CAApE;;AAGA,QAAIqB,KAAK,IAAI,CAAT,IAAcE,MAAM,IAAI,CAA5B,EAA+B;AAC7B,aAAO,IAAP;AACD;;AAED,WAAO;AAACxB,MAAAA,CAAD;AAAIC,MAAAA,CAAJ;AAAOqB,MAAAA,KAAP;AAAcE,MAAAA;AAAd,KAAP;AACD;;AAzU6B","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {\n  Framebuffer,\n  Texture2D,\n  isWebGL2,\n  readPixelsToArray,\n  cssToDeviceRatio,\n  cssToDevicePixels\n} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\nimport assert from '../utils/assert';\nimport PickLayersPass from '../passes/pick-layers-pass';\nimport {getClosestObject, getUniqueObjects} from './picking/query-object';\nimport {processPickInfo, getLayerPickingInfo} from './picking/pick-info';\n\nexport default class DeckPicker {\n  constructor(gl) {\n    this.gl = gl;\n    this.pickingFBO = null;\n    this.pickLayersPass = new PickLayersPass(gl);\n    this.layerFilter = null;\n    this.lastPickedInfo = {\n      // For callback tracking and auto highlight\n      index: -1,\n      layerId: null,\n      info: null\n    };\n    this._onError = null;\n  }\n\n  setProps(props) {\n    if ('layerFilter' in props) {\n      this.layerFilter = props.layerFilter;\n    }\n\n    if ('onError' in props) {\n      this._onError = props.onError;\n    }\n  }\n\n  finalize() {\n    if (this.pickingFBO) {\n      this.pickingFBO.delete();\n    }\n    if (this.depthFBO) {\n      this.depthFBO.color.delete();\n      this.depthFBO.delete();\n    }\n  }\n\n  // Pick the closest info at given coordinate\n  pickObject(opts) {\n    return this._pickClosestObject(opts);\n  }\n\n  // Get all unique infos within a bounding box\n  pickObjects(opts) {\n    return this._pickVisibleObjects(opts);\n  }\n\n  // Returns a new picking info object by assuming the last picked object is still picked\n  getLastPickedObject({x, y, layers, viewports}, lastPickedInfo = this.lastPickedInfo.info) {\n    const lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;\n    const layer = lastPickedLayerId ? layers.find(l => l.id === lastPickedLayerId) : null;\n    const coordinate = viewports[0] && viewports[0].unproject([x, y]);\n\n    const info = {\n      x,\n      y,\n      coordinate,\n      // TODO remove the lngLat prop after compatibility check\n      lngLat: coordinate,\n      layer\n    };\n\n    if (layer) {\n      return Object.assign({}, lastPickedInfo, info);\n    }\n    return Object.assign(info, {color: null, object: null, index: -1});\n  }\n\n  // Private\n  _resizeBuffer() {\n    const {gl} = this;\n    // Create a frame buffer if not already available\n    if (!this.pickingFBO) {\n      this.pickingFBO = new Framebuffer(gl);\n      if (Framebuffer.isSupported(gl, {colorBufferFloat: true})) {\n        this.depthFBO = new Framebuffer(gl);\n        this.depthFBO.attach({\n          [GL.COLOR_ATTACHMENT0]: new Texture2D(gl, {\n            format: isWebGL2(gl) ? GL.RGBA32F : GL.RGBA,\n            type: GL.FLOAT\n          })\n        });\n      }\n    }\n    // Resize it to current canvas size (this is a noop if size hasn't changed)\n    this.pickingFBO.resize({width: gl.canvas.width, height: gl.canvas.height});\n    this.depthFBO.resize({width: gl.canvas.width, height: gl.canvas.height});\n    return this.pickingFBO;\n  }\n\n  // Pick the closest object at the given (x,y) coordinate\n  // eslint-disable-next-line max-statements,complexity\n  _pickClosestObject({\n    layers,\n    viewports,\n    x,\n    y,\n    radius = 0,\n    depth = 1,\n    mode = 'query',\n    unproject3D,\n    onViewportActive\n  }) {\n    this._resizeBuffer();\n    // Convert from canvas top-left to WebGL bottom-left coordinates\n    // Top-left coordinates [x, y] to bottom-left coordinates [deviceX, deviceY]\n    // And compensate for pixelRatio\n    const pixelRatio = cssToDeviceRatio(this.gl);\n    const devicePixelRange = cssToDevicePixels(this.gl, [x, y], true);\n    const devicePixel = [\n      devicePixelRange.x + Math.floor(devicePixelRange.width / 2),\n      devicePixelRange.y + Math.floor(devicePixelRange.height / 2)\n    ];\n\n    const deviceRadius = Math.round(radius * pixelRatio);\n    const {width, height} = this.pickingFBO;\n    const deviceRect = this._getPickingRect({\n      deviceX: devicePixel[0],\n      deviceY: devicePixel[1],\n      deviceRadius,\n      deviceWidth: width,\n      deviceHeight: height\n    });\n\n    let infos;\n    const result = [];\n    const affectedLayers = {};\n\n    for (let i = 0; i < depth; i++) {\n      const pickedColors =\n        deviceRect &&\n        this._drawAndSample({\n          layers,\n          viewports,\n          onViewportActive,\n          deviceRect,\n          pass: `picking:${mode}`,\n          redrawReason: mode\n        });\n\n      const pickInfo = getClosestObject({\n        pickedColors,\n        layers,\n        deviceX: devicePixel[0],\n        deviceY: devicePixel[1],\n        deviceRadius,\n        deviceRect\n      });\n\n      let z;\n      if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {\n        const zValues = this._drawAndSample({\n          layers: [pickInfo.pickedLayer],\n          viewports,\n          onViewportActive,\n          deviceRect: {x: pickInfo.pickedX, y: pickInfo.pickedY, width: 1, height: 1},\n          pass: `picking:${mode}`,\n          redrawReason: 'pick-z',\n          pickZ: true\n        });\n        // picked value is in common space (pixels) from the camera target (viewport.position)\n        // convert it to meters from the ground\n        z = zValues[0] * viewports[0].distanceScales.metersPerUnit[2] + viewports[0].position[2];\n      }\n\n      // Only exclude if we need to run picking again.\n      // We need to run picking again if an object is detected AND\n      // we have not exhausted the requested depth.\n      if (pickInfo.pickedColor && i + 1 < depth) {\n        const layerId = pickInfo.pickedColor[3] - 1;\n        affectedLayers[layerId] = true;\n        layers[layerId].clearPickingColor(pickInfo.pickedColor);\n      }\n\n      // This logic needs to run even if no object is picked.\n      infos = processPickInfo({\n        pickInfo,\n        lastPickedInfo: this.lastPickedInfo,\n        mode,\n        layers,\n        viewports,\n        x,\n        y,\n        z,\n        pixelRatio\n      });\n\n      for (const info of infos.values()) {\n        if (info.layer) {\n          result.push(info);\n        }\n      }\n\n      // If no object is picked stop.\n      if (!pickInfo.pickedColor) {\n        break;\n      }\n    }\n\n    // reset only affected buffers\n    for (const layerId in affectedLayers) {\n      layers[layerId].restorePickingColors();\n    }\n\n    return {result, emptyInfo: infos && infos.get(null)};\n  }\n\n  // Pick all objects within the given bounding box\n  _pickVisibleObjects({\n    layers,\n    viewports,\n    x,\n    y,\n    width = 1,\n    height = 1,\n    mode = 'query',\n    onViewportActive\n  }) {\n    this._resizeBuffer();\n    // Convert from canvas top-left to WebGL bottom-left coordinates\n    // And compensate for pixelRatio\n    const pixelRatio = cssToDeviceRatio(this.gl);\n    const leftTop = cssToDevicePixels(this.gl, [x, y], true);\n\n    // take left and top (y inverted in device pixels) from start location\n    const deviceLeft = leftTop.x;\n    const deviceTop = leftTop.y + leftTop.height;\n\n    // take right and bottom (y inverted in device pixels) from end location\n    const rightBottom = cssToDevicePixels(this.gl, [x + width, y + height], true);\n    const deviceRight = rightBottom.x + rightBottom.width;\n    const deviceBottom = rightBottom.y;\n\n    const deviceRect = {\n      x: deviceLeft,\n      y: deviceBottom,\n      // deviceTop and deviceRight represent the first pixel outside the desired rect\n      width: deviceRight - deviceLeft,\n      height: deviceTop - deviceBottom\n    };\n\n    const pickedColors = this._drawAndSample({\n      layers,\n      viewports,\n      onViewportActive,\n      deviceRect,\n      pass: `picking:${mode}`,\n      redrawReason: mode\n    });\n\n    const pickInfos = getUniqueObjects({pickedColors, layers});\n\n    // Only return unique infos, identified by info.object\n    const uniqueInfos = new Map();\n\n    pickInfos.forEach(pickInfo => {\n      let info = {\n        color: pickInfo.pickedColor,\n        layer: null,\n        index: pickInfo.pickedObjectIndex,\n        picked: true,\n        x,\n        y,\n        width,\n        height,\n        pixelRatio\n      };\n\n      info = getLayerPickingInfo({layer: pickInfo.pickedLayer, info, mode});\n      if (!uniqueInfos.has(info.object)) {\n        uniqueInfos.set(info.object, info);\n      }\n    });\n\n    return Array.from(uniqueInfos.values());\n  }\n\n  // returns pickedColor or null if no pickable layers found.\n  _drawAndSample({layers, viewports, onViewportActive, deviceRect, pass, redrawReason, pickZ}) {\n    assert(deviceRect.width > 0 && deviceRect.height > 0);\n\n    const pickableLayers = layers.filter(layer => layer.isPickable());\n    if (pickableLayers.length < 1) {\n      return null;\n    }\n\n    const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;\n\n    this.pickLayersPass.render({\n      layers,\n      layerFilter: this.layerFilter,\n      onError: this._onError,\n      viewports,\n      onViewportActive,\n      pickingFBO,\n      deviceRect,\n      pass,\n      redrawReason,\n      pickZ\n    });\n\n    // Read from an already rendered picking buffer\n    // Returns an Uint8ClampedArray of picked pixels\n    const {x, y, width, height} = deviceRect;\n    const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);\n    readPixelsToArray(pickingFBO, {\n      sourceX: x,\n      sourceY: y,\n      sourceWidth: width,\n      sourceHeight: height,\n      target: pickedColors\n    });\n\n    return pickedColors;\n  }\n\n  // Calculate a picking rect centered on deviceX and deviceY and clipped to device\n  // Returns null if pixel is outside of device\n  _getPickingRect({deviceX, deviceY, deviceRadius, deviceWidth, deviceHeight}) {\n    // Create a box of size `radius * 2 + 1` centered at [deviceX, deviceY]\n    const x = Math.max(0, deviceX - deviceRadius);\n    const y = Math.max(0, deviceY - deviceRadius);\n    const width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x;\n    const height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y;\n\n    // x, y out of bounds.\n    if (width <= 0 || height <= 0) {\n      return null;\n    }\n\n    return {x, y, width, height};\n  }\n}\n"],"file":"deck-picker.js"}