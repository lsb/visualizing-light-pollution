{"version":3,"sources":["../../../src/solid-polygon-layer/polygon-tesselator.js"],"names":["Polygon","Tesselator","PolygonTesselator","constructor","opts","fp64","IndexType","Uint32Array","attributes","positions","size","type","Float64Array","Float32Array","vertexValid","Uint8ClampedArray","indices","get","attributeName","subarray","vertexCount","updateGeometry","externalIndices","buffers","value","length","getGeometrySize","polygon","getVertexCount","positionSize","normalize","getGeometryFromBuffer","buffer","updateGeometryAttributes","context","geometrySize","_updateIndices","_updatePositions","_updateVertexValid","geometryIndex","vertexStart","offset","indexStart","indexStarts","typedArrayManager","target","i","getSurfaceIndices","preproject","allocate","copy","j","polygonPositions","x","y","z","holeIndices","fill"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Handles tesselation of polygons with holes\n// - 2D surfaces\n// - 2D outlines\n// - 3D surfaces (top and sides only)\n// - 3D wireframes (not yet)\nimport * as Polygon from './polygon';\nimport {Tesselator} from '@deck.gl/core';\n\n// This class is set up to allow querying one attribute at a time\n// the way the AttributeManager expects it\nexport default class PolygonTesselator extends Tesselator {\n  constructor(opts) {\n    const {fp64, IndexType = Uint32Array} = opts;\n    super({\n      ...opts,\n      attributes: {\n        positions: {size: 3, type: fp64 ? Float64Array : Float32Array},\n        vertexValid: {type: Uint8ClampedArray, size: 1},\n        indices: {type: IndexType, size: 1}\n      }\n    });\n  }\n\n  /* Getters */\n  get(attributeName) {\n    const {attributes} = this;\n    if (attributeName === 'indices') {\n      return attributes.indices && attributes.indices.subarray(0, this.vertexCount);\n    }\n\n    return attributes[attributeName];\n  }\n\n  /* Implement base Tesselator interface */\n  updateGeometry(opts) {\n    super.updateGeometry(opts);\n\n    const externalIndices = this.buffers.indices;\n    if (externalIndices) {\n      this.vertexCount = (externalIndices.value || externalIndices).length;\n    }\n  }\n\n  getGeometrySize(polygon) {\n    return Polygon.getVertexCount(polygon, this.positionSize, this.normalize);\n  }\n\n  getGeometryFromBuffer(buffer) {\n    if (this.normalize || !this.buffers.indices) {\n      return super.getGeometryFromBuffer(buffer);\n    }\n    // we don't need to read the positions if no normalization/tesselation\n    return () => null;\n  }\n\n  updateGeometryAttributes(polygon, context) {\n    if (this.normalize) {\n      polygon = Polygon.normalize(polygon, this.positionSize, context.geometrySize);\n    }\n\n    this._updateIndices(polygon, context);\n    this._updatePositions(polygon, context);\n    this._updateVertexValid(polygon, context);\n  }\n\n  // Flatten the indices array\n  _updateIndices(polygon, {geometryIndex, vertexStart: offset, indexStart}) {\n    const {attributes, indexStarts, typedArrayManager} = this;\n\n    let target = attributes.indices;\n    if (!target) {\n      return;\n    }\n    let i = indexStart;\n\n    // 1. get triangulated indices for the internal areas\n    const indices = Polygon.getSurfaceIndices(polygon, this.positionSize, this.opts.preproject);\n\n    // make sure the buffer is large enough\n    target = typedArrayManager.allocate(target, indexStart + indices.length, {\n      copy: true\n    });\n\n    // 2. offset each index by the number of indices in previous polygons\n    for (let j = 0; j < indices.length; j++) {\n      target[i++] = indices[j] + offset;\n    }\n\n    indexStarts[geometryIndex + 1] = indexStart + indices.length;\n    attributes.indices = target;\n  }\n\n  // Flatten out all the vertices of all the sub subPolygons\n  _updatePositions(polygon, {vertexStart, geometrySize}) {\n    const {\n      attributes: {positions},\n      positionSize\n    } = this;\n    if (!positions) {\n      return;\n    }\n    const polygonPositions = polygon.positions || polygon;\n\n    for (let i = vertexStart, j = 0; j < geometrySize; i++, j++) {\n      const x = polygonPositions[j * positionSize];\n      const y = polygonPositions[j * positionSize + 1];\n      const z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;\n\n      positions[i * 3] = x;\n      positions[i * 3 + 1] = y;\n      positions[i * 3 + 2] = z;\n    }\n  }\n\n  _updateVertexValid(polygon, {vertexStart, geometrySize}) {\n    const {\n      attributes: {vertexValid},\n      positionSize\n    } = this;\n    const holeIndices = polygon && polygon.holeIndices;\n    /* We are reusing the some buffer for `nextPositions` by offseting one vertex\n     * to the left. As a result,\n     * the last vertex of each ring overlaps with the first vertex of the next ring.\n     * `vertexValid` is used to mark the end of each ring so we don't draw these\n     * segments:\n      positions      A0 A1 A2 A3 A4 B0 B1 B2 C0 ...\n      nextPositions  A1 A2 A3 A4 B0 B1 B2 C0 C1 ...\n      vertexValid    1  1  1  1  0  1  1  0  1 ...\n     */\n    vertexValid.fill(1, vertexStart, vertexStart + geometrySize);\n    if (holeIndices) {\n      for (let j = 0; j < holeIndices.length; j++) {\n        vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;\n      }\n    }\n    vertexValid[vertexStart + geometrySize - 1] = 0;\n  }\n}\n"],"file":"polygon-tesselator.js"}